#!/bin/sh
#
#   "SystemImager"
#
#   Copyright (C) 1999-2004 Brian Elliott Finley
#
#   28.07.2005 Erich Focht : SCSI device detection and generation of
#                            /a/etc/systemconfig/hardware.lst
#
#   David N. Lombard : Disks enumeration and disk editing
#
#   $Id$
#

##VERSION_INFO##

# Pull in variables left behind by the linuxrc script.
# This information is passed from the linuxrc script on the autoinstall media 
# via /tmp/variables.txt.  Apparently the shell we use in BOEL is not 
# intelligent enough to take a "set -a" parameter.
#
. /tmp/variables.txt

# Load functions and other variables
. /etc/init.d/functions

get_arch

##NO_LISTING##
if [ -z $NO_LISTING ]; then
    VERBOSE_OPT="v"
else
    VERBOSE_OPT=""
fi

##SET_IMAGENAME##
##SET_OVERRIDES##

### BEGIN Check to be sure this not run from a working machine ###
# Test for mounted SCSI or IDE disks
mount | grep [hs]d[a-z][1-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout

# Test for mounted software RAID devices
mount | grep md[0-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout

# Test for mounted hardware RAID disks
mount | grep c[0-9]+d[0-9]+p > /dev/null 2>&1
[ $? -eq 0 ] &&  logmsg Sorry.  Must not run on a working machine... && shellout
### END Check to be sure this not run from a working machine ###


################################################################################
#
#   Stop RAID devices before partitioning begins
#
# Q1) Why did they get started in the first place?  
# A1) So we can pull a local.cfg file off a root mounted software RAID system.
#     They may not be started on your system -- they would only be started if
#     you did the stuff in Q3 below.
#
# Q2) Why didn't my local.cfg on my root mounted software RAID work for me 
#     with the standard kernel flavour?
# A2) The standard kernel flavour uses modules for the software RAID drivers --
#     therefore, software RAID is not available at the point in the boot process
#     where BOEL needs to read the local.cfg file.  They are only pulled over 
#     when this script is run, which is, of course, only runnable if it was
#     pulled over the network using the settings that you would have wanted it
#     to get from the local.cfg file, which it couldn't.  Right?
#
# Q3) Whatever.  So how do I make it work with a local.cfg file on my root
#     mounted software RAID?  
# A3) Compile an autoinstall kernel with software RAID, and any other drivers 
#     you might need built in (filesystem, SCSI drivers, etc.).
#
if [ -f /proc/mdstat ]; then
  RAID_DEVICES=` cat /proc/mdstat | grep ^md | sed 's/ .*$//g' `

  # raidstop will not run unless a raidtab file exists
  echo "" >> /etc/raidtab || shellout

  # turn dem pesky raid devices off!
  for RAID_DEVICE in ${RAID_DEVICES}
  do
    DEV="/dev/${RAID_DEVICE}"
    # we don't do a shellout here because, well I forgot why, but we don't.
    logmsg "raidstop ${DEV}" && raidstop ${DEV}
  done
fi
#
################################################################################
# BEGIN disk enumeration
#
# Note the kludgey way to get /dev/sd* and /dev/*/c*d* to sort properly...
#
# Parse the correct file depending by the kernel release -AR-
kernel=`uname -r | sed "s/^\(2\.[64]\).*/\1/"`
if [ $kernel = "2.4" ]; then
    diskfile=/proc/partitions
else
    diskfile=/proc/diskstats
fi 
echo DISKORDER=${DISKORDER=sd,cciss,ida,rd,hd}
[ -z $DISKORDER ] || {
  logmsg enumerate_disks
  order=`echo "$DISKORDER" | sed 's/ /,/g' | sed s/,,*/,/g | sed s/^,//`
  DISKS=0
  while : ; do
    [ -z $order ] && break
    type=`expr $order : '\([^,]*\),' \| $order`
    case $type in
    cciss | ida | rd )
      for dev in `cat $diskfile | sed -ne "s/.*\($type\\/c[0-9]d[0-9]\).*/\1/p" | sort -u` ; do
        logmsg " $dev"
        eval DISK$DISKS=/dev/${dev}
        DISKS=`expr $DISKS + 1`
      done
      ;;
    hd | sd )
      for dev in `cat $diskfile | sed -ne "s/.*\($type[a-z]\+\).*/\1/p" | sort -u` ; do
        logmsg " $dev"
        eval DISK$DISKS=/dev/${dev}
        DISKS=`expr $DISKS + 1`
      done
      ;;
    * )
      logmsg "type='$type'"
      shellout
      ;;
    esac
    order=`expr $order : '[^,]*,\(.*\)'`
  done
  logmsg DISKS=$DISKS
  [ $DISKS -eq 0 ] && {
    beep
    beep
    logmsg ""
    logmsg "NO DISK DEVICE FILES WERE FOUND.  THIS USUALLY MEANS THE KERNEL DID NOT"
    logmsg "RECOGNIZE ANY OF THE ATTACHED DISKS."
    logmsg ""
    logmsg "The kernel boot messages, which preceded this, may indicate why."
    logmsg ""
    logmsg "Reverting to disk configuration specified by image master script."
    DISKORDER=
    logmsg ""
  }
  echo
  beep
}
#
# END disk enumeration
################################################################################

##PARTITION_DISKS##

### BEGIN software-RAID initialization commands -AR- ###
##CREATE_SOFT_RAID_DISKS##
### END software-RAID initialization commands ###

logmsg "Load device mapper driver (for LVM)."
modprobe dm-mod

### BEGIN LVM initialization commands -AR- ###
##INITIALIZE_LVM_PARTITIONS##
### END LVM initialization commands ###

### BEGIN LVM groups creation commands -AR- ###
##CREATE_LVM_GROUPS##
### END LVM groups creation commands ###

### BEGIN LVM volumes creation commands -AR- ###
##CREATE_LVM_VOLUMES##
### END LVM volumes creation commands ###

logmsg "Load additional filesystem drivers."
modprobe reiserfs
modprobe ext2
modprobe ext3
modprobe jfs
modprobe xfs

### BEGIN swap and filesystem creation commands ###
##CREATE_FILESYSTEMS##
### END swap and filesystem creation commands ###

### BEGIN mount proc in image for tools like System Configurator ###
logmsg "mkdir -p /a/proc || shellout"
mkdir -p /a/proc || shellout
logmsg "mount proc /a/proc -t proc -o defaults || shellout"
mount proc /a/proc -t proc -o defaults || shellout
### END mount proc in image for tools like System Configurator ###

if [ ! $kernel = "2.4" ]; then
### BEGIN mount sysfs in image for tools that might be run during chroot ###
logmsg "mkdir -p /a/sys || shellout"
mkdir -p /a/sys || shellout
logmsg "mount sysfs /a/sys -t sysfs -o defaults || shellout"
mount sysfs /a/sys -t sysfs -o defaults || shellout
### END mount sysfs in image for tools that might be run during chroot ###
fi

################################################################################
#
#   Lay the image down on the freshly formatted disk(s)
#
if [ ! -z $MONITOR_SERVER ]; then
    start_report_task
fi

if [ ! -z $FLAMETHROWER_DIRECTORY_PORTBASE ]; then 

    # Use multicast 
    MODULE_NAME="${IMAGENAME}"
    DIR=/a
    RETRY=7
    FLAMETHROWER_TARPIPE=y
    flamethrower_client
    if [ ! -z $MONITOR_SERVER ]; then
        stop_report_task 100
    fi
elif [ ! -z $BITTORRENT_STAGING ]; then
    # Use BitTorrent
    if [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent" ]; then
        bittorrent_tarball="image-${IMAGENAME}.tar.gz"
        compress='z'
    elif [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent" ]; then
        bittorrent_tarball="image-${IMAGENAME}.tar"
        compress=''
    else
        logmsg "error: cannot find a valid torrent file for the image ${IMAGENAME}"
        shellout
    fi
    # Download image from peers
    logmsg "Start downloading image using torrent ${bittorrent_tarball}.torrent"
    logmsg ""
    logmsg "--> INFO: remember to run si_installbtimage on the image server!"
    logmsg ""
    bittorrent_get_file ${TORRENTS_DIR}/${bittorrent_tarball}.torrent ${BITTORRENT_STAGING}
    if [ ! -z $MONITOR_SERVER ]; then
        stop_report_task 100
    fi
    # Extract image.
    logmsg "Extracting image from ${bittorrent_tarball} ..."
    (cd /a/ && tar -xv${compress}Spf ${BITTORRENT_STAGING}/${bittorrent_tarball}) || shellout
    rm -f ${BITTORRRENT_STAGING}/${bittorrent_tarball}
    unset bittorrent_tarball
else 
    # Use rsync 
    if [ $NO_LISTING ]; then
        logmsg "Quietly installing image... "
        start_spinner
    fi
    if [ "${TMPFS_STAGING}" = "yes" ]; then 

        # Deposit image into tmpfs
        DIR=/tmp/tmpfs_staging
        logmsg
        logmsg "TMPFS_STAGING=${TMPFS_STAGING} -- Staging in ${DIR}"
        mkdir -p ${DIR}

        logmsg "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids \
              ${IMAGESERVER}::${IMAGENAME}/ ${DIR}/ || shellout 

        if [ ! -z $MONITOR_SERVER ]; then
            stop_report_task 100
        fi

        # Move from staging in tmpfs to disk
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --numeric-ids ${DIR}/ /a/
    else
        logmsg "rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /a/" 
        rsync -aHS${VERBOSE_OPT} --exclude=lost+found/ --exclude=/proc/* --numeric-ids ${IMAGESERVER}::${IMAGENAME}/ /a/ || shellout 
        if [ ! -z $MONITOR_SERVER ]; then
            stop_report_task 100
        fi
    fi
fi 

beep

#
################################################################################


if [ $NO_LISTING ]; then
    stop_spinner
fi

# Leave notice of which image is installed on the client
echo $IMAGENAME > /a/etc/systemimager/IMAGE_LAST_SYNCED_TO || shellout

# Copy the raidtab into the image.
cp -f /etc/raidtab /a/etc/raidtab

### BEGIN generate new fstab file from autoinstallscript.conf ###
##GENERATE_FSTAB##
### END generate new fstab file from autoinstallscript.conf ###

################################################################################
#
#   Process override directories
#
for OVERRIDE in $OVERRIDES
do
    if [ ! -z $FLAMETHROWER_DIRECTORY_PORTBASE ]; then
        # Use multicast
        MODULE_NAME="override_${OVERRIDE}"
        DIR=/a
        RETRY=7
        FLAMETHROWER_TARPIPE=y
        flamethrower_client
    elif [ ! -z $BITTORRENT_STAGING ]; then
        # Use BitTorrent
        if [ -f "${TORRENTS_DIR}/override-${OVERRIDE}.tar.gz.torrent" ]; then
            bittorrent_tarball="override-${OVERRIDE}.tar.gz"
            compress='z'
        elif [ -f "${TORRENTS_DIR}/override-${OVERRIDE}.tar.torrent" ]; then
            bittorrent_tarball="override-${OVERRIDE}.tar"
            compress=''
        else
            bittorrent_tarball=""
            logmsg "error: cannot find a valid torrent file for override ${OVERRIDE}"
        fi
        if [ ! -z $bittorrent_tarball ]; then
            logmsg "Start downloading override using torrent ${bittorrent_tarball}.torrent"
            logmsg ""
            logmsg "--> INFO: remember to run si_installbtimage on the image server!"
            logmsg ""
            # Download override from peers
            bittorrent_get_file ${TORRENTS_DIR}/${bittorrent_tarball}.torrent ${BITTORRENT_STAGING}
            # Extract override.
            logmsg "Extracting override from ${bittorrent_tarball} ..."
            (cd /a/ && tar -xv${compress}Spf ${BITTORRENT_STAGING}/${bittorrent_tarball}) || shellout
            rm -f ${BITTORRRENT_STAGING}/${bittorrent_tarball}
        else
            # Use rsync
            logmsg "trying to download override ${OVERRIDE} with rsync..."
            logmsg "rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/"
            rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/ || logmsg "Override directory $OVERRIDE doesn't seem to exist, but that may be OK."
        fi
        unset bittorrent_tarball
    else
        # Use rsync
        logmsg "rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/"
        rsync -av --numeric-ids $IMAGESERVER::overrides/$OVERRIDE/ /a/ || logmsg "Override directory $OVERRIDE doesn't seem to exist, but that may be OK."
    fi
done

beep

#
################################################################################

################################################################################
# BEGIN disk edits
#
[ -z $DISKORDER ] || {
  echo "Editing files for actual disk configuration..."
##SHOW_DISK_EDITS##
  for file in /etc/fstab /etc/raidtab /etc/systemconfig/systemconfig.conf; do
    [ -f /a/$file ] || continue
    echo " $file"
    cp /a/$file /a/$file.image
    cat /a/$file.image |
##EDIT_DISK_NAMES##
    cat > /a/$file
  done
  echo
  beep
}
#
# END disk edits
################################################################################


##################################################################
#
# Uncomment the line below to leave your hostname blank.
# Certain distributions use this as an indication to take on the
# hostname provided by a DHCP server.  The default is to have
# SystemConfigurator assign your clients the hostname that
# corresponds to the IP address the use during the install.
# (If you used to use the static_dhcp option, this is your man.)
#
#HOSTNAME=""


################################################################################
#
# mount /dev /a/dev -o bind if needed
#
##BOEL_DEVSTYLE##
#
################################################################################


################################################################################
#
#   Detect scsi hardware and include the device IDs into the hardware.lst
#   file used by systemconfigurator. Do nothing if the hardware.lst file
#   already exists (which is a sign that it has been already prepared).
#   Would be shorter if discover could return numerical device IDs...
#
if [ ! -f /a/etc/systemconfig/hardware.lst ]; then
   SCSI_MODS=`discover -f "%m\n" scsi | grep -v ide-scsi | uniq`
   for MOD in $SCSI_MODS; do
      DEVID=`grep $MOD /proc/bus/pci/devices | cut -f 2 | sort | uniq`
      for MYDEV in $DEVID; do
         VENDOR=`echo $MYDEV | cut -b 1-4`
         MODEL=`echo $MYDEV | cut -b 5-8`
         echo "$VENDOR $MODEL scsi $MOD" >> /a/etc/systemconfig/hardware.lst
         echo "Added SCSI device $VENDOR:$MODEL using module $MOD to hardware.lst"
      done
   done
fi
#
################################################################################

################################################################################
#
#   System Configurator
#
# Configure the client's hardware, network interface, and boot loader.
#

# Create an /etc/mtab file with appropriate entries
grep -v '/dev/ram' /etc/mtab | sed 's,/a/*,/,g' | sort -u > /a/etc/mtab

# Ensure that /dev devices are available for boot loader installer,
# even if client system uses udev.
mount --bind /dev /a/dev

##SYSTEMCONFIGURATOR##
#
################################################################################


################################################################################
#
#   Post Install Scripts
#
run_post_install_scripts
#
################################################################################


################################################################################
#
#   Unmount filesystems
#

# We should unmount /a/dev/ first...
umount /a/dev

# ...then
##UMOUNT_FILESYSTEMS##
#
################################################################################


################################################################################
#
#   Tell the image server we're done
#   
rsync $IMAGESERVER::scripts/imaging_complete > /dev/null 2>&1
logmsg "Imaging completed"
#
################################################################################

# Take network interface down
[ -z $DEVICE ] && DEVICE=eth0
ifconfig $DEVICE down || shellout

# Announce completion (even for non beep-incessantly --post-install options)
beep 3

##POSTINSTALL##
