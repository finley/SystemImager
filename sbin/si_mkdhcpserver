#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use File::Spec;
use SystemImager::IpUtils qw(get_local_ip get_network_interfaces);
use SystemImager::KeaConfUtils qw(
    load_kea_config write_kea_config add_client list_clients
    add_network list_networks add_pool list_pools
);

# Variables pour stocker les options
my $dns_domain;
my @dns_servers;
my @add_networks;        # Liste de réseaux : [ [ip/mask, ip_debut, ip_fin], ... ]
my @del_networks;        # Liste de réseaux à supprimer : [ ip/mask, force ]
my $image_server;
my $boot_server;
my $log_server;
my $log_server_port;
my $ssh_download_url;
my $flamethrower_port_base;
my $staging_dir;
my $help;
my @add_clients;         # Liste de triplets [nom, MAC, IP]
my $global;              # Option --global pour --add-client
my @del_clients;         # Liste de critères pour suppression
my $config_file;
my $debug;
my $list_clients;
my $list_pools;
my $list_subnets;
my $csv;

# Parsing des options
GetOptions(
    'dns-domain=s' => \$dns_domain,
    'dns-servers=s' => \@dns_servers,
    'add-network=s{1,3}' => \@add_networks,
    'del-network=s{1,2}' => \@del_networks,
    'image-server=s' => \$image_server,
    'boot-server=s' => \$boot_server,
    'log-server=s' => \$log_server,
    'log-server-port=i' => \$log_server_port,
    'ssh-download-url:s' => \$ssh_download_url,
    'flamethrower-port-base:i' => \$flamethrower_port_base,
    'staging-dir=s' => \$staging_dir,
    'add-client=s{3}' => \@add_clients,
    'global' => \$global,
    'del-client=s' => \@del_clients,
    'list-clients' => \$list_clients,
    'list-pools' => \$list_pools,
    'list-subnets' => \$list_subnets,
    'csv' => \$csv,
	'file=s' => \$config_file,
    'debug' => \$debug,
    'help' => \$help
) or die "Erreur dans les options de la ligne de commande\n";

# Affichage de l'aide si demandée
if ($help) {
    print_usage();
    exit 0;
}

# Vérifier si des options de modification sont présentes
my $has_modifications = @add_networks || @del_networks || @add_clients || @del_clients;

# Vérifier si le fichier de configuration est accessible en écriture
$config_file ||= '/etc/kea/kea-dhcp4.conf';
my $config_dir = File::Spec->catdir(File::Spec->splitpath($config_file))[1];
if ($has_modifications) {
    if (-e $config_file) {
        die "Erreur: Impossible d'écrire dans $config_file : fichier non accessible en écriture\n" unless -w $config_file;
    } else {
        die "Erreur: Répertoire $config_dir n'existe pas ou n'est pas accessible en écriture\n" unless -d $config_dir && -w $config_dir;
    }
}

# Vérifier si kea-dhcp4 est installé (avertissement non bloquant)
if (system("which kea-dhcp4 >/dev/null 2>&1") != 0) {
    print "Avertissement : kea-dhcp4 n'est pas installé. La configuration générée ne pourra pas être utilisée immédiatement.\n";
}

# Charger la configuration
my ($config, $config_exists) = SystemImager::KeaConfUtils::load_kea_config($config_file, $debug);
if (!$config_exists && !@add_networks && !@add_clients && !@del_clients && !@del_networks && !($list_clients || $list_pools || $list_subnets)) {
    die "L'option --add-network est requise pour créer une nouvelle configuration\n";
}

# Obtenir l'adresse IP locale si nécessaire
my $local_ip = ($has_modifications || $list_subnets || $list_pools || $list_clients) ? SystemImager::IpUtils::get_local_ip(@add_networks, $config) : undef;

# Gestion des options de listage
if ($list_clients || $list_pools || $list_subnets) {
    if ($list_clients) {
        SystemImager::KeaConfUtils::list_clients($config, $csv, $debug);
    }
    if ($list_pools) {
        SystemImager::KeaConfUtils::list_pools($config, $csv, $debug);
    }
    if ($list_subnets) {
        SystemImager::KeaConfUtils::list_networks($config, $csv, $debug);
    }
    exit 0 unless $has_modifications;
}

# Gestion du domaine DNS par défaut
unless ($dns_domain) {
    if (-r '/etc/resolv.conf') {
        open my $resolv, '<', '/etc/resolv.conf' or die "Impossible d'ouvrir /etc/resolv.conf: $!\n";
        while (<$resolv>) {
            if (/^domain\s+(\S+)/) {
                $dns_domain = $1;
                last;
            }
        }
        close $resolv;
    }
}

# Gestion des serveurs par défaut
$image_server = $local_ip unless $image_server;
$boot_server = $local_ip unless $boot_server;

# Gestion de ssh-download-url
if (defined $ssh_download_url && $ssh_download_url eq '') {
    $ssh_download_url = "ssh://$image_server/var/lib/systemimager/images";
}

# Gestion de flamethrower-port-base
if (defined $flamethrower_port_base && $flamethrower_port_base == 0) {
    $flamethrower_port_base = 8000;
}

# Validation des serveurs DNS
if (@dns_servers) {
    @dns_servers = split(/\s+/, join(' ', @dns_servers));
    foreach my $dns (@dns_servers) {
        die "Serveur DNS invalide: $dns\n" unless SystemImager::IpUtils::valid_ip($dns) || SystemImager::IpUtils::valid_fqdn($dns);
    }
}

# Validation de l'image-server et boot-server
die "image-server invalide: $image_server\n" unless SystemImager::IpUtils::valid_ip($image_server) || SystemImager::IpUtils::valid_fqdn($image_server);
die "boot-server invalide: $boot_server\n" unless SystemImager::IpUtils::valid_ip($boot_server) || SystemImager::IpUtils::valid_fqdn($boot_server);

# Validation de log-server
if ($log_server) {
    die "log-server invalide: $log_server\n" unless SystemImager::IpUtils::valid_ip($log_server) || SystemImager::IpUtils::valid_fqdn($log_server);
}

# Validation de log-server-port
if (defined $log_server_port) {
    die "log-server-port doit être un entier entre 1 et 65535\n" unless $log_server_port >= 1 && $log_server_port <= 65535;
}

# Ajouter les réseaux
if (@add_networks) {
    foreach my $i (0 .. $#add_networks / 3) {
        my ($net, $ip_start, $ip_end) = @add_networks[$i*3 .. $i*3+2];
        unless (defined $net && $net ne '') {
            print "Erreur: Paramètre réseau manquant pour --add-network\n";
            next;
        }
        SystemImager::KeaConfUtils::add_network($config, $net, $ip_start, $ip_end, $debug) or next;
    }
}

# Supprimer les réseaux
my %existing_subnets;
if (exists $config->{"Dhcp4"}->{"subnet4"}) {
    %existing_subnets = map { $_->{"subnet"} => $_ } @{$config->{"Dhcp4"}->{"subnet4"}};
}

my @deleted_subnets;
my @deleted_reservations;
if (@del_networks) {
    foreach my $i (0 .. $#del_networks / 2) {
        my ($net, $force) = @del_networks[$i*2 .. $i*2+1];
        my ($ip, $mask) = split('/', $net);
        die "Format réseau invalide: $net\n" unless SystemImager::IpUtils::valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32;
        $force = (defined $force && $force eq '--force') ? 1 : 0;

        unless (exists $existing_subnets{$net}) {
            print "Erreur: Le sous-réseau $net n'existe pas dans la configuration\n";
            next;
        }

        # Vérifier les réservations dans le sous-réseau
        my @conflicting_reservations;
        my @remaining_global_reservations;
        $config->{"Dhcp4"}->{"reservations"} ||= [];
        foreach my $reservation (@{$config->{"Dhcp4"}->{"reservations"}}) {
            if ($reservation->{'ip-address'} && SystemImager::IpUtils::is_ip_in_network($reservation->{'ip-address'}, $mask, $ip, $mask)) {
                push @conflicting_reservations, $reservation;
            } else {
                push @remaining_global_reservations, $reservation;
            }
        }

        if (@conflicting_reservations && !$force) {
            print "Erreur: Impossible de supprimer le sous-réseau $net car il contient des réservations :\n";
            foreach my $res (@conflicting_reservations) {
                print "  - ", ($res->{"hostname"} || $res->{'hw-address'} || $res->{'ip-address'}), "\n";
            }
            print "Utilisez --force pour supprimer le sous-réseau et ses réservations.\n";
            next;
        }

        # Supprimer le sous-réseau
        $config->{"Dhcp4"}->{"subnet4"} = [ grep { $_->{"subnet"} ne $net } @{$config->{"Dhcp4"}->{"subnet4"}} ];
        push @deleted_subnets, $net;

        # Supprimer les réservations si --force
        if ($force && @conflicting_reservations) {
            push @deleted_reservations, map { $_->{"hostname"} || $_->{'hw-address'} || $_->{'ip-address'} } @conflicting_reservations;
            $config->{"Dhcp4"}->{"reservations"} = \@remaining_global_reservations;
        }
    }

    if (@deleted_subnets) {
        print "Sous-réseau(s) supprimé(s) : ", join(", ", @deleted_subnets), "\n";
        if (@deleted_reservations) {
            print "Réservation(s) supprimée(s) : ", join(", ", @deleted_reservations), "\n";
        }
    }
}

# Ajouter les clients
if (@add_clients) {
    foreach my $i (0 .. $#add_clients / 3) {
        my ($name, $mac, $ip) = @add_clients[$i*3 .. $i*3+2];
        SystemImager::KeaConfUtils::add_client($config, $name, $mac, $ip, $global, $debug) or next;
    }
}

# Supprimer les clients
my $deleted_count = 0;
my @deleted_clients;
if (@del_clients) {
    my @remaining_global_reservations;
    $config->{"Dhcp4"}->{"reservations"} ||= [];
    foreach my $reservation (@{$config->{"Dhcp4"}->{"reservations"}}) {
        my $keep = 1;
        foreach my $criterion (@del_clients) {
            $criterion =~ s/\*/.*/g;
            if (($reservation->{"hostname"} && $reservation->{"hostname"} =~ /^$criterion$/) ||
                ($reservation->{'hw-address'} && $reservation->{'hw-address'} =~ /^$criterion$/i) ||
                ($reservation->{'ip-address'} && $reservation->{'ip-address'} =~ /^$criterion$/)) {
                $keep = 0;
                $deleted_count++;
                push @deleted_clients, $reservation->{"hostname"} || $reservation->{'hw-address'} || $reservation->{'ip-address'};
            }
        }
        push @remaining_global_reservations, $reservation if $keep;
    }
    $config->{"Dhcp4"}->{"reservations"} = \@remaining_global_reservations;

    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            next unless exists $subnet->{"reservations"};
            my @remaining_subnet_reservations;
            foreach my $reservation (@{$subnet->{"reservations"}}) {
                my $keep = 1;
                foreach my $criterion (@del_clients) {
                    $criterion =~ s/\*/.*/g;
                    if (($reservation->{"hostname"} && $reservation->{"hostname"} =~ /^$criterion$/) ||
                        ($reservation->{'hw-address'} && $reservation->{'hw-address'} =~ /^$criterion$/i) ||
                        ($reservation->{'ip-address'} && $reservation->{'ip-address'} =~ /^$criterion$/)) {
                        $keep = 0;
                        $deleted_count++;
                        push @deleted_clients, $reservation->{"hostname"} || $reservation->{'hw-address'} || $reservation->{'ip-address'};
                    }
                }
                push @remaining_subnet_reservations, $reservation if $keep;
            }
            $subnet->{"reservations"} = \@remaining_subnet_reservations;
        }
    }

    if ($deleted_count > 0) {
        print "Supprimé $deleted_count client(s) : ", join(", ", @deleted_clients), "\n";
    } else {
        print "Aucun client supprimé\n";
    }
}

# Vérifier les doublons d'ID
my %id_check;
if (exists $config->{"Dhcp4"}->{"subnet4"}) {
    foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
        die "Erreur: ID de sous-réseau dupliqué : $subnet->{id} pour $subnet->{subnet}\n" if exists $id_check{$subnet->{"id"}};
        $id_check{$subnet->{"id"}} = 1;
    }
}

# Si aucune modification n'est demandée et aucun sous-réseau n'existe
if (!@add_networks && !@add_clients && !@del_clients && !@del_networks && !exists $config->{"Dhcp4"}->{"subnet4"}) {
    die "Aucun sous-réseau défini et aucune modification demandée\n";
}

# Mettre à jour les interfaces
if (exists $config->{"Dhcp4"}->{"subnet4"} && @{$config->{"Dhcp4"}->{"subnet4"}}) {
    my @all_networks = map { $_->{"subnet"} } @{$config->{"Dhcp4"}->{"subnet4"}};
    $config->{"Dhcp4"}->{"interfaces-config"} = {
        "interfaces" => [ SystemImager::IpUtils::get_network_interfaces(@all_networks) ]
    };
} else {
    $config->{"Dhcp4"}->{"interfaces-config"} = {
        "interfaces" => []
    };
}

# Mettre à jour la base de données de leases
$config->{"Dhcp4"}->{"lease-database"} = {
    "type" => "memfile",
    "persist" => JSON::PP::true,
    "name" => "/var/lib/kea/dhcp4.leases"
};

# Mettre à jour ou ajouter les classes de clients
my @client_classes = (
    {
        "name" => "IA32_UEFI",
        "test" => "option[93].hex == 0x0006",
        "option-data" => [
            {
                "name" => "boot-file-name",
                "code" => 67,
                "space" => "dhcp4",
                "data" => "bootia32.efi"
            }
        ]
    },
    {
        "name" => "X64_UEFI",
        "test" => "option[93].hex == 0x0007",
        "option-data" => [
            {
                "name" => "boot-file-name",
                "code" => 67,
                "space" => "dhcp4",
                "data" => "grubx64.efi"
            }
        ]
    },
    {
        "name" => "ARM64_UEFI",
        "test" => "option[93].hex == 0x000B",
        "option-data" => [
            {
                "name" => "boot-file-name",
                "code" => 67,
                "space" => "dhcp4",
                "data" => "grubaa64.efi"
            }
        ]
    },
    {
        "name" => "PXE_LEGACY",
        "test" => "option[93].hex == 0x0000",
        "option-data" => [
            {
                "name" => "boot-file-name",
                "code" => 67,
                "space" => "dhcp4",
                "data" => "pxelinux.0"
            }
        ]
    }
);

# Préserver les classes existantes
my %existing_classes;
if (exists $config->{"Dhcp4"}->{"client-classes"}) {
    foreach my $class (@{$config->{"Dhcp4"}->{"client-classes"}}) {
        next unless defined $class->{"name"};
        $existing_classes{$class->{"name"}} = $class unless grep { defined $_->{"name"} && $_->{"name"} eq $class->{"name"} } @client_classes;
    }
}
$config->{"Dhcp4"}->{"client-classes"} = [
    @client_classes,
    values %existing_classes
];

# Mettre à jour les définitions d'options
my @option_def = (
    {
        "name" => "image-server",
        "code" => 200,
        "type" => "ipv4-address",
        "space" => "dhcp4"
    },
    ($log_server ? {
        "name" => "log-server",
        "code" => 201,
        "type" => SystemImager::IpUtils::valid_ip($log_server) ? "ipv4-address" : "string",
        "space" => "dhcp4"
    } : ()),
    ($log_server_port ? {
        "name" => "log-server-port",
        "code" => 202,
        "type" => "uint16",
        "space" => "dhcp4"
    } : ()),
    (defined $ssh_download_url ? {
        "name" => "ssh-download-url",
        "code" => 203,
        "type" => "string",
        "space" => "dhcp4"
    } : ()),
    (defined $flamethrower_port_base ? {
        "name" => "flamethrower-port-base",
        "code" => 204,
        "type" => "uint16",
        "space" => "dhcp4"
    } : ()),
    ($staging_dir ? {
        "name" => "staging-dir",
        "code" => 205,
        "type" => "string",
        "space" => "dhcp4"
    } : ())
);

# Préserver les définitions d'options existantes
my %existing_option_def;
if (exists $config->{"Dhcp4"}->{"option-def"}) {
    foreach my $def (@{$config->{"Dhcp4"}->{"option-def"}}) {
        next unless defined $def->{"name"};
        $existing_option_def{$def->{"name"}} = $def unless grep { defined $_->{"name"} && $_->{"name"} eq $def->{"name"} } @option_def;
    }
}
$config->{"Dhcp4"}->{"option-def"} = [
    @option_def,
    values %existing_option_def
];

# Mettre à jour les données d'options
my @option_data = (
    ($dns_domain ? { 
        "name" => "domain-name", 
        "code" => 15,
        "space" => "dhcp4",
        "data" => $dns_domain 
    } : ()),
    (@dns_servers ? { 
        "name" => "domain-name-servers", 
        "code" => 6,
        "space" => "dhcp4",
        "data" => join(',', @dns_servers) 
    } : ()),
    { 
        "name" => "boot-file-name", 
        "code" => 67,
        "space" => "dhcp4",
        "data" => "pxelinux.0" 
    },
    { 
        "name" => "tftp-server-name", 
        "code" => 66,
        "space" => "dhcp4",
        "data" => $boot_server 
    },
    { 
        "name" => "image-server", 
        "space" => "dhcp4",
        "data" => $image_server 
    },
    ($log_server ? { 
        "name" => "log-server", 
        "space" => "dhcp4",
        "data" => $log_server 
    } : ()),
    ($log_server_port ? { 
        "name" => "log-server-port", 
        "space" => "dhcp4",
        "data" => "$log_server_port" 
    } : ()),
    (defined $ssh_download_url ? { 
        "name" => "ssh-download-url", 
        "space" => "dhcp4",
        "data" => $ssh_download_url 
    } : ()),
    (defined $flamethrower_port_base ? { 
        "name" => "flamethrower-port-base", 
        "space" => "dhcp4",
        "data" => "$flamethrower_port_base" 
    } : ()),
    ($staging_dir ? { 
        "name" => "staging-dir", 
        "space" => "dhcp4",
        "data" => $staging_dir 
    } : ())
);

# Préserver les options existantes
my %existing_option_data;
if (exists $config->{"Dhcp4"}->{"option-data"}) {
    foreach my $opt (@{$config->{"Dhcp4"}->{"option-data"}}) {
        next unless defined $opt->{"name"};
        $existing_option_data{$opt->{"name"}} = $opt unless grep { defined $_->{"name"} && $_->{"name"} eq $opt->{"name"} } @option_data;
    }
}
$config->{"Dhcp4"}->{"option-data"} = [
    @option_data,
    values %existing_option_data
];

# Écrire la configuration si des modifications ont été demandées
if ($has_modifications) {
    SystemImager::KeaConfUtils::write_kea_config($config, $config_file);
}

# Fonction pour afficher l'aide
sub print_usage {
    print <<'EOF';
Usage: si_mkdhcpserver [options]
Options:
  --dns-domain <domain>           Domaine DNS (par défaut: /etc/resolv.conf)
  --dns-servers <servers>         Liste de serveurs DNS (séparés par des espaces)
  --add-network <ip/mask> [<ip_debut> <ip_fin>]  Ajoute ou met à jour un réseau
  --del-network <ip/mask> [--force]  Supprime un réseau
  --image-server <ip|fqdn>        Serveur d'image (par défaut: IP locale)
  --boot-server <ip|fqdn>         Serveur de boot (par défaut: IP locale)
  --log-server <ip|fqdn>          Adresse du serveur de logs
  --log-server-port <port>        Port du serveur de logs (1-65535)
  --ssh-download-url [<url>]      URL pour téléchargement SSH
  --flamethrower-port-base [<port>] Port de base pour Flamethrower (par défaut: 8000)
  --staging-dir <path>            Répertoire temporaire pour staging
  --add-client <nom> <MAC> <IP> [--global]  Ajoute une réservation (globale si --global)
  --del-client <nom|MAC|IP>       Supprime des réservations (support des wildcards *)
  --list-clients [--csv]          Liste les réservations
  --list-pools [--csv]            Liste les pools
  --list-subnets [--csv]          Liste les sous-réseaux
  --file <path>                   Fichier de configuration (par défaut: /etc/kea/kea-dhcp4.conf)
  --debug                         Active les messages de débogage
  --help                          Affiche cette aide
EOF
}

__END__

=encoding utf8

=head1 NAME

si_mkdhcpserver - Génère un fichier de configuration pour le serveur Kea DHCPv4

=head1 SYNOPSIS

si_mkdhcpserver [options]

=head1 DESCRIPTION

Le script C<si_mkdhcpserver> génère un fichier de configuration JSON pour le serveur Kea DHCPv4, enregistré dans F</etc/kea/kea-dhcp4.conf>. Il permet de configurer des sous-réseaux, des pools, des réservations de clients, et des options DHCP spécifiques. Le script prend en charge l'ajout, la suppression et la mise à jour de sous-réseaux et de réservations, ainsi que l'affichage des informations de configuration existantes. La version 0.8.2 inclut des améliorations pour la modularité avec l'utilisation des modules C<SystemImager::IpUtils> et C<SystemImager::KeaConfUtils>. Les commentaires dans le fichier de configuration existant ne sont pas préservés, sauf pour un en-tête standard ajouté lors de la génération du fichier.

=head1 OPTIONS

=over 4

=item B<--dns-domain> <domain>

Spécifie le domaine DNS à utiliser pour les clients DHCP. Par défaut, le domaine est extrait de F</etc/resolv.conf> (champ C<domain>).

=item B<--dns-servers> <servers>

Liste des serveurs DNS (IP ou FQDN) séparés par des espaces. Les adresses doivent être valides (IPv4 ou noms de domaine valides).

=item B<--add-network> <ip/mask> [<ip_debut> <ip_fin>]

Ajoute ou met à jour un sous-réseau avec l'adresse réseau et le masque spécifiés (format C<xxx.xxx.xxx.xxx/n>). Si C<ip_debut> et C<ip_fin> sont fournis, un pool DHCP est défini pour ce sous-réseau. La fonction C<SystemImager::KeaConfUtils::add_network> vérifie que :
- L'adresse IP et le masque sont valides.
- Les adresses de début et de fin du pool sont dans le sous-réseau et cohérentes.
- Le pool ne chevauche pas partiellement un pool existant.
- Le pool n'inclut pas d'adresses réservées globalement.

Un identifiant unique est assigné au sous-réseau.

=item B<--del-network> <ip/mask> [--force]

Supprime un sous-réseau spécifié. Si le sous-réseau contient des réservations, l'opération échoue sauf si C<--force> est utilisé, auquel cas les réservations globales correspondantes sont supprimées.

=item B<--image-server> <ip|fqdn>

Adresse du serveur d'image (IP ou FQDN). Par défaut, utilise l'adresse IP locale détectée via C<SystemImager::IpUtils::get_local_ip>.

=item B<--boot-server> <ip|fqdn>

Adresse du serveur de démarrage (IP ou FQDN). Par défaut, utilise l'adresse IP locale.

=item B<--log-server> <ip|fqdn>

Adresse du serveur de logs (IP ou FQDN). Ajoute une option DHCP personnalisée (code 201).

=item B<--log-server-port> <port>

Port du serveur de logs (1-65535). Ajoute une option DHCP personnalisée (code 202).

=item B<--ssh-download-url> [<url>]

URL pour le téléchargement SSH des images. Par défaut, utilise C<ssh://<image-server>/var/lib/systemimager/images>. Ajoute une option DHCP personnalisée (code 203).

=item B<--flamethrower-port-base> [<port>]

Port de base pour Flamethrower (par défaut: 8000). Ajoute une option DHCP personnalisée (code 204).

=item B<--staging-dir> <path>

Répertoire temporaire pour le staging. Ajoute une option DHCP personnalisée (code 205).

=item B<--add-client> <nom> <MAC> <IP> [--global]

Ajoute une réservation pour un client avec C<SystemImager::KeaConfUtils::add_client>. Vérifie l'unicité du nom, de la MAC, et de l'IP dans toute la configuration. Sans C<--global>, l'IP doit appartenir à un sous-réseau défini.

=item B<--del-client> <nom|MAC|IP>

Supprime les réservations correspondant au critère (support des wildcards *).

=item B<--list-clients> [--csv]

Liste les réservations avec C<SystemImager::KeaConfUtils::list_clients>. Colonnes : subnet, subnet-id, net-interface, fqdn, MAC, IP. Format CSV avec C<--csv>.

=item B<--list-pools> [--csv]

Liste les pools avec C<SystemImager::KeaConfUtils::list_pools>. Colonnes : subnet, subnet-id, net-interface, pool-start, pool-end. Format CSV avec C<--csv>.

=item B<--list-subnets> [--csv]

Liste les sous-réseaux avec C<SystemImager::KeaConfUtils::list_networks>. Colonnes : subnet, subnet-id, ip-min, ip-max. Format CSV avec C<--csv>.

=item B<--file> <path>

Spécifie le chemin du fichier de configuration Kea DHCPv4 (par défaut: F</etc/kea/kea-dhcp4.conf>).

=item B<--debug>

Active les messages de débogage.

=item B<--help>

Affiche l'aide.

=back

=head1 NOTES

- Les interfaces réseau sont détectées via C<SystemImager::IpUtils::get_network_interfaces>. "N/A" est affiché si aucune interface ne correspond à un sous-réseau.
- Les réservations ajoutées avec C<--add-client> sont placées dans le sous-réseau correspondant à l'IP (vérifié avec C<SystemImager::IpUtils::is_ip_in_network>) ou globalement avec C<--global>. L'unicité est vérifiée dans toute la configuration.
- Les options de listage utilisent les fonctions de C<SystemImager::KeaConfUtils> et affichent "N/A" pour les champs manquants ou les interfaces non associées.
- Les commentaires sont limités à l'en-tête standard généré par C<SystemImager::KeaConfUtils::write_kea_config>.
- Les paramètres non définis pour C<--add-network> sont maintenant correctement gérés pour éviter les erreurs de type "Use of uninitialized value".

=head1 EXIT STATUS

=over 4

=item B<0> Succès.

=item B<1> Erreur (fichier non accessible, paramètres invalides, conflits, etc.).

=back

=head1 DEPENDENCIES

Modules Perl :
- C<Getopt::Long>
- C<JSON::PP>
- C<File::Spec>
- C<Text::Table>
- C<SystemImager::IpUtils>
- C<SystemImager::KeaConfUtils>

Commandes externes :
- C<ip> (pour détecter les interfaces réseau)
- C<kea-dhcp4> (avertissement si non installé)

=head1 FILES

=over 4

=item F</etc/kea/kea-dhcp4.conf>

Fichier de configuration généré.

=item F</var/lib/kea/dhcp4.leases>

Fichier de leases.

=item F</etc/resolv.conf>

Source du domaine DNS par défaut.

=back

=head1 BUGS

- Les commentaires existants ne sont pas préservés, sauf l'en-tête standard.
- Les sous-réseaux mal formés dans la configuration existante sont ignorés.
- Signalez les bugs à l'équipe SystemImager.

B<Problèmes résolus dans la version 0.8.2> :
- Correction des erreurs "Use of uninitialized value" dans C<SystemImager::KeaConfUtils::add_pool> et C<SystemImager::IpUtils::valid_ip> en ajoutant des vérifications explicites pour les paramètres indéfinis.

=head1 AUTHOR

Équipe SystemImager

=head1 SEE ALSO

kea-dhcp4(8), kea-ctrl-agent(8), systemimager(1)

=cut
