#!/usr/bin/perl -w

#
#    vi:set filetype=perl:
#
#    This file is part of SystemImager.
#
#    SystemImager is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 2 of the License, or
#    (at your option) any later version.
#
#    SystemImager is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with SystemImager. If not, see <https://www.gnu.org/licenses/>.
#
#    Copyright (C) 2025 Olivier Lahaye <olivier.lahaye1@free.fr>
#
#    Others who have contributed to this code (in alphabetical order):
#     Grok 3 https://grok.com
#
#    See http://www.iana.org/assignments/bootp-dhcp-parameters for info on
#    custom option numbers.
#

use strict;
use Getopt::Long qw(:config no_bundling no_auto_help);
use Pod::Usage;
use File::Spec;
use File::Copy;
use POSIX qw(strftime);
use SystemImager::IpUtils qw(valid_ip valid_hostname valid_fqdn);
use SystemImager::KeaConfUtils;

# Global variables
my $config_file = "/etc/kea/kea-dhcp4.conf";
my $debug = 0;
my $quiet = 0;
my $force = 0;
my $help = 0;
my $man = 0;
my @add_subnets;
my @del_subnets;
my @add_pools;
my @del_pools;
my @add_clients;
my @del_clients;
my $list_subnets = 0;
my $list_pools = 0;
my $list_clients = 0;
my $csv = 0;
my @dns_domains;
my @dns_searches;
my @dns_servers;
my @image_servers;
my @boot_servers;
my @log_servers;
my @log_server_ports;
my @ssh_download_urls;
my @flamethrower_port_bases;
my @staging_dir;

# Override die to use pod2usage for option-related errors
BEGIN {
    *CORE::GLOBAL::die = sub {
        my ($message) = @_;
        if ($quiet && !($help || $man || $debug)) {
            exit 1;  # Simply exit with status 1 when quiet is enabled
        }
        chomp $message;
        my ($option) = ($message =~ /--([\w-]+):/);
        if ($option) {
            pod2usage(
                -message => $message,
                -sections => [ "SYNOPSIS", "OPTIONS/$option" ],
                -exitval => 1,
                -verbose => 99
            );
        } else {
            local $! = 1;  # Set $! to control the exit code
            CORE::die "$message\n";
        }
    };
}

# Pre-parse @ARGV to set $debug early
for (my $i = 0; $i < @ARGV; $i++) {
    if ($ARGV[$i] =~ /^--debug(?:=(\d+))?$/ || ($ARGV[$i] eq "--debug" && $i + 1 < @ARGV && $ARGV[$i + 1] !~ /^--/)) {
        $debug = defined $1 ? $1 : ($i + 1 < @ARGV ? $ARGV[$i + 1] : 0);
        $debug = 0 if $debug !~ /^\d+$/;
        last;
    }
}

# Function: check_arg
# Description: Validates an option argument based on its type. Ensures the argument does not start with "--" and matches the specified type.
# Parameters:
#   $opt - String, the name of the option
#   $value - String, the argument to validate
#   $type - String, the expected type ('ip', 'path', 'file', 'subnet', 'client', 'fqdn', 'mac', 'port', 'ssh_url', 'host')
# Returns: The validated argument
# Dies: If the argument starts with "--" or fails type validation
sub check_arg {
    my ($opt, $value, $type) = @_;
    die "--$opt: Insufficient arguments.\n" if $value =~ /^--/;
    if ($type eq 'ip') {
        die "--$opt: Invalid IPv4 address: $value\n" unless valid_ip($value);
    } elsif ($type eq 'path') {
        die "--$opt: Invalid path format: $value\n" unless $value =~ m|^/(?:[a-zA-Z0-9._-][a-zA-Z0-9._-]*(?:/[a-zA-Z0-9._-][a-zA-Z0-9._-]*)*)?$|;
    } elsif ($type eq 'file') {
        die "--$opt: Invalid file path: $value\n" unless $value =~ m|^[\w/.-]+$| && $value !~ m|^\s*$|;
    } elsif ($type eq 'subnet') {
        die "--$opt: Invalid subnet format: $value\n" unless $value =~ m|^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/\d{1,2}$|;
    } elsif ($type eq 'client') {
        die "--$opt: Invalid client format: $value\n"
            unless $value =~ m{^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?)*|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2})$};
    } elsif ($type eq 'hostname') {
        die "--$opt: Invalid hostname format: $value\n"
            unless valid_hostname($value);
    } elsif ($type eq 'fqdn') {
        die "--$opt: Invalid FQDN format: $value\n"
            unless valid_fqdn($value);
    } elsif ($type eq 'mac') {
        die "--$opt: Invalid MAC address: $value\n"
            unless $value =~ /^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$/;
    } elsif ($type eq 'port') {
        die "--$opt: Invalid port format: $value\n" unless $value =~ m|^\d+$| && $value >= 0 && $value <= 65535;
    } elsif ($type eq 'ssh_url') {
        die "--$opt: Invalid SSH URL path format: $value\n"
            unless $value =~ m|^/(?:[a-zA-Z0-9._-][a-zA-Z0-9._-]*(?:/[a-zA-Z0-9._-][a-zA-Z0-9._-]*)*)?$|;
    } elsif ($type eq 'host') {
		# A host can be either an IPv4 address or an FQDN (with or without trailing dot)
        die "--$opt: Invalid host format (must be IPv4 or FQDN): $value\n"
            unless valid_ip($value) || valid_fqdn($value);
    } else {
        die "--$opt: Unknown validation type: $type\n";
    }
    return $value;
}

#
# Function: get_modifier
# Description: Retrieves the modifier (--subnet or --client) and its value from @ARGV.
#              Returns --global with undef value if no valid modifier is found.
# Parameters:
#   None (uses global @ARGV)
# Returns: Hash reference with keys:
#   - modifier: String ("--global", "--subnet", or "--client")
#   - modifier_value: S
#
sub get_modifier {
    my $modifier = "--global";
    my $modifier_value = undef;
    print "get_modifier called, ARGV=", join(", ", @ARGV), "\n" if $debug >= 3;
    if (@ARGV && $ARGV[0] =~ /^--(subnet|client)$/) {
        if (@ARGV > 1) {
            $modifier = "--$1";
            $modifier_value = $ARGV[1];
            print "Found modifier=$modifier, value=$modifier_value\n" if $debug >= 3;
            # Warn if the value looks like another option (possible missing value)
            print "Warning: Modifier $modifier value '$modifier_value' looks like an option; possible missing value?\n" if $debug >= 1 && $modifier_value =~ /^--/;
        } else {
            print "Warning: Modifier $modifier found but no value provided\n" if $debug >= 1;
        }
    }
    return { modifier => $modifier, modifier_value => $modifier_value };
}

#
# Function: process_option_values
# Description: Processes option values by validating and collecting them into a temporary array.
#              When a modifier or new option is encountered, it creates a hash with the collected
#              values and their associated modifier, then pushes it to the target array.
# Parameters:
#   $opt - String, the name of the option
#   $value - String, the value to process
#   $temp_array_ref - Array reference, temporary array to collect values
#   $target_array_ref - Array reference, target array to store the final hash
#   $arg_type - String, the type for validation ('ip', 'fqdn', etc.)
# Returns: None
# Dies: If validation via check_arg fails
#
sub process_option_values {
    my ($opt, $value, $temp_array_ref, $target_array_ref, $arg_type) = @_;
    # Validate the value
    $value = check_arg($opt, $value, $arg_type);
    # Add value to temporary array
    push @$temp_array_ref, $value;
    # Check for a following modifier or new option
    if (!@ARGV || $ARGV[0] =~ /^--/) {
        # Push collected values as a hash to target array if temp array is not empty
        if (@$temp_array_ref) {
            my $modifier_ref = get_modifier();
            my $hash = {
                params => [@$temp_array_ref],
                modifier => substr($modifier_ref->{modifier}, 2),  # Remove "--" prefix
                modifier_value => $modifier_ref->{modifier_value}
            };
            push @$target_array_ref, $hash;
            # Reset temporary array
            @$temp_array_ref = ();
        }
    }
}

# Function: push_remaining_params
# Description: Pushes any remaining values in the temporary array to the target array
#              as a hash with a "global" modifier and undef modifier_value.
# Parameters:
#   $temp_array_ref - Array reference, temporary array containing values
#   $target_array_ref - Array reference, target array to store the hash
# Returns: None
# Dies: None
sub push_remaining_params {
    my ($temp_array_ref, $target_array_ref) = @_;
    if (@$temp_array_ref) {
        my $hash = {
            params => [@$temp_array_ref],
            modifier => "global",
            modifier_value => undef
        };
        push @$target_array_ref, $hash;
        @$temp_array_ref = ();  # Reset temporary array
    }
}

# Function: set_option
# Description: Applies a configuration option to the Kea configuration based on the modifier.
#              Handles both single-value and multi-value options, joining multiple values into
#              a CSV string if required. Calls SystemImager::KeaConfUtils::set_option or
#              set_client_option depending on the modifier.
# Parameters:
#   $config - Hash reference, the Kea configuration
#   $values - Array reference, the values for the option
#   $modifier - String, the modifier ("subnet", "client", or "global")
#   $modifier_value - String or undef, the value associated with the modifier
#   $option_name - String, the name of the option (e.g., "domain-name", "next-server")
#   $multiple_values - Boolean, true if values should be joined into a CSV string
# Returns: Array of ($success, $msg) where $success is a boolean and $msg is the status message
# Dies: None
sub set_option {
    my ($config, $values, $modifier, $modifier_value, $option_name, $multiple_values) = @_;
    my $value = $multiple_values ? join(",", @$values) : $values->[0];  # Use CSV for multiple values, first value otherwise
    if ($modifier eq 'subnet') {
        print "Calling set_option($option_name, $value, $modifier_value)\n" if $debug >= 2;
        return SystemImager::KeaConfUtils::set_option($config, $option_name, $value, $modifier_value);
    } elsif ($modifier eq 'client') {
        print "Calling set_client_option($modifier_value, $option_name, $value)\n" if $debug >= 2;
        return SystemImager::KeaConfUtils::set_client_option($config, $modifier_value, $option_name, $value);
    } else {
        print "Calling set_option($option_name, $value, global)\n" if $debug >= 2;
        return SystemImager::KeaConfUtils::set_option($config, $option_name, $value);
    }
}

# Define option arrays for options that support modifiers
my %option_arrays = (
    'dns-domain'            => { temp => [], target => \@dns_domains, arg_type => 'fqdn' },
    'dns-search'            => { temp => [], target => \@dns_searches, arg_type => 'fqdn' },
    'dns-servers'           => { temp => [], target => \@dns_servers, arg_type => 'ip' },
    'image-servers'         => { temp => [], target => \@image_servers, arg_type => 'host' },
    'boot-server'           => { temp => [], target => \@boot_servers, arg_type => 'ip' },
    'log-servers'           => { temp => [], target => \@log_servers, arg_type => 'ip' },
    'log-server-port'       => { temp => [], target => \@log_server_ports, arg_type => 'port' },
    'ssh-download-url'      => { temp => [], target => \@ssh_download_urls, arg_type => 'ssh_url' },
    'flamethrower-port-base' => { temp => [], target => \@flamethrower_port_bases, arg_type => 'port' },
    'staging-dir'           => { temp => [], target => \@staging_dir, arg_type => 'path' },
);


# Define option handlers for options that support modifiers
# Each entry specifies the option name and whether it accepts multiple values (joined as CSV)
my %option_handlers = (
    'dns-domain' => {
        option_name => 'domain-name',
        multiple_values => 0,  # Single value
    },
    'dns-search' => {
        option_name => 'domain-search',
        multiple_values => 0,  # Single value
    },
    'dns-servers' => {
        option_name => 'domain-name-servers',
        multiple_values => 1,  # Multiple values, joined as CSV
    },
    'image-servers' => {
        option_name => 'image-servers',
        multiple_values => 1,  # Multiple values, joined as CSV
    },
    'boot-server' => {
        option_name => 'next-server',
        multiple_values => 0,  # Single value
    },
    'log-servers' => {
        option_name => 'log-servers',
        multiple_values => 1,  # Multiple values, joined as CSV
    },
    'log-server-port' => {
        option_name => 'log-server-port',
        multiple_values => 0,  # Single value
    },
    'ssh-download-url' => {
        option_name => 'ssh-download-url',
        multiple_values => 0,  # Single value
    },
    'flamethrower-port-base' => {
        option_name => 'flamethrower-port-base',
        multiple_values => 0,  # Single value
    },
    'staging-dir' => {
        option_name => 'tmpfs-staging',
        multiple_values => 0,  # Single value
    },
);

# Parse command line options

# Configure Getopt::Long to pass through unrecognized options
# Complex options are parsed manually.
Getopt::Long::Configure("pass_through");

GetOptions(
    "file=s"              => sub {
        $config_file = check_arg(@_, 'file');
    },
    "debug:i"             => \$debug,
    "quiet"               => \$quiet,
    "help"                => \$help,
    "man"                 => \$man,
    "force"               => \$force,
    "add-subnet=s{1}"     => sub {
        push @add_subnets, check_arg(@_, 'subnet');
    },
    "del-subnet=s{1}"     => sub {
        push @del_subnets, check_arg(@_, 'subnet');
    },
    "add-pool=s{2}"       => sub {
        push @add_pools, check_arg(@_, 'ip'); # called for each parameter. (resulting in a flat list)
    },
    "del-pool=s{2}"       => sub {
        push @del_pools, check_arg(@_, 'ip'); # called for each parameter. (resulting in a flat list)
    },
    "add-client=s{3,4}"   => sub {
        my ($opt, @args) = @_;
        push @add_clients, @args;
        push @add_clients, shift @ARGV if defined $ARGV[0] && $ARGV[0] =~ /^--global/; # --xxx seen as option, thus sub not triggered 
    },
    "del-client=s{1}"     => sub {
        push @del_clients, [check_arg(@_, 'client')];
    },
    "dns-domain=s"        => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'dns-domain'}{temp}, $option_arrays{'dns-domain'}{target}, $option_arrays{'dns-domain'}{arg_type});
    },
    "dns-search=s"        => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'dns-search'}{temp}, $option_arrays{'dns-search'}{target}, $option_arrays{'dns-search'}{arg_type});
    },
    "dns-servers=s{1,}"   => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'dns-servers'}{temp}, $option_arrays{'dns-servers'}{target}, $option_arrays{'dns-servers'}{arg_type});
    },
    "image-servers=s{1,}" => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'image-servers'}{temp}, $option_arrays{'image-servers'}{target}, $option_arrays{'image-servers'}{arg_type});
    },
    "boot-server=s"       => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'boot-server'}{temp}, $option_arrays{'boot-server'}{target}, $option_arrays{'boot-server'}{arg_type});
    },
    "log-servers=s{1,}"   => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'log-servers'}{temp}, $option_arrays{'log-servers'}{target}, $option_arrays{'log-servers'}{arg_type});
    },
    "log-server-port=i"   => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'log-server-port'}{temp}, $option_arrays{'log-server-port'}{target}, $option_arrays{'log-server-port'}{arg_type});
    },
    "ssh-download-url=s"  => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'ssh-download-url'}{temp}, $option_arrays{'ssh-download-url'}{target}, $option_arrays{'ssh-download-url'}{arg_type});
    },
    "flamethrower-port-base=i" => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'flamethrower-port-base'}{temp}, $option_arrays{'flamethrower-port-base'}{target}, $option_arrays{'flamethrower-port-base'}{arg_type});
    },
    "staging-dir=s"       => sub {
        my ($opt, $value) = @_;
        process_option_values($opt, $value, $option_arrays{'staging-dir'}{temp}, $option_arrays{'staging-dir'}{target}, $option_arrays{'staging-dir'}{arg_type});
    },
    "subnet=s"            => sub {
        my ($opt, $value) = @_;
        check_arg($opt, $value, 'subnet');
    },
    "client=s"            => sub {
        my ($opt, $value) = @_;
        check_arg($opt, $value, 'client');
    },
    "list-subnets"        => \$list_subnets,
    "list-pools"          => \$list_pools,
    "list-clients"        => \$list_clients,
    "csv"                 => \$csv,
) or die "Command failed. See documentation: ./si_mkdhcpserver --man";

# Push any remaining values in temporary arrays to their target arrays
foreach my $option (keys %option_arrays) {
    push_remaining_params($option_arrays{$option}{temp}, $option_arrays{$option}{target});
}

# Validate options
if ($quiet && ($help || $man || $debug)) {
    die "--quiet: is incompatible with --help, --man or --debug\n";
}

if ($help) {
   pod2usage(-verbose => 1,
             -exitval => 0);
}

if ($man) {
    pod2usage(-verbose => 2,
              -exitval => 0);
}

if (!@add_subnets && !@del_subnets && !@add_pools && !@del_pools && !@add_clients && !@del_clients &&
    !@dns_domains && !@dns_searches && !@dns_servers && !@image_servers && !@boot_servers &&
    !@log_servers && !@log_server_ports && !@ssh_download_urls && !@flamethrower_port_bases &&
    !@staging_dir && !$list_subnets && !$list_pools && !$list_clients) {
    print STDERR "Error: At least one action option is required\n";
    pod2usage(1);
    exit 1;
}

# Validate file permissions
my $needs_write = (@add_subnets || @del_subnets || @add_pools || @del_pools || @add_clients || @del_clients ||
                   @dns_domains || @dns_searches || @dns_servers || @image_servers || @boot_servers ||
                   @log_servers || @log_server_ports || @ssh_download_urls || @flamethrower_port_bases ||
                   @staging_dir);
if ($needs_write) {
    if (-e $config_file) {
        unless (-w $config_file) {
            print STDERR "Error: Configuration file '$config_file' is not writable\n" unless $quiet;
            exit 1;
        }
    } else {
        my $dir = File::Spec->catdir((File::Spec->splitpath($config_file))[0,1]);
        unless (-e $dir) {
            die "--file: directory '$dir' does not exists\n" unless $quiet;
            exit 1;
        }
        unless (-w $dir) {
            die "--file: Cannot create configuration file '$config_file' in directory '$dir'. Needs write permission\n" unless $quiet;
            exit 1;
        }
    }
} else {
    unless (-e $config_file) {
        die "--file: Configuration file '$config_file' does not exists\n" unless $quiet;
        exit 1;
    }
    unless (-r $config_file) {
        die "--file: Configuration file '$config_file' is not readable\n" unless $quiet;
        exit 1;
    }
}

# Load or initialize configuration
print "Calling load_kea_config\n" if $debug >= 2;
my ($config, $changelog) = SystemImager::KeaConfUtils::load_kea_config($config_file, $debug);
unless ($config) {
    print "Calling init_kea_config\n" if $debug >= 2;
    $config = SystemImager::KeaConfUtils::init_kea_config();
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S kea-dhcp4.conf generated from scratch by si_mkdhcpserver", localtime);
}

# Process modification options

# Process --add-subnet option
my $modified = 0;
foreach my $subnet (@add_subnets) {
    my ($ip, $mask) = split /\//, $subnet;
    unless (valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32) {
        print STDERR "Error: Invalid subnet format: $subnet\n" unless $quiet;
        exit 1;
    }
    print "Calling add_subnet($subnet)\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::add_subnet($config, $subnet);
    unless ($success) {
        print STDERR "Error: $msg\n" unless $quiet;
        exit 1;
    }
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

# Process --del-subnet option
foreach my $subnet (@del_subnets) {
    my ($ip, $mask) = split /\//, $subnet;
    unless (valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32) {
        print STDERR "Error: Invalid subnet format: $subnet\n" unless $quiet;
        exit 1;
    }
    print "Calling del_subnet($subnet, $force)\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::del_subnet($config, $subnet, $force);
    unless ($success) {
        print STDERR "Error: $msg\n" unless $quiet;
        exit 1;
    }
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

# Process --add-pool options
while (@add_pools) {
    my ($start_ip, $end_ip) = splice(@add_pools, 0, 2);
    print "Calling add_pool($start_ip, $end_ip)\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::add_pool($config, $start_ip, $end_ip);
    unless ($success) {
        print STDERR "Error: $msg\n" unless $quiet;
        exit 1;
    }
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

# Process --del-pool options
while (@del_pools) {
    my ($start_ip, $end_ip) = splice(@del_pools, 0, 2);
    print "Calling del_pool($start_ip, $end_ip)\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::del_pool($config, $start_ip, $end_ip);
    unless ($success) {
        print STDERR "Error: $msg\n" unless $quiet;
        exit 1;
    }
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

# Process --add-client options
while (@add_clients >= 3) {
    my $name = shift @add_clients;
    my $mac = shift @add_clients;
    my $ip = shift @add_clients;
    my $global = (@add_clients && $add_clients[0] eq "--global") ? shift @add_clients : undef;
    check_arg("add-client", $name, 'hostname');
    check_arg("add-client", $mac, 'mac');
    check_arg("add-client", $ip, 'ip');
    print "Calling add_client($name, $mac, $ip, ", ($global ? "global" : "subnet"), ")\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::add_client($config, $name, $mac, $ip, $global);
    die "Error: $msg" unless ($success);
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

foreach my $client (@del_clients) {
    my ($identifier) = @$client;
    print "Calling del_client($identifier)\n" if $debug >= 2;
    my ($success, $msg) = SystemImager::KeaConfUtils::del_client($config, $identifier);
    unless ($success) {
        print STDERR "Error: $msg\n" unless $quiet;
        exit 1;
    }
    print "$msg\n" unless $quiet;
    push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
    $modified = 1;
}

# Process options with modifiers
# Iterate over each option that supports modifiers and apply the corresponding
# configuration changes using the generic set_option function. Values are already
# validated by check_arg during GetOptions, so we directly call set_option with
# the option name and multiple_values flag from %option_handlers.
foreach my $option (keys %option_handlers) {
    my $handler = $option_handlers{$option};
    my $target_array = $option_arrays{$option}{target};
    foreach my $entry (@$target_array) {
        my $values = $entry->{params};  # Array of values for this option
        my $modifier = $entry->{modifier};
        my $modifier_value = $entry->{modifier_value};
        my ($success, $msg) = set_option(
            $config,
            $values,
            $modifier,
            $modifier_value,
            $handler->{option_name},
            $handler->{multiple_values}
        );
        unless ($success) {
            print STDERR "Error: $msg\n" unless $quiet;
            exit 1;
        }
        print "$msg\n" unless $quiet;
        push @$changelog, strftime("// %Y-%m-%d %H:%M:%S $msg", localtime);
        $modified = 1;
    }
}

# Write configuration if modified
if ($modified) {
    print "Calling write_kea_config\n" if $debug >= 2;
    unless (SystemImager::KeaConfUtils::write_kea_config($config_file, $config, $changelog, $debug)) {
        print STDERR "Error: Failed to write configuration file\n" unless $quiet;
        exit 1;
    }
    # Reload configuration to ensure consistency
    print "Reloading configuration after modification\n" if $debug >= 1;
    ($config, $changelog) = SystemImager::KeaConfUtils::load_kea_config($config_file, $debug);
    unless ($config) {
        print STDERR "Error: Failed to reload configuration after writing\n" unless $quiet;
        exit 1;
    }
}

# Process list options
$csv = 1 if $quiet && ($list_subnets || $list_pools || $list_clients);

if ($list_subnets) {
    print "Calling list_subnets\n" if $debug >= 2;
    SystemImager::KeaConfUtils::list_subnets($config, $csv, $quiet);
}
if ($list_pools) {
    print "Calling list_pools\n" if $debug >= 2;
    SystemImager::KeaConfUtils::list_pools($config, $csv, $quiet);
}
if ($list_clients) {
    print "Calling list_clients\n" if $debug >= 2;
    SystemImager::KeaConfUtils::list_clients($config, $csv, $quiet);
}

exit 0;

__END__

=pod

=head1 NAME

si_mkdhcpserver - SystemImager DHCP server configuration tool for Kea DHCPv4

=head1 SYNOPSIS

si_mkdhcpserver [options]

=head1 DESCRIPTION

B<si_mkdhcpserver> is a command-line tool designed to manage and configure Kea DHCPv4 server configurations. It creates and modifies Kea configuration files, typically F</etc/kea/kea-dhcp4.conf>, with support for SystemImager-specific options and client classes. The tool allows for adding subnets, pools, client reservations, and setting various DHCP options, either globally or scoped to specific subnets or clients. It also supports listing configuration elements in human-readable or CSV format.

=head1 OPTIONS

The options are processed in the order they appear on the command line. Modifiers (e.g., C<--subnet>, C<--client>, C<--global>, C<--force>, C<--csv>) apply to the option immediately preceding them. If an option is specified multiple times, each instance can have its own modifier, which applies only to that instance.

=head2 General Options

=over 4

=item B<--file> <filename>

Specifies the Kea configuration file to read and write. The default is F</etc/kea/kea-dhcp4.conf>. The file path must be valid, and the directory must exist and be writable. Invalid paths (e.g., containing special characters like C<|>) or non-existent directories will cause the command to fail.

Example: C<--file /tmp/kea-dhcp4.conf>

=item B<--debug> [n]

Enables debug output. The level C<n> controls verbosity:
- C<n=1>: Displays operations performed.
- C<n=2>: Includes function calls.
- C<n=3>: Includes data structures.

Incompatible with C<--quiet>.

Example: C<--debug 2>

=item B<--quiet>

Suppresses all output messages except for the results of list operations (C<--list-subnets>, C<--list-pools>, C<--list-clients>). Automatically enables CSV format for list options. Incompatible with C<--debug>, C<--help>, and C<--man>.

Example: C<--quiet --list-subnets>

=item B<--help>

Displays a brief help message summarizing available options and exits with status 0.

Example: C<--help>

=item B<--man>

Displays the full manual page (this documentation) and exits with status 0.

Example: C<--man>

=back

=head2 Configuration Modification Options

=over 4

=item B<--add-subnet> <ip/mask>

Adds a new subnet to the configuration, specified in CIDR notation (e.g., C<192.168.1.0/24>). Fails if the subnet already exists or if the IP/mask is invalid.

Example: C<--add-subnet 192.168.1.0/24>

=item B<--del-subnet> <ip/mask> [--force]

Deletes a subnet from the configuration. Fails if the subnet contains reservations unless C<--force> is specified. The C<--force> modifier applies only to the immediately preceding C<--del-subnet>.

Example: C<--del-subnet 192.168.1.0/24 --force>

=item B<--add-pool> <start-ip> <end-ip>

Adds an IP address pool to the appropriate subnet. The pool must be within an existing subnet, and the start and end IPs must be valid and in the correct order.

Example: C<--add-pool 192.168.1.10 192.168.1.20>

=item B<--del-pool> <start-ip> <end-ip>

Deletes an IP address pool from a subnet. The pool must exist in the configuration.

Example: C<--del-pool 192.168.1.10 192.168.1.20>

=item B<--add-client> <name> <MAC> <IP> [--global]

Adds a client reservation with the specified hostname, MAC address, and IP address. The hostname must be a valid simple hostname (no dots, per RFC 1123), the MAC address must be in the format C<xx:xx:xx:xx:xx:xx>, and the IP must be valid and within an existing subnet unless C<--global> is specified. The C<--global> modifier makes the reservation global rather than subnet-specific and applies only to the immediately preceding C<--add-client>.

Example: C<--add-client testclient 00:11:22:33:44:55 192.168.1.100 --global>

=item B<--del-client> <name|MAC|IP>

Deletes a client reservation identified by its hostname, MAC address, or IP address. Supports wildcards (e.g., C<test*> to delete all clients starting with "test").

Example: C<--del-client testclient>

=back

=head2 DHCP Option Configuration

These options configure DHCP options globally or for a specific subnet or client. The C<--subnet> or C<--client> modifier, when used, applies the option to the specified subnet or client and must immediately follow the option. Multiple instances of an option can be specified with different modifiers.

=over 4

=item B<--dns-domain> <domain> [--subnet <ip/mask>]

Sets the DHCP option C<domain-name> to the specified domain (a valid FQDN per RFC 1123, with or without a trailing dot). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--dns-domain example.com --subnet 192.168.1.0/24>

=item B<--dns-search> <domain1 domain2 ...> [--subnet <ip/mask>]

Sets the DHCP option C<domain-search> with one or more valid FQDNs (per RFC 1123, with or without trailing dots). Multiple domains are combined into a comma-separated value in the configuration and displayed in a single message (e.g., "Updated domain-search to example.com,example.org"). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--dns-search example.com example.org --subnet 192.168.1.0/24>

=item B<--dns-servers> <ip> [<ip> ...] [--subnet <ip/mask>]

Sets the DHCP option C<domain-name-servers> with one or more valid IP addresses. Multiple IPs are combined into a comma-separated value in the configuration and displayed in a single message (e.g., "Updated domain-name-servers to 8.8.8.8,8.8.4.4"). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--dns-servers 8.8.8.8 8.8.4.4 --subnet 192.168.1.0/24>

=item B<--image-servers> <ip|fqdn> [<ip|fqdn> ...] [--subnet <ip/mask>]

Sets the SystemImager-specific DHCP option C<image-servers> (code 200) with one or more IP addresses or valid FQDNs (per RFC 1123, with or without trailing dots). Multiple values are combined into a comma-separated value in the configuration and displayed in a single message (e.g., "Updated image-servers to server1.example.com,server2.example.com"). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--image-servers server1.example.com server2.example.com>

=item B<--boot-server> <ip> [--subnet <ip/mask>]

Sets the DHCP option C<next-server> (boot server) to a single valid IP address. Applies globally unless C<--subnet> specifies a subnet.

Example: C<--boot-server 192.168.1.1 --subnet 192.168.1.0/24>

=item B<--log-servers> <ip> [<ip> ...] [--subnet <ip/mask>]

Sets the SystemImager-specific DHCP option C<log-servers> (code 7) with one or more valid IP addresses. Multiple IPs are combined into a comma-separated value in the configuration and displayed in a single message (e.g., "Updated log-servers to 10.0.0.1,10.0.0.2"). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--log-servers 10.0.0.1 10.0.0.2>

=item B<--log-server-port> <port> [--subnet <ip/mask>]

Sets the SystemImager-specific DHCP option C<log-server-port> (code 8) to a single port number (uint16, 1-65535). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--log-server-port 514 --subnet 192.168.1.0/24>

=item B<--ssh-download-url> <user@host/path> [--subnet <ip/mask>]

Sets the SystemImager-specific DHCP option C<ssh-download-url> (code 201) to a URL in the format C<user@host/path>. Applies globally unless C<--subnet> specifies a subnet.

Example: C<--ssh-download-url user@server.example.com/image --subnet 192.168.1.0/24>

=item B<--flamethrower-port-base> <port> [--subnet <ip/mask>]

Sets the SystemImager-specific DHCP option C<flamethrower-port-base> (code 203) to a port number (uint16, 1-65535). Applies globally unless C<--subnet> specifies a subnet.

Example: C<--flamethrower-port-base 9000 --subnet 192.168.1.0/24>

=item B<--staging-dir> <path> [--subnet <ip/mask> | --client <name|MAC|IP>]

Sets the SystemImager-specific DHCP option C<staging-dir> (code 202) to a directory path (default: F</tmp>). Can be applied globally, to a subnet with C<--subnet>, or to a specific client with C<--client>. The C<--client> modifier supports wildcards.

Example: C<--staging-dir /mnt/staging --client testclient>

=back

=head2 List Options

=over 4

=item B<--list-subnets> [--csv]

Lists all subnets in the configuration. With C<--csv>, outputs in CSV format with columns: C<subnet,subnet-id,net-interface-name,ip-min,ip-max>. The C<--csv> modifier applies only to the immediately preceding C<--list-subnets>.

Example: C<--list-subnets --csv>

=item B<--list-pools> [--csv]

Lists all IP pools in the configuration. With C<--csv>, outputs in CSV format. The C<--csv> modifier applies only to the immediately preceding C<--list-pools>.

Example: C<--list-pools --csv>

=item B<--list-clients> [--csv]

Lists all client reservations in the configuration. With C<--csv>, outputs in CSV format. The C<--csv> modifier applies only to the immediately preceding C<--list-clients>.

Example: C<--list-clients --csv>

=back

=head2 Modifiers

Modifiers adjust the scope or behavior of the option they follow. Each modifier applies only to the option immediately preceding it in the command line. If an option is specified multiple times, each instance can have its own modifier, allowing fine-grained control over the configuration.

=over 4

=item B<--subnet> <ip/mask>

Specifies that the preceding option (e.g., C<--dns-domain>, C<--dns-servers>, etc.) applies to the given subnet (in CIDR notation, e.g., C<192.168.1.0/24>) rather than globally. The subnet must exist in the configuration.

Example:
  C<--dns-servers 8.8.8.8 --subnet 192.168.1.0/24 --dns-servers 1.1.1.1 --subnet 192.168.2.0/24>
  Applies C<8.8.8.8> to subnet C<192.168.1.0/24> and C<1.1.1.1> to subnet C<192.168.2.0/24>.

=item B<--client> <name|MAC|IP>

Specifies that the preceding option (e.g., C<--staging-dir>) applies to the client reservation identified by its hostname, MAC address, or IP address. Supports wildcards. The client must exist in the configuration.

Example:
  C<--staging-dir /mnt/client1 --client client1 --staging-dir /mnt/client2 --client client2>
  Sets different staging directories for clients C<client1> and C<client2>.

=item B<--global>

Specifies that the preceding C<--add-client> option creates a global reservation rather than a subnet-specific one. Only applies to C<--add-client>.

Example:
  C<--add-client client1 00:11:22:33:44:55 192.168.1.100 --global>
  Adds a global reservation for C<client1>.

=item B<--force>

Allows the preceding C<--del-subnet> option to delete a subnet even if it contains reservations. Only applies to C<--del-subnet>.

Example:
  C<--del-subnet 192.168.1.0/24 --force>
  Deletes the subnet and its reservations.

=item B<--csv>

Enables CSV output for the preceding list option (C<--list-subnets>, C<--list-pools>, C<--list-clients>). Also implied by C<--quiet> for list operations.

Example:
  C<--list-subnets --csv --list-pools>
  Outputs subnets in CSV format but pools in human-readable format.

=back

=head1 EXIT STATUS

=over 4

=item B<0>

Success: The configuration was modified or listed successfully, and the output file (if modified) is valid according to C<kea-dhcp4 -t>.

=item B<1>

Error: Invalid options, arguments, file permissions, or configuration issues (e.g., non-existent subnet, invalid IP).

=back

=head1 EXAMPLES

=over 4

=item Add a subnet and a pool:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --add-subnet 192.168.1.0/24 --add-pool 192.168.1.10 192.168.1.20>

=item Add a client reservation to a subnet:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --add-client testclient 00:11:22:33:44:55 192.168.1.100>

=item Add a global client reservation:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --add-client testclient 00:11:22:33:44:55 192.168.1.100 --global>

=item Set different DNS servers for two subnets:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --dns-servers 8.8.8.8 --subnet 192.168.1.0/24 --dns-servers 1.1.1.1 --subnet 192.168.2.0/24>

=item Set multiple options with different scopes:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --dns-domain example.com --dns-servers 8.8.8.8 --subnet 192.168.1.0/24 --staging-dir /mnt/client --client testclient>

=item List subnets in CSV format:

  C<si_mkdhcpserver --file /tmp/kea-dhcp4.conf --list-subnets --csv>

=back

=head1 AUTHOR

Olivier Lahaye <olivier.lahaye1@free.fr>

=head1 COPYRIGHT

Copyright (C) 2025 Olivier Lahaye
Licensed under the GNU General Public License v2 or later.

=cut

