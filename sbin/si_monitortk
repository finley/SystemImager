#!/usr/bin/perl -w
#
#  "SystemImager"
#
#  Copyright (C) 2005-2006 Andrea Righi <a.righi@cineca.it>
#  Copyright (C) 2005-2006 Bernard Li <bli@bcgsc.ca>

use lib "USR_PREFIX/lib/systemimager/perl";
use strict;
use Tk::HList;

# Hack the HList object to properly handle the single click on a list
# element.
package Tk::MyHList;
@Tk::MyHList::ISA = qw(Tk::HList);
Construct Tk::Widget 'MyHList';

sub ButtonRelease_1 {
}

package main;

# set version number
my $VERSION = "SYSTEMIMAGER_VERSION_STRING";
my $program_name = "si_monitortk";

use Socket;
use Tk;
use Tk::Label;
use Tk::Balloon;
use Tk::ItemStyle;
use Tk::ROText;
use Tk::ProgressBar;
use Tk::widgets qw/Dialog ErrorDialog/;
use Fcntl ':flock';
use XML::Simple;
use Getopt::Long qw(:config no_ignore_case bundling);

my $version_info = << "EOF";
perl (v$])
Tk (v$Tk::VERSION)

$program_name (part of SystemImager) v$VERSION

Copyright (C) 2005-2006 Andrea Righi <a.righi\@cineca.it>
Copyright (C) 2005-2006 Bernard Li <bli\@bcgsc.ca>

This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF

my $get_help = "\n       Try \"--help\" for more options.";

my $help_info = $version_info . <<"EOF";

Usage: $program_name [OPTION]...

Options: (options can be presented in any order and may be abbreviated)
 --help                 Display this output.

 --version              Display version and copyright information.

 --db DATABASENAME      Get clients informations from the XML file
                        DATABASENAME.

 --progress             Display a graphical progress bar, instead of
                        numerical percentages.

 --refresh RATE         Set the refresh rate (in sec).

Download, report bugs, and make suggestions at:
http://systemimager.org/
EOF

my $CONFDIR = '/etc/systemimager';

# load resources
my %conf;
my $conffile = "$CONFDIR/$program_name";
if (-r $conffile) {
    Config::Simple->import_from($conffile, \%conf);
}

# Get the lock directory. 
$conf{'lock_dir'} ||= "/var/lock/systemimager";
die "No such lock directory '$conf{'lock_dir'}'\n"
    if (! -d $conf{'lock_dir'});

# Get the database file.
$conf{'monitor_db'} ||= "/var/lib/systemimager/clients.xml";

my ($help, $version, $quiet, $database, $refresh_rate, $progress); 
GetOptions(
        "help"          => \$help,
        "version"       => \$version,
        "db=s"          => \$database,
        "progress"      => \$progress,
        "refresh=i"     => \$refresh_rate,
) or die "$help_info";
if ($help) {
    print "$help_info";
    exit(0);
}
if ($version) {
    print "$version_info";
    exit(0);
}

# Create the database if it doesn't exist.
$database = $conf{'monitor_db'};
unless (-f $database) {
    open(DB, '>', "$database") or
    die "error: cannot open file \"$database\" for writing!\n";
    close(DB);
}

# Set the refresh rate.
unless ($refresh_rate) {
    $refresh_rate = 5000;
} else {
    $refresh_rate *= 1000;
}

# Define lock files.
my $lock_file = $conf{'lock_dir'} . "/db.si_monitor.lock";

# Graphic stuff.
my (
    # Main window.
    $window,
    $tab, $timer, $status_bar, 
    $start_refresh_button, $stop_refresh_button,
    $clear_clients_button,
    $quit_button,
    $status_progress,
    
    # Selected node entry in the list.
    $selected_mac_addr,
    
    # Check if refreshing clients.
    $is_refreshing,

    # Field used to sort the nodes table.
    $sort_field,
    $sort_order,

    # Virtual console stuff.
    $sub_win,
    $sub_tab,
    $sub_title,
    $sub_mac_addr,
);

# Initialize refresing status.
$is_refreshing = 0;

# Set default sort options.
$sort_field = 'mac';
$sort_order = 1;

# Client attributes.
my $attrs_struct = {
### KEY ###     ### NAME ###       ### LABEL ###          ### DESCRIPTION ###
    chr(0x00) => { -name => 'mac',       -label => '~MAC',         -description => 'Network MAC address' },
    chr(0x01) => { -name => 'ip',        -label => '~IP',          -description => 'Network IP address' },
    chr(0x02) => { -name => 'host',      -label => '~Hostname',    -description => 'Name of the client' },
    chr(0x03) => { -name => 'os',        -label => 'I~mage',       -description => 'Image installed in the client' },
    chr(0x04) => { -name => 'kernel',    -label => '~Kernel',      -description => 'SystemImager Kernel version' },
    chr(0x05) => { -name => 'status',    -label => '~Status',      -description => 'Status of installation' },
    chr(0x06) => { -name => 'time',      -label => '~Time',        -description => 'Elapsed time for installation' },
    chr(0x07) => { -name => 'speed',     -label => 'S~peed',       -description => 'Network bandwidth' },
    chr(0x08) => { -name => 'mem',       -label => '~RAM',         -description => 'Physical RAM installed in the client' },
    chr(0x09) => { -name => 'tmpfs',     -label => 'RAM ~used',    -description => 'Allocated RAM' },
    chr(0x0a) => { -name => 'ncpus',     -label => '~nCPUs',       -description => 'Number of CPUs' },
    chr(0x0b) => { -name => 'cpu',       -label => '~CPU',         -description => 'CPU model' },
    chr(0x0c) => { -name => 'timestamp', -label => '~Last update', -description => 'Timestamp of the last report' },
};
# Cache attribute names.
my @attrs = grep !/mac/, map {$attrs_struct->{$_}->{'-name'}} sort keys %{$attrs_struct};

# Create the main window.
$window = MainWindow->new();
$window->title("$program_name: client installation monitoring system");
$window->configure(-menu => my $menubar = $window->Menu(-border => 0));
$window->gridRowconfigure(0, -weight => 1);
$window->gridColumnconfigure(0, -weight => 1);
$window->protocol('WM_DELETE_WINDOW' => \&quit);

# Image resources.
my $server_init_icon  = $window->Photo(-file => 'USR_PREFIX/share/systemimager/icons/serverinit.gif');
my $server_inst_icon  = $window->Photo(-file => 'USR_PREFIX/share/systemimager/icons/serverinst.gif');
my $server_ok_icon    = $window->Photo(-file => 'USR_PREFIX/share/systemimager/icons/serverok.gif');
my $server_error_icon = $window->Photo(-file => 'USR_PREFIX/share/systemimager/icons/servererror.gif');

# Use this font.
my $FONT = '-*-helvetica-bold-r-normal-*-12-120-*-*-*-*-*-*';

# Generate the "File" menu bar.
my $file_menu = $menubar->cascade(
    -label     => 'File',
    -underline => 0,
    -tearoff   => 0,
);
my $refresh_file_menu = $file_menu->command(
    -label    => '~Refresh',
    -command  => \&start_refresh,
    -state    => 'disabled',
);
my $stop_refresh_file_menu = $file_menu->command(
    -label    => '~Stop refresh',
    -command  => \&stop_refresh,
    -state    => 'normal',
);

$file_menu->separator();

my $clear_clients_file_menu = $file_menu->command(
    -label    => '~Clear clients',
    -command  => \&clear_clients,
    -state    => 'normal',
);

$file_menu->separator();

my $quit_file_menu = $file_menu->command(
    -label    => '~Quit',
    -command  => \&quit,
);

# Generate the "Edit" menu bar.
my $edit_menu = $menubar->cascade(
    -label     => 'Edit',
    -underline => 0,
    -tearoff   => 0,
);
my $sort_menu = $edit_menu->cascade(
    -label     => 'Sort',
    -underline => 0,
    -tearoff   => 0,
);
# Show sort attributes.
foreach (sort keys %{$attrs_struct}) {
    $sort_menu->radiobutton(
        -label    => $attrs_struct->{$_}->{'-label'},
        -command  => \&refresh,
        -variable => \$sort_field,
        -value    => $attrs_struct->{$_}->{'-name'},
        -state    => 'normal',
    );
}
$sort_menu->separator();
$sort_menu->radiobutton(
    -label    => '~Ascending',
    -command  => \&refresh,
    -variable => \$sort_order,
    -value    => 1,
    -state    => 'normal',
);
$sort_menu->radiobutton(
    -label    => '~Descending',
    -command  => \&refresh,
    -variable => \$sort_order,
    -value    => 0,
    -state    => 'normal',
);
$edit_menu->checkbutton(
    -label     => '~Show progress bars',
    -command   => \&refresh,
    -variable  => \$progress,
);

# Generate the "About" menu bar.
my $help_menu = $menubar->cascade(qw/-label Help -underline 0 -tearoff 0 -menuitems/ => [
    [command => '~About'],
]);

# Dialogs.
my $DIALOG_CLEAR_CLIENTS = $window->Dialog(
    -title          => "Clear all collected clients",
    -bitmap         => 'question',
    -default_button => 'No',
    -buttons        => [qw/Yes No/],
    -font           => $FONT,
    -text           => "Are you sure to clear all collected clients informations?",
);
my $DIALOG_NO_CLIENTS = $window->Dialog(
    -title          => "Clear all collected clients",
    -bitmap         => 'warning',
    -default_button => 'OK',
    -buttons        => ['OK'],
    -font           => $FONT,
    -text           => "No clients collected.",
);
my $DIALOG_ABOUT = $window->Dialog(
    -title          => "About $program_name",
    -bitmap         => 'info',
    -default_button => 'OK',
    -buttons        => ['OK'],
    -font           => $FONT,
    -wraplength     => '4i',
    -text           => "$version_info",
);
$help_menu->cget(-menu)->entryconfigure('About',
    -command => [$DIALOG_ABOUT => 'Show'],
);

# Define the status bar format.
$status_bar = $window->Label(
    -relief => "sunken", 
    -bd => 1, 
    -anchor => 'sw'
);

# Define the balloon structure.
my $bal = $window->Balloon(-statusbar => $status_bar);

# Create the table of nodes status.
$tab = $window->Scrolled(
    'MyHList',
    -header           => 1,
    -columns          => 14,
    -scrollbars       => 'se',
    -width            => 110,
    -height           => 28,
    -selectmode       => 'browse',
    -selectbackground => 'yellow',
    -background       => 'white',
    -command          => \&show_virtual_console,
    -browsecmd        => \&update_selected_mac,
)->grid(qw/-sticky nsew/);

# Create the tab item styles.
# Initializing.
my $init_style = $tab->ItemStyle('text');
$init_style->configure(
    -foreground => '#0000FF',
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Failed.
my $fail_style = $tab->ItemStyle('text');
$fail_style->configure(
    -foreground => '#FF0000',
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Done.
my $done_style = $tab->ItemStyle('text');
$done_style->configure(
    -foreground => '#009000',
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Installing.
my $inst_style = $tab->ItemStyle('text');
$inst_style->configure(
    -foreground => '#000000',
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Unknown.
my $unkn_style = $tab->ItemStyle('text');
$unkn_style->configure(
    -foreground => 'darkgrey',
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Image style.
my $image_style = $tab->ItemStyle('imagetext');
$image_style->configure(
    -background => '#FFFFFF',
    -font       => $FONT,
    -anchor     => 'center',
);
# Window style.
my $window_style = $tab->ItemStyle('window');
$window_style->configure(
    -anchor     => 'center',
);

# Create the table header.
$tab->header('create', 0, -text => ' ');
my $i = 1;
foreach (sort keys %{$attrs_struct}) {
    $_ = $attrs_struct->{$_}->{'-label'};
    s/~//g;
    $tab->header('create', $i++, -text => $_); 
}

# Show the body.
display_nodes();

# Display a legend.
show_legend();

# Display command buttons.
show_command_buttons();

# Main loop.
start_refresh();
MainLoop();

# Well done.
exit(0);

########################################################################
#
#    Functions
#
########################################################################

# Usage:
# show_virtual_console();
# Description:
#    Open the virtual console window.
sub show_virtual_console 
{
    # Allow only one virtual console -AR-
    # TODO: handle more than one console.
    $sub_win->destroy() if Exists($sub_win);

    # Get info to show in the title.
    my $mac = $tab->itemCget($_[0], 1, 'text');
    my $ip = $tab->itemCget($_[0], 2, 'text');
    my $hostname  = $tab->itemCget($_[0], 3, 'text') || '';

    # Open the console in a new window.
    $sub_win = MainWindow->new();
    $sub_win->bind('<Escape>' => sub { $sub_win->destroy() });

    # Display the hostname or the IP address in the title.
    $sub_win->title('Client: ' . ("$hostname" ne '-' ? "$hostname" : "$ip"));

    # Store MAC address of the selected client.
    $sub_mac_addr = $mac;

    # Console body.
    $sub_tab = $sub_win->Scrolled(
        'ROText',
        -scrollbars    => 'e',
        -wrap          => 'word',
        -background    => 'black',
        -foreground    => 'lightgrey',
        -font          => $FONT,
        -setgrid       => 1,
        -insertofftime => 0,
    )->grid(-in => $sub_win, -row => 1, -column => 1, -sticky => 'nsew');
    $sub_win->gridRowconfigure(1, -weight => 1);
    $sub_win->gridColumnconfigure(1, -weight => 1);
    $sub_tab->insert('end',
        "$hostname($ip):> virtual console started for client $mac.\n",
        'title'
    );

    # Gather all log messages from the installing client.
    $sub_tab->insert('end',
        "$hostname($ip):> gathering previous messages...\n",
        'title'
    );
    $sub_win->update();
    my @old_logmsg = ();
    socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp')) or BEGIN {
        print STDERR "error: cannot create TCP socket for client $ip!\n";
        goto skip_old_logmsg;
    };
    eval {
        # Set a timeout on the socket.
        setsockopt(SOCK, SOL_SOCKET, SO_SNDTIMEO, pack('L!L!', 10, 0)) or 
            die "error: cannot set SO_SNDTIMEO option to socket\n";
        setsockopt(SOCK, SOL_SOCKET, SO_RCVTIMEO, pack('L!L!', 10, 0)) or
            die "error: cannot set SO_RCVTIMEO option to socket\n";
        # Connection to the client.
        connect(SOCK, sockaddr_in(8181, inet_aton($ip))) or
            die "error: connection failed\n";
    };
    if ($@) {
        # Error handler.
        $sub_tab->insert('end',
            "$hostname($ip):> host unreachable: cannot gather previous messages!\n",
            'title'
        );
    } else {
        # Gather all logs.
        while (<SOCK>) {
            push(@old_logmsg, $_);
        }
        close(SOCK);

        # Fill virtual console with old log messages.
        for (my $i = 0; $i < $#old_logmsg - 1; $i++) {
            $sub_tab->insert('end',
                "$hostname($ip):> " . $old_logmsg[$i],
                'title'
            );
        }
        # Refresh console view (default 100ms).
        my $cons_timer = Tk::After->new(
                $sub_win,
                100,
                'repeat',
                \&refresh_console
        );
    }
}

# Usage:
# refresh_console();
# Description:
#    Refresh the virtual console view.
sub refresh_console
{
    # Get mac address of the client to monitor.
    my $mac = $sub_mac_addr;

    # Open and read lock the database.
    open(LOCK, ">", "$lock_file") or
        die "error: cannot open lock file \"$lock_file\"!\n";
    flock(LOCK, LOCK_SH);
    
    # Parse XML database.
    my $xml = XMLin($database, KeyAttr => {client => 'name'}, ForceArray => 1);

    # Close and unlock database.
    flock(LOCK, LOCK_UN);
    close(LOCK);

    # Parse clients data.
    my %client = %{$xml->{'client'}};

    # Correct the host name in the title of the console.
    if ($client{$mac}->{'host'}) {
        $sub_win->title('Client: ' . $client{$mac}->{'host'});
    }

    # Generate the last message.
    my $line = ($client{$mac}->{'host'} || '') . 
        '(' . $client{$mac}->{'ip'} . ')' .
        ":> " .
        ($client{$mac}->{'log'} || '') . "\n";

    # Replace escape sequences for the special field separator ':'.
    $line =~ s/\\x3a/:/g;

    # Get previous message.
    my $last_line = $sub_tab->get('end - 2 lines', 'end - 1 lines');

    # Display the client message only if it is different from
    # the previous one.
    if ($last_line ne $line) {
        $sub_tab->insert('end', $line);
        $sub_tab->see('end');
    }
}

# Usage:
# show_legend(); 
# Description:
#    Display the legend panel.
sub show_legend
{
    # Define buttons.
    my $legend = $window->Frame();
    $legend->grid(qw/-pady 2m -sticky ew/);
    $legend->gridColumnconfigure(qw/0 -weight 1/);
    $legend->gridColumnconfigure(qw/1 -weight 1/);
    $legend->gridColumnconfigure(qw/2 -weight 1/);
    $legend->gridColumnconfigure(qw/3 -weight 1/);
    $legend->Label(
        -image => $server_init_icon,
    )->grid(qw/-row 0 -column 0/);
    $legend->Label(
        -text => 'Initialization',
    )->grid(qw/-row 1 -column 0/);
    $legend->Label(
        -image => $server_inst_icon,
    )->grid(qw/-row 0 -column 1/);
    $legend->Label(
        -text => 'Installation in progress',
    )->grid(qw/-row 1 -column 1/);
    $legend->Label(
        -image => $server_ok_icon,
    )->grid(qw/-row 0 -column 2/);
    $legend->Label(
        -text => 'Installation completed',
    )->grid(qw/-row 1 -column 2/);
    $legend->Label(
        -image => $server_error_icon,
    )->grid(qw/-row 0 -column 3/);
    $legend->Label(
        -text => 'Installation failed!',
    )->grid(qw/-row 1 -column 3/);

    # Draw the legend.
    $legend->grid("-", "-", -sticky => "nesw");
}

# Usage:
# show_command_buttons(); 
# Description:
#    Display the command buttons panel.
sub show_command_buttons
{
    # Define buttons.
    my $buttons = $window->Frame;
    $start_refresh_button = $buttons->Button(
        -text      => 'Refresh',
        -underline => 0,
        -command   => [\&start_refresh],
        -width     => 20,
        -pady      => 5,
        -padx      => 5,
        -state     => 'disabled', 
    );
    $stop_refresh_button = $buttons->Button(
        -text      => 'Stop refresh',
        -underline => 0,
        -command   => [\&stop_refresh],
        -width     => 20,
        -pady      => 5,
        -padx      => 5,
        -state     => 'normal', 
    );
    $clear_clients_button = $buttons->Button(
        -text      => 'Clear clients',
        -underline => 0,
        -command   => [\&clear_clients],
        -width     => 20,
        -pady      => 5,
        -padx      => 5,
        -state     => 'normal', 
    );
    $quit_button = $buttons->Button(
        -text      => 'Quit',
        -underline => 0,
        -command   => [\&quit],
        -width     => 20,
        -pady      => 5,
        -padx      => 5,
    );
    $buttons->grid(qw/-pady 2m -sticky ew/);
    $buttons->gridColumnconfigure(qw/0 -weight 1/);
    $buttons->gridColumnconfigure(qw/1 -weight 1/);
    $buttons->gridColumnconfigure(qw/2 -weight 1/);
    $buttons->gridColumnconfigure(qw/3 -weight 1/);
    $start_refresh_button->grid(qw/-row 0 -column 0/);
    $stop_refresh_button->grid(qw/-row 0 -column 1/);
    $clear_clients_button->grid(qw/-row 0 -column 2/);
    $quit_button->grid(qw/-row 0 -column 3/);

    # Bind hot-keys to buttons.
    $window->bind("<Alt-r>", sub {$start_refresh_button->invoke;});
    $window->bind("<Alt-s>", sub {$stop_refresh_button->invoke;});
    $window->bind("<Alt-c>", sub {$clear_clients_button->invoke;});
    $window->bind("<Alt-q>", sub {$quit_button->invoke;});

    # Define status bar messages.
    $bal->attach($start_refresh_button,
        -statusmsg  => "Start to refresh the status of the nodes",
    );
    $bal->attach($stop_refresh_button,
        -statusmsg  => "Stop to refresh the status of the nodes",
    );
    $bal->attach($clear_clients_button,
        -statusmsg  => "Clear all collected clients",
    );
    $bal->attach($quit_button,
        -statusmsg  => "Quit program",
    );
    
    # Draw status bar.
    $status_bar->grid("-", "-", -sticky => "nesw");
}

# Usage:
# update_selected_mac(); 
# Description:
#    Set the selected client entry in the table.
sub update_selected_mac
{
    my $prev_sel = (defined($selected_mac_addr) ? $selected_mac_addr : '');
    $selected_mac_addr = $tab->itemCget($_[0], 1, 'text');
    if ($prev_sel eq $selected_mac_addr) {
        undef($selected_mac_addr);
        $tab->selectionClear();
        $tab->anchorClear();
    }
}

# Usage:
# display_nodes(); 
# Description:
#    Fill the main list with the status of all nodes.
sub display_nodes
{
    ### XXX: Profiling stuff ###
    #use Time::HiRes qw(gettimeofday tv_interval);
    #my $t0 = [gettimeofday];
    ### END of profiling stuff ###

    # Statistic counters.
    my $num_ok = 0;
    my $num_fail = 0;
    my $num_inst = 0;
    my $num_unkn = 0;

    # Drop previous selection if nothing is selected.
    if (defined($selected_mac_addr)) {
        undef($selected_mac_addr)
            unless (defined($tab->info('selection')));
    }

    # Delete all clients.
    $tab->delete('all');
    unless (-s $database) {
        goto status_bar_update;
    }

    # Open and read lock the database.
    open(LOCK, ">", "$lock_file") or
        die "error: cannot open lock file \"$lock_file\"!\n";
    flock(LOCK, LOCK_SH);
    
    # Parse XML database.
    my $xml = XMLin($database, KeyAttr => {client => 'name'}, ForceArray => 1);

    # Close and unlock database.
    flock(LOCK, LOCK_UN);
    close(LOCK);

    # Display DB entries.
    my $client = $xml->{'client'};
    # Sort clients.
    my @list;
    if ($sort_field eq 'mac') {
        @list = sort {($sort_order) ? ($a cmp $b) : ($b cmp $a)} keys %{$client};
    } else {
        @list = sort {
            my $x = $client->{$a}->{$sort_field} || 0;
            my $y = $client->{$b}->{$sort_field} || 0;
            if (($x =~ /^(\d+)%$/) && ($y =~ /^(\d+)%$/)) {
                $x =~ s/%//;
                $y =~ s/%//;
            }
            if ((($x =~ /^(\d+)$/) && ($y =~ /(\d+)$/)) || 
                (($x =~ /^(\d+).(\d+)$/) && ($y =~ /(\d+).(\d+)$/))) {
                ($sort_order) ? ($x <=> $y) : ($y <=> $x);
            } else {
                ($sort_order) ? ($x cmp $y) : ($y cmp $x);
            }
        } keys %{$client};
    }
    foreach my $mac (@list) {
        # Create the entry.
        my $row = $tab->addchild('');
        # Evaluate the status and adjust the style of the entry.
        my ($style, $status_icon);
        my $status;
        # Create the installation progress bar.
        if ($progress) {
            $status_progress = $tab->ProgressBar(
                -borderwidth => 0,
                -relief      => 'flat',
                -padx        => 2,
                -pady        => 8,
                -variable    => \$status,
                -colors      => [
                    0  => '#0000FF',
                    10 => '#0000EF',
                    20 => '#0000DF',
                    30 => '#0000CF',
                    40 => '#0000BF',
                    50 => '#0000AF',
                    60 => '#00009F',
                    70 => '#00008F',
                    80 => '#00007F',
                    90 => '#00006F',
                ],
                -troughcolor => 'white',
                -gap         => 1,
                -blocks      => 10,
                -from        => 0,
                -to          => 100,
           );
        }
        $status = $client->{$mac}->{'status'} || 0;
        if (!$status) {
            $num_inst++;
            $client->{$mac}->{'status'} = 'initializing...';
            $style = $init_style;
            $status_icon = $server_init_icon;
        } elsif ($status < 0) {
            $num_fail++;
            $client->{$mac}->{'status'} = 'error!';
            $style = $fail_style;
            $status_icon = $server_error_icon;
        } elsif ($status == 100) {
            $num_ok++;
            $client->{$mac}->{'status'} = 'done';
            $style = $done_style;
            $status_icon = $server_ok_icon;
        } elsif (($status > 0) && ($status < 100)) {
            $num_inst++;
            $client->{$mac}->{'status'} = sprintf('%.2f%%', $status);
            $style = $inst_style;
            $status_icon = $server_inst_icon;
        } else {
            $num_unkn++;
            $client->{$mac}->{'status'} = '???';
            $style = $unkn_style;
            $status_icon = $server_error_icon;
        }
        # Format the uptime.
        if (defined($client->{$mac}->{'time'})) {
            $client->{$mac}->{'time'} .= 'min';
        }
        # Format the bandwidth.
        if (!$client->{$mac}->{'speed'}) {
            $client->{$mac}->{'speed'} = '-';
        } else {
            if ($client->{$mac}->{'speed'} < 1000) {
                $client->{$mac}->{'speed'} = 
                sprintf("%.0fKB/s", $client->{$mac}->{'speed'});
            } else {
                $client->{$mac}->{'speed'} = 
                sprintf("%.2fMB/s", $client->{$mac}->{'speed'} / 1000);
            }
        }
        # Format the total amount of RAM.
        if (defined($client->{$mac}->{'mem'})) {
            $client->{$mac}->{'mem'} .= 'MB';
        }
        # Display the node icon.
        $tab->itemCreate(
            $row,
            0,
            -itemtype => 'imagetext',
            -style    => $image_style,
            -image    => $status_icon,
        );
        # Display the node identity (MAC address).
        $tab->itemCreate(
            $row,
            1,
            -itemtype => 'text',
            -style    => $style,
            -text     => $mac,
        );
        # Display other node attributes.
        for (0 .. $#attrs) {
            # Status.
            if (($progress) && ($attrs[$_] eq 'status')) {
                # Display the status using a progress bar.
                $tab->itemCreate(
                    $row,
                    $_ + 2,
                    -itemtype => 'window',
                    -style    => $window_style,
                    -widget   => $status_progress,
                );
            # Timestamp.
            } elsif ($attrs[$_] eq 'timestamp') {
                my $date;
                my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
                    localtime($client->{$mac}->{$attrs[$_]});
                $year += 1900;
                $date = sprintf("%04d-%02d-%02d %02d:%02d:%02d",
                    $year, $mon, $mday, $hour, $min, $sec);
#                my $date = strftime("%Y-%m-%d %H:%M:%S", $client->{$mac}->{$attrs[$_]});
                $tab->itemCreate(
                    $row,
                    $_ + 2,
                    -itemtype => 'text',
                    -style    => $style,
                    -text     => $date,
                );
            # Others.
            } else {
                $tab->itemCreate(
                    $row,
                    $_ + 2,
                    -itemtype => 'text',
                    -style    => $style,
                    -text     => $client->{$mac}->{$attrs[$_]} || '-',
                );
            }
        }
        # Update selection.
        if (defined($selected_mac_addr) && ($selected_mac_addr eq $mac)) {
            $tab->selectionSet($row);
            $tab->anchorSet($row);
        }
    }
    # Update the status bar.
status_bar_update:
    ### XXX: Profiling stuff ###
    #printf("elapsed time = %0.6f\n", tv_interval($t0, [gettimeofday]));
    ### END of profiling stuff ###
    $bal->attach($tab,
        -statusmsg  => "Managed nodes: " . ($num_ok  + $num_inst + $num_unkn + $num_fail) .
            " ($num_ok ok, $num_inst installing, $num_unkn unknown, $num_fail error)",
    );
    # Refresh view.
    $tab->update();
    # Refresh the status bar.
    $bal->update();
}

# Usage:
# refresh();
# Description:
#    Refresh the client label.
sub refresh
{
    # FIXME: maybe a semaphore/spinlock is needed here.
    # This is very ugly, but it is a simple way to implement 
    # something similar to a critical section.
    return if ($is_refreshing);
    $is_refreshing = 1;

    # Refresh clients.
    display_nodes();

    $is_refreshing = 0;
}

# Usage:
# start_refresh();
# Description:
#    Begin to refresh the nodes view.
sub start_refresh
{
    # Refresh nodes visualization.
    $timer = Tk::After->new($window, $refresh_rate, 'repeat', \&refresh);

    # Refresh the buttons look.
    $start_refresh_button->configure(-state => 'disabled');
    $stop_refresh_button->configure(-state => 'normal');

    # Refresh the menu look.
    $refresh_file_menu->configure(-state => 'disabled');
    $stop_refresh_file_menu->configure(-state => 'normal');
}

# Usage:
# stop_refresh();
# Description:
#    Stop to refresh the nodes view.
sub stop_refresh
{
    # Stop to refresh nodes view.
    $timer->cancel();

    # Refresh the interface look.
    $start_refresh_button->configure(-state => 'normal');
    $stop_refresh_button->configure(-state => 'disabled');

    # Refresh the menu look.
    $refresh_file_menu->configure(-state => 'normal');
    $stop_refresh_file_menu->configure(-state => 'disabled');
}

# Usage:
# clear_clients();
# Description:
#    Clear all collected informations
sub clear_clients
{
    # If database is empty simply quit.
    unless (-s $database) {
        $DIALOG_NO_CLIENTS->Show();
        return;
    }

    # Ask for a confirmation before deleting.
    my $answer = $DIALOG_CLEAR_CLIENTS->Show();
    if ($answer eq "No") {
        return;
    }

    # Close the virtual consoles if opened.
    $sub_win->destroy() if Exists($sub_win);

    # Open and read lock the database.
    open(LOCK, '>', "$lock_file") or
        die "error: cannot open lock file \"$lock_file\"!\n";
    flock(LOCK, LOCK_EX);

    # Clear the XML database.
    open(DB, '>', $database) or
        die "error: cannot open \"$database\" for writing!\n";
    close(DB);

    # Close and unlock database.
    flock(LOCK, LOCK_UN);
    close(LOCK);

    # Refresh view.
    refresh();
}

# Usage:
# quit();
# Description:
#    Exit program.

sub quit
{
    # Close the virtual console.
    $sub_win->destroy() if Exists($sub_win);
    # Close the main window.
    $window->destroy() if Exists($window);
    # Quit program.
    exit(0);
}

__END__

=head1 NAME

si_monitortk - systemimager monitor Tk-based GUI

=head1 SYNOPSIS

si_monitortk [OPTIONS]... --db DATABASENAME 

=head1 DESCRIPTION

Report a list of all the clients with a detailed real time
status of their installation.

The B<si_monitortk> is a perl-Tk user interface. It does not collect
directly the client informations, but simply gets that informations
in a file generated and updated by the B<si_monitor> daemon.

=head1 OPTIONS

=over 8

=item B<--help>

Display a short help.

=item B<--version>

Display version and copyright information.

=item B<--db DATABASENAME>

Perform a periodical polling to the B<DATABASENAME> where B<si_monitor>
stores the clients informations and the current status of the installation
process.

This file is created and kept updated by the B<si_monitor> daemon, so
to use this interface probably you need to start first the B<si_monitor>
daemon.

For default the file B</var/lib/systemimager/clients.xml> is taken.

=item B<--progress>

Display progress bars instead of textual precentages for installation
status.

=item B<--refresh RATE>

If specified this options sets a different refresh rate for the clients
informations displayed in the GUI. This sets the period (in sec) between
two different accesses to the B<DATABASENAME> XML file.

The default value is 5 seconds.

=head1 SEE ALSO

systemimager(8), si_monitor(1)

=head1 AUTHOR

Andrea Righi <a.righi@cineca.it>.

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2005-2006 Andrea Righi <a.righi@cineca.it>
Copyright (C) 2005-2006 Bernard Li <bli@bcgsc.ca>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=cut

