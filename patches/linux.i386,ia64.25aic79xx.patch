diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_core.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_core.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_core.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_core.c	2002-09-16 12:48:42.000000000 -0600
@@ -0,0 +1,8706 @@
+/*
+ * Core routines and tables shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2002 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#112 $
+ *
+ * $FreeBSD$
+ */
+
+#ifdef __linux__
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+#include "aicasm/aicasm_insformat.h"
+#else
+#include <dev/aic7xxx/aic79xx_osm.h>
+#include <dev/aic7xxx/aic79xx_inline.h>
+#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
+#endif
+
+/******************************** Globals *************************************/
+struct ahd_softc_tailq ahd_tailq = TAILQ_HEAD_INITIALIZER(ahd_tailq);
+
+/***************************** Lookup Tables **********************************/
+char *ahd_chip_names[] =
+{
+	"NONE",
+	"aic7901",
+	"aic7902",
+	"aic7901A"
+};
+static const u_int num_chip_names = NUM_ELEMENTS(ahd_chip_names);
+
+/*
+ * Hardware error codes.
+ */
+struct ahd_hard_error_entry {
+        uint8_t errno;
+	char *errmesg;
+};
+
+static struct ahd_hard_error_entry ahd_hard_errors[] = {
+	{ DSCTMOUT,	"Discard Timer has timed out" },
+	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
+	{ SQPARERR,	"Sequencer Parity Error" },
+	{ DPARERR,	"Data-path Parity Error" },
+	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
+	{ CIOPARERR,	"CIOBUS Parity Error" },
+};
+static const u_int num_errors = NUM_ELEMENTS(ahd_hard_errors);
+
+static struct ahd_phase_table_entry ahd_phase_table[] =
+{
+	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
+	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
+	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
+	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
+	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
+	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
+	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
+	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
+	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
+	{ 0,		MSG_NOOP,		"in unknown phase"	}
+};
+
+/*
+ * In most cases we only wish to itterate over real phases, so
+ * exclude the last element from the count.
+ */
+static const u_int num_phases = NUM_ELEMENTS(ahd_phase_table) - 1;
+
+/* Our Sequencer Program */
+#include "aic79xx_seq.h"
+
+/**************************** Function Declarations ***************************/
+static void		ahd_handle_transmission_error(struct ahd_softc *ahd);
+static void		ahd_handle_lqiphase_error(struct ahd_softc *ahd,
+						  u_int lqistat1);
+static int		ahd_handle_pkt_busfree(struct ahd_softc *ahd,
+					       u_int busfreetime);
+static int		ahd_handle_nonpkt_busfree(struct ahd_softc *ahd);
+static void		ahd_handle_proto_violation(struct ahd_softc *ahd);
+static void		ahd_force_renegotiation(struct ahd_softc *ahd,
+						struct ahd_devinfo *devinfo);
+
+static struct ahd_tmode_tstate*
+			ahd_alloc_tstate(struct ahd_softc *ahd,
+					 u_int scsi_id, char channel);
+#ifdef AHD_TARGET_MODE
+static void		ahd_free_tstate(struct ahd_softc *ahd,
+					u_int scsi_id, char channel, int force);
+#endif
+static void		ahd_devlimited_syncrate(struct ahd_softc *ahd,
+					        struct ahd_initiator_tinfo *,
+						u_int *period,
+						u_int *ppr_options,
+						role_t role);
+static void		ahd_update_neg_table(struct ahd_softc *ahd,
+					     struct ahd_devinfo *devinfo,
+					     struct ahd_transinfo *tinfo);
+static void		ahd_update_pending_scbs(struct ahd_softc *ahd);
+static void		ahd_fetch_devinfo(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo);
+static void		ahd_print_devinfo(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo);
+static void		ahd_scb_devinfo(struct ahd_softc *ahd,
+					struct ahd_devinfo *devinfo,
+					struct scb *scb);
+static void		ahd_setup_initiator_msgout(struct ahd_softc *ahd,
+						   struct ahd_devinfo *devinfo,
+						   struct scb *scb);
+static void		ahd_build_transfer_msg(struct ahd_softc *ahd,
+					       struct ahd_devinfo *devinfo);
+static void		ahd_construct_sdtr(struct ahd_softc *ahd,
+					   struct ahd_devinfo *devinfo,
+					   u_int period, u_int offset);
+static void		ahd_construct_wdtr(struct ahd_softc *ahd,
+					   struct ahd_devinfo *devinfo,
+					   u_int bus_width);
+static void		ahd_construct_ppr(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo,
+					  u_int period, u_int offset,
+					  u_int bus_width, u_int ppr_options);
+static void		ahd_clear_msg_state(struct ahd_softc *ahd);
+static void		ahd_handle_message_phase(struct ahd_softc *ahd);
+typedef enum {
+	AHDMSG_1B,
+	AHDMSG_2B,
+	AHDMSG_EXT
+} ahd_msgtype;
+static int		ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type,
+				     u_int msgval, int full);
+static int		ahd_parse_msg(struct ahd_softc *ahd,
+				      struct ahd_devinfo *devinfo);
+static int		ahd_handle_msg_reject(struct ahd_softc *ahd,
+					      struct ahd_devinfo *devinfo);
+static void		ahd_handle_ign_wide_residue(struct ahd_softc *ahd,
+						struct ahd_devinfo *devinfo);
+static void		ahd_reinitialize_dataptrs(struct ahd_softc *ahd);
+static void		ahd_handle_devreset(struct ahd_softc *ahd,
+					    struct ahd_devinfo *devinfo,
+					    cam_status status, char *message,
+					    int verbose_level);
+#if AHD_TARGET_MODE
+static void		ahd_setup_target_msgin(struct ahd_softc *ahd,
+					       struct ahd_devinfo *devinfo,
+					       struct scb *scb);
+#endif
+
+static bus_size_t	ahd_sglist_size(struct ahd_softc *ahd);
+static bus_size_t	ahd_sglist_allocsize(struct ahd_softc *ahd);
+static bus_dmamap_callback_t
+			ahd_dmamap_cb; 
+static void		ahd_initialize_hscbs(struct ahd_softc *ahd);
+static int		ahd_init_scbdata(struct ahd_softc *ahd);
+static void		ahd_fini_scbdata(struct ahd_softc *ahd);
+static void		ahd_setup_iocell_workaround(struct ahd_softc *ahd);
+static void		ahd_iocell_first_selection(struct ahd_softc *ahd);
+static void		ahd_add_col_list(struct ahd_softc *ahd,
+					 struct scb *scb, u_int col_idx);
+static void		ahd_rem_col_list(struct ahd_softc *ahd,
+					 struct scb *scb);
+static void		ahd_chip_init(struct ahd_softc *ahd);
+static void		ahd_qinfifo_requeue(struct ahd_softc *ahd,
+					    struct scb *prev_scb,
+					    struct scb *scb);
+static int		ahd_qinfifo_count(struct ahd_softc *ahd);
+static int		ahd_search_scb_list(struct ahd_softc *ahd, int target,
+					    char channel, int lun, u_int tag,
+					    role_t role, uint32_t status,
+					    ahd_search_action action,
+					    u_int *list_head, u_int tid);
+static void		ahd_stitch_tid_list(struct ahd_softc *ahd,
+					    u_int tid_prev, u_int tid_cur,
+					    u_int tid_next);
+static void		ahd_add_scb_to_free_list(struct ahd_softc *ahd,
+						 u_int scbid);
+static u_int		ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
+				     u_int prev, u_int next, u_int tid);
+static void		ahd_reset_current_bus(struct ahd_softc *ahd);
+static ahd_callback_t	ahd_reset_poll;
+#ifdef AHD_DUMP_SEQ
+static void		ahd_dumpseq(struct ahd_softc *ahd);
+#endif
+static void		ahd_loadseq(struct ahd_softc *ahd);
+static int		ahd_check_patch(struct ahd_softc *ahd,
+					struct patch **start_patch,
+					u_int start_instr, u_int *skip_addr);
+static u_int		ahd_resolve_seqaddr(struct ahd_softc *ahd,
+					    u_int address);
+static void		ahd_download_instr(struct ahd_softc *ahd,
+					   u_int instrptr, uint8_t *dconsts);
+#ifdef AHD_TARGET_MODE
+static void		ahd_queue_lstate_event(struct ahd_softc *ahd,
+					       struct ahd_tmode_lstate *lstate,
+					       u_int initiator_id,
+					       u_int event_type,
+					       u_int event_arg);
+static void		ahd_update_scsiid(struct ahd_softc *ahd,
+					  u_int targid_mask);
+static int		ahd_handle_target_cmd(struct ahd_softc *ahd,
+					      struct target_cmd *cmd);
+#endif
+
+/******************************** Private Inlines *****************************/
+static __inline void	ahd_assert_atn(struct ahd_softc *ahd);
+static __inline int	ahd_currently_packetized(struct ahd_softc *ahd);
+static __inline int	ahd_set_active_fifo(struct ahd_softc *ahd);
+
+static __inline void
+ahd_assert_atn(struct ahd_softc *ahd)
+{
+	ahd_outb(ahd, SCSISIGO, ATNO);
+}
+
+/*
+ * Determine if the current connection has a packetized
+ * agreement.  This does not necessarily mean that we
+ * are currently in a packetized transfer.  We could
+ * just as easily be sending or receiving a message.
+ */
+static __inline int
+ahd_currently_packetized(struct ahd_softc *ahd)
+{
+	ahd_mode_state	 saved_modes;
+	int		 packetized;
+
+	saved_modes = ahd_save_modes(ahd);
+	if ((ahd->bugs & AHD_PKTIZED_STATUS_BUG) != 0) {
+		/*
+		 * The packetized bit refers to the last
+		 * connection, not the current one.  Check
+		 * for non-zero LQISTATE instead.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		packetized = ahd_inb(ahd, LQISTATE) != 0;
+	} else {
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		packetized = ahd_inb(ahd, LQISTAT2) & PACKETIZED;
+	}
+	ahd_restore_modes(ahd, saved_modes);
+	return (packetized);
+}
+
+static __inline int
+ahd_set_active_fifo(struct ahd_softc *ahd)
+{
+	u_int active_fifo;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	active_fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
+/* XXX This is a three possition switch in the B. */
+	switch (active_fifo) {
+	case 0:
+	case 1:
+		ahd_set_modes(ahd, active_fifo, active_fifo);
+		return (1);
+	default:
+		return (0);
+	}
+}
+
+/************************* Sequencer Execution Control ************************/
+/*
+ * Restart the sequencer program from address zero
+ */
+void
+ahd_restart(struct ahd_softc *ahd)
+{
+
+	ahd_pause(ahd);
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	/* No more pending messages */
+	ahd_clear_msg_state(ahd);
+	ahd_outb(ahd, SCSISIGO, 0);		/* De-assert BSY */
+	ahd_outb(ahd, MSG_OUT, MSG_NOOP);	/* No message to send */
+	ahd_outb(ahd, SXFRCTL1, ahd_inb(ahd, SXFRCTL1) & ~BITBUCKET);
+	ahd_outb(ahd, SEQINTCTL, 0);
+	ahd_outb(ahd, LASTPHASE, P_BUSFREE);
+	ahd_outb(ahd, SEQ_FLAGS, 0);
+	ahd_outb(ahd, SAVED_SCSIID, 0xFF);
+	ahd_outb(ahd, SAVED_LUN, 0xFF);
+
+	/*
+	 * Ensure that the sequencer's idea of TQINPOS
+	 * matches our own.  The sequencer increments TQINPOS
+	 * only after it sees a DMA complete and a reset could
+	 * occur before the increment leaving the kernel to believe
+	 * the command arrived but the sequencer to not.
+	 */
+	ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
+
+	/* Always allow reselection */
+	ahd_outb(ahd, SCSISEQ1,
+		 ahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
+	/* Ensure that no DMA operations are in progress */
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	ahd_outb(ahd, SCBHCNT, 0);
+	ahd_outb(ahd, CCSCBCTL, CCSCBRESET);
+
+	ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
+	ahd_unpause(ahd);
+}
+
+void
+ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo)
+{
+	ahd_mode_state	 saved_modes;
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_FIFOS) != 0)
+		printf("%s: Clearing FIFO %d\n", ahd_name(ahd), fifo);
+#endif
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, fifo, fifo);
+	ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
+	if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)
+		ahd_outb(ahd, CCSGCTL, CCSGRESET);
+	ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
+	ahd_outb(ahd, SG_STATE, 0);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/************************* Input/Output Queues ********************************/
+void
+ahd_run_qoutfifo(struct ahd_softc *ahd)
+{
+	struct scb *scb;
+	u_int  scb_index;
+
+	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);
+	while ((ahd->qoutfifo[ahd->qoutfifonext]
+	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag) {
+
+		scb_index = ahd_le16toh(ahd->qoutfifo[ahd->qoutfifonext]
+				      & ~QOUTFIFO_ENTRY_VALID_LE);
+		scb = ahd_lookup_scb(ahd, scb_index);
+		if (scb == NULL) {
+			printf("%s: WARNING no command for scb %d "
+			       "(cmdcmplt)\nQOUTPOS = %d\n",
+			       ahd_name(ahd), scb_index,
+			       ahd->qoutfifonext);
+			ahd_dump_card_state(ahd);
+		} else
+			ahd_complete_scb(ahd, scb);
+
+		ahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);
+		if (ahd->qoutfifonext == 0)
+			ahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID_LE;
+
+	}
+}
+
+/************************* Interrupt Handling *********************************/
+void
+ahd_handle_hwerrint(struct ahd_softc *ahd)
+{
+	/*
+	 * Some catastrophic hardware error has occurred.
+	 * Print it for the user and disable the controller.
+	 */
+	int i;
+	int error;
+
+	error = ahd_inb(ahd, ERROR);
+	for (i = 0; i < num_errors; i++) {
+		if ((error & ahd_hard_errors[i].errno) != 0)
+			printf("%s: hwerrint, %s\n",
+			       ahd_name(ahd), ahd_hard_errors[i].errmesg);
+	}
+
+	ahd_dump_card_state(ahd);
+	panic("BRKADRINT");
+
+	/* Tell everyone that this HBA is no longer availible */
+	ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
+		       CAM_NO_HBA);
+
+	/* Tell the system that this controller has gone away. */
+	ahd_free(ahd);
+}
+
+void
+ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)
+{
+	u_int seqintcode;
+
+	/*
+	 * Save the sequencer interrupt code and clear the SEQINT
+	 * bit. We will unpause the sequencer, if appropriate,
+	 * after servicing the request.
+	 */
+	seqintcode = ahd_inb(ahd, SEQINTCODE);
+	ahd_outb(ahd, CLRINT, CLRSEQINT);
+	ahd_update_modes(ahd);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: Handle Seqint Called for code %d\n",
+		       ahd_name(ahd), seqintcode);
+#endif
+	switch (seqintcode) {
+	case ENTERING_NONPACK:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+
+		AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+				 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			/*
+			 * Somehow need to know if this
+			 * is from a selection or reselection.
+			 * From that, we can termine target
+			 * ID so we at least have an I_T nexus.
+			 */
+		} else {
+			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
+			ahd_outb(ahd, SAVED_LUN, scb->hscb->lun);
+			ahd_outb(ahd, SEQ_FLAGS, 0x0);
+		}
+		if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0
+		 && (ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
+			/*
+			 * Phase change after read stream with
+			 * CRC error with P0 asserted on last
+			 * packet.
+			 */
+			printf("Assuming LQIPHASE_NLQ with P0 assertion\n");
+		}
+		printf("Entering NONPACK\n");
+		break;
+	}
+	case INVALID_SEQINT:
+		printf("%s: Invalid Sequencer interrupt occurred.\n",
+		       ahd_name(ahd));
+		ahd_dump_card_state(ahd);
+		printf("invalid seqint");
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		break;
+	case STATUS_OVERRUN:
+	{
+		printf("%s: Status Overrun", ahd_name(ahd));
+		ahd_dump_card_state(ahd);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		break;
+	}
+	case CFG4ISTAT_INTR:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			ahd_dump_card_state(ahd);
+			printf("CFG4ISTAT: Free SCB %d referenced", scbid);
+			panic("For safety");
+		}
+		ahd_outq(ahd, HADDR, scb->sense_busaddr);
+		ahd_outw(ahd, HCNT, AHD_SENSE_BUFSIZE);
+		ahd_outb(ahd, HCNT + 2, 0);
+		ahd_outb(ahd, SG_CACHE_PRE, SG_LAST_SEG);
+		ahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);
+		break;
+	}
+	case ILLEGAL_PHASE:
+	{
+		u_int bus_phase;
+
+		bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+		printf("%s: ILLEGAL_PHASE 0x%x\n",
+		       ahd_name(ahd), bus_phase);
+
+		switch (bus_phase) {
+		case P_DATAOUT:
+		case P_DATAIN:
+		case P_DATAOUT_DT:
+		case P_DATAIN_DT:
+		case P_MESGOUT:
+		case P_STATUS:
+		case P_MESGIN:
+			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+			printf("%s: Issued Bus Reset.\n", ahd_name(ahd));
+			break;
+		case P_COMMAND:
+		{
+			struct	ahd_devinfo devinfo;
+			struct	scb *scb;
+			struct	ahd_initiator_tinfo *targ_info;
+			struct	ahd_tmode_tstate *tstate;
+			struct	ahd_transinfo *tinfo;
+			u_int	scbid;
+
+			/*
+			 * If a target takes us into the command phase
+			 * assume that it has been externally reset and
+			 * has thus lost our previous packetized negotiation
+			 * agreement.  Since we have not sent an identify
+			 * message and may not have fully qualified the
+			 * connection, we change our command to TUR, assert
+			 * ATN and ABORT the task when we go to message in
+			 * phase.  The OSM will see the REQUEUE_REQUEST
+			 * status and retry the command.
+			 */
+			scbid = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scbid);
+			if (scb == NULL) {
+				printf("Invalid phase with no valid SCB.  "
+				       "Resetting bus.\n");
+				ahd_reset_channel(ahd, 'A',
+						  /*Initiate Reset*/TRUE);
+				break;
+			}
+			ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
+					    SCB_GET_TARGET(ahd, scb),
+					    SCB_GET_LUN(scb),
+					    SCB_GET_CHANNEL(ahd, scb),
+					    ROLE_INITIATOR);
+			targ_info = ahd_fetch_transinfo(ahd,
+							devinfo.channel,
+							devinfo.our_scsiid,
+							devinfo.target,
+							&tstate);
+			tinfo = &targ_info->curr;
+			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
+					 /*offset*/0, /*ppr_options*/0,
+					 AHD_TRANS_ACTIVE, /*paused*/TRUE);
+			ahd_outb(ahd, SCB_CDB_STORE, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+1, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+2, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+3, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+4, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+5, 0);
+			ahd_outb(ahd, SCB_CDB_LEN, 6);
+			scb->hscb->control &= ~(TAG_ENB|SCB_TAG_TYPE);
+			scb->hscb->control |= MK_MESSAGE;
+			ahd_outb(ahd, SCB_CONTROL, scb->hscb->control);
+			ahd_outb(ahd, MSG_OUT, HOST_MSG);
+			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
+			/*
+			 * The lun is 0, regardless of the SCB's lun
+			 * as we have not sent an identify message.
+			 */
+			ahd_outb(ahd, SAVED_LUN, 0);
+			ahd_outb(ahd, SEQ_FLAGS, 0);
+			ahd_assert_atn(ahd);
+			scb->flags &= ~(SCB_PACKETIZED);
+			scb->flags |= SCB_ABORT|SCB_CMDPHASE_ABORT;
+			ahd_freeze_devq(ahd, scb);
+			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			ahd_freeze_scb(scb);
+
+			/*
+			 * Allow the sequencer to continue with
+			 * non-pack processing.
+			 */
+			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+			ahd_outb(ahd, CLRLQOINT1, CLRLQOPHACHGINPKT);
+			if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+				ahd_outb(ahd, CLRLQOINT1, 0);
+			}
+			printf("Continuing non-pack processing...\n");
+			break;
+		}
+		}
+		break;
+	}
+	case CFG4OVERRUN:
+		printf("%s: CFG4OVERRUN mode = %x\n", ahd_name(ahd),
+		       ahd_inb(ahd, MODE_PTR));
+		break;
+	case DUMP_CARD_STATE:
+	{
+		ahd_dump_card_state(ahd);
+		break;
+	}
+	case PDATA_REINIT:
+	{
+		printf("%s: PDATA_REINIT - DFCNTRL = 0x%x "
+		       "SG_CACHE_SHADOW = 0x%x\n",
+		       ahd_name(ahd), ahd_inb(ahd, DFCNTRL),
+		       ahd_inb(ahd, SG_CACHE_SHADOW));
+		ahd_reinitialize_dataptrs(ahd);
+		break;
+	}
+	case HOST_MSG_LOOP:
+	{
+		struct ahd_devinfo devinfo;
+
+		/*
+		 * The sequencer has encountered a message phase
+		 * that requires host assistance for completion.
+		 * While handling the message phase(s), we will be
+		 * notified by the sequencer after each byte is
+		 * transfered so we can track bus phase changes.
+		 *
+		 * If this is the first time we've seen a HOST_MSG_LOOP
+		 * interrupt, initialize the state of the host message
+		 * loop.
+		 */
+		ahd_fetch_devinfo(ahd, &devinfo);
+		if (ahd->msg_type == MSG_TYPE_NONE) {
+			struct scb *scb;
+			u_int scb_index;
+			u_int bus_phase;
+
+			bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+			if (bus_phase != P_MESGIN
+			 && bus_phase != P_MESGOUT) {
+				printf("ahd_intr: HOST_MSG_LOOP bad "
+				       "phase 0x%x\n",
+				      bus_phase);
+				/*
+				 * Probably transitioned to bus free before
+				 * we got here.  Just punt the message.
+				 */
+				ahd_dump_card_state(ahd);
+				ahd_clear_intstat(ahd);
+				ahd_restart(ahd);
+				return;
+			}
+
+			scb_index = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scb_index);
+			if (devinfo.role == ROLE_INITIATOR) {
+				if (bus_phase == P_MESGOUT)
+					ahd_setup_initiator_msgout(ahd,
+								   &devinfo,
+								   scb);
+				else {
+					ahd->msg_type =
+					    MSG_TYPE_INITIATOR_MSGIN;
+					ahd->msgin_index = 0;
+				}
+			}
+#if AHD_TARGET_MODE
+			else {
+				if (bus_phase == P_MESGOUT) {
+					ahd->msg_type =
+					    MSG_TYPE_TARGET_MSGOUT;
+					ahd->msgin_index = 0;
+				}
+				else 
+					ahd_setup_target_msgin(ahd,
+							       &devinfo,
+							       scb);
+			}
+#endif
+		}
+
+		ahd_handle_message_phase(ahd);
+		break;
+	}
+	case NO_MATCH:
+	{
+		/* Ensure we don't leave the selection hardware on */
+		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+
+		printf("%s:%c:%d: no active SCB for reconnecting "
+		       "target - issuing BUS DEVICE RESET\n",
+		       ahd_name(ahd), 'A', ahd_inb(ahd, SELID) >> 4);
+		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
+		       "REG0 == 0x%x ACCUM = 0x%x\n",
+		       ahd_inb(ahd, SAVED_SCSIID), ahd_inb(ahd, SAVED_LUN),
+		       ahd_inw(ahd, REG0), ahd_inb(ahd, ACCUM));
+		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
+		       "SINDEX == 0x%x\n",
+		       ahd_inb(ahd, SEQ_FLAGS), ahd_get_scbptr(ahd),
+		       ahd_find_busy_tcl(ahd,
+					 BUILD_TCL(ahd_inb(ahd, SAVED_SCSIID),
+						   ahd_inb(ahd, SAVED_LUN))),
+		       ahd_inw(ahd, SINDEX));
+		printf("SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
+		       "SCB_CONTROL == 0x%x\n",
+		       ahd_inb(ahd, SELID), ahd_inb_scbram(ahd, SCB_SCSIID),
+		       ahd_inb_scbram(ahd, SCB_LUN),
+		       ahd_inb_scbram(ahd, SCB_CONTROL));
+		printf("SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\n",
+		       ahd_inb(ahd, SCSIBUS), ahd_inb(ahd, SCSISIGI));
+		printf("SXFRCTL0 == 0x%x\n", ahd_inb(ahd, SXFRCTL0));
+		printf("SEQCTL0 == 0x%x\n", ahd_inb(ahd, SEQCTL0));
+		ahd_dump_card_state(ahd);
+		ahd->msgout_buf[0] = MSG_BUS_DEV_RESET;
+		ahd->msgout_len = 1;
+		ahd->msgout_index = 0;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		ahd_assert_atn(ahd);
+		break;
+	}
+	case PROTO_VIOLATION:
+	{
+		ahd_handle_proto_violation(ahd);
+		break;
+	}
+	case IGN_WIDE_RES:
+	{
+		struct ahd_devinfo devinfo;
+
+		ahd_fetch_devinfo(ahd, &devinfo);
+		ahd_handle_ign_wide_residue(ahd, &devinfo);
+		break;
+	}
+	case BAD_PHASE:
+	{
+		u_int lastphase;
+
+		lastphase = ahd_inb(ahd, LASTPHASE);
+		printf("%s:%c:%d: unknown scsi bus phase %x, "
+		       "lastphase = 0x%x.  Attempting to continue\n",
+		       ahd_name(ahd), 'A',
+		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
+		       lastphase, ahd_inb(ahd, SCSISIGI));
+		break;
+	}
+	case MISSED_BUSFREE:
+	{
+		u_int lastphase;
+
+		lastphase = ahd_inb(ahd, LASTPHASE);
+		printf("%s:%c:%d: Missed busfree. "
+		       "Lastphase = 0x%x, Curphase = 0x%x\n",
+		       ahd_name(ahd), 'A',
+		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
+		       lastphase, ahd_inb(ahd, SCSISIGI));
+		ahd_restart(ahd);
+		return;
+	}
+	case DATA_OVERRUN:
+	{
+		/*
+		 * When the sequencer detects an overrun, it
+		 * places the controller in "BITBUCKET" mode
+		 * and allows the target to complete its transfer.
+		 * Unfortunately, none of the counters get updated
+		 * when the controller is in this mode, so we have
+		 * no way of knowing how large the overrun was.
+		 */
+		struct	scb *scb;
+		u_int	scbindex = ahd_get_scbptr(ahd);
+		u_int	lastphase = ahd_inb(ahd, LASTPHASE);
+
+		scb = ahd_lookup_scb(ahd, scbindex);
+		ahd_print_path(ahd, scb);
+		printf("data overrun detected %s."
+		       "  Tag == 0x%x.\n",
+		       ahd_lookup_phase_entry(lastphase)->phasemsg,
+  		       SCB_GET_TAG(scb));
+		ahd_print_path(ahd, scb);
+		printf("%s seen Data Phase.  Length = %ld.  NumSGs = %d.\n",
+		       ahd_inb(ahd, SEQ_FLAGS) & DPHASE ? "Have" : "Haven't",
+		       ahd_get_transfer_length(scb), scb->sg_count);
+		ahd_dump_sglist(scb);
+
+		/*
+		 * Set this and it will take effect when the
+		 * target does a command complete.
+		 */
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		ahd_freeze_scb(scb);
+		break;
+	}
+	case MKMSG_FAILED:
+	{
+		struct ahd_devinfo devinfo;
+		struct scb *scb;
+		u_int scbid;
+
+		ahd_fetch_devinfo(ahd, &devinfo);
+		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
+		       ahd_name(ahd), devinfo.channel, devinfo.target,
+		       devinfo.lun);
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL
+		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
+			/*
+			 * Ensure that we didn't put a second instance of this
+			 * SCB into the QINFIFO.
+			 */
+			ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
+					   SCB_GET_CHANNEL(ahd, scb),
+					   SCB_GET_LUN(scb), SCB_GET_TAG(scb),
+					   ROLE_INITIATOR, /*status*/0,
+					   SEARCH_REMOVE);
+		ahd_outb(ahd, SCB_CONTROL,
+			 ahd_inb(ahd, SCB_CONTROL) & ~MK_MESSAGE);
+		break;
+	}
+	default:
+		printf("%s: Unexpected SEQINTCODE %d\n", ahd_name(ahd),
+		       seqintcode);
+		break;
+	}
+	/*
+	 *  The sequencer is paused immediately on
+	 *  a SEQINT, so we should restart it when
+	 *  we're done.
+	 */
+	ahd_unpause(ahd);
+}
+
+void
+ahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)
+{
+	struct scb	*scb;
+	u_int		 status0;
+	u_int		 status3;
+	u_int		 status;
+	u_int		 lqistat1;
+	u_int		 lqostat0;
+	u_int		 scbid;
+
+	ahd_update_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	status3 = ahd_inb(ahd, SSTAT3) & (NTRAMPERR|OSRAMPERR);
+	status0 = ahd_inb(ahd, SSTAT0) & (IOERR|OVERRUN|SELDI|SELDO);
+	status = ahd_inb(ahd, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
+	lqistat1 = ahd_inb(ahd, LQISTAT1);
+	lqostat0 = ahd_inb(ahd, LQOSTAT0);
+	if ((status0 & (SELDI|SELDO)) != 0) {
+		u_int simode0;
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		simode0 = ahd_inb(ahd, SIMODE0);
+		status0 &= simode0 & (IOERR|OVERRUN|SELDI|SELDO);
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	}
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	if (scb != NULL
+	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
+		scb = NULL;
+
+	/* Make sure the sequencer is in a safe location. */
+	ahd_clear_critical_section(ahd);
+
+	if ((status0 & IOERR) != 0) {
+		u_int now_lvd;
+
+		now_lvd = ahd_inb(ahd, SBLKCTL) & ENAB40;
+		printf("%s: Transceiver State Has Changed to %s mode\n",
+		       ahd_name(ahd), now_lvd ? "LVD" : "SE");
+		ahd_outb(ahd, CLRSINT0, CLRIOERR);
+		/*
+		 * A change in I/O mode is equivalent to a bus reset.
+		 */
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/FALSE);
+		ahd_pause(ahd);
+		ahd_setup_iocell_workaround(ahd);
+		ahd_unpause(ahd);
+	} else if ((status0 & OVERRUN) != 0) {
+		printf("%s: SCSI offset overrun detected.  Resetting bus.\n",
+		       ahd_name(ahd));
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+	} else if ((status & SCSIRSTI) != 0) {
+		printf("%s: Someone reset channel A\n", ahd_name(ahd));
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/FALSE);
+	} else if ((status & SCSIPERR) != 0) {
+		ahd_handle_transmission_error(ahd);
+	} else if (lqostat0 != 0) {
+		printf("%s: lqostat0 == 0x%x!\n", ahd_name(ahd), lqostat0);
+		ahd_outb(ahd, CLRLQOINT0, lqostat0);
+		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+			ahd_outb(ahd, CLRLQOINT1, 0);
+		}
+	} else if ((status & SELTO) != 0) {
+		u_int scbid;
+
+		/* Stop the selection */
+		ahd_outb(ahd, SCSISEQ0, 0);
+
+		/* No more pending messages */
+		ahd_clear_msg_state(ahd);
+
+		/* Clear interrupt state */
+		ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
+
+		/*
+		 * Although the driver does not care about the
+		 * 'Selection in Progress' status bit, the busy
+		 * LED does.  SELINGO is only cleared by a sucessfull
+		 * selection, so we must manually clear it to insure
+		 * the LED turns off just incase no future successful
+		 * selections occur (e.g. no devices on the bus).
+		 */
+		ahd_outb(ahd, CLRSINT0, CLRSELINGO);
+
+		scbid = ahd_inw(ahd, WAITING_TID_HEAD);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: ahd_intr - referenced scb not "
+			       "valid during SELTO scb(0x%x)\n",
+			       ahd_name(ahd), scbid);
+			ahd_dump_card_state(ahd);
+			panic("For diagnostics");
+		} else {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_SELTO) != 0) {
+				ahd_print_path(ahd, scb);
+				printf("Saw Selection Timeout for SCB 0x%x\n",
+				       scbid);
+			}
+#endif
+			ahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);
+			ahd_freeze_devq(ahd, scb);
+		}
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		ahd_iocell_first_selection(ahd);
+		ahd_restart(ahd);
+	} else if ((status0 & (SELDI|SELDO)) != 0) {
+		ahd_iocell_first_selection(ahd);
+		ahd_unpause(ahd);
+	} else if (status3 != 0) {
+		printf("%s: SCSI Cell parity error SSTAT3 == 0x%x\n",
+		       ahd_name(ahd), status3);
+		ahd_outb(ahd, CLRSINT3, status3);
+	} else if ((lqistat1 & (LQIPHASE_LQ|LQIPHASE_NLQ)) != 0) {
+		ahd_handle_lqiphase_error(ahd, lqistat1);
+	} else if ((status & BUSFREE) != 0) {
+		u_int busfreetime;
+		u_int lqostat1;
+		int   restart;
+		int   clear_fifo;
+		int   packetized;
+		u_int mode;
+
+		/*
+		 * Clear our selection hardware as soon as possible.
+		 * We may have an entry in the waiting Q for this target,
+		 * that is affected by this busfree and we don't want to
+		 * go about selecting the target while we handle the event.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+
+		/*
+		 * Determine what we were up to at the time of
+		 * the busfree.
+		 */
+		mode = AHD_MODE_SCSI;
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		busfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;
+		lqostat1 = ahd_inb(ahd, LQOSTAT1);
+		switch (busfreetime) {
+		case BUSFREE_DFF0:
+		case BUSFREE_DFF1:
+		{
+			u_int	scbid;
+			struct	scb *scb;
+
+			mode = busfreetime == BUSFREE_DFF0
+			     ? AHD_MODE_DFF0 : AHD_MODE_DFF1;
+			ahd_set_modes(ahd, mode, mode);
+			scbid = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scbid);
+			if (scb == NULL) {
+				printf("%s: Invalid SCB in DFF%d "
+				       "during unexpected busfree\n",
+				       ahd_name(ahd), mode);
+				packetized = 0;
+			} else
+				packetized = (scb->flags & SCB_PACKETIZED) != 0;
+			clear_fifo = 1;
+			break;
+		}
+		case BUSFREE_LQO:
+			clear_fifo = 0;
+			packetized = 1;
+			break;
+		default:
+			clear_fifo = 0;
+			packetized =  (lqostat1 & LQOBUSFREE) != 0;
+			if (!packetized
+			 && ahd_inb(ahd, LASTPHASE) == P_BUSFREE)
+				packetized = 1;
+			break;
+		}
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("Saw Busfree.  Busfreetime = 0x%x.\n",
+			       busfreetime);
+#endif
+		/*
+		 * Busfrees that occur in non-packetized phases are
+		 * handled by the nonpkt_busfree handler.
+		 */
+		if (packetized && ahd_inb(ahd, LASTPHASE) == P_BUSFREE) {
+			restart = ahd_handle_pkt_busfree(ahd, busfreetime);
+		} else {
+			packetized = 0;
+			restart = ahd_handle_nonpkt_busfree(ahd);
+		}
+		/*
+		 * Clear the busfree interrupt status.  The setting of
+		 * the interrupt is a pulse, so in a perfect world, we
+		 * would not need to muck with the ENBUSFREE logic.  This
+		 * would ensure that if the bus moves on to another
+		 * connection, busfree protection is still in force.  If
+		 * BUSFREEREV is broken, however, we must manually clear
+		 * the ENBUSFREE if the busfree occurred during a non-pack
+		 * connection so that we don't get false positives during
+		 * future, packetized, connections.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRBUSFREE);
+		if (packetized == 0
+		 && (ahd->bugs & AHD_BUSFREEREV_BUG) != 0)
+			ahd_outb(ahd, SIMODE1,
+				 ahd_inb(ahd, SIMODE1) & ~ENBUSFREE);
+
+		if (clear_fifo)
+			ahd_clear_fifo(ahd, mode);
+
+		ahd_clear_msg_state(ahd);
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		if (restart) {
+			ahd_restart(ahd);
+		} else {
+			ahd_unpause(ahd);
+		}
+	} else {
+		printf("%s: Missing case in ahd_handle_scsiint. status = %x\n",
+		       ahd_name(ahd), status);
+		ahd_dump_card_state(ahd);
+		ahd_clear_intstat(ahd);
+		ahd_unpause(ahd);
+	}
+}
+
+static void
+ahd_handle_transmission_error(struct ahd_softc *ahd)
+{
+	u_int	lqistat1;
+	u_int	lqistat2;
+	u_int	msg_out;
+	u_int	curphase;
+	u_int	lastphase;
+	u_int	perrdiag;
+	u_int	cur_col;
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	lqistat1 = ahd_inb(ahd, LQISTAT1) & ~(LQIPHASE_LQ|LQIPHASE_NLQ);
+	lqistat2 = ahd_inb(ahd, LQISTAT2);
+	if ((lqistat1 & (LQICRCI_NLQ|LQICRCI_LQ)) == 0
+	 && (ahd->bugs & AHD_NLQICRC_DELAYED_BUG) != 0) {
+		u_int lqistate;
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		lqistate = ahd_inb(ahd, LQISTATE);
+		if ((lqistate >= 0x1E && lqistate <= 0x24)
+		 || (lqistate == 0x29)) {
+			printf("%s: NLQCRC found via LQISTATE\n",
+			       ahd_name(ahd));
+			lqistat1 |= LQICRCI_NLQ;
+		}
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	}
+
+	ahd_outb(ahd, CLRLQIINT1, lqistat1);
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+	perrdiag = ahd_inb(ahd, PERRDIAG);
+	msg_out = MSG_INITIATOR_DET_ERR;
+	ahd_outb(ahd, CLRSINT1, CLRSCSIPERR);
+	printf("%s: Transmission error detected\n", ahd_name(ahd));
+	cur_col = 0;
+	ahd_lqistat1_print(lqistat1, &cur_col, 50);
+	ahd_lastphase_print(lastphase, &cur_col, 50);
+	ahd_scsisigi_print(curphase, &cur_col, 50);
+	ahd_perrdiag_print(perrdiag, &cur_col, 50);
+	printf("\n");
+	ahd_dump_card_state(ahd);
+	if ((lqistat1 & (LQIOVERI_LQ|LQIOVERI_NLQ)) != 0) {
+		printf("%s: Gross protocol error during incoming "
+		       "packet.  lqistat1 == 0x%x.  Resetting bus.\n",
+		       ahd_name(ahd), lqistat1);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		return;
+	} else if ((lqistat1 & LQICRCI_LQ) != 0) {
+		/*
+		 * A CRC error has been detected on an incoming LQ.
+		 * The bus is currently hung on the last ACK.
+		 * Hit LQIRETRY to release the last ack, and
+		 * wait for the sequencer to determine that ATNO
+		 * is asserted while in message out to take us
+		 * to our host message loop.  No NONPACKREQ or
+		 * LQIPHASE type errors will occur in this
+		 * scenario.  After this first LQIRETRY, the LQI
+		 * manager will be in ISELO where it will
+		 * happily sit until another packet phase begins.
+		 * Unexpected bus free detection is enabled
+		 * through any phases that occur after we release
+		 * this last ack until the LQI manager sees a
+		 * packet phase.  This implies we may have to
+		 * ignore a perfectly valid "unexected busfree"
+		 * after our "initiator detected error" message is
+		 * sent.  A busfree is the expected response after
+		 * we tell the target that it's L_Q was corrupted.
+		 * (SPI4R09 10.7.3.3.3)
+		 */
+		ahd_outb(ahd, LQCTL2, LQIRETRY);
+		printf("LQIRetry for LQICRCI_LQ to release ACK\n");
+	} else if ((lqistat1 & LQICRCI_NLQ) != 0) {
+		u_int scbid;
+		struct scb *scb;
+
+		/*
+		 * We detected a CRC error in a NON-LQ packet.
+		 * The hardware has varying behavior in this situation
+		 * depending on whether this packet was part of a
+		 * stream or not.
+		 *
+		 * PKT by PKT mode:
+		 * The hardware has already acked the complete packet.
+		 * If the target honors our outstanding ATN condition,
+		 * we should be (or soon will be) in MSGOUT phase.
+		 * This will trigger the LQIPHASE_LQ status bit as the
+		 * hardware was expecting another LQ.  Unexpected
+		 * busfree detection is enabled.  Once LQIPHASE_LQ is
+		 * true (first entry into host message loop is much
+		 * the same), we must clear LQIPHASE_LQ and hit
+		 * LQIRETRY so the hardware is ready to handle
+		 * a future LQ.  NONPACKREQ will not be asserted again
+		 * once we hit LQIRETRY until another packet is
+		 * processed.  The target may either go busfree
+		 * or start another packet in response to our message.
+		 *
+		 * Read Streaming P0 asserted:
+		 * If we raise ATN and the target completes the entire
+		 * stream (P0 asserted during the last packet), the
+		 * hardware will ack all data and return to the ISTART
+		 * state.  When the target reponds to our ATN condition,
+		 * LQIPHASE_LQ will be asserted.  We should respond to
+		 * this with an LQIRETRY to prepare for any future
+		 * packets.  NONPACKREQ will not be asserted again
+		 * once we hit LQIRETRY until another packet is
+		 * processed.  The target may either go busfree or
+		 * start another packet in response to our message.
+		 * Busfree detection is enabled.
+		 *
+		 * Read Streaming P0 not asserted:
+		 * If we raise ATN and the target transitions to
+		 * MSGOUT in or after a packet where P0 is not
+		 * asserted, the hardware will assert LQIPHASE_NLQ.
+		 * We should respond to the LQIPHASE_NLQ with an
+		 * LQICONTINUE.  Should the target stay in a non-pkt
+		 * phase after we send our message, the hardware
+		 * will assert LQIPHASE_LQ.  Recovery is then just as
+		 * listed above for the read streaming with P0 asserted.
+		 * Busfree detection is enabled.
+		 */
+		printf("LQICRC_NLQ\n");
+		ahd_set_active_fifo(ahd);
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: No SCB valid for LQICRC_NLQ.  "
+			       "Resetting bus\n", ahd_name(ahd));
+			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+			return;
+		}
+		scb->flags |= SCB_TRANSMISSION_ERROR;
+	} else if ((lqistat1 & LQIBADLQI) != 0) {
+		printf("Need to handle BADLQI!\n");
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		return;
+	} else if ((perrdiag & (PARITYERR|PREVPHASE)) == PARITYERR) {
+		if ((curphase & ~P_DATAIN_DT) != 0) {
+			/* Ack the byte.  So we can continue. */
+			printf("Acking %s to clear perror\n",
+			       ahd_lookup_phase_entry(curphase)->phasemsg);
+			ahd_inb(ahd, SCSIDAT);
+		}
+	
+		if (curphase == P_MESGIN)
+			msg_out = MSG_PARITY_ERROR;
+	}
+
+	/*
+	 * We've set the hardware to assert ATN if we 
+	 * get a parity error on "in" phases, so all we
+	 * need to do is stuff the message buffer with
+	 * the appropriate message.  "In" phases have set
+	 * mesg_out to something other than MSG_NOP.
+	 */
+	ahd->send_msg_perror = msg_out;
+	ahd_outb(ahd, MSG_OUT, HOST_MSG);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+	ahd_unpause(ahd);
+}
+
+static void
+ahd_handle_lqiphase_error(struct ahd_softc *ahd, u_int lqistat1)
+{
+	/*
+	 * Clear the sources of the interrupts.
+	 */
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, CLRLQIINT1, lqistat1);
+
+	/*
+	 * If the "illegal" phase changes were in response
+	 * to our ATN to flag a CRC error, AND we ended up
+	 * on packet boundaries, clear the error, restart the
+	 * LQI manager as appropriate, and go on our merry
+	 * way toward sending the message.  Otherwise, reset
+	 * the bus to clear the error.
+	 */
+	ahd_set_active_fifo(ahd);
+	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0
+	 && (ahd_inb(ahd, MDFFSTAT) & DLZERO) != 0) {
+		if ((lqistat1 & LQIPHASE_LQ) != 0) {
+			printf("LQIRETRY for LQIPHASE_LQ\n");
+			ahd_outb(ahd, LQCTL2, LQIRETRY);
+		} else if ((lqistat1 & LQIPHASE_NLQ) != 0) {
+			printf("LQICONTINUE for LQIPHASE_NLQ\n");
+			ahd_outb(ahd, LQCTL2, LQIRETRY);
+		} else
+			panic("ahd_handle_lqiphase_error: No phase errors\n");
+		ahd_dump_card_state(ahd);
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		ahd_unpause(ahd);
+	} else {
+		printf("Reseting Channel for LQI Phase error\n");
+		ahd_dump_card_state(ahd);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+	}
+}
+
+/*
+ * Packetized unexpected or expected busfree.
+ * Entered in mode based on busfreetime.
+ */
+static int
+ahd_handle_pkt_busfree(struct ahd_softc *ahd, u_int busfreetime)
+{
+	u_int lqostat1;
+
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	lqostat1 = ahd_inb(ahd, LQOSTAT1);
+	if ((lqostat1 & LQOBUSFREE) != 0) {
+		struct scb *scb;
+		u_int scbid;
+		u_int saved_scbptr;
+		u_int waiting_h;
+		u_int waiting_t;
+		u_int next;
+
+		if ((busfreetime & BUSFREE_LQO) == 0)
+			printf("%s: Warning, BUSFREE time is 0x%x.  "
+			       "Expected BUSFREE_LQO.\n",
+			       ahd_name(ahd), busfreetime);
+		/*
+		 * The LQO manager detected an unexpected busfree
+		 * either:
+		 *
+		 * 1) During an outgoing LQ.
+		 * 2) After an outgoing LQ but before the first
+		 *    REQ of the command packet.
+		 * 3) During an outgoing command packet.
+		 *
+		 * In all cases, CURRSCB is pointing to the
+		 * SCB that encountered the failure.  Clean
+		 * up the queue, clear SELDO and LQOBUSFREE,
+		 * and allow the sequencer to restart the select
+		 * out at its lesure.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		scbid = ahd_inw(ahd, CURRSCB);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL)
+		       panic("SCB not valid during LQOBUSFREE");
+		ahd_print_path(ahd, scb);
+		printf("Probable outgoing LQ CRC error.  Retrying command\n");
+
+		/*
+		 * Return the LQO manager to its idle loop.  It will
+		 * not do this automatically if the busfree occurs
+		 * after the first REQ of either the LQ or command
+		 * packet or between the LQ and command packet.
+		 */
+		ahd_outb(ahd, LQCTL2, ahd_inb(ahd, LQCTL2) | LQOTOIDLE);
+
+		/*
+		 * Clear the status.
+		 */
+		ahd_outb(ahd, CLRLQOINT1, CLRLQOBUSFREE);
+		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)
+			ahd_outb(ahd, CLRLQOINT1, 0);
+		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+		ahd_outb(ahd, CLRSINT0, CLRSELDO);
+
+		/*
+		 * Update the waiting for selection queue so
+		 * we restart on the correct SCB.
+		 */
+		waiting_h = ahd_inw(ahd, WAITING_TID_HEAD);
+		saved_scbptr = ahd_get_scbptr(ahd);
+		if (waiting_h != scbid) {
+
+			ahd_outw(ahd, WAITING_TID_HEAD, scbid);
+			waiting_t = ahd_inw(ahd, WAITING_TID_TAIL);
+			next = SCB_LIST_NULL;
+			if (waiting_t == waiting_h) {
+				ahd_outw(ahd, WAITING_TID_TAIL, scbid);
+			} else {
+				ahd_set_scbptr(ahd, waiting_h);
+				next = ahd_inw(ahd, SCB_NEXT2);
+			}
+			ahd_set_scbptr(ahd, scbid);
+			ahd_outw(ahd, SCB_NEXT2, next);
+		}
+		ahd_set_scbptr(ahd, saved_scbptr);
+		/* Return unpausing the sequencer. */
+		return (0);
+	}
+	if (ahd->src_mode != AHD_MODE_SCSI) {
+		u_int	scbid;
+		struct	scb *scb;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		ahd_print_path(ahd, scb);
+		printf("Unexpected PKT busfree condition\n");
+		ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb), 'A',
+			       SCB_GET_LUN(scb), SCB_GET_TAG(scb),
+			       ROLE_INITIATOR, CAM_UNEXP_BUSFREE);
+
+		/* Return restarting the sequencer. */
+		return (1);
+	}
+	printf("%s: Unexpected PKT busfree condition\n", ahd_name(ahd));
+	ahd_dump_card_state(ahd);
+	/* Restart the sequencer. */
+	return (1);
+}
+
+/*
+ * Non-packetized unexpected or expected busfree.
+ */
+static int
+ahd_handle_nonpkt_busfree(struct ahd_softc *ahd)
+{
+	struct	ahd_devinfo devinfo;
+	struct	scb *scb;
+	u_int	lastphase;
+	u_int	saved_scsiid;
+	u_int	saved_lun;
+	u_int	target;
+	u_int	initiator_role_id;
+	u_int	scbid;
+	int	printerror;
+
+	/*
+	 * Look at what phase we were last in.  If its message out,
+	 * chances are pretty good that the busfree was in response
+	 * to one of our abort requests.
+	 */
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
+	saved_lun = ahd_inb(ahd, SAVED_LUN);
+	target = SCSIID_TARGET(ahd, saved_scsiid);
+	initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
+	ahd_compile_devinfo(&devinfo, initiator_role_id,
+			    target, saved_lun, 'A', ROLE_INITIATOR);
+	printerror = 1;
+
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	if (scb != NULL
+	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
+		scb = NULL;
+
+	if (lastphase == P_MESGOUT) {
+		u_int tag;
+
+		tag = SCB_LIST_NULL;
+		if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT_TAG, TRUE)
+		 || ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT, TRUE)) {
+			int found;
+			int sent_msg;
+
+			if (scb == NULL) {
+				ahd_print_devinfo(ahd, &devinfo);
+				printf("Abort for unidentified "
+				       "connection completed.\n");
+				/* restart the sequencer. */
+				return (1);
+			}
+			sent_msg = ahd->msgout_buf[ahd->msgout_index - 1];
+			ahd_print_path(ahd, scb);
+			printf("SCB %d - Abort%s Completed.\n",
+			       SCB_GET_TAG(scb),
+			       sent_msg == MSG_ABORT_TAG ? "" : " Tag");
+
+			if (sent_msg == MSG_ABORT_TAG)
+				tag = SCB_GET_TAG(scb);
+
+			if ((scb->flags & SCB_CMDPHASE_ABORT) != 0) {
+				/*
+				 * This abort is in response to an
+				 * unexpected switch to command phase
+				 * for a packetized connection.  Since
+				 * the identify message was never sent,
+				 * "saved lun" is 0.  We really want to
+				 * abort only the SCB that encountered
+				 * this error, which could have a different
+				 * lun.  The SCB will be retried so the OS
+				 * will see the UA after renegotiating to
+				 * packetized.
+				 */
+				tag = SCB_GET_TAG(scb);
+				saved_lun = scb->hscb->lun;
+			}
+			found = ahd_abort_scbs(ahd, target, 'A', saved_lun,
+					       tag, ROLE_INITIATOR,
+					       CAM_REQ_ABORTED);
+			printf("found == 0x%x\n", found);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_1B,
+					MSG_BUS_DEV_RESET, TRUE)) {
+#ifdef __FreeBSD__
+			/*
+			 * Don't mark the user's request for this BDR
+			 * as completing with CAM_BDR_SENT.  CAM3
+			 * specifies CAM_REQ_CMP.
+			 */
+			if (scb != NULL
+			 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
+			 && ahd_match_scb(ahd, scb, target, 'A',
+					  CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					  ROLE_INITIATOR))
+				ahd_set_transaction_status(scb, CAM_REQ_CMP);
+#endif
+			ahd_handle_devreset(ahd, &devinfo, CAM_BDR_SENT,
+					    "Bus Device Reset",
+					    /*verbose_level*/0);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, FALSE)) {
+			struct ahd_initiator_tinfo *tinfo;
+			struct ahd_tmode_tstate *tstate;
+
+			/*
+			 * PPR Rejected.  Try non-ppr negotiation
+			 * and retry command.
+			 */
+			tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
+						    devinfo.our_scsiid,
+						    devinfo.target, &tstate);
+			tinfo->curr.transport_version = 2;
+			tinfo->goal.transport_version = 2;
+			tinfo->goal.ppr_options = 0;
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, FALSE)
+			|| ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, FALSE)) {
+			/*
+			 * Negotiation Rejected.  Go-async and
+			 * retry command.
+			 */
+			ahd_set_width(ahd, &devinfo,
+				      MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			ahd_set_syncrate(ahd, &devinfo,
+					/*period*/0, /*offset*/0,
+					/*ppr_options*/0,
+					AHD_TRANS_CUR|AHD_TRANS_GOAL,
+					/*paused*/TRUE);
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			printerror = 0;
+		} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_IDE_BUSFREE) != 0
+			&& ahd_sent_msg(ahd, AHDMSG_1B,
+					 MSG_INITIATOR_DET_ERR, TRUE)) {
+
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("Expected IDE Busfree\n");
+#endif
+			printerror = 0;
+		}
+	}
+
+	/*
+	 * The busfree required flag is honored at the end of
+	 * the message phases.  We check it last in case we
+	 * had to send some other message that caused a busfree.
+	 */
+	if (printerror != 0
+	 && (lastphase == P_MESGIN || lastphase == P_MESGOUT)
+	 && ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {
+
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+		ahd_freeze_scb(scb);
+		if ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {
+			ahd_print_path(ahd, scb);
+			printf("Now %spacketized.\n",
+			       (scb->flags & SCB_PACKETIZED) == 0
+			     ? "" : "non-");
+			ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
+				       SCB_GET_CHANNEL(ahd, scb),
+				       SCB_GET_LUN(scb), SCB_LIST_NULL,
+				       ROLE_INITIATOR, CAM_REQ_ABORTED);
+		} else {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("PPR Negotiation Busfree.\n");
+#endif
+			ahd_done(ahd, scb);
+		}
+		printerror = 0;
+	}
+	if (printerror != 0) {
+		int aborted;
+
+		aborted = 0;
+		if (scb != NULL) {
+			u_int tag;
+
+			if ((scb->hscb->control & TAG_ENB) != 0)
+				tag = SCB_GET_TAG(scb);
+			else
+				tag = SCB_LIST_NULL;
+			ahd_print_path(ahd, scb);
+			aborted = ahd_abort_scbs(ahd, target, 'A',
+				       SCB_GET_LUN(scb), tag,
+				       ROLE_INITIATOR,
+				       CAM_UNEXP_BUSFREE);
+		} else {
+			/*
+			 * We had not fully identified this connection,
+			 * so we cannot abort anything.
+			 */
+			printf("%s: ", ahd_name(ahd));
+		}
+		if (lastphase != P_BUSFREE)
+			ahd_force_renegotiation(ahd, &devinfo);
+		printf("Unexpected busfree %s, %d SCBs aborted, "
+		       "PRGMCNT == 0x%x\n",
+		       ahd_lookup_phase_entry(lastphase)->phasemsg,
+		       aborted,
+		       ahd_inb(ahd, PRGMCNT)
+			| (ahd_inb(ahd, PRGMCNT+1) << 8));
+		ahd_dump_card_state(ahd);
+	}
+	/* Always restart the sequencer. */
+	return (1);
+}
+
+static void
+ahd_handle_proto_violation(struct ahd_softc *ahd)
+{
+	struct	ahd_devinfo devinfo;
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	seq_flags;
+	u_int	curphase;
+	u_int	lastphase;
+	int	found;
+
+	ahd_fetch_devinfo(ahd, &devinfo);
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	seq_flags = ahd_inb(ahd, SEQ_FLAGS);
+	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	if ((seq_flags & NOT_IDENTIFIED) != 0) {
+
+		/*
+		 * The reconnecting target either did not send an
+		 * identify message, or did, but we didn't find an SCB
+		 * to match.
+		 */
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("Target did not send an IDENTIFY message. "
+		       "LASTPHASE = 0x%x.\n", lastphase);
+		scb = NULL;
+	} else if (scb == NULL) {
+		/*
+		 * We don't seem to have an SCB active for this
+		 * transaction.  Print an error and reset the bus.
+		 */
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("No SCB found during protocol violation\n");
+		goto proto_violation_reset;
+	} else {
+		ahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
+		if ((seq_flags & NO_CDB_SENT) != 0) {
+			ahd_print_path(ahd, scb);
+			printf("No or incomplete CDB sent to device.\n");
+		} else if ((ahd_inb(ahd, SCB_CONTROL) & STATUS_RCVD) == 0) {
+			/*
+			 * The target never bothered to provide status to
+			 * us prior to completing the command.  Since we don't
+			 * know the disposition of this command, we must attempt
+			 * to abort it.  Assert ATN and prepare to send an abort
+			 * message.
+			 */
+			ahd_print_path(ahd, scb);
+			printf("Completed command without status.\n");
+		} else {
+			ahd_print_path(ahd, scb);
+			printf("Unknown protocol violation.\n");
+			ahd_dump_card_state(ahd);
+		}
+	}
+	if ((lastphase & ~P_DATAIN_DT) == 0) {
+proto_violation_reset:
+		/*
+		 * Target either went directly to data
+		 * phase or didn't respond to our ATN.
+		 * The only safe thing to do is to blow
+		 * it away with a bus reset.
+		 */
+		found = ahd_reset_channel(ahd, 'A', TRUE);
+		printf("%s: Issued Channel %c Bus Reset. "
+		       "%d SCBs aborted\n", ahd_name(ahd), 'A', found);
+	} else {
+		/*
+		 * Leave the selection hardware off in case
+		 * this abort attempt will affect yet to
+		 * be sent commands.
+		 */
+		ahd_outb(ahd, SCSISEQ0,
+			 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+		ahd_assert_atn(ahd);
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		if (scb == NULL) {
+			ahd_print_devinfo(ahd, &devinfo);
+			ahd->msgout_buf[0] = MSG_ABORT_TASK;
+			ahd->msgout_len = 1;
+			ahd->msgout_index = 0;
+			ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		} else {
+			ahd_print_path(ahd, scb);
+			scb->flags |= SCB_ABORT;
+		}
+		printf("Protocol violation %s.  Attempting to abort.\n",
+		       ahd_lookup_phase_entry(curphase)->phasemsg);
+	}
+}
+
+/*
+ * Force renegotiation to occur the next time we initiate
+ * a command to the current device.
+ */
+static void
+ahd_force_renegotiation(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	ahd_initiator_tinfo *targ_info;
+	struct	ahd_tmode_tstate *tstate;
+
+	printf("Forcing renegotiation (%d:%c:%d)\n",
+	       devinfo->our_scsiid, devinfo->channel, 
+	       devinfo->target);
+	targ_info = ahd_fetch_transinfo(ahd,
+					devinfo->channel,
+					devinfo->our_scsiid,
+					devinfo->target,
+					&tstate);
+	ahd_update_neg_request(ahd, devinfo, tstate,
+			       targ_info, /*force*/TRUE);
+}
+
+#define AHD_MAX_STEPS 2000
+void
+ahd_clear_critical_section(struct ahd_softc *ahd)
+{
+	ahd_mode_state	saved_modes;
+	int		stepping;
+	int		steps;
+
+	if (ahd->num_critical_sections == 0)
+		return;
+
+	stepping = FALSE;
+	steps = 0;
+	saved_modes = ahd_save_modes(ahd);
+	for (;;) {
+		struct	cs *cs;
+		u_int	seqaddr;
+		u_int	i;
+
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		seqaddr = ahd_inb(ahd, CURADDR)
+			| (ahd_inb(ahd, CURADDR+1) << 8);
+
+		cs = ahd->critical_sections;
+		for (i = 0; i < ahd->num_critical_sections; i++, cs++) {
+			
+			if (cs->begin < seqaddr && cs->end >= seqaddr)
+				break;
+		}
+
+		if (i == ahd->num_critical_sections)
+			break;
+
+		if (steps > AHD_MAX_STEPS) {
+			printf("%s: Infinite loop in critical section\n",
+			       ahd_name(ahd));
+			ahd_dump_card_state(ahd);
+			panic("critical section loop");
+		}
+
+		steps++;
+		if (stepping == FALSE) {
+
+			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+			ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) | STEP);
+			stepping = TRUE;
+		}
+		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+		ahd_outb(ahd, HCNTRL, ahd->unpause);
+		do {
+			ahd_delay(200);
+		} while (!ahd_is_paused(ahd));
+		ahd_update_modes(ahd);
+	}
+	if (stepping) {
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);
+	}
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * Clear any pending interrupt status.
+ */
+void
+ahd_clear_intstat(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	/* Clear any interrupt conditions this may have caused */
+	ahd_outb(ahd, CLRLQIINT0, CLRLQIATNQAS|CLRLQICRCT1|CLRLQICRCT2
+				 |CLRLQIBADLQT|CLRLQIATNLQ|CLRLQIATNCMD);
+	ahd_outb(ahd, CLRLQIINT1, CLRLQIPHASE_LQ|CLRLQIPHASE_NLQ|CLRLIQABORT
+				 |CLRLQICRCI_LQ|CLRLQICRCI_NLQ|CLRLQIBADLQI
+				 |CLRLQIOVERI_LQ|CLRLQIOVERI_NLQ|CLRNONPACKREQ);
+	ahd_outb(ahd, CLRLQOINT0, CLRLQOTARGSCBPERR|CLRLQOSTOPT2|CLRLQOATNLQ
+				 |CLRLQOATNPKT|CLRLQOTCRC);
+	ahd_outb(ahd, CLRLQOINT1, CLRLQOINITSCBPERR|CLRLQOSTOPI2|CLRLQOBADQAS
+				 |CLRLQOBUSFREE|CLRLQOPHACHGINPKT);
+	if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+		ahd_outb(ahd, CLRLQOINT0, 0);
+		ahd_outb(ahd, CLRLQOINT1, 0);
+	}
+	ahd_outb(ahd, CLRSINT3, CLRNTRAMPERR|CLROSRAMPERR);
+	ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
+				|CLRBUSFREE|CLRSCSIPERR|CLRREQINIT);
+	ahd_outb(ahd, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO|CLRIOERR);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+}
+
+/**************************** Debugging Routines ******************************/
+#ifdef AHD_DEBUG
+uint32_t ahd_debug = AHD_DEBUG_OPTS;
+#endif
+void
+ahd_print_scb(struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	int i;
+
+	hscb = scb->hscb;
+	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
+	       (void *)scb,
+	       hscb->control,
+	       hscb->scsiid,
+	       hscb->lun,
+	       hscb->cdb_len);
+	printf("Shared Data: ");
+	for (i = 0; i < sizeof(hscb->shared_data.idata.cdb); i++)
+		printf("%#02x", hscb->shared_data.idata.cdb[i]);
+	printf("        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n",
+	       (uint32_t)((ahd_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),
+	       (uint32_t)(ahd_le64toh(hscb->dataptr) & 0xFFFFFFFF),
+	       ahd_le32toh(hscb->datacnt),
+	       ahd_le32toh(hscb->sgptr),
+	       SCB_GET_TAG(scb));
+	ahd_dump_sglist(scb);
+}
+
+void
+ahd_dump_sglist(struct scb *scb)
+{
+	int i;
+
+	if (scb->sg_count > 0) {
+		if ((scb->ahd_softc->flags & AHD_64BIT_ADDRESSING) != 0) {
+			struct ahd_dma64_seg *sg_list;
+
+			sg_list = (struct ahd_dma64_seg*)scb->sg_list;
+			for (i = 0; i < scb->sg_count; i++) {
+				uint64_t addr;
+				uint32_t len;
+
+				addr = ahd_le64toh(sg_list[i].addr);
+				len = ahd_le32toh(sg_list[i].len);
+				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
+				       i,
+				       (uint32_t)((addr >> 32) & 0xFFFFFFFF),
+				       (uint32_t)(addr & 0xFFFFFFFF),
+				       sg_list[i].len & AHD_SG_LEN_MASK,
+				       (sg_list[i].len & AHD_DMA_LAST_SEG)
+				     ? " Last" : "");
+			}
+		} else {
+			struct ahd_dma_seg *sg_list;
+
+			sg_list = (struct ahd_dma_seg*)scb->sg_list;
+			for (i = 0; i < scb->sg_count; i++) {
+				uint32_t len;
+
+				len = ahd_le32toh(sg_list[i].len);
+				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
+				       i,
+				       (sg_list[i].len >> 24)&SG_HIGH_ADDR_BITS,
+				       ahd_le32toh(sg_list[i].addr),
+				       sg_list[i].len & AHD_SG_LEN_MASK,
+				       (sg_list[i].len & AHD_DMA_LAST_SEG)
+				     ? " Last" : "");
+			}
+		}
+	}
+}
+
+/************************* Transfer Negotiation *******************************/
+/*
+ * Allocate per target mode instance (ID we respond to as a target)
+ * transfer negotiation data structures.
+ */
+static struct ahd_tmode_tstate *
+ahd_alloc_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel)
+{
+	struct ahd_tmode_tstate *master_tstate;
+	struct ahd_tmode_tstate *tstate;
+	int i;
+
+	master_tstate = ahd->enabled_targets[ahd->our_id];
+	if (ahd->enabled_targets[scsi_id] != NULL
+	 && ahd->enabled_targets[scsi_id] != master_tstate)
+		panic("%s: ahd_alloc_tstate - Target already allocated",
+		      ahd_name(ahd));
+	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
+	if (tstate == NULL)
+		return (NULL);
+
+	/*
+	 * If we have allocated a master tstate, copy user settings from
+	 * the master tstate (taken from SRAM or the EEPROM) for this
+	 * channel, but reset our current and goal settings to async/narrow
+	 * until an initiator talks to us.
+	 */
+	if (master_tstate != NULL) {
+		memcpy(tstate, master_tstate, sizeof(*tstate));
+		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
+		for (i = 0; i < 16; i++) {
+			memset(&tstate->transinfo[i].curr, 0,
+			      sizeof(tstate->transinfo[i].curr));
+			memset(&tstate->transinfo[i].goal, 0,
+			      sizeof(tstate->transinfo[i].goal));
+		}
+	} else
+		memset(tstate, 0, sizeof(*tstate));
+	ahd->enabled_targets[scsi_id] = tstate;
+	return (tstate);
+}
+
+#ifdef AHD_TARGET_MODE
+/*
+ * Free per target mode instance (ID we respond to as a target)
+ * transfer negotiation data structures.
+ */
+static void
+ahd_free_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel, int force)
+{
+	struct ahd_tmode_tstate *tstate;
+
+	/*
+	 * Don't clean up our "master" tstate.
+	 * It has our default user settings.
+	 */
+	if (scsi_id == ahd->our_id
+	 && force == FALSE)
+		return;
+
+	tstate = ahd->enabled_targets[scsi_id];
+	if (tstate != NULL)
+		free(tstate, M_DEVBUF);
+	ahd->enabled_targets[scsi_id] = NULL;
+}
+#endif
+
+/*
+ * Called when we have an active connection to a target on the bus,
+ * this function finds the nearest period to the input period limited
+ * by the capabilities of the bus connectivity of and sync settings for
+ * the target.
+ */
+void
+ahd_devlimited_syncrate(struct ahd_softc *ahd,
+			struct ahd_initiator_tinfo *tinfo,
+			u_int *period, u_int *ppr_options, role_t role)
+{
+	struct	ahd_transinfo *transinfo;
+	u_int	maxsync;
+
+	if ((ahd_inb(ahd, SBLKCTL) & ENAB40) != 0
+	 && (ahd_inb(ahd, SSTAT2) & EXP_ACTIVE) == 0) {
+		maxsync = AHD_SYNCRATE_PACED;
+	} else {
+		maxsync = AHD_SYNCRATE_ULTRA;
+		/* Can't do DT related options on an SE bus */
+		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
+	}
+	/*
+	 * Never allow a value higher than our current goal
+	 * period otherwise we may allow a target initiated
+	 * negotiation to go above the limit as set by the
+	 * user.  In the case of an initiator initiated
+	 * sync negotiation, we limit based on the user
+	 * setting.  This allows the system to still accept
+	 * incoming negotiations even if target initiated
+	 * negotiation is not performed.
+	 */
+	if (role == ROLE_TARGET)
+		transinfo = &tinfo->user;
+	else 
+		transinfo = &tinfo->goal;
+	*ppr_options &= (transinfo->ppr_options|MSG_EXT_PPR_PCOMP_EN);
+	if (transinfo->period == 0) {
+		*period = 0;
+		*ppr_options = 0;
+	} else {
+		*period = MAX(*period, transinfo->period);
+		ahd_find_syncrate(ahd, period, ppr_options, maxsync);
+	}
+}
+
+/*
+ * Look up the valid period to SCSIRATE conversion in our table.
+ * Return the period and offset that should be sent to the target
+ * if this was the beginning of an SDTR.
+ */
+void
+ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
+		  u_int *ppr_options, u_int maxsync)
+{
+	/* Skip all PACED only entries if IU is not available */
+	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0
+	 && maxsync < AHD_SYNCRATE_DT)
+		maxsync = AHD_SYNCRATE_DT;
+
+	/* Skip all DT only entries if DT is not available */
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
+	 && maxsync < AHD_SYNCRATE_ULTRA2)
+		maxsync = AHD_SYNCRATE_ULTRA2;
+	
+	if (*period < maxsync)
+		*period = maxsync;
+
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) != 0
+	 && *period > AHD_SYNCRATE_MIN_DT)
+		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+		
+	if (*period > AHD_SYNCRATE_MIN)
+		*period = 0;
+
+	/* Honor PPR option conformance rules. */
+	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
+		*ppr_options &= (MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_QAS_REQ);
+
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0)
+		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
+}
+
+/*
+ * Truncate the given synchronous offset to a value the
+ * current adapter type and syncrate are capable of.
+ */
+void
+ahd_validate_offset(struct ahd_softc *ahd,
+		    struct ahd_initiator_tinfo *tinfo,
+		    u_int period, u_int *offset, int wide,
+		    role_t role)
+{
+	u_int maxoffset;
+
+	/* Limit offset to what we can do */
+	if (period == 0)
+		maxoffset = 0;
+	else if (period <= AHD_SYNCRATE_PACED)
+		maxoffset = MAX_OFFSET_PACED;
+	else
+		maxoffset = MAX_OFFSET;
+	*offset = MIN(*offset, maxoffset);
+	if (tinfo != NULL) {
+		if (role == ROLE_TARGET)
+			*offset = MIN(*offset, tinfo->user.offset);
+		else
+			*offset = MIN(*offset, tinfo->goal.offset);
+	}
+}
+
+/*
+ * Truncate the given transfer width parameter to a value the
+ * current adapter type is capable of.
+ */
+void
+ahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,
+		   u_int *bus_width, role_t role)
+{
+	switch (*bus_width) {
+	default:
+		if (ahd->features & AHD_WIDE) {
+			/* Respond Wide */
+			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
+			break;
+		}
+		/* FALLTHROUGH */
+	case MSG_EXT_WDTR_BUS_8_BIT:
+		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
+		break;
+	}
+	if (tinfo != NULL) {
+		if (role == ROLE_TARGET)
+			*bus_width = MIN(tinfo->user.width, *bus_width);
+		else
+			*bus_width = MIN(tinfo->goal.width, *bus_width);
+	}
+}
+
+/*
+ * Update the bitmask of targets for which the controller should
+ * negotiate with at the next convenient oportunity.  This currently
+ * means the next time we send the initial identify messages for
+ * a new transaction.
+ */
+int
+ahd_update_neg_request(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		       struct ahd_tmode_tstate *tstate,
+		       struct ahd_initiator_tinfo *tinfo, int force)
+{
+	u_int auto_negotiate_orig;
+
+	auto_negotiate_orig = tstate->auto_negotiate;
+	if (tinfo->curr.period != tinfo->goal.period
+	 || tinfo->curr.width != tinfo->goal.width
+	 || tinfo->curr.offset != tinfo->goal.offset
+	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
+	 || (force
+	  && (tinfo->goal.period != 0
+	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
+	   || tinfo->goal.ppr_options != 0)))
+		tstate->auto_negotiate |= devinfo->target_mask;
+	else
+		tstate->auto_negotiate &= ~devinfo->target_mask;
+
+	return (auto_negotiate_orig != tstate->auto_negotiate);
+}
+
+/*
+ * Update the user/goal/curr tables of synchronous negotiation
+ * parameters as well as, in the case of a current or active update,
+ * any data structures on the host controller.  In the case of an
+ * active update, the specified target is currently talking to us on
+ * the bus, so the transfer parameter update must take effect
+ * immediately.
+ */
+void
+ahd_set_syncrate(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		 u_int period, u_int offset, u_int ppr_options,
+		 u_int type, int paused)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	u_int	old_period;
+	u_int	old_offset;
+	u_int	old_ppr;
+	int	active;
+	int	update_needed;
+
+	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
+	update_needed = 0;
+
+	if (period == 0 || offset == 0) {
+		period = 0;
+		offset = 0;
+	}
+
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	if ((type & AHD_TRANS_USER) != 0) {
+		tinfo->user.period = period;
+		tinfo->user.offset = offset;
+		tinfo->user.ppr_options = ppr_options;
+	}
+
+	if ((type & AHD_TRANS_GOAL) != 0) {
+		tinfo->goal.period = period;
+		tinfo->goal.offset = offset;
+		tinfo->goal.ppr_options = ppr_options;
+	}
+
+	old_period = tinfo->curr.period;
+	old_offset = tinfo->curr.offset;
+	old_ppr	   = tinfo->curr.ppr_options;
+
+	if ((type & AHD_TRANS_CUR) != 0
+	 && (old_period != period
+	  || old_offset != offset
+	  || old_ppr != ppr_options)) {
+
+		update_needed++;
+
+		tinfo->curr.period = period;
+		tinfo->curr.offset = offset;
+		tinfo->curr.ppr_options = ppr_options;
+
+		ahd_send_async(ahd, devinfo->channel, devinfo->target,
+			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
+		if (bootverbose) {
+			if (offset != 0) {
+				printf("%s: target %d synchronous with "
+				       "period = 0x%x, offset = 0x%x%s\n",
+				       ahd_name(ahd), devinfo->target,
+				       period, offset,
+				       (ppr_options & MSG_EXT_PPR_DT_REQ)
+				       ? " (DT)" : "");
+			} else {
+				printf("%s: target %d using "
+				       "asynchronous transfers\n",
+				       ahd_name(ahd), devinfo->target);
+			}
+		}
+	}
+	/*
+	 * Always refresh the neg-table to handle the case of the
+	 * sequencer setting the ENATNO bit for a MK_MESSAGE request.
+	 * We will always renegotiate in that case if this is a
+	 * packetized request.  Also manage the busfree expected flag
+	 * from this common routine so that we catch changes due to
+	 * WDTR or SDTR messages.
+	 */
+	if ((type & AHD_TRANS_CUR) != 0) {
+		if (!paused)
+			ahd_pause(ahd);
+		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
+		if (!paused)
+			ahd_unpause(ahd);
+		if (ahd->msg_type != MSG_TYPE_NONE) {
+			if ((old_ppr & MSG_EXT_PPR_IU_REQ)
+			 != (ppr_options & MSG_EXT_PPR_IU_REQ)) {
+#ifdef AHD_DEBUG
+				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+					printf("Expecting IU Change busfree\n");
+#endif
+				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE
+					       |  MSG_FLAG_IU_REQ_CHANGED;
+			}
+			if ((old_ppr & MSG_EXT_PPR_IU_REQ) != 0) {
+#ifdef AHD_DEBUG
+				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+					printf("PPR with IU_REQ outstanding\n");
+#endif
+				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE;
+			}
+		}
+	}
+
+	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
+						tinfo, /*force*/FALSE);
+
+	if (update_needed && active)
+		ahd_update_pending_scbs(ahd);
+}
+
+/*
+ * Update the user/goal/curr tables of wide negotiation
+ * parameters as well as, in the case of a current or active update,
+ * any data structures on the host controller.  In the case of an
+ * active update, the specified target is currently talking to us on
+ * the bus, so the transfer parameter update must take effect
+ * immediately.
+ */
+void
+ahd_set_width(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+	      u_int width, u_int type, int paused)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	u_int	oldwidth;
+	int	active;
+	int	update_needed;
+
+	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
+	update_needed = 0;
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	if ((type & AHD_TRANS_USER) != 0)
+		tinfo->user.width = width;
+
+	if ((type & AHD_TRANS_GOAL) != 0)
+		tinfo->goal.width = width;
+
+	oldwidth = tinfo->curr.width;
+	if ((type & AHD_TRANS_CUR) != 0 && oldwidth != width) {
+
+		update_needed++;
+
+		tinfo->curr.width = width;
+		ahd_send_async(ahd, devinfo->channel, devinfo->target,
+			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
+		if (bootverbose) {
+			printf("%s: target %d using %dbit transfers\n",
+			       ahd_name(ahd), devinfo->target,
+			       8 * (0x01 << width));
+		}
+	}
+
+	if ((type & AHD_TRANS_CUR) != 0) {
+		if (!paused)
+			ahd_pause(ahd);
+		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
+		if (!paused)
+			ahd_unpause(ahd);
+	}
+
+	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
+						tinfo, /*force*/FALSE);
+	if (update_needed && active)
+		ahd_update_pending_scbs(ahd);
+
+}
+
+/*
+ * Update the current state of tagged queuing for a given target.
+ */
+void
+ahd_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+	     ahd_queue_alg alg)
+{
+ 	ahd_platform_set_tags(ahd, devinfo, alg);
+ 	ahd_send_async(ahd, devinfo->channel, devinfo->target,
+ 		       devinfo->lun, AC_TRANSFER_NEG, &alg);
+}
+
+static void
+ahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		     struct ahd_transinfo *tinfo)
+{
+	ahd_mode_state	saved_modes;
+	u_int		period;
+	u_int		ppr_opts;
+	u_int		con_opts;
+	u_int		offset;
+	u_int		precomp;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	ahd_outb(ahd, NEGOADDR, devinfo->target);
+	period = tinfo->period;
+	offset = tinfo->offset;
+	precomp = 0;
+	if (period == 0)
+		period = AHD_SYNCRATE_ASYNC;
+	if (period == AHD_SYNCRATE_160) {
+		period = AHD_SYNCRATE_REVA_160;
+		precomp = 0;
+		if ((ahd->flags & AHD_CPQ_BOARD) == 0)
+			precomp |= AHD_PRECOMP_FASTSLEW;
+		if ((tinfo->ppr_options & MSG_EXT_PPR_PCOMP_EN) != 0)
+			precomp |= AHD_PRECOMP_CUTBACK_29;
+	}
+	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP);
+	ahd_outb(ahd, ANNEXDAT, precomp);
+
+	ahd_outb(ahd, NEGPERIOD, period);
+	ppr_opts = tinfo->ppr_options
+		 & (MSG_EXT_PPR_QAS_REQ|MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_IU_REQ);
+	/*
+	 * When the SPI4 spec was finalized, PACE transfers
+	 * was not made a configurable option in the PPR message.
+	 * Instead it is assumed to be enabled for any
+	 * syncrate faster than 80MHz.  Nevertheless, Harpoon
+	 * allows this to be configurable.
+	 *
+	 * Harpoon also assumes at most 2 data bytes per negotiated
+	 * REQ/ACK offset.  Paced transfers take 4, so we must
+	 * adjust our offset.
+	 */
+	if (period <= AHD_SYNCRATE_PACED) {
+		ppr_opts |= PPROPT_PACE;
+		offset *= 2;
+	}
+	ahd_outb(ahd, NEGPPROPTS, ppr_opts);
+	ahd_outb(ahd, NEGOFFSET, offset);
+
+	con_opts = 0;
+	if (tinfo->width == MSG_EXT_WDTR_BUS_16_BIT)
+		con_opts |= WIDEXFER;
+
+	/*
+	 * During packetized transfers, the target will
+	 * give us the oportunity to send command packets
+	 * without us asserting attention.
+	 */
+	if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
+		con_opts |= ENAUTOATNO;
+	ahd_outb(ahd, NEGCONOPTS, con_opts);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * When the transfer settings for a connection change, setup for
+ * negotiation in pending SCBs to effect the change as quickly as
+ * possible.  We also cancel any negotiations that are scheduled
+ * for inflight SCBs that have not been started yet.
+ */
+static void
+ahd_update_pending_scbs(struct ahd_softc *ahd)
+{
+	struct		scb *pending_scb;
+	int		pending_scb_count;
+	int		i;
+	int		paused;
+	u_int		saved_scbptr;
+	ahd_mode_state	saved_modes;
+
+	/*
+	 * Traverse the pending SCB list and ensure that all of the
+	 * SCBs there have the proper settings.  We can only safely
+	 * clear the negotiation required flag (setting requires the
+	 * execution queue to be modified) and this is only possible
+	 * if we are not already attempting to select out for this
+	 * SCB.  For this reason, all callers only call this routine
+	 * if we are changing the negotiation settings for the currently
+	 * active transaction on the bus.
+	 */
+	pending_scb_count = 0;
+	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
+		struct ahd_devinfo devinfo;
+		struct hardware_scb *pending_hscb;
+		struct ahd_initiator_tinfo *tinfo;
+		struct ahd_tmode_tstate *tstate;
+
+		ahd_scb_devinfo(ahd, &devinfo, pending_scb);
+		tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
+					    devinfo.our_scsiid,
+					    devinfo.target, &tstate);
+		pending_hscb = pending_scb->hscb;
+		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
+		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
+			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
+			pending_hscb->control &= ~MK_MESSAGE;
+		}
+		ahd_sync_scb(ahd, pending_scb,
+			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+		pending_scb_count++;
+	}
+
+	if (pending_scb_count == 0)
+		return;
+
+	if (ahd_is_paused(ahd)) {
+		paused = 1;
+	} else {
+		paused = 0;
+		ahd_pause(ahd);
+	}
+
+	/*
+	 * Force the sequencer to reinitialize the selection for
+	 * the command at the head of the execution queue if it
+	 * has already been setup.  The negotiation changes may
+	 * effect whether we select-out with ATN.
+	 */
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+	saved_scbptr = ahd_get_scbptr(ahd);
+	/* Ensure that the hscbs down on the card match the new information */
+	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
+		struct	hardware_scb *pending_hscb;
+		u_int	control;
+		u_int	scb_tag;
+
+		ahd_set_scbptr(ahd, i);
+		scb_tag = i;
+		pending_scb = ahd_lookup_scb(ahd, scb_tag);
+		if (pending_scb == NULL)
+			continue;
+
+		pending_hscb = pending_scb->hscb;
+		control = ahd_inb_scbram(ahd, SCB_CONTROL);
+		control &= ~MK_MESSAGE;
+		control |= pending_hscb->control & MK_MESSAGE;
+		ahd_outb(ahd, SCB_CONTROL, control);
+	}
+	ahd_set_scbptr(ahd, saved_scbptr);
+	ahd_restore_modes(ahd, saved_modes);
+
+	if (paused == 0)
+		ahd_unpause(ahd);
+}
+
+/**************************** Pathing Information *****************************/
+static void
+ahd_fetch_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	ahd_mode_state	saved_modes;
+	u_int		saved_scsiid;
+	role_t		role;
+	int		our_id;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	if (ahd_inb(ahd, SSTAT0) & TARGET)
+		role = ROLE_TARGET;
+	else
+		role = ROLE_INITIATOR;
+
+	if (role == ROLE_TARGET
+	 && (ahd_inb(ahd, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
+		/* We were selected, so pull our id from TARGIDIN */
+		our_id = ahd_inb(ahd, TARGIDIN) & OID;
+	} else if (role == ROLE_TARGET)
+		our_id = ahd_inb(ahd, TOWNID);
+	else
+		our_id = ahd_inb(ahd, IOWNID);
+
+	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
+	ahd_compile_devinfo(devinfo,
+			    our_id,
+			    SCSIID_TARGET(ahd, saved_scsiid),
+			    ahd_inb(ahd, SAVED_LUN),
+			    SCSIID_CHANNEL(ahd, saved_scsiid),
+			    role);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static void
+ahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	printf("%s:%c:%d:%d:", ahd_name(ahd), 'A',
+	       devinfo->target, devinfo->lun);
+}
+
+struct ahd_phase_table_entry*
+ahd_lookup_phase_entry(int phase)
+{
+	struct ahd_phase_table_entry *entry;
+	struct ahd_phase_table_entry *last_entry;
+
+	/*
+	 * num_phases doesn't include the default entry which
+	 * will be returned if the phase doesn't match.
+	 */
+	last_entry = &ahd_phase_table[num_phases];
+	for (entry = ahd_phase_table; entry < last_entry; entry++) {
+		if (phase == entry->phase)
+			break;
+	}
+	return (entry);
+}
+
+void
+ahd_compile_devinfo(struct ahd_devinfo *devinfo, u_int our_id, u_int target,
+		    u_int lun, char channel, role_t role)
+{
+	devinfo->our_scsiid = our_id;
+	devinfo->target = target;
+	devinfo->lun = lun;
+	devinfo->target_offset = target;
+	devinfo->channel = channel;
+	devinfo->role = role;
+	if (channel == 'B')
+		devinfo->target_offset += 8;
+	devinfo->target_mask = (0x01 << devinfo->target_offset);
+}
+
+static void
+ahd_scb_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		struct scb *scb)
+{
+	role_t	role;
+	int	our_id;
+
+	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
+	role = ROLE_INITIATOR;
+	if ((scb->hscb->control & TARGET_SCB) != 0)
+		role = ROLE_TARGET;
+	ahd_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahd, scb),
+			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahd, scb), role);
+}
+
+
+/************************ Message Phase Processing ****************************/
+/*
+ * When an initiator transaction with the MK_MESSAGE flag either reconnects
+ * or enters the initial message out phase, we are interrupted.  Fill our
+ * outgoing message buffer with the appropriate message and beging handing
+ * the message phase(s) manually.
+ */
+static void
+ahd_setup_initiator_msgout(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+			   struct scb *scb)
+{
+	/*
+	 * To facilitate adding multiple messages together,
+	 * each routine should increment the index and len
+	 * variables instead of setting them explicitly.
+	 */
+	ahd->msgout_index = 0;
+	ahd->msgout_len = 0;
+
+	if (ahd_currently_packetized(ahd))
+		ahd->msg_flags |= MSG_FLAG_PACKETIZED;
+
+	if (ahd->send_msg_perror
+	 && ahd_inb(ahd, MSG_OUT) == HOST_MSG) {
+		ahd->msgout_buf[ahd->msgout_index++] = ahd->send_msg_perror;
+		ahd->msgout_len++;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		printf("Setting up for Parity Error delivery\n");
+		return;
+	} else if (scb == NULL) {
+		printf("%s: WARNING. No pending message for "
+		       "I_T msgin.  Issuing NO-OP\n", ahd_name(ahd));
+		ahd->msgout_buf[ahd->msgout_index++] = MSG_NOOP;
+		ahd->msgout_len++;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		return;
+	}
+
+	if ((scb->flags & SCB_DEVICE_RESET) == 0
+	 && (scb->flags & SCB_PACKETIZED) == 0
+	 && ahd_inb(ahd, MSG_OUT) == MSG_IDENTIFYFLAG) {
+		u_int identify_msg;
+
+		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
+		if ((scb->hscb->control & DISCENB) != 0)
+			identify_msg |= MSG_IDENTIFY_DISCFLAG;
+		ahd->msgout_buf[ahd->msgout_index++] = identify_msg;
+		ahd->msgout_len++;
+
+		if ((scb->hscb->control & TAG_ENB) != 0) {
+			ahd->msgout_buf[ahd->msgout_index++] =
+			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
+			ahd->msgout_buf[ahd->msgout_index++] = SCB_GET_TAG(scb);
+			ahd->msgout_len += 2;
+		}
+	}
+
+	if (scb->flags & SCB_DEVICE_RESET) {
+		ahd->msgout_buf[ahd->msgout_index++] = MSG_BUS_DEV_RESET;
+		ahd->msgout_len++;
+		ahd_print_path(ahd, scb);
+		printf("Bus Device Reset Message Sent\n");
+		/*
+		 * Clear our selection hardware in advance of
+		 * the busfree.  We may have an entry in the waiting
+		 * Q for this target, and we don't want to go about
+		 * selecting while we handle the busfree and blow it
+		 * away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else if ((scb->flags & SCB_ABORT) != 0) {
+
+		if ((scb->hscb->control & TAG_ENB) != 0) {
+			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT_TAG;
+		} else {
+			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT;
+		}
+		ahd->msgout_len++;
+		ahd_print_path(ahd, scb);
+		printf("Abort%s Message Sent\n",
+		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
+		/*
+		 * Clear our selection hardware in advance of
+		 * the busfree.  We may have an entry in the waiting
+		 * Q for this target, and we don't want to go about
+		 * selecting while we handle the busfree and blow it
+		 * away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
+		ahd_build_transfer_msg(ahd, devinfo);
+		/*
+		 * Clear our selection hardware in advance of potential
+		 * PPR IU status change busfree.  We may have an entry in
+		 * the waiting Q for this target, and we don't want to go
+		 * about selecting while we handle the busfree and blow
+		 * it away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else {
+		printf("ahd_intr: AWAITING_MSG for an SCB that "
+		       "does not have a waiting message\n");
+		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
+		       devinfo->target_mask);
+		panic("SCB = %d, SCB Control = %x, MSG_OUT = %x "
+		      "SCB flags = %x", SCB_GET_TAG(scb), scb->hscb->control,
+		      ahd_inb(ahd, MSG_OUT), scb->flags);
+	}
+
+	/*
+	 * Clear the MK_MESSAGE flag from the SCB so we aren't
+	 * asked to send this message again.
+	 */
+	ahd_outb(ahd, SCB_CONTROL,
+		 ahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);
+	scb->hscb->control &= ~MK_MESSAGE;
+	ahd->msgout_index = 0;
+	ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+}
+
+/*
+ * Build an appropriate transfer negotiation message for the
+ * currently active target.
+ */
+static void
+ahd_build_transfer_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	/*
+	 * We need to initiate transfer negotiations.
+	 * If our current and goal settings are identical,
+	 * we want to renegotiate due to a check condition.
+	 */
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	dowide;
+	int	dosync;
+	int	doppr;
+	int	use_ppr;
+	u_int	period;
+	u_int	ppr_options;
+	u_int	offset;
+
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	/*
+	 * Filter our period based on the current connection.
+	 * If we can't perform DT transfers on this segment (not in LVD
+	 * mode for instance), then our decision to issue a PPR message
+	 * may change.
+	 */
+	period = tinfo->goal.period;
+	ppr_options = tinfo->goal.ppr_options;
+	/* Target initiated PPR is not allowed in the SCSI spec */
+	if (devinfo->role == ROLE_TARGET)
+		ppr_options = 0;
+	ahd_devlimited_syncrate(ahd, tinfo, &period,
+				&ppr_options, devinfo->role);
+	dowide = tinfo->curr.width != tinfo->goal.width;
+	dosync = tinfo->curr.period != period;
+	doppr = tinfo->curr.ppr_options != ppr_options;
+
+	if (!dowide && !dosync && !doppr) {
+		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
+		dosync = tinfo->goal.period != 0;
+		doppr = tinfo->goal.ppr_options != 0;
+	}
+
+	if (!dowide && !dosync && !doppr) {
+		panic("ahd_intr: AWAITING_MSG for negotiation, "
+		      "but no negotiation needed\n");	
+	}
+
+	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
+	/* Target initiated PPR is not allowed in the SCSI spec */
+	if (devinfo->role == ROLE_TARGET)
+		use_ppr = 0;
+
+	/*
+	 * Both the PPR message and SDTR message require the
+	 * goal syncrate to be limited to what the target device
+	 * is capable of handling (based on whether an LVD->SE
+	 * expander is on the bus), so combine these two cases.
+	 * Regardless, guarantee that if we are using WDTR and SDTR
+	 * messages that WDTR comes first.
+	 */
+	if (use_ppr || (dosync && !dowide)) {
+
+		offset = tinfo->goal.offset;
+		ahd_validate_offset(ahd, tinfo, period, &offset,
+				    use_ppr ? tinfo->goal.width
+					    : tinfo->curr.width,
+				    devinfo->role);
+		if (use_ppr) {
+			ahd_construct_ppr(ahd, devinfo, period, offset,
+					  tinfo->goal.width, ppr_options);
+		} else {
+			ahd_construct_sdtr(ahd, devinfo, period, offset);
+		}
+	} else {
+		ahd_construct_wdtr(ahd, devinfo, tinfo->goal.width);
+	}
+}
+
+/*
+ * Build a synchronous negotiation message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_sdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		   u_int period, u_int offset)
+{
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR;
+	ahd->msgout_buf[ahd->msgout_index++] = period;
+	ahd->msgout_buf[ahd->msgout_index++] = offset;
+	ahd->msgout_len += 5;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       devinfo->lun, period, offset);
+	}
+}
+
+/*
+ * Build a wide negotiateion message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_wdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		   u_int bus_width)
+{
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR;
+	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
+	ahd->msgout_len += 4;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       devinfo->lun, bus_width);
+	}
+}
+
+/*
+ * Build a parallel protocol request message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_ppr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		  u_int period, u_int offset, u_int bus_width,
+		  u_int ppr_options)
+{
+	/*
+	 * Always request precompensation from
+	 * the other target if we are running
+	 * at paced syncrates.
+	 */
+	if (period <= AHD_SYNCRATE_PACED)
+		ppr_options |= MSG_EXT_PPR_PCOMP_EN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR;
+	ahd->msgout_buf[ahd->msgout_index++] = period;
+	ahd->msgout_buf[ahd->msgout_index++] = 0;
+	ahd->msgout_buf[ahd->msgout_index++] = offset;
+	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
+	ahd->msgout_buf[ahd->msgout_index++] = ppr_options;
+	ahd->msgout_len += 8;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
+		       "offset %x, ppr_options %x\n", ahd_name(ahd),
+		       devinfo->channel, devinfo->target, devinfo->lun,
+		       bus_width, period, offset, ppr_options);
+	}
+}
+
+/*
+ * Clear any active message state.
+ */
+static void
+ahd_clear_msg_state(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd->send_msg_perror = 0;
+	ahd->msg_flags = MSG_FLAG_NONE;
+	ahd->msgout_len = 0;
+	ahd->msgin_index = 0;
+	ahd->msg_type = MSG_TYPE_NONE;
+	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
+		/*
+		 * The target didn't care to respond to our
+		 * message request, so clear ATN.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRATNO);
+	}
+	ahd_outb(ahd, MSG_OUT, MSG_NOOP);
+	ahd_outb(ahd, SEQ_FLAGS2,
+		 ahd_inb(ahd, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * Manual message loop handler.
+ */
+static void
+ahd_handle_message_phase(struct ahd_softc *ahd)
+{ 
+	struct	ahd_devinfo devinfo;
+	u_int	bus_phase;
+	int	end_session;
+
+	ahd_fetch_devinfo(ahd, &devinfo);
+	end_session = FALSE;
+	bus_phase = ahd_inb(ahd, LASTPHASE);
+
+	if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0) {
+		printf("LQIRETRY for LQIPHASE_OUTPKT\n");
+		ahd_outb(ahd, LQCTL2, LQIRETRY);
+	}
+reswitch:
+	switch (ahd->msg_type) {
+	case MSG_TYPE_INITIATOR_MSGOUT:
+	{
+		int lastbyte;
+		int phasemis;
+		int msgdone;
+
+		if (ahd->msgout_len == 0 && ahd->send_msg_perror == 0)
+			panic("HOST_MSG_LOOP interrupt with no active message");
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("INITIATOR_MSG_OUT");
+		}
+#endif
+		phasemis = bus_phase != P_MESGOUT;
+		if (phasemis) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahd_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
+			if (bus_phase == P_MESGIN) {
+				/*
+				 * Change gears and see if
+				 * this messages is of interest to
+				 * us or should be passed back to
+				 * the sequencer.
+				 */
+				ahd_outb(ahd, CLRSINT1, CLRATNO);
+				ahd->send_msg_perror = 0;
+				ahd->msg_type = MSG_TYPE_INITIATOR_MSGIN;
+				ahd->msgin_index = 0;
+				goto reswitch;
+			}
+			end_session = TRUE;
+			break;
+		}
+
+		if (ahd->send_msg_perror) {
+			ahd_outb(ahd, CLRSINT1, CLRATNO);
+			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf(" byte 0x%x\n", ahd->send_msg_perror);
+#endif
+			/*
+			 * If we are notifying the target of a CRC error
+			 * during packetized operations, the target is
+			 * within its rights to acknowledge our message
+			 * with a busfree.
+			 */
+			if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0
+			 && ahd->send_msg_perror == MSG_INITIATOR_DET_ERR)
+				ahd->msg_flags |= MSG_FLAG_EXPECT_IDE_BUSFREE;
+
+			ahd_outb(ahd, RETURN_2, ahd->send_msg_perror);
+			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
+			break;
+		}
+
+		msgdone	= ahd->msgout_index == ahd->msgout_len;
+		if (msgdone) {
+			/*
+			 * The target has requested a retry.
+			 * Re-assert ATN, reset our message index to
+			 * 0, and try again.
+			 */
+			ahd->msgout_index = 0;
+			ahd_assert_atn(ahd);
+		}
+
+		lastbyte = ahd->msgout_index == (ahd->msgout_len - 1);
+		if (lastbyte) {
+			/* Last byte is signified by dropping ATN */
+			ahd_outb(ahd, CLRSINT1, CLRATNO);
+		}
+
+		/*
+		 * Clear our interrupt status and present
+		 * the next byte on the bus.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahd->msgout_buf[ahd->msgout_index]);
+#endif
+		ahd_outb(ahd, RETURN_2, ahd->msgout_buf[ahd->msgout_index++]);
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
+		break;
+	}
+	case MSG_TYPE_INITIATOR_MSGIN:
+	{
+		int phasemis;
+		int message_done;
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("INITIATOR_MSG_IN");
+		}
+#endif
+		phasemis = bus_phase != P_MESGIN;
+		if (phasemis) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahd_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
+			ahd->msgin_index = 0;
+			if (bus_phase == P_MESGOUT
+			 && (ahd->send_msg_perror != 0
+			  || (ahd->msgout_len != 0
+			   && ahd->msgout_index == 0))) {
+				ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+				goto reswitch;
+			}
+			end_session = TRUE;
+			break;
+		}
+
+		/* Pull the byte in without acking it */
+		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIBUS);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahd->msgin_buf[ahd->msgin_index]);
+#endif
+
+		message_done = ahd_parse_msg(ahd, &devinfo);
+
+		if (message_done) {
+			/*
+			 * Clear our incoming message buffer in case there
+			 * is another message following this one.
+			 */
+			ahd->msgin_index = 0;
+
+			/*
+			 * If this message illicited a response,
+			 * assert ATN so the target takes us to the
+			 * message out phase.
+			 */
+			if (ahd->msgout_len != 0)
+				ahd_assert_atn(ahd);
+		} else 
+			ahd->msgin_index++;
+
+		if (message_done == MSGLOOP_TERMINATED) {
+			end_session = TRUE;
+		} else {
+			/* Ack the byte */
+			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_READ);
+		}
+		break;
+	}
+	case MSG_TYPE_TARGET_MSGIN:
+	{
+		int msgdone;
+		int msgout_request;
+
+		/*
+		 * By default, the message loop will continue.
+		 */
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
+
+		if (ahd->msgout_len == 0)
+			panic("Target MSGIN with no active message");
+
+		/*
+		 * If we interrupted a mesgout session, the initiator
+		 * will not know this until our first REQ.  So, we
+		 * only honor mesgout requests after we've sent our
+		 * first byte.
+		 */
+		if ((ahd_inb(ahd, SCSISIGI) & ATNI) != 0
+		 && ahd->msgout_index > 0)
+			msgout_request = TRUE;
+		else
+			msgout_request = FALSE;
+
+		if (msgout_request) {
+
+			/*
+			 * Change gears and see if
+			 * this messages is of interest to
+			 * us or should be passed back to
+			 * the sequencer.
+			 */
+			ahd->msg_type = MSG_TYPE_TARGET_MSGOUT;
+			ahd_outb(ahd, SCSISIGO, P_MESGOUT | BSYO);
+			ahd->msgin_index = 0;
+			/* Dummy read to REQ for first byte */
+			ahd_inb(ahd, SCSIDAT);
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+			break;
+		}
+
+		msgdone = ahd->msgout_index == ahd->msgout_len;
+		if (msgdone) {
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
+			end_session = TRUE;
+			break;
+		}
+
+		/*
+		 * Present the next byte on the bus.
+		 */
+		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+		ahd_outb(ahd, SCSIDAT, ahd->msgout_buf[ahd->msgout_index++]);
+		break;
+	}
+	case MSG_TYPE_TARGET_MSGOUT:
+	{
+		int lastbyte;
+		int msgdone;
+
+		/*
+		 * By default, the message loop will continue.
+		 */
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
+
+		/*
+		 * The initiator signals that this is
+		 * the last byte by dropping ATN.
+		 */
+		lastbyte = (ahd_inb(ahd, SCSISIGI) & ATNI) == 0;
+
+		/*
+		 * Read the latched byte, but turn off SPIOEN first
+		 * so that we don't inadvertently cause a REQ for the
+		 * next byte.
+		 */
+		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
+		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIDAT);
+		msgdone = ahd_parse_msg(ahd, &devinfo);
+		if (msgdone == MSGLOOP_TERMINATED) {
+			/*
+			 * The message is *really* done in that it caused
+			 * us to go to bus free.  The sequencer has already
+			 * been reset at this point, so pull the ejection
+			 * handle.
+			 */
+			return;
+		}
+		
+		ahd->msgin_index++;
+
+		/*
+		 * XXX Read spec about initiator dropping ATN too soon
+		 *     and use msgdone to detect it.
+		 */
+		if (msgdone == MSGLOOP_MSGCOMPLETE) {
+			ahd->msgin_index = 0;
+
+			/*
+			 * If this message illicited a response, transition
+			 * to the Message in phase and send it.
+			 */
+			if (ahd->msgout_len != 0) {
+				ahd_outb(ahd, SCSISIGO, P_MESGIN | BSYO);
+				ahd_outb(ahd, SXFRCTL0,
+					 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+				ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
+				ahd->msgin_index = 0;
+				break;
+			}
+		}
+
+		if (lastbyte)
+			end_session = TRUE;
+		else {
+			/* Ask for the next byte. */
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+		}
+
+		break;
+	}
+	default:
+		panic("Unknown REQINIT message type");
+	}
+
+	if (end_session) {
+		if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0) {
+			printf("%s: Returning to Idle Loop\n",
+			       ahd_name(ahd));
+			ahd_outb(ahd, LASTPHASE, P_BUSFREE);
+			ahd_clear_msg_state(ahd);
+			ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
+		} else {
+			ahd_clear_msg_state(ahd);
+			ahd_outb(ahd, RETURN_1, EXIT_MSG_LOOP);
+		}
+	}
+}
+
+/*
+ * See if we sent a particular extended message to the target.
+ * If "full" is true, return true only if the target saw the full
+ * message.  If "full" is false, return true if the target saw at
+ * least the first byte of the message.
+ */
+static int
+ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type, u_int msgval, int full)
+{
+	int found;
+	u_int index;
+
+	found = FALSE;
+	index = 0;
+
+	while (index < ahd->msgout_len) {
+		if (ahd->msgout_buf[index] == MSG_EXTENDED) {
+			u_int end_index;
+
+			end_index = index + 1 + ahd->msgout_buf[index + 1];
+			if (ahd->msgout_buf[index+2] == msgval
+			 && type == AHDMSG_EXT) {
+
+				if (full) {
+					if (ahd->msgout_index > end_index)
+						found = TRUE;
+				} else if (ahd->msgout_index > index)
+					found = TRUE;
+			}
+			index = end_index;
+		} else if (ahd->msgout_buf[index] >= MSG_SIMPLE_TASK
+			&& ahd->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
+
+			/* Skip tag type and tag id or residue param*/
+			index += 2;
+		} else {
+			/* Single byte message */
+			if (type == AHDMSG_1B
+			 && ahd->msgout_buf[index] == msgval
+			 && ahd->msgout_index > index)
+				found = TRUE;
+			index++;
+		}
+
+		if (found)
+			break;
+	}
+	return (found);
+}
+
+/*
+ * Wait for a complete incoming message, parse it, and respond accordingly.
+ */
+static int
+ahd_parse_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	reject;
+	int	done;
+	int	response;
+
+	done = MSGLOOP_IN_PROG;
+	response = FALSE;
+	reject = FALSE;
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	/*
+	 * Parse as much of the message as is availible,
+	 * rejecting it if we don't support it.  When
+	 * the entire message is availible and has been
+	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
+	 * that we have parsed an entire message.
+	 *
+	 * In the case of extended messages, we accept the length
+	 * byte outright and perform more checking once we know the
+	 * extended message type.
+	 */
+	switch (ahd->msgin_buf[0]) {
+	case MSG_DISCONNECT:
+	case MSG_SAVEDATAPOINTER:
+	case MSG_CMDCOMPLETE:
+	case MSG_RESTOREPOINTERS:
+	case MSG_IGN_WIDE_RESIDUE:
+		/*
+		 * End our message loop as these are messages
+		 * the sequencer handles on its own.
+		 */
+		done = MSGLOOP_TERMINATED;
+		break;
+	case MSG_MESSAGE_REJECT:
+		response = ahd_handle_msg_reject(ahd, devinfo);
+		/* FALLTHROUGH */
+	case MSG_NOOP:
+		done = MSGLOOP_MSGCOMPLETE;
+		break;
+	case MSG_EXTENDED:
+	{
+		/* Wait for enough of the message to begin validation */
+		if (ahd->msgin_index < 2)
+			break;
+		switch (ahd->msgin_buf[2]) {
+		case MSG_EXT_SDTR:
+		{
+			u_int	 period;
+			u_int	 ppr_options;
+			u_int	 offset;
+			u_int	 saved_offset;
+			
+			if (ahd->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have both args before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_SDTR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_SDTR_LEN + 1))
+				break;
+
+			period = ahd->msgin_buf[3];
+			ppr_options = 0;
+			saved_offset = offset = ahd->msgin_buf[4];
+			ahd_devlimited_syncrate(ahd, tinfo, &period,
+						&ppr_options, devinfo->role);
+			ahd_validate_offset(ahd, tinfo, period, &offset,
+					    tinfo->curr.width, devinfo->role);
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received "
+				       "SDTR period %x, offset %x\n\t"
+				       "Filtered to period %x, offset %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       ahd->msgin_buf[3], saved_offset,
+				       period, offset);
+			}
+			ahd_set_syncrate(ahd, devinfo, period,
+					 offset, ppr_options,
+					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+					 /*paused*/TRUE);
+
+			/*
+			 * See if we initiated Sync Negotiation
+			 * and didn't have to fall down to async
+			 * transfers.
+			 */
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, TRUE)) {
+				/* We started it */
+				if (saved_offset != offset) {
+					/* Went too low - force async */
+					reject = TRUE;
+				}
+			} else {
+				/*
+				 * Send our own SDTR in reply
+				 */
+				if (bootverbose
+				 && devinfo->role == ROLE_INITIATOR) {
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated SDTR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				}
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_sdtr(ahd, devinfo,
+						   period, offset);
+				ahd->msgout_index = 0;
+				response = TRUE;
+			}
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		case MSG_EXT_WDTR:
+		{
+			u_int bus_width;
+			u_int saved_width;
+			u_int sending_reply;
+
+			sending_reply = FALSE;
+			if (ahd->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have our arg before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_WDTR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_WDTR_LEN + 1))
+				break;
+
+			bus_width = ahd->msgin_buf[3];
+			saved_width = bus_width;
+			ahd_validate_width(ahd, tinfo, &bus_width,
+					   devinfo->role);
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received WDTR "
+				       "%x filtered to %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       saved_width, bus_width);
+			}
+
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, TRUE)) {
+				/*
+				 * Don't send a WDTR back to the
+				 * target, since we asked first.
+				 * If the width went higher than our
+				 * request, reject it.
+				 */
+				if (saved_width > bus_width) {
+					reject = TRUE;
+					printf("(%s:%c:%d:%d): requested %dBit "
+					       "transfers.  Rejecting...\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun,
+					       8 * (0x01 << bus_width));
+					bus_width = 0;
+				}
+			} else {
+				/*
+				 * Send our own WDTR in reply
+				 */
+				if (bootverbose
+				 && devinfo->role == ROLE_INITIATOR) {
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated WDTR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				}
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_wdtr(ahd, devinfo, bus_width);
+				ahd->msgout_index = 0;
+				response = TRUE;
+				sending_reply = TRUE;
+			}
+			ahd_set_width(ahd, devinfo, bus_width,
+				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			/* After a wide message, we are async */
+			ahd_set_syncrate(ahd, devinfo, /*period*/0,
+					 /*offset*/0, /*ppr_options*/0,
+					 AHD_TRANS_ACTIVE, /*paused*/TRUE);
+			if (sending_reply == FALSE && reject == FALSE) {
+
+				if (tinfo->goal.period) {
+					ahd->msgout_index = 0;
+					ahd->msgout_len = 0;
+					ahd_build_transfer_msg(ahd, devinfo);
+					ahd->msgout_index = 0;
+					response = TRUE;
+				}
+			}
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		case MSG_EXT_PPR:
+		{
+			u_int	period;
+			u_int	offset;
+			u_int	bus_width;
+			u_int	ppr_options;
+			u_int	saved_width;
+			u_int	saved_offset;
+			u_int	saved_ppr_options;
+
+			if (ahd->msgin_buf[1] != MSG_EXT_PPR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have all args before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_PPR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_PPR_LEN + 1))
+				break;
+
+			period = ahd->msgin_buf[3];
+			offset = ahd->msgin_buf[5];
+			bus_width = ahd->msgin_buf[6];
+			saved_width = bus_width;
+			ppr_options = ahd->msgin_buf[7];
+			/*
+			 * According to the spec, a DT only
+			 * period factor with no DT option
+			 * set implies async.
+			 */
+			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
+			 && period <= 9)
+				offset = 0;
+			saved_ppr_options = ppr_options;
+			saved_offset = offset;
+
+			/*
+			 * Transfer options are only available if we
+			 * are negotiating wide.
+			 */
+			if (bus_width == 0)
+				ppr_options &= MSG_EXT_PPR_QAS_REQ;
+
+			ahd_validate_width(ahd, tinfo, &bus_width,
+					   devinfo->role);
+			ahd_devlimited_syncrate(ahd, tinfo, &period,
+						&ppr_options, devinfo->role);
+			ahd_validate_offset(ahd, tinfo, period, &offset,
+					    bus_width, devinfo->role);
+
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, TRUE)) {
+				/*
+				 * If we are unable to do any of the
+				 * requested options (we went too low),
+				 * then we'll have to reject the message.
+				 */
+				if (saved_width > bus_width
+				 || saved_offset != offset
+				 || saved_ppr_options != ppr_options) {
+					reject = TRUE;
+					period = 0;
+					offset = 0;
+					bus_width = 0;
+					ppr_options = 0;
+				}
+			} else {
+				if (devinfo->role != ROLE_TARGET)
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated PPR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				else
+					printf("(%s:%c:%d:%d): Initiator "
+					       "Initiated PPR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_ppr(ahd, devinfo, period, offset,
+						  bus_width, ppr_options);
+				ahd->msgout_index = 0;
+				response = TRUE;
+			}
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received PPR width %x, "
+				       "period %x, offset %x,options %x\n"
+				       "\tFiltered to width %x, period %x, "
+				       "offset %x, options %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       saved_width, ahd->msgin_buf[3],
+				       saved_offset, saved_ppr_options,
+				       bus_width, period, offset, ppr_options);
+			}
+			ahd_set_width(ahd, devinfo, bus_width,
+				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			ahd_set_syncrate(ahd, devinfo, period,
+					 offset, ppr_options,
+					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+					 /*paused*/TRUE);
+
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		default:
+			/* Unknown extended message.  Reject it. */
+			reject = TRUE;
+			break;
+		}
+		break;
+	}
+#ifdef AHD_TARGET_MODE
+	case MSG_BUS_DEV_RESET:
+		ahd_handle_devreset(ahd, devinfo,
+				    CAM_BDR_SENT,
+				    "Bus Device Reset Received",
+				    /*verbose_level*/0);
+		ahd_restart(ahd);
+		done = MSGLOOP_TERMINATED;
+		break;
+	case MSG_ABORT_TAG:
+	case MSG_ABORT:
+	case MSG_CLEAR_QUEUE:
+	{
+		int tag;
+
+		/* Target mode messages */
+		if (devinfo->role != ROLE_TARGET) {
+			reject = TRUE;
+			break;
+		}
+		tag = SCB_LIST_NULL;
+		if (ahd->msgin_buf[0] == MSG_ABORT_TAG)
+			tag = ahd_inb(ahd, INITIATOR_TAG);
+		ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
+			       devinfo->lun, tag, ROLE_TARGET,
+			       CAM_REQ_ABORTED);
+
+		tstate = ahd->enabled_targets[devinfo->our_scsiid];
+		if (tstate != NULL) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[devinfo->lun];
+			if (lstate != NULL) {
+				ahd_queue_lstate_event(ahd, lstate,
+						       devinfo->our_scsiid,
+						       ahd->msgin_buf[0],
+						       /*arg*/tag);
+				ahd_send_lstate_events(ahd, lstate);
+			}
+		}
+		ahd_restart(ahd);
+		done = MSGLOOP_TERMINATED;
+		break;
+	}
+#endif
+	case MSG_QAS_REQUEST:
+		printf("%s: QAS request.  SCSISIGI == 0x%x\n",
+		       ahd_name(ahd), ahd_inb(ahd, SCSISIGI));
+		/* FALLTHROUGH */
+	case MSG_TERM_IO_PROC:
+	default:
+		reject = TRUE;
+		break;
+	}
+
+	if (reject) {
+		/*
+		 * Setup to reject the message.
+		 */
+		ahd->msgout_index = 0;
+		ahd->msgout_len = 1;
+		ahd->msgout_buf[0] = MSG_MESSAGE_REJECT;
+		done = MSGLOOP_MSGCOMPLETE;
+		response = TRUE;
+	}
+
+	if (done != MSGLOOP_IN_PROG && !response)
+		/* Clear the outgoing message buffer */
+		ahd->msgout_len = 0;
+
+	return (done);
+}
+
+/*
+ * Process a message reject message.
+ */
+static int
+ahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	/*
+	 * What we care about here is if we had an
+	 * outstanding SDTR or WDTR message for this
+	 * target.  If we did, this is a signal that
+	 * the target is refusing negotiation.
+	 */
+	struct scb *scb;
+	struct ahd_initiator_tinfo *tinfo;
+	struct ahd_tmode_tstate *tstate;
+	u_int scb_index;
+	u_int last_msg;
+	int   response = 0;
+
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	/* Might be necessary */
+	last_msg = ahd_inb(ahd, LAST_MSG);
+
+	if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
+		/*
+		 * Target does not support the PPR message.
+		 * Attempt to negotiate SPI-2 style.
+		 */
+		if (bootverbose) {
+			printf("(%s:%c:%d:%d): PPR Rejected. "
+			       "Trying WDTR/SDTR\n",
+			       ahd_name(ahd), devinfo->channel,
+			       devinfo->target, devinfo->lun);
+		}
+		tinfo->goal.ppr_options = 0;
+		tinfo->curr.transport_version = 2;
+		tinfo->goal.transport_version = 2;
+		ahd->msgout_index = 0;
+		ahd->msgout_len = 0;
+		ahd_build_transfer_msg(ahd, devinfo);
+		ahd->msgout_index = 0;
+		response = 1;
+	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
+
+		/* note 8bit xfers */
+		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
+		       "8bit transfers\n", ahd_name(ahd),
+		       devinfo->channel, devinfo->target, devinfo->lun);
+		ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+			      /*paused*/TRUE);
+		/*
+		 * No need to clear the sync rate.  If the target
+		 * did not accept the command, our syncrate is
+		 * unaffected.  If the target started the negotiation,
+		 * but rejected our response, we already cleared the
+		 * sync rate before sending our WDTR.
+		 */
+		if (tinfo->goal.period) {
+
+			/* Start the sync negotiation */
+			ahd->msgout_index = 0;
+			ahd->msgout_len = 0;
+			ahd_build_transfer_msg(ahd, devinfo);
+			ahd->msgout_index = 0;
+			response = 1;
+		}
+	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
+		/* note asynch xfers and clear flag */
+		ahd_set_syncrate(ahd, devinfo, /*period*/0,
+				 /*offset*/0, /*ppr_options*/0,
+				 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
+		       "Using asynchronous transfers\n",
+		       ahd_name(ahd), devinfo->channel,
+		       devinfo->target, devinfo->lun);
+	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
+		int tag_type;
+		int mask;
+
+		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);
+
+		if (tag_type == MSG_SIMPLE_TASK) {
+			printf("(%s:%c:%d:%d): refuses tagged commands.  "
+			       "Performing non-tagged I/O\n", ahd_name(ahd),
+			       devinfo->channel, devinfo->target, devinfo->lun);
+			ahd_set_tags(ahd, devinfo, AHD_QUEUE_NONE);
+			mask = ~0x23;
+		} else {
+			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
+			       "Performing simple queue tagged I/O only\n",
+			       ahd_name(ahd), devinfo->channel, devinfo->target,
+			       devinfo->lun, tag_type == MSG_ORDERED_TASK
+			       ? "ordered" : "head of queue");
+			ahd_set_tags(ahd, devinfo, AHD_QUEUE_BASIC);
+			mask = ~0x03;
+		}
+
+		/*
+		 * Resend the identify for this CCB as the target
+		 * may believe that the selection is invalid otherwise.
+		 */
+		ahd_outb(ahd, SCB_CONTROL,
+			 ahd_inb_scbram(ahd, SCB_CONTROL) & mask);
+	 	scb->hscb->control &= mask;
+		ahd_set_transaction_tag(scb, /*enabled*/FALSE,
+					/*type*/MSG_SIMPLE_TASK);
+		ahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);
+		ahd_assert_atn(ahd);
+		ahd_busy_tcl(ahd, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
+			     SCB_GET_TAG(scb));
+
+		/*
+		 * Requeue all tagged commands for this target
+		 * currently in our posession so they can be
+		 * converted to untagged commands.
+		 */
+		ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
+				   SCB_GET_CHANNEL(ahd, scb),
+				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
+				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
+				   SEARCH_COMPLETE);
+	} else {
+		/*
+		 * Otherwise, we ignore it.
+		 */
+		printf("%s:%c:%d: Message reject for %x -- ignored\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       last_msg);
+	}
+	return (response);
+}
+
+/*
+ * Process an ingnore wide residue message.
+ */
+static void
+ahd_handle_ign_wide_residue(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	u_int scb_index;
+	struct scb *scb;
+
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+	/*
+	 * XXX Actually check data direction in the sequencer?
+	 * Perhaps add datadir to some spare bits in the hscb?
+	 */
+	if ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0
+	 || ahd_get_transfer_dir(scb) != CAM_DIR_IN) {
+		/*
+		 * Ignore the message if we haven't
+		 * seen an appropriate data phase yet.
+		 */
+	} else {
+		/*
+		 * If the residual occurred on the last
+		 * transfer and the transfer request was
+		 * expected to end on an odd count, do
+		 * nothing.  Otherwise, subtract a byte
+		 * and update the residual count accordingly.
+		 */
+		uint32_t sgptr;
+
+		sgptr = ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
+		if ((sgptr & SG_LIST_NULL) != 0
+		 && ahd_inb(ahd, DATA_COUNT_ODD) == 1) {
+			/*
+			 * If the residual occurred on the last
+			 * transfer and the transfer request was
+			 * expected to end on an odd count, do
+			 * nothing.
+			 */
+		} else {
+			uint32_t data_cnt;
+			uint64_t data_addr;
+			uint32_t sglen;
+
+			/* Pull in the rest of the sgptr */
+			sgptr |=
+			    (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
+			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
+			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8);
+			sgptr &= SG_PTR_MASK;
+			data_cnt =
+			    (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24)
+			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+2) << 16)
+			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+1) << 8)
+			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT));
+
+			data_addr = (((uint64_t)ahd_inb(ahd, SHADDR + 7)) << 56)
+				  | (((uint64_t)ahd_inb(ahd, SHADDR + 6)) << 48)
+				  | (((uint64_t)ahd_inb(ahd, SHADDR + 5)) << 40)
+				  | (((uint64_t)ahd_inb(ahd, SHADDR + 4)) << 32)
+				  | (ahd_inb(ahd, SHADDR + 3) << 24)
+				  | (ahd_inb(ahd, SHADDR + 2) << 16)
+				  | (ahd_inb(ahd, SHADDR + 1) << 8)
+				  | (ahd_inb(ahd, SHADDR));
+
+			data_cnt += 1;
+			data_addr -= 1;
+
+			if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+				struct ahd_dma64_seg *sg;
+
+				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+				/*
+				 * The residual sg ptr points to the next S/G
+				 * to load so we must go back one.
+				 */
+				sg--;
+				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				if (sg != scb->sg_list
+				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
+
+					sg--;
+					sglen = ahd_le32toh(sg->len);
+					/*
+					 * Preserve High Address and SG_LIST
+					 * bits while setting the count to 1.
+					 */
+					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
+					data_addr = ahd_le64toh(sg->addr)
+						  + (sglen & AHD_SG_LEN_MASK)
+						  - 1;
+
+					/*
+					 * Increment sg so it points to the
+					 * "next" sg.
+					 */
+					sg++;
+					sgptr = ahd_sg_virt_to_bus(ahd, scb,
+								   sg);
+				}
+			} else {
+				struct ahd_dma_seg *sg;
+
+				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+				/*
+				 * The residual sg ptr points to the next S/G
+				 * to load so we must go back one.
+				 */
+				sg--;
+				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				if (sg != scb->sg_list
+				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
+
+					sg--;
+					sglen = ahd_le32toh(sg->len);
+					/*
+					 * Preserve High Address and SG_LIST
+					 * bits while setting the count to 1.
+					 */
+					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
+					data_addr = ahd_le32toh(sg->addr)
+						  + (sglen & AHD_SG_LEN_MASK)
+						  - 1;
+
+					/*
+					 * Increment sg so it points to the
+					 * "next" sg.
+					 */
+					sg++;
+					sgptr = ahd_sg_virt_to_bus(ahd, scb,
+								  sg);
+				}
+			}
+			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 3, sgptr >> 24);
+			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 2, sgptr >> 16);
+			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 1, sgptr >> 8);
+			ahd_outb(ahd, SCB_RESIDUAL_SGPTR, sgptr);
+
+			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
+			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
+			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
+			ahd_outb(ahd, SCB_RESIDUAL_DATACNT, data_cnt);
+
+			/*
+			 * The FIFO's pointers will be updated if/when the
+			 * sequencer re-enters a data phase.
+			 */
+		}
+	}
+}
+
+
+/*
+ * Reinitialize the data pointers for the active transfer
+ * based on its current residual.
+ */
+static void
+ahd_reinitialize_dataptrs(struct ahd_softc *ahd)
+{
+	struct		 scb *scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 scb_index;
+	u_int		 wait;
+	uint32_t	 sgptr;
+	uint32_t	 resid;
+	uint64_t	 dataptr;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK,
+			 AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK);
+			 
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+
+	/*
+	 * Release and reacquire the FIFO so we
+	 * have a clean slate.
+	 */
+	ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
+	wait = 1000;
+	do {
+		ahd_delay(100);
+	} while (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE));
+	if (wait == 0) {
+		ahd_print_path(ahd, scb);
+		printf("ahd_reinitialize_dataptrs: Forcing FIFO free.\n");
+		ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
+	}
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, DFFSTAT,
+		 ahd_inb(ahd, DFFSTAT) | (saved_modes == 0x11 ? CURRFIFO : 0));
+
+	/*
+	 * Determine initial values for data_addr and data_cnt
+	 * for resuming the data phase.
+	 */
+	sgptr = (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8)
+	      |	ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
+	sgptr &= SG_PTR_MASK;
+
+	resid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 1) << 8)
+	      | ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT);
+
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		dataptr = ahd_le64toh(sg->addr)
+			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+			- resid;
+		ahd_outb(ahd, HADDR + 7, dataptr >> 56);
+		ahd_outb(ahd, HADDR + 6, dataptr >> 48);
+		ahd_outb(ahd, HADDR + 5, dataptr >> 40);
+		ahd_outb(ahd, HADDR + 4, dataptr >> 32);
+	} else {
+		struct	 ahd_dma_seg *sg;
+
+		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		dataptr = ahd_le32toh(sg->addr)
+			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+			- resid;
+		ahd_outb(ahd, HADDR + 4,
+			 (ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);
+	}
+	ahd_outb(ahd, HADDR + 3, dataptr >> 24);
+	ahd_outb(ahd, HADDR + 2, dataptr >> 16);
+	ahd_outb(ahd, HADDR + 1, dataptr >> 8);
+	ahd_outb(ahd, HADDR, dataptr);
+	ahd_outb(ahd, HCNT + 2, resid >> 16);
+	ahd_outb(ahd, HCNT + 1, resid >> 8);
+	ahd_outb(ahd, HCNT, resid);
+}
+
+/*
+ * Handle the effects of issuing a bus device reset message.
+ */
+static void
+ahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		    cam_status status, char *message, int verbose_level)
+{
+#ifdef AHD_TARGET_MODE
+	struct ahd_tmode_tstate* tstate;
+	u_int lun;
+#endif
+	int found;
+
+	found = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
+			       CAM_LUN_WILDCARD, SCB_LIST_NULL, devinfo->role,
+			       status);
+
+#ifdef AHD_TARGET_MODE
+	/*
+	 * Send an immediate notify ccb to all target mord peripheral
+	 * drivers affected by this action.
+	 */
+	tstate = ahd->enabled_targets[devinfo->our_scsiid];
+	if (tstate != NULL) {
+		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[lun];
+			if (lstate == NULL)
+				continue;
+
+			ahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,
+					       MSG_BUS_DEV_RESET, /*arg*/0);
+			ahd_send_lstate_events(ahd, lstate);
+		}
+	}
+#endif
+
+	/*
+	 * Go back to async/narrow transfers and renegotiate.
+	 */
+	ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+		      AHD_TRANS_CUR, /*paused*/TRUE);
+	ahd_set_syncrate(ahd, devinfo, /*period*/0, /*offset*/0,
+			 /*ppr_options*/0, AHD_TRANS_CUR, /*paused*/TRUE);
+	
+	ahd_send_async(ahd, devinfo->channel, devinfo->target,
+		       CAM_LUN_WILDCARD, AC_SENT_BDR, NULL);
+
+	if (message != NULL
+	 && (verbose_level <= bootverbose))
+		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahd_name(ahd),
+		       message, devinfo->channel, devinfo->target, found);
+}
+
+#ifdef AHD_TARGET_MODE
+static void
+ahd_setup_target_msgin(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		       struct scb *scb)
+{
+
+	/*              
+	 * To facilitate adding multiple messages together,
+	 * each routine should increment the index and len
+	 * variables instead of setting them explicitly.
+	 */             
+	ahd->msgout_index = 0;
+	ahd->msgout_len = 0;
+
+	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
+		ahd_build_transfer_msg(ahd, devinfo);
+	else
+		panic("ahd_intr: AWAITING target message with no message");
+
+	ahd->msgout_index = 0;
+	ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
+}
+#endif
+/**************************** Initialization **********************************/
+static bus_size_t
+ahd_sglist_size(struct ahd_softc *ahd)
+{
+	bus_size_t list_size;
+
+	list_size = sizeof(struct ahd_dma_seg) * AHD_NSEG;
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		list_size = sizeof(struct ahd_dma64_seg) * AHD_NSEG;
+	return (list_size);
+}
+
+/*
+ * Calculate the optimum S/G List allocation size.  S/G elements used
+ * for a given transaction must be physically contiguous.  Assume the
+ * OS will allocate full pages to us, so it doesn't make sense to request
+ * less than a page.
+ */
+static bus_size_t
+ahd_sglist_allocsize(struct ahd_softc *ahd)
+{
+	bus_size_t sg_list_increment;
+	bus_size_t sg_list_size;
+	bus_size_t max_list_size;
+	bus_size_t best_list_size;
+
+	/* Start out with the minimum required for AHD_NSEG. */
+	sg_list_increment = ahd_sglist_size(ahd);
+	sg_list_size = sg_list_increment;
+
+	/* Get us as close as possible to a page in size. */
+	while ((sg_list_size + sg_list_increment) <= PAGE_SIZE)
+		sg_list_size += sg_list_increment;
+
+	/*
+	 * Try to reduce the amount of wastage by allocating
+	 * multiple pages.
+	 */
+	best_list_size = sg_list_size;
+	max_list_size = roundup(sg_list_increment, PAGE_SIZE);
+	if (max_list_size < 4 * PAGE_SIZE)
+		max_list_size = 4 * PAGE_SIZE;
+	if (max_list_size > (AHD_SCB_MAX_ALLOC * sg_list_increment))
+		max_list_size = (AHD_SCB_MAX_ALLOC * sg_list_increment);
+	while ((sg_list_size + sg_list_increment) <= max_list_size
+	   &&  (sg_list_size % PAGE_SIZE) != 0) {
+		bus_size_t new_mod;
+		bus_size_t best_mod;
+
+		sg_list_size += sg_list_increment;
+		new_mod = sg_list_size % PAGE_SIZE;
+		best_mod = best_list_size % PAGE_SIZE;
+		if (new_mod > best_mod || new_mod == 0) {
+			best_list_size = sg_list_size;
+		}
+	}
+	return (best_list_size);
+}
+
+/*
+ * Allocate a controller structure for a new device
+ * and perform initial initializion.
+ */
+struct ahd_softc *
+ahd_alloc(void *platform_arg, char *name)
+{
+	struct  ahd_softc *ahd;
+
+#ifndef	__FreeBSD__
+	ahd = malloc(sizeof(*ahd), M_DEVBUF, M_NOWAIT);
+	if (!ahd) {
+		printf("aic7xxx: cannot malloc softc!\n");
+		free(name, M_DEVBUF);
+		return NULL;
+	}
+#else
+	ahd = device_get_softc((device_t)platform_arg);
+#endif
+	memset(ahd, 0, sizeof(*ahd));
+	ahd->seep_config = malloc(sizeof(*ahd->seep_config),
+				  M_DEVBUF, M_NOWAIT);
+	if (ahd->seep_config == NULL) {
+#ifndef	__FreeBSD__
+		free(ahd, M_DEVBUF);
+#endif
+		free(name, M_DEVBUF);
+		return (NULL);
+	}
+	LIST_INIT(&ahd->pending_scbs);
+	/* We don't know our unit number until the OSM sets it */
+	ahd->name = name;
+	ahd->unit = -1;
+	ahd->description = NULL;
+	ahd->bus_description = NULL;
+	ahd->channel = 'A';
+	ahd->chip = AHD_NONE;
+	ahd->features = AHD_FENONE;
+	ahd->bugs = AHD_BUGNONE;
+	ahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A
+		   | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;
+	ahd_timer_init(&ahd->reset_timer);
+
+	if (ahd_platform_alloc(ahd, platform_arg) != 0) {
+		ahd_free(ahd);
+		ahd = NULL;
+	}
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MEMORY) != 0) {
+		printf("%s: scb size = 0x%x, hscb size - 0x%x\n",
+		       ahd_name(ahd), sizeof(struct scb),
+		       sizeof(struct hardware_scb));
+	}
+#endif
+	return (ahd);
+}
+
+int
+ahd_softc_init(struct ahd_softc *ahd)
+{
+
+	ahd->unpause = 0;
+	ahd->pause = PAUSE; 
+	return (0);
+}
+
+void
+ahd_softc_insert(struct ahd_softc *ahd)
+{
+	struct ahd_softc *list_ahd;
+
+#if AHD_PCI_CONFIG > 0
+	/*
+	 * Second Function PCI devices need to inherit some
+	 * settings from function 0.
+	 */
+	if ((ahd->features & AHD_MULTI_FUNC) != 0) {
+		TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+			ahd_dev_softc_t list_pci;
+			ahd_dev_softc_t pci;
+
+			list_pci = list_ahd->dev_softc;
+			pci = ahd->dev_softc;
+			if (ahd_get_pci_slot(list_pci) == ahd_get_pci_slot(pci)
+			 && ahd_get_pci_bus(list_pci) == ahd_get_pci_bus(pci)) {
+				struct ahd_softc *master;
+				struct ahd_softc *slave;
+
+				if (ahd_get_pci_function(list_pci) == 0) {
+					master = list_ahd;
+					slave = ahd;
+				} else {
+					master = ahd;
+					slave = list_ahd;
+				}
+				slave->flags &= ~AHD_BIOS_ENABLED; 
+				slave->flags |=
+				    master->flags & AHD_BIOS_ENABLED;
+				slave->flags &= ~AHD_PRIMARY_CHANNEL; 
+				slave->flags |=
+				    master->flags & AHD_PRIMARY_CHANNEL;
+				break;
+			}
+		}
+	}
+#endif
+
+	/*
+	 * Insertion sort into our list of softcs.
+	 */
+	list_ahd = TAILQ_FIRST(&ahd_tailq);
+	while (list_ahd != NULL
+	    && ahd_softc_comp(list_ahd, ahd) <= 0)
+		list_ahd = TAILQ_NEXT(list_ahd, links);
+	if (list_ahd != NULL)
+		TAILQ_INSERT_BEFORE(list_ahd, ahd, links);
+	else
+		TAILQ_INSERT_TAIL(&ahd_tailq, ahd, links);
+	ahd->init_level++;
+}
+
+/*
+ * Verify that the passed in softc pointer is for a
+ * controller that is still configured.
+ */
+struct ahd_softc *
+ahd_find_softc(struct ahd_softc *ahd)
+{
+	struct ahd_softc *list_ahd;
+
+	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+		if (list_ahd == ahd)
+			return (ahd);
+	}
+	return (NULL);
+}
+
+void
+ahd_set_unit(struct ahd_softc *ahd, int unit)
+{
+	ahd->unit = unit;
+}
+
+void
+ahd_set_name(struct ahd_softc *ahd, char *name)
+{
+	if (ahd->name != NULL)
+		free(ahd->name, M_DEVBUF);
+	ahd->name = name;
+}
+
+void
+ahd_free(struct ahd_softc *ahd)
+{
+	int i;
+
+	ahd_fini_scbdata(ahd);
+	switch (ahd->init_level) {
+	default:
+	case 5:
+		ahd_shutdown(ahd);
+		TAILQ_REMOVE(&ahd_tailq, ahd, links);
+		/* FALLTHROUGH */
+	case 4:
+		ahd_dmamap_unload(ahd, ahd->shared_data_dmat,
+				  ahd->shared_data_dmamap);
+		/* FALLTHROUGH */
+	case 3:
+		ahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,
+				ahd->shared_data_dmamap);
+		ahd_dmamap_destroy(ahd, ahd->shared_data_dmat,
+				   ahd->shared_data_dmamap);
+		/* FALLTHROUGH */
+	case 2:
+		ahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);
+	case 1:
+#ifndef __linux__
+		ahd_dma_tag_destroy(ahd, ahd->buffer_dmat);
+#endif
+		break;
+	case 0:
+		break;
+	}
+
+#ifndef __linux__
+	ahd_dma_tag_destroy(ahd, ahd->parent_dmat);
+#endif
+	ahd_platform_free(ahd);
+	for (i = 0; i < AHD_NUM_TARGETS; i++) {
+		struct ahd_tmode_tstate *tstate;
+
+		tstate = ahd->enabled_targets[i];
+		if (tstate != NULL) {
+#if AHD_TARGET_MODE
+			int j;
+
+			for (j = 0; j < AHD_NUM_LUNS; j++) {
+				struct ahd_tmode_lstate *lstate;
+
+				lstate = tstate->enabled_luns[j];
+				if (lstate != NULL) {
+					xpt_free_path(lstate->path);
+					free(lstate, M_DEVBUF);
+				}
+			}
+#endif
+			free(tstate, M_DEVBUF);
+		}
+	}
+#if AHD_TARGET_MODE
+	if (ahd->black_hole != NULL) {
+		xpt_free_path(ahd->black_hole->path);
+		free(ahd->black_hole, M_DEVBUF);
+	}
+#endif
+	if (ahd->name != NULL)
+		free(ahd->name, M_DEVBUF);
+	if (ahd->seep_config != NULL)
+		free(ahd->seep_config, M_DEVBUF);
+#ifndef __FreeBSD__
+	free(ahd, M_DEVBUF);
+#endif
+	return;
+}
+
+void
+ahd_shutdown(void *arg)
+{
+	struct	ahd_softc *ahd;
+
+	ahd = (struct ahd_softc *)arg;
+
+	/* This will reset most registers to 0, but not all */
+	ahd_reset(ahd);
+}
+
+/*
+ * Reset the controller and record some information about it
+ * that is only available just after a reset.
+ */
+int
+ahd_reset(struct ahd_softc *ahd)
+{
+	u_int	 sxfrctl1;
+	int	 wait;
+	uint32_t cmd;
+	
+	/*
+	 * Preserve the value of the SXFRCTL1 register for all channels.
+	 * It contains settings that affect termination and we don't want
+	 * to disturb the integrity of the bus.
+	 */
+	ahd_pause(ahd);
+	sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
+
+	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
+		uint32_t mod_cmd;
+
+		/*
+		 * A4 Razor #632
+		 * During the assertion of CHIPRST, the chip
+		 * does not disable its parity logic prior to
+		 * the start of the reset.  This may cause a
+		 * parity error to be detected and thus a
+		 * spurious SERR or PERR assertion.  Disble
+		 * PERR and SERR responses during the CHIPRST.
+		 */
+		mod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     mod_cmd, /*bytes*/2);
+	}
+	ahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);
+
+	/*
+	 * Ensure that the reset has finished.  We delay 1000us
+	 * prior to reading the register to make sure the chip
+	 * has sufficiently completed its reset to handle register
+	 * accesses.
+	 */
+	wait = 1000;
+	do {
+		ahd_delay(1000);
+	} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));
+
+	if (wait == 0) {
+		printf("%s: WARNING - Failed chip reset!  "
+		       "Trying to initialize anyway.\n", ahd_name(ahd));
+	}
+	ahd_outb(ahd, HCNTRL, ahd->pause);
+
+	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
+		/*
+		 * Clear any latched PCI error status and restore
+		 * previous SERR and PERR response enables.
+		 */
+		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+				     0xFF, /*bytes*/1);
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     cmd, /*bytes*/2);
+	}
+	/* After a reset, we know the state of the mode register. */
+	ahd_known_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	/* Determine chip configuration */
+	ahd->features &= ~AHD_WIDE;
+	if ((ahd_inb(ahd, SBLKCTL) & SELWIDE) != 0)
+		ahd->features |= AHD_WIDE;
+
+	/*
+	 * Restore SXFRCTL1.
+	 *
+	 * We must always initialize STPWEN to 1 before we
+	 * restore the saved values.  STPWEN is initialized
+	 * to a tri-state condition which can only be cleared
+	 * by turning it on.
+	 */
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
+
+	/*
+	 * If a recovery action has forced a chip reset,
+	 * re-initialize the chip to our likeing.
+	 */
+	if (ahd->init_level > 0)
+		ahd_chip_init(ahd);
+
+	return (0);
+}
+
+/*
+ * Determine the number of SCBs available on the controller
+ */
+int
+ahd_probe_scbs(struct ahd_softc *ahd) {
+	int i;
+
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	for (i = 0; i < AHD_SCB_MAX; i++) {
+		int j;
+
+		ahd_set_scbptr(ahd, i);
+		ahd_outw(ahd, SCB_BASE, i);
+		for (j = 2; j < 64; j++)
+			ahd_outb(ahd, SCB_BASE+j, 0);
+		/* Start out life as unallocated (needing an abort) */
+		ahd_outb(ahd, SCB_CONTROL, MK_MESSAGE);
+		if (ahd_inw_scbram(ahd, SCB_BASE) != i)
+			break;
+		ahd_set_scbptr(ahd, 0);
+		if (ahd_inw_scbram(ahd, SCB_BASE) != 0)
+			break;
+	}
+	return (i);
+}
+
+static void
+ahd_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
+{
+	bus_addr_t *baddr;
+
+	baddr = (bus_addr_t *)arg;
+	*baddr = segs->ds_addr;
+}
+
+static void
+ahd_initialize_hscbs(struct ahd_softc *ahd)
+{
+	int i;
+
+	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
+		ahd_set_scbptr(ahd, i);
+
+		/* Clear the control byte. */
+		ahd_outb(ahd, SCB_CONTROL, 0);
+
+		/* Set the next pointer */
+		ahd_outw(ahd, SCB_NEXT, SCB_LIST_NULL);
+	}
+}
+
+static int
+ahd_init_scbdata(struct ahd_softc *ahd)
+{
+	struct	scb_data *scb_data;
+	int	i;
+
+	scb_data = &ahd->scb_data;
+	TAILQ_INIT(&scb_data->free_scbs);
+	for (i = 0; i < AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT; i++)
+		LIST_INIT(&scb_data->free_scb_lists[i]);
+	LIST_INIT(&scb_data->any_dev_free_scb_list);
+	SLIST_INIT(&scb_data->hscb_maps);
+	SLIST_INIT(&scb_data->sg_maps);
+	SLIST_INIT(&scb_data->sense_maps);
+
+	/* Determine the number of hardware SCBs and initialize them */
+	scb_data->maxhscbs = ahd_probe_scbs(ahd);
+	if (scb_data->maxhscbs == 0) {
+		printf("%s: No SCB space found\n", ahd_name(ahd));
+		return (ENXIO);
+	}
+
+	ahd_initialize_hscbs(ahd);
+
+	/*
+	 * Create our DMA tags.  These tags define the kinds of device
+	 * accessible memory allocations and memory mappings we will
+	 * need to perform during normal operation.
+	 *
+	 * Unless we need to further restrict the allocation, we rely
+	 * on the restrictions of the parent dmat, hence the common
+	 * use of MAXADDR and MAXSIZE.
+	 */
+
+	/* DMA tag for our hardware scb structures */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       PAGE_SIZE, /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
+		goto error_exit;
+	}
+
+	scb_data->init_level++;
+
+	/* DMA tag for our S/G structures. */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       ahd_sglist_allocsize(ahd), /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->sg_dmat) != 0) {
+		goto error_exit;
+	}
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MEMORY) != 0)
+		printf("%s: ahd_sglist_allocsize = 0x%x\n", ahd_name(ahd),
+		       ahd_sglist_allocsize(ahd));
+#endif
+
+	scb_data->init_level++;
+
+	/* DMA tag for our sense buffers.  We allocate in page sized chunks */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       PAGE_SIZE, /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->sense_dmat) != 0) {
+		goto error_exit;
+	}
+
+	scb_data->init_level++;
+
+	/* Perform initial CCB allocation */
+	ahd_alloc_scbs(ahd);
+
+	if (scb_data->numscbs == 0) {
+		printf("%s: ahd_init_scbdata - "
+		       "Unable to allocate initial scbs\n",
+		       ahd_name(ahd));
+		goto error_exit;
+	}
+
+	/*
+	 * Note that we were successfull
+	 */
+	return (0); 
+
+error_exit:
+
+	return (ENOMEM);
+}
+
+static struct scb *
+ahd_find_scb_by_tag(struct ahd_softc *ahd, u_int tag)
+{
+	struct scb *scb;
+
+	/*
+	 * Look on the pending list.
+	 */
+	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+		if (SCB_GET_TAG(scb) == tag)
+			return (scb);
+	}
+
+	/*
+	 * Then on all of the collision free lists.
+	 */
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		struct scb *list_scb;
+
+		list_scb = scb;
+		do {
+			if (SCB_GET_TAG(list_scb) == tag)
+				return (list_scb);
+			list_scb = LIST_NEXT(list_scb, collision_links);
+		} while (list_scb);
+	}
+
+	/*
+	 * And finally on the generic free list.
+	 */
+	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
+		if (SCB_GET_TAG(scb) == tag)
+			return (scb);
+	}
+
+	return (NULL);
+}
+
+static void
+ahd_fini_scbdata(struct ahd_softc *ahd)
+{
+	struct scb_data *scb_data;
+
+	scb_data = &ahd->scb_data;
+	if (scb_data == NULL)
+		return;
+
+	switch (scb_data->init_level) {
+	default:
+	case 7:
+	{
+		struct map_node *sns_map;
+
+		while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->sense_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->sense_dmat,
+					  sns_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->sense_dmat,
+					sns_map->vaddr, sns_map->dmamap);
+			free(sns_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->sense_dmat);
+		/* FALLTHROUGH */
+	}
+	case 6:
+	{
+		struct map_node *sg_map;
+
+		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->sg_dmat,
+					  sg_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->sg_dmat,
+					sg_map->vaddr, sg_map->dmamap);
+			free(sg_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->sg_dmat);
+		/* FALLTHROUGH */
+	}
+	case 5:
+	{
+		struct map_node *hscb_map;
+
+		while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->hscb_dmat,
+					  hscb_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->hscb_dmat,
+					hscb_map->vaddr, hscb_map->dmamap);
+			free(hscb_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);
+		/* FALLTHROUGH */
+	}
+	case 4:
+	case 3:
+	case 2:
+	case 1:
+	case 0:
+		break;
+	}
+}
+
+/*
+ * DSP filter Bypass must be enabled until the first selection
+ * after a change in bus mode (Razor #491 and #493).
+ */
+static void
+ahd_setup_iocell_workaround(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	ahd_outb(ahd, DSPDATACTL, ahd_inb(ahd, DSPDATACTL)
+	       | BYPASSENAB | RCVROFFSTDIS | XMITOFFSTDIS);
+	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) | (ENSELDO|ENSELDI));
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: Setting up iocell workaround\n", ahd_name(ahd));
+#endif
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static void
+ahd_iocell_first_selection(struct ahd_softc *ahd)
+{
+	ahd_mode_state	saved_modes;
+	u_int		sblkctl;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	sblkctl = ahd_inb(ahd, SBLKCTL);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: iocell first selection\n", ahd_name(ahd));
+#endif
+	if ((sblkctl & ENAB40) != 0) {
+		ahd_outb(ahd, DSPDATACTL,
+			 ahd_inb(ahd, DSPDATACTL) & ~BYPASSENAB);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("%s: BYPASS now disabled\n", ahd_name(ahd));
+#endif
+	}
+	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) & ~(ENSELDO|ENSELDI));
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*************************** SCB Management ***********************************/
+static void
+ahd_add_col_list(struct ahd_softc *ahd, struct scb *scb, u_int col_idx)
+{
+	struct	scb_list *free_list;
+	struct	scb_tailq *free_tailq;
+	struct	scb *first_scb;
+
+	scb->flags |= SCB_ON_COL_LIST;
+	AHD_SET_SCB_COL_IDX(scb, col_idx);
+	free_list = &ahd->scb_data.free_scb_lists[col_idx];
+	free_tailq = &ahd->scb_data.free_scbs;
+	first_scb = LIST_FIRST(free_list);
+	if (first_scb != NULL) {
+		LIST_INSERT_AFTER(first_scb, scb, collision_links);
+	} else {
+		LIST_INSERT_HEAD(free_list, scb, collision_links);
+		TAILQ_INSERT_TAIL(free_tailq, scb, links.tqe);
+	}
+}
+
+static void
+ahd_rem_col_list(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct	scb_list *free_list;
+	struct	scb_tailq *free_tailq;
+	struct	scb *first_scb;
+	u_int	col_idx;
+
+	scb->flags &= ~SCB_ON_COL_LIST;
+	col_idx = AHD_GET_SCB_COL_IDX(ahd, scb);
+	free_list = &ahd->scb_data.free_scb_lists[col_idx];
+	free_tailq = &ahd->scb_data.free_scbs;
+	first_scb = LIST_FIRST(free_list);
+	if (first_scb == scb) {
+		struct scb *next_scb;
+
+		/*
+		 * Maintain order in the collision free
+		 * lists for fairness if this device has
+		 * other colliding tags active.
+		 */
+		next_scb = LIST_NEXT(scb, collision_links);
+		if (next_scb != NULL) {
+			TAILQ_INSERT_AFTER(free_tailq, scb,
+					   next_scb, links.tqe);
+		}
+		TAILQ_REMOVE(free_tailq, scb, links.tqe);
+	}
+	LIST_REMOVE(scb, collision_links);
+}
+
+/*
+ * Get a free scb. If there are none, see if we can allocate a new SCB.
+ */
+struct scb *
+ahd_get_scb(struct ahd_softc *ahd, u_int col_idx)
+{
+	struct scb *scb;
+	int tries;
+
+	tries = 0;
+look_again:
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		if (AHD_GET_SCB_COL_IDX(ahd, scb) != col_idx) {
+			ahd_rem_col_list(ahd, scb);
+			goto found;
+		}
+	}
+	if ((scb = LIST_FIRST(&ahd->scb_data.any_dev_free_scb_list)) == NULL) {
+
+		if (tries++ != 0)
+			return (NULL);
+		ahd_alloc_scbs(ahd);
+		goto look_again;
+	}
+	LIST_REMOVE(scb, links.le);
+	if (col_idx != AHD_NEVER_COL_IDX
+	 && (scb->col_scb != NULL)
+	 && (scb->col_scb->flags & SCB_ACTIVE) == 0) {
+		LIST_REMOVE(scb->col_scb, links.le);
+		ahd_add_col_list(ahd, scb->col_scb, col_idx);
+	}
+found:
+	scb->flags |= SCB_ACTIVE;
+	return (scb);
+}
+
+/*
+ * Return an SCB resource to the free list.
+ */
+void
+ahd_free_scb(struct ahd_softc *ahd, struct scb *scb)
+{       
+
+	/* Clean up for the next user */
+	scb->flags = SCB_FLAG_NONE;
+	scb->hscb->control = 0;
+	ahd->scb_data.scbindex[scb->hscb->tag] = NULL;
+
+	if (scb->col_scb == NULL) {
+
+		/*
+		 * No collision possible.  Just free normally.
+		 */
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+	} else if ((scb->col_scb->flags & SCB_ON_COL_LIST) != 0) {
+
+		/*
+		 * The SCB we might have collided with is on
+		 * a free collision list.  Put both SCBs on
+		 * the generic list.
+		 */
+		ahd_rem_col_list(ahd, scb->col_scb);
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb->col_scb, links.le);
+	} else if ((scb->col_scb->flags
+		  & (SCB_PACKETIZED|SCB_ACTIVE)) == SCB_ACTIVE
+		&& (scb->col_scb->hscb->control & TAG_ENB) != 0) {
+
+		/*
+		 * The SCB we might collide with on the next allocation
+		 * is still active in a non-packetized, tagged, context.
+		 * Put us on the SCB collision list.
+		 */
+		ahd_add_col_list(ahd, scb,
+				 AHD_GET_SCB_COL_IDX(ahd, scb->col_scb));
+	} else {
+		/*
+		 * The SCB we might collide with on the next allocation
+		 * is either active in a packetized context, or free.
+		 * Since we can't collide, put this SCB on the generic
+		 * free list.
+		 */
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+	}
+
+	ahd_platform_scb_free(ahd, scb);
+}
+
+void
+ahd_alloc_scbs(struct ahd_softc *ahd)
+{
+	struct scb_data *scb_data;
+	struct scb	*next_scb;
+	struct hardware_scb *hscb;
+	struct map_node *hscb_map;
+	struct map_node *sg_map;
+	struct map_node *sense_map;
+	uint8_t		*segs;
+	uint8_t		*sense_data;
+	bus_addr_t	 hscb_busaddr;
+	bus_addr_t	 sg_busaddr;
+	bus_addr_t	 sense_busaddr;
+	int		 newcount;
+	int		 i;
+
+	scb_data = &ahd->scb_data;
+	if (scb_data->numscbs >= AHD_SCB_MAX_ALLOC)
+		/* Can't allocate any more */
+		return;
+
+	if (scb_data->scbs_left != 0) {
+		int offset;
+
+		offset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;
+		hscb_map = SLIST_FIRST(&scb_data->hscb_maps);
+		hscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];
+		hscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));
+	} else {
+		hscb_map = malloc(sizeof(*hscb_map), M_DEVBUF, M_NOWAIT);
+
+		if (hscb_map == NULL)
+			return;
+
+		/* Allocate the next batch of hardware SCBs */
+		if (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,
+				     (void **)&hscb_map->vaddr,
+				     BUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {
+			free(hscb_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,
+				hscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
+				&hscb_map->physaddr, /*flags*/0);
+
+		hscb = (struct hardware_scb *)hscb_map->vaddr;
+		hscb_busaddr = hscb_map->physaddr;
+		scb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);
+	}
+
+	if (scb_data->sgs_left != 0) {
+		int offset;
+
+		offset = ahd_sglist_allocsize(ahd)
+		       - (scb_data->sgs_left * ahd_sglist_size(ahd));
+		sg_map = SLIST_FIRST(&scb_data->sg_maps);
+		segs = sg_map->vaddr + offset;
+		sg_busaddr = sg_map->physaddr + offset;
+	} else {
+		sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
+
+		if (sg_map == NULL)
+			return;
+
+		/* Allocate the next batch of S/G lists */
+		if (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,
+				     (void **)&sg_map->vaddr,
+				     BUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {
+			free(sg_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,
+				sg_map->vaddr, ahd_sglist_allocsize(ahd),
+				ahd_dmamap_cb, &sg_map->physaddr, /*flags*/0);
+
+		segs = sg_map->vaddr;
+		sg_busaddr = sg_map->physaddr;
+		scb_data->sgs_left =
+		    ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_MEMORY)
+			printf("Mapped SG data\n");
+#endif
+	}
+
+	if (scb_data->sense_left != 0) {
+		int offset;
+
+		offset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);
+		sense_map = SLIST_FIRST(&scb_data->sense_maps);
+		sense_data = sense_map->vaddr + offset;
+		sense_busaddr = sense_map->physaddr + offset;
+	} else {
+		sense_map = malloc(sizeof(*sense_map), M_DEVBUF, M_NOWAIT);
+
+		if (sense_map == NULL)
+			return;
+
+		/* Allocate the next batch of sense buffers */
+		if (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,
+				     (void **)&sense_map->vaddr,
+				     BUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {
+			free(sense_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,
+				sense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
+				&sense_map->physaddr, /*flags*/0);
+
+		sense_data = sense_map->vaddr;
+		sense_busaddr = sense_map->physaddr;
+		scb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_MEMORY)
+			printf("Mapped sense data\n");
+#endif
+	}
+
+	newcount = MIN(scb_data->sense_left, scb_data->scbs_left);
+	newcount = MIN(newcount, scb_data->sgs_left);
+	newcount = MIN(newcount, (AHD_SCB_MAX_ALLOC - scb_data->numscbs));
+	scb_data->sense_left -= newcount;
+	scb_data->scbs_left -= newcount;
+	scb_data->sgs_left -= newcount;
+	for (i = 0; i < newcount; i++) {
+		u_int col_tag;
+
+		struct scb_platform_data *pdata;
+#ifndef __linux__
+		int error;
+#endif
+		next_scb = (struct scb *)malloc(sizeof(*next_scb),
+						M_DEVBUF, M_NOWAIT);
+		if (next_scb == NULL)
+			break;
+
+		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
+							   M_DEVBUF, M_NOWAIT);
+		if (pdata == NULL) {
+			free(next_scb, M_DEVBUF);
+			break;
+		}
+		next_scb->platform_data = pdata;
+		next_scb->hscb_map = hscb_map;
+		next_scb->sg_map = sg_map;
+		next_scb->sense_map = sense_map;
+		next_scb->sg_list = segs;
+		next_scb->sense_data = sense_data;
+		next_scb->sense_busaddr = sense_busaddr;
+		next_scb->hscb = hscb;
+		hscb->hscb_busaddr = ahd_htole32(hscb_busaddr);
+
+		/*
+		 * The sequencer always starts with the second entry.
+		 * The first entry is embedded in the scb.
+		 */
+		next_scb->sg_list_busaddr = sg_busaddr;
+		if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+			next_scb->sg_list_busaddr
+			    += sizeof(struct ahd_dma64_seg);
+		else
+			next_scb->sg_list_busaddr += sizeof(struct ahd_dma_seg);
+		next_scb->ahd_softc = ahd;
+		next_scb->flags = SCB_FLAG_NONE;
+#ifndef __linux__
+		error = ahd_dmamap_create(ahd, ahd->buffer_dmat, /*flags*/0,
+					  &next_scb->dmamap);
+		if (error != 0) {
+			free(next_scb, M_DEVBUF);
+			free(pdata, M_DEVBUF);
+			break;
+		}
+#endif
+		next_scb->hscb->tag = ahd_htole16(scb_data->numscbs);
+		col_tag = scb_data->numscbs ^ 0x100;
+		next_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);
+		if (next_scb->col_scb != NULL)
+			next_scb->col_scb->col_scb = next_scb;
+		ahd_free_scb(ahd, next_scb);
+		hscb++;
+		hscb_busaddr += sizeof(*hscb);
+		segs += ahd_sglist_size(ahd);
+		sg_busaddr += ahd_sglist_size(ahd);
+		sense_data += AHD_SENSE_BUFSIZE;
+		sense_busaddr += AHD_SENSE_BUFSIZE;
+		scb_data->numscbs++;
+	}
+}
+
+void
+ahd_controller_info(struct ahd_softc *ahd, char *buf)
+{
+	const char *speed;
+	const char *type;
+	int len;
+
+	len = sprintf(buf, "%s: ", ahd_chip_names[ahd->chip & AHD_CHIPID_MASK]);
+	buf += len;
+
+	speed = "Ultra320 ";
+	if ((ahd->features & AHD_WIDE) != 0) {
+		type = "Wide ";
+	} else {
+		type = "Single ";
+	}
+	len = sprintf(buf, "%s%sChannel %c, SCSI Id=%d, ",
+		      speed, type, ahd->channel, ahd->our_id);
+	buf += len;
+
+	sprintf(buf, "%s, %d SCBs", ahd->bus_description,
+		ahd->scb_data.maxhscbs);
+}
+
+static const char *channel_strings[] = {
+	"Primary Low",
+	"Primary High",
+	"Secondary Low", 
+	"Secondary High"
+};
+
+static const char *termstat_strings[] = {
+	"Terminated Correctly",
+	"Over Terminated",
+	"Under Terminated",
+	"Not Configured"
+};
+
+/*
+ * Start the board, ready for normal operation
+ */
+int
+ahd_init(struct ahd_softc *ahd)
+{
+	uint8_t		*base_vaddr;
+	uint8_t		*next_vaddr;
+	bus_addr_t	 next_baddr;
+	size_t		 driver_data_size;
+	int		 i;
+	int		 error;
+	u_int		 warn_user;
+	uint8_t		 current_sensing;
+	uint8_t		 fstat;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+
+	/*
+	 * Verify that the compiler hasn't over-agressively
+	 * padded important structures.
+	 */
+	if (sizeof(struct hardware_scb) != 64)
+		panic("Hardware SCB size is incorrect");
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_DEBUG_SEQUENCER) != 0)
+		ahd->flags |= AHD_SEQUENCER_DEBUG;
+#endif
+
+	/*
+	 * Default to allowing initiator operations.
+	 */
+	ahd->flags |= AHD_INITIATORROLE;
+
+	/*
+	 * Only allow target mode features if this unit has them enabled.
+	 */
+	if ((AHD_TMODE_ENABLE & (0x1 << ahd->unit)) == 0)
+		ahd->features &= ~AHD_TARGETMODE;
+
+#ifndef __linux__
+	/* DMA tag for mapping buffers into device visible space. */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       /*maxsize*/MAXBSIZE, /*nsegments*/AHD_NSEG,
+			       /*maxsegsz*/AHD_MAXTRANSFER_SIZE,
+			       /*flags*/BUS_DMA_ALLOCNOW,
+			       &ahd->buffer_dmat) != 0) {
+		return (ENOMEM);
+	}
+#endif
+
+	ahd->init_level++;
+
+	/*
+	 * DMA tag for our command fifos and other data in system memory
+	 * the card's sequencer must be able to access.  For initiator
+	 * roles, we need to allocate space for the qoutfifo.  When providing
+	 * for the target mode role, we must additionally provide space for
+	 * the incoming target command fifo.
+	 */
+	driver_data_size = AHD_SCB_MAX * sizeof(uint16_t)
+			 + sizeof(struct hardware_scb);
+	if ((ahd->features & AHD_TARGETMODE) != 0)
+		driver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)
+		driver_data_size += PKT_OVERRUN_BUFSIZE;
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       driver_data_size,
+			       /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &ahd->shared_data_dmat) != 0) {
+		return (ENOMEM);
+	}
+
+	ahd->init_level++;
+
+	/* Allocation of driver data */
+	if (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,
+			     (void **)&base_vaddr,
+			     BUS_DMA_NOWAIT, &ahd->shared_data_dmamap) != 0) {
+		return (ENOMEM);
+	}
+
+	ahd->init_level++;
+
+	/* And permanently map it in */
+	ahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			base_vaddr, driver_data_size, ahd_dmamap_cb,
+			&ahd->shared_data_busaddr, /*flags*/0);
+	ahd->qoutfifo = (uint16_t *)base_vaddr;
+	next_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];
+	next_baddr = ahd->shared_data_busaddr + AHD_QOUT_SIZE*sizeof(uint16_t);
+	if ((ahd->features & AHD_TARGETMODE) != 0) {
+		ahd->targetcmds = (struct target_cmd *)next_vaddr;
+		next_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+		next_baddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+	}
+
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+		ahd->overrun_buf = next_vaddr;
+		next_vaddr += PKT_OVERRUN_BUFSIZE;
+		next_baddr += PKT_OVERRUN_BUFSIZE;
+	}
+
+	/*
+	 * We need one SCB to serve as the "next SCB".  Since the
+	 * tag identifier in this SCB will never be used, there is
+	 * no point in using a valid HSCB tag from an SCB pulled from
+	 * the standard free pool.  So, we allocate this "sentinel"
+	 * specially from the DMA safe memory chunk used for the QOUTFIFO.
+	 */
+	ahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;
+	ahd->next_queued_hscb->hscb_busaddr = next_baddr;
+
+	ahd->init_level++;
+
+	/* Allocate SCB data now that buffer_dmat is initialized */
+	if (ahd_init_scbdata(ahd) != 0)
+		return (ENOMEM);
+
+	if ((ahd->flags & AHD_INITIATORROLE) == 0)
+		ahd->flags &= ~AHD_RESET_BUS_A;
+
+	ahd_chip_init(ahd);
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+
+	if ((ahd->flags & AHD_CURRENT_SENSING) == 0)
+		goto init_done;
+
+	/*
+	 * Verify termination based on current draw and
+	 * warn user if the bus is over/under terminated.
+	 */
+	error = ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,
+				   CURSENSE_ENB);
+	if (error != 0) {
+		printf("%s: current sensing timeout 1\n", ahd_name(ahd));
+		goto init_done;
+	}
+	for (i = 20, fstat = FLX_FSTAT_BUSY;
+	     (fstat & FLX_FSTAT_BUSY) != 0 && i; i--) {
+		error = ahd_read_flexport(ahd, FLXADDR_FLEXSTAT, &fstat);
+		if (error != 0) {
+			printf("%s: current sensing timeout 2\n",
+			       ahd_name(ahd));
+			goto init_done;
+		}
+	}
+	if (i == 0) {
+		printf("%s: Timedout during current-sensing test\n",
+		       ahd_name(ahd));
+		goto init_done;
+	}
+
+	/* Latch Current Sensing status. */
+	error = ahd_read_flexport(ahd, FLXADDR_CURRENT_STAT, &current_sensing);
+	if (error != 0) {
+		printf("%s: current sensing timeout 3\n", ahd_name(ahd));
+		goto init_done;
+	}
+
+	/* Diable current sensing. */
+	ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_TERMCTL) != 0) {
+		printf("%s: current_sensing == 0x%x\n",
+		       ahd_name(ahd), current_sensing);
+	}
+#endif
+	warn_user = 0;
+	for (i = 0; i < 4; i++, current_sensing >>= FLX_CSTAT_SHIFT) {
+		u_int term_stat;
+
+		term_stat = (current_sensing & FLX_CSTAT_MASK);
+		switch (term_stat) {
+		case FLX_CSTAT_OVER:
+		case FLX_CSTAT_UNDER:
+			warn_user++;
+		case FLX_CSTAT_INVALID:
+		case FLX_CSTAT_OKAY:
+			if (warn_user == 0 && bootverbose == 0)
+				break;
+			printf("%s: %s Channel %s\n", ahd_name(ahd),
+			       channel_strings[i], termstat_strings[term_stat]);
+			break;
+		}
+	}
+	if (warn_user) {
+		printf("%s: WARNING. Termination is not configured correctly.\n"
+		       "%s: WARNING. SCSI bus operations may FAIL.\n",
+		       ahd_name(ahd), ahd_name(ahd));
+	}
+init_done:
+	ahd_restart(ahd);
+	return (0);
+}
+
+/*
+ * (Re)initialize chip state after a chip reset.
+ */
+static void
+ahd_chip_init(struct ahd_softc *ahd)
+{
+	uint32_t busaddr;
+	u_int	 sxfrctl1;
+	u_int	 scsiseq_template;
+	u_int	 wait;
+	u_int	 i;
+	u_int	 target;
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/*
+	 * Take the LED out of diagnostic mode
+	 */
+	ahd_outb(ahd, SBLKCTL, ahd_inb(ahd, SBLKCTL) & ~(DIAGLEDEN|DIAGLEDON));
+
+	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */
+	ahd_outb(ahd, IOWNID, ahd->our_id);
+	ahd_outb(ahd, TOWNID, ahd->our_id);
+	sxfrctl1 = (ahd->flags & AHD_TERM_ENB_A) != 0 ? STPWEN : 0;
+	sxfrctl1 |= (ahd->flags & AHD_SPCHK_ENB_A) != 0 ? ENSPCHK : 0;
+	if ((ahd->bugs & AHD_LONG_SETIMO_BUG)
+	 && (ahd->seltime != STIMESEL_MIN)) {
+		/*
+		 * The selection timer duration is twice as long
+		 * as it should be.  Halve it by adding "1" to
+		 * the user specified setting.
+		 */
+		sxfrctl1 |= ahd->seltime + STIMESEL_BUG_ADJ;
+	} else {
+		sxfrctl1 |= ahd->seltime;
+	}
+		
+	ahd_outb(ahd, SXFRCTL0, DFON);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|ahd->seltime|ENSTIMER|ACTNEGEN);
+	ahd_outb(ahd, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
+
+	/*
+	 * Now that termination is set, wait for up
+	 * to 500ms for our transceivers to settle.  If
+	 * the adapter does not have a cable attached,
+	 * the tranceivers may never settle, so don't
+	 * complain if we fail here.
+	 */
+	for (wait = 10000;
+	     (ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
+	     wait--)
+		ahd_delay(100);
+
+	/* Clear any false bus resets due to the transceivers settling */
+	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+
+	/* Initialize mode specific S/G state. */
+	for (i = 0; i < 2; i++) {
+		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
+		ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
+		ahd_outw(ahd, LONGJMP_SCB, SCB_LIST_NULL);
+		ahd_outb(ahd, SG_STATE, 0);
+		ahd_outb(ahd, CLRSEQINTSRC, 0xFF);
+		ahd_outb(ahd, SEQIMODE,
+			 ENSAVEPTRS|ENCFG4DATA|ENCFG4ISTAT
+			|ENCFG4TSTAT|ENCFG4ICMD|ENCFG4TCMD);
+	}
+
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	ahd_outb(ahd, DSCOMMAND0, ahd_inb(ahd, DSCOMMAND0)|MPARCKEN|CACHETHEN);
+	ahd_outb(ahd, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
+	ahd_outb(ahd, SIMODE0, ENIOERR|ENOVERRUN);
+	ahd_outb(ahd, SIMODE3, ENNTRAMPERR|ENOSRAMPERR);
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|AUTO_MSGOUT_DE);
+	} else {
+		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|BUSFREEREV|AUTO_MSGOUT_DE);
+	}
+	if ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX)
+		/*
+		 * Do not issue a target abort when a split completion
+		 * error occurs.  Let our PCIX interrupt handler deal
+		 * with it instead. H2A4 Razor #625
+		 */
+		ahd_outb(ahd, PCIXCTL, ahd_inb(ahd, PCIXCTL) | SPLTSTADIS);
+
+	/*
+	 * Tweak IOCELL settings.
+	 */
+	if ((ahd->flags & AHD_CPQ_BOARD) != 0) {
+		for (i = 0; i < NUMDSPS; i++) {
+			ahd_outb(ahd, DSPSELECT, i);
+			ahd_outb(ahd, WRTBIASCTL, WRTBIASCTL_CPQ_DEFAULT);
+		}
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("%s: WRTBIASCTL now 0x%x\n", ahd_name(ahd),
+			       WRTBIASCTL_CPQ_DEFAULT);
+#endif
+	}
+	ahd_setup_iocell_workaround(ahd);
+
+	/*
+	 * Enable LQI Manager interrupts.
+	 */
+	ahd_outb(ahd, LQIMODE1, ENLQIPHASE_LQ|ENLQIPHASE_NLQ|ENLIQABORT
+			      | ENLQICRCI_LQ|ENLQICRCI_NLQ|ENLQIBADLQI
+			      | ENLQIOVERI_LQ|ENLQIOVERI_NLQ);
+	ahd_outb(ahd, LQOMODE0, ENLQOATNLQ|ENLQOATNPKT|ENLQOTCRC);
+	/*
+	 * An interrupt from LQOBUSFREE is made redundant by the
+	 * BUSFREE interrupt.  We choose to have the sequencer catch
+	 * LQOPHCHGINPKT errors manually for the command phase at the
+	 * start of a packetized selection case.
+	ahd_outb(ahd, LQOMODE1, ENLQOBUSFREE|ENLQOPHACHGINPKT);
+	 */
+	ahd_outb(ahd, LQOMODE1, 0);
+
+	/*
+	 * Setup sequencer interrupt handler.
+	 */
+	ahd_outw(ahd, INTVEC1_ADDR, ahd_resolve_seqaddr(ahd, LABEL_seq_isr));
+
+	/*
+	 * Setup SCB Offset registers.
+	 */
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
+		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb,
+			 pkt_long_lun));
+	} else {
+		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb, lun));
+	}
+	ahd_outb(ahd, CMDLENPTR, offsetof(struct hardware_scb, cdb_len));
+	ahd_outb(ahd, ATTRPTR, offsetof(struct hardware_scb, task_attribute));
+	ahd_outb(ahd, FLAGPTR, offsetof(struct hardware_scb, task_management));
+	ahd_outb(ahd, CMDPTR, offsetof(struct hardware_scb,
+				       shared_data.idata.cdb));
+	ahd_outb(ahd, QNEXTPTR,
+		 offsetof(struct hardware_scb, next_hscb_busaddr));
+	ahd_outb(ahd, ABRTBITPTR, MK_MESSAGE_BIT_OFFSET);
+	ahd_outb(ahd, ABRTBYTEPTR, offsetof(struct hardware_scb, control));
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
+		ahd_outb(ahd, LUNLEN,
+			 sizeof(ahd->next_queued_hscb->pkt_long_lun) - 1);
+	} else {
+		ahd_outb(ahd, LUNLEN, sizeof(ahd->next_queued_hscb->lun) - 1);
+	}
+	ahd_outb(ahd, CDBLIMIT, SCB_CDB_LEN_PTR - 1);
+	ahd_outb(ahd, MAXCMD, 0xFF);
+	ahd_outb(ahd, SCBAUTOPTR,
+		 AUSCBPTR_EN | offsetof(struct hardware_scb, tag));
+
+	/* We haven't been enabled for target mode yet. */
+	ahd_outb(ahd, MULTARGID, 0);
+	ahd_outb(ahd, MULTARGID + 1, 0);
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/*
+	 * Clear the spare bytes in the neg table to avoid
+	 * spurious parity errors.
+	 */
+	for (target = 0; target < AHD_NUM_TARGETS; target++) {
+
+		ahd_outb(ahd, NEGOADDR, target);
+		ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP);
+		for (i = 0; i < AHD_NUM_ANNEXCOLS; i++)
+			ahd_outb(ahd, ANNEXDAT, 0);
+	}
+	ahd_outb(ahd, CLRSINT3, NTRAMPERR|OSRAMPERR);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+
+	/*
+	 * Always enable abort on incoming L_Qs if this feature is
+	 * supported.  We use this to catch invalid SCB references.
+	 */
+	if ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)
+		ahd_outb(ahd, LQCTL1, ABORTPENDING);
+	else
+		ahd_outb(ahd, LQCTL1, 0);
+
+	/* All of our queues are empty */
+	ahd->qoutfifonext = 0;
+	ahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID_LE;
+	ahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID >> 8);
+	for (i = 0; i < AHD_QOUT_SIZE; i++)
+		ahd->qoutfifo[i] = 0;
+	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);
+
+	ahd->qinfifonext = 0;
+	for (i = 0; i < AHD_QIN_SIZE; i++)
+		ahd->qinfifo[i] = SCB_LIST_NULL;
+
+	if ((ahd->features & AHD_TARGETMODE) != 0) {
+		/* All target command blocks start out invalid. */
+		for (i = 0; i < AHD_TMODE_CMDS; i++)
+			ahd->targetcmds[i].cmd_valid = 0;
+		ahd_sync_tqinfifo(ahd, BUS_DMASYNC_PREREAD);
+		ahd->tqinfifonext = 1;
+		ahd_outb(ahd, KERNEL_TQINPOS, ahd->tqinfifonext - 1);
+		ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
+	}
+
+	/* Initialize Scratch Ram. */
+	ahd_outb(ahd, SEQ_FLAGS, 0);
+	ahd_outb(ahd, SEQ_FLAGS2, 0);
+
+	/* We don't have any waiting selections */
+	ahd_outw(ahd, WAITING_TID_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, WAITING_TID_TAIL, SCB_LIST_NULL);
+	for (i = 0; i < AHD_NUM_TARGETS; i++)
+		ahd_outw(ahd, WAITING_SCB_TAILS + (2 * i), SCB_LIST_NULL);
+
+	/*
+	 * Nobody is waiting to be DMAed into the QOUTFIFO.
+	 */
+	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
+
+	/*
+	 * The Freeze Count is 0.
+	 */
+	ahd_outw(ahd, QFREEZE_COUNT, 0);
+
+	/*
+	 * Tell the sequencer where it can find our arrays in memory.
+	 */
+	busaddr = ahd->shared_data_busaddr;
+	ahd_outb(ahd, SHARED_DATA_ADDR, busaddr & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 3, (busaddr >> 24) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR, busaddr & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 3, (busaddr >> 24) & 0xFF);
+
+	/*
+	 * Setup the allowed SCSI Sequences based on operational mode.
+	 * If we are a target, we'll enable select in operations once
+	 * we've had a lun enabled.
+	 */
+	scsiseq_template = ENAUTOATNP;
+	if ((ahd->flags & AHD_INITIATORROLE) != 0)
+		scsiseq_template |= ENRSELI;
+	ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq_template);
+
+	/* There are no busy SCBs yet. */
+	for (target = 0; target < AHD_NUM_TARGETS; target++) {
+		int lun;
+
+		for (lun = 0; lun < AHD_NUM_LUNS_NONPKT; lun++)
+			ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(target, 'A', lun));
+	}
+
+	/*
+	 * Always enable abort on incoming L_Qs if this feature is
+	 * supported.  We use this to catch invalid SCB references.
+	 */
+	if ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)
+		ahd_outb(ahd, LQCTL1, ABORTPENDING);
+	else
+		ahd_outb(ahd, LQCTL1, 0);
+
+	/*
+	 * Initialize the group code to command length table.
+	 * Vendor Unique codes are set to 0 so we only capture
+	 * the first byte of the cdb.  These can be overridden
+	 * when target mode is enabled.
+	 */
+	ahd_outb(ahd, CMDSIZE_TABLE, 5);
+	ahd_outb(ahd, CMDSIZE_TABLE + 1, 9);
+	ahd_outb(ahd, CMDSIZE_TABLE + 2, 9);
+	ahd_outb(ahd, CMDSIZE_TABLE + 3, 0);
+	ahd_outb(ahd, CMDSIZE_TABLE + 4, 15);
+	ahd_outb(ahd, CMDSIZE_TABLE + 5, 11);
+	ahd_outb(ahd, CMDSIZE_TABLE + 6, 0);
+	ahd_outb(ahd, CMDSIZE_TABLE + 7, 0);
+		
+	/* Tell the sequencer of our initial queue positions */
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	ahd_outb(ahd, QOFF_CTLSTA, SCB_QSIZE_512);
+	ahd->qinfifonext = 0;
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+	ahd_set_hescb_qoff(ahd, 0);
+	ahd_set_snscb_qoff(ahd, 0);
+	ahd_set_sescb_qoff(ahd, 0);
+	ahd_set_sdscb_qoff(ahd, 0);
+
+	/*
+	 * Tell the sequencer which SCB will be the next one it receives.
+	 */
+	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+	ahd_loadseq(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+}
+
+/*
+ * Setup default device and controller settings.
+ * This should only be called if our probe has
+ * determined that no configuration data is available.
+ */
+int
+ahd_default_config(struct ahd_softc *ahd)
+{
+	int	targ;
+
+	ahd->our_id = 7;
+
+	/*
+	 * Allocate a tstate to house information for our
+	 * initiator presence on the bus as well as the user
+	 * data for any target mode initiator.
+	 */
+	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
+		printf("%s: unable to allocate ahd_tmode_tstate.  "
+		       "Failing attach\n", ahd_name(ahd));
+		return (ENOMEM);
+	}
+
+	for (targ = 0; targ < AHD_NUM_TARGETS; targ++) {
+		struct	 ahd_devinfo devinfo;
+		struct	 ahd_initiator_tinfo *tinfo;
+		struct	 ahd_tmode_tstate *tstate;
+		uint16_t target_mask;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    targ, &tstate);
+		/*
+		 * We support SPC2 and SPI4.
+		 */
+		tinfo->user.protocol_version = 4;
+		tinfo->user.transport_version = 4;
+
+		target_mask = 0x01 << targ;
+		ahd->user_discenable |= target_mask;
+		tstate->discenable |= target_mask;
+		ahd->user_tagenable |= target_mask;
+#ifdef AHD_FORCE_160
+		tinfo->user.period = AHD_SYNCRATE_DT;
+#else
+		tinfo->user.period = AHD_SYNCRATE_160;
+#endif
+		tinfo->user.offset= ~0;
+		tinfo->user.ppr_options = MSG_EXT_PPR_RD_STRM
+					| MSG_EXT_PPR_WR_FLOW
+					| MSG_EXT_PPR_HOLD_MCS
+					| MSG_EXT_PPR_IU_REQ
+					| MSG_EXT_PPR_QAS_REQ
+					| MSG_EXT_PPR_DT_REQ;
+
+		tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
+
+		/*
+		 * Start out Async/Narrow/Untagged and with
+		 * conservative protocol support.
+		 */
+		tinfo->goal.protocol_version = 2;
+		tinfo->goal.transport_version = 2;
+		tinfo->curr.protocol_version = 2;
+		tinfo->curr.transport_version = 2;
+		ahd_compile_devinfo(&devinfo, ahd->our_id,
+				    targ, CAM_LUN_WILDCARD,
+				    'A', ROLE_INITIATOR);
+		tstate->tagenable &= ~target_mask;
+		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
+		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
+				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+		/*
+		 * The neg table must be initialized even if the
+		 * new settings above are the same as those from
+		 * when our xfer info data structures were allocated
+		 * and initialized.
+		 */
+		ahd_update_neg_table(ahd, &devinfo, &tinfo->curr);
+	}
+	return (0);
+}
+
+/*
+ * Parse device configuration information.
+ */
+int
+ahd_parse_cfgdata(struct ahd_softc *ahd, struct seeprom_config *sc)
+{
+	int targ;
+	int max_targ;
+
+	max_targ = sc->max_targets & CFMAXTARG;
+	ahd->our_id = sc->brtime_id & CFSCSIID;
+
+	/*
+	 * Allocate a tstate to house information for our
+	 * initiator presence on the bus as well as the user
+	 * data for any target mode initiator.
+	 */
+	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
+		printf("%s: unable to allocate ahd_tmode_tstate.  "
+		       "Failing attach\n", ahd_name(ahd));
+		return (ENOMEM);
+	}
+
+	for (targ = 0; targ < max_targ; targ++) {
+		struct	 ahd_devinfo devinfo;
+		struct	 ahd_initiator_tinfo *tinfo;
+		struct	 ahd_transinfo *user_tinfo;
+		struct	 ahd_tmode_tstate *tstate;
+		uint16_t target_mask;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    targ, &tstate);
+		user_tinfo = &tinfo->user;
+
+		/*
+		 * We support SPC2 and SPI4.
+		 */
+		tinfo->user.protocol_version = 4;
+		tinfo->user.transport_version = 4;
+
+		target_mask = 0x01 << targ;
+		ahd->user_discenable &= ~target_mask;
+		tstate->discenable &= ~target_mask;
+		ahd->user_tagenable &= ~target_mask;
+		if (sc->device_flags[targ] & CFDISC) {
+			tstate->discenable |= target_mask;
+			ahd->user_discenable |= target_mask;
+			ahd->user_tagenable |= target_mask;
+		} else {
+			/*
+			 * Cannot be packetized without disconnection.
+			 */
+			sc->device_flags[targ] &= ~CFPACKETIZED;
+		}
+
+		user_tinfo->ppr_options = 0;
+		user_tinfo->period = (sc->device_flags[targ] & CFXFER);
+		if (user_tinfo->period < CFXFER_ASYNC) {
+			if (user_tinfo->period <= AHD_PERIOD_10MHz)
+				user_tinfo->ppr_options |= MSG_EXT_PPR_DT_REQ;
+			user_tinfo->offset = MAX_OFFSET;
+		} else  {
+			user_tinfo->offset = 0;
+			user_tinfo->period = AHD_PERIOD_ASYNC;
+		}
+#ifdef AHD_FORCE_160
+		if (user_tinfo->period <= AHD_SYNCRATE_160)
+			user_tinfo->period = AHD_SYNCRATE_DT;
+#endif
+
+		if ((sc->device_flags[targ] & CFPACKETIZED) != 0)
+			user_tinfo->ppr_options |= MSG_EXT_PPR_RD_STRM
+						|  MSG_EXT_PPR_WR_FLOW
+						|  MSG_EXT_PPR_HOLD_MCS
+						|  MSG_EXT_PPR_IU_REQ;
+
+		if ((sc->device_flags[targ] & CFQAS) != 0)
+			user_tinfo->ppr_options |= MSG_EXT_PPR_QAS_REQ;
+
+		if ((sc->device_flags[targ] & CFWIDEB) != 0)
+			user_tinfo->width = MSG_EXT_WDTR_BUS_16_BIT;
+		else
+			user_tinfo->width = MSG_EXT_WDTR_BUS_8_BIT;
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("(%d): %x:%x:%x:%x\n", targ, user_tinfo->width,
+			       user_tinfo->period, user_tinfo->offset,
+			       user_tinfo->ppr_options);
+#endif
+		/*
+		 * Start out Async/Narrow/Untagged and with
+		 * conservative protocol support.
+		 */
+		tstate->tagenable &= ~target_mask;
+		tinfo->goal.protocol_version = 2;
+		tinfo->goal.transport_version = 2;
+		tinfo->curr.protocol_version = 2;
+		tinfo->curr.transport_version = 2;
+		ahd_compile_devinfo(&devinfo, ahd->our_id,
+				    targ, CAM_LUN_WILDCARD,
+				    'A', ROLE_INITIATOR);
+		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
+		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
+				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+		/*
+		 * The neg table must be initialized even if the
+		 * new settings above are the same as those from
+		 * when our xfer info data structures were allocated
+		 * and initialized.
+		 */
+		ahd_update_neg_table(ahd, &devinfo, &tinfo->curr);
+	}
+
+	ahd->flags &= ~AHD_SPCHK_ENB_A;
+	if (sc->bios_control & CFSPARITY)
+		ahd->flags |= AHD_SPCHK_ENB_A;
+
+	ahd->flags &= ~AHD_RESET_BUS_A;
+	if (sc->bios_control & CFRESETB)
+		ahd->flags |= AHD_RESET_BUS_A;
+
+	ahd->flags &= ~AHD_EXTENDED_TRANS_A;
+	if (sc->bios_control & CFEXTEND)
+		ahd->flags |= AHD_EXTENDED_TRANS_A;
+
+	ahd->flags &= ~AHD_BIOS_ENABLED;
+	if ((sc->bios_control & CFBIOSSTATE) == CFBS_ENABLED)
+		ahd->flags |= AHD_BIOS_ENABLED;
+
+	ahd->flags &= ~AHD_STPWLEVEL_A;
+	if ((sc->adapter_control & CFSTPWLEVEL) != 0)
+		ahd->flags |= AHD_STPWLEVEL_A;
+
+	return (0);
+}
+
+void
+ahd_intr_enable(struct ahd_softc *ahd, int enable)
+{
+	u_int hcntrl;
+
+	hcntrl = ahd_inb(ahd, HCNTRL);
+	hcntrl &= ~INTEN;
+	ahd->pause &= ~INTEN;
+	ahd->unpause &= ~INTEN;
+	if (enable) {
+		hcntrl |= INTEN;
+		ahd->pause |= INTEN;
+		ahd->unpause |= INTEN;
+	}
+	ahd_outb(ahd, HCNTRL, hcntrl);
+}
+
+/*
+ * Ensure that the card is paused in a location
+ * outside of all critical sections and that all
+ * pending work is completed prior to returning.
+ * This routine should only be called from outside
+ * an interrupt context.
+ */
+void
+ahd_pause_and_flushwork(struct ahd_softc *ahd)
+{
+	int intstat;
+	int maxloops;
+
+	maxloops = 1000;
+	ahd->flags |= AHD_ALL_INTERRUPTS;
+	intstat = 0;
+	do {
+		ahd_intr(ahd);
+		ahd_pause(ahd);
+		ahd_clear_critical_section(ahd);
+		if (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0)
+			break;
+		maxloops--;
+	} while (((intstat = ahd_inb(ahd, INTSTAT)) & INT_PEND) && --maxloops);
+	if (maxloops == 0) {
+		printf("Infinite interrupt loop, INTSTAT = %x",
+		      ahd_inb(ahd, INTSTAT));
+	}
+	ahd_platform_flushwork(ahd);
+	ahd->flags &= ~AHD_ALL_INTERRUPTS;
+}
+
+int
+ahd_suspend(struct ahd_softc *ahd)
+{
+#if 0
+	uint8_t *ptr;
+	int	 i;
+
+	ahd_pause_and_flushwork(ahd);
+
+	if (LIST_FIRST(&ahd->pending_scbs) != NULL)
+		return (EBUSY);
+
+#if AHD_TARGET_MODE
+	/*
+	 * XXX What about ATIOs that have not yet been serviced?
+	 * Perhaps we should just refuse to be suspended if we
+	 * are acting in a target role.
+	 */
+	if (ahd->pending_device != NULL)
+		return (EBUSY);
+#endif
+
+	/* Save volatile registers */
+	ahd->suspend_state.channel[0].scsiseq = ahd_inb(ahd, SCSISEQ0);
+	ahd->suspend_state.channel[0].sxfrctl0 = ahd_inb(ahd, SXFRCTL0);
+	ahd->suspend_state.channel[0].sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
+	ahd->suspend_state.channel[0].simode0 = ahd_inb(ahd, SIMODE0);
+	ahd->suspend_state.channel[0].simode1 = ahd_inb(ahd, SIMODE1);
+	ahd->suspend_state.channel[0].seltimer = ahd_inb(ahd, SELTIMER);
+	ahd->suspend_state.channel[0].seqctl = ahd_inb(ahd, SEQCTL0);
+	ahd->suspend_state.dscommand0 = ahd_inb(ahd, DSCOMMAND0);
+	ahd->suspend_state.dspcistatus = ahd_inb(ahd, DSPCISTATUS);
+
+	if ((ahd->features & AHD_DT) != 0) {
+		u_int sfunct;
+
+		sfunct = ahd_inb(ahd, SFUNCT) & ~ALT_MODE;
+		ahd_outb(ahd, SFUNCT, sfunct | ALT_MODE);
+		ahd->suspend_state.optionmode = ahd_inb(ahd, OPTIONMODE);
+		ahd_outb(ahd, SFUNCT, sfunct);
+		ahd->suspend_state.crccontrol1 = ahd_inb(ahd, CRCCONTROL1);
+	}
+
+	if ((ahd->features & AHD_MULTI_FUNC) != 0)
+		ahd->suspend_state.scbbaddr = ahd_inb(ahd, SCBBADDR);
+
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		ahd->suspend_state.dff_thrsh = ahd_inb(ahd, DFF_THRSH);
+
+	ptr = ahd->suspend_state.scratch_ram;
+	for (i = 0; i < 64; i++)
+		*ptr++ = ahd_inb(ahd, SRAM_BASE + i);
+
+	if ((ahd->features & AHD_MORE_SRAM) != 0) {
+		for (i = 0; i < 16; i++)
+			*ptr++ = ahd_inb(ahd, TARG_OFFSET + i);
+	}
+
+	ptr = ahd->suspend_state.btt;
+	for (i = 0;i < AHD_NUM_TARGETS; i++) {
+		int j;
+
+		for (j = 0;j < AHD_NUM_LUNS_NONPKT; j++) {
+			u_int tcl;
+
+			tcl = BUILD_TCL_RAW(i, 'A', j);
+			*ptr = ahd_find_busy_tcl(ahd, tcl);
+		}
+	}
+	ahd_shutdown(ahd);
+#endif
+	return (0);
+}
+
+int
+ahd_resume(struct ahd_softc *ahd)
+{
+#if 0
+	uint8_t *ptr;
+	int	 i;
+
+	ahd_reset(ahd);
+
+	ahd_build_free_scb_list(ahd);
+
+	/* Restore volatile registers */
+	ahd_outb(ahd, SCSISEQ0, ahd->suspend_state.channel[0].scsiseq);
+	ahd_outb(ahd, SXFRCTL0, ahd->suspend_state.channel[0].sxfrctl0);
+	ahd_outb(ahd, SXFRCTL1, ahd->suspend_state.channel[0].sxfrctl1);
+	ahd_outb(ahd, SIMODE0, ahd->suspend_state.channel[0].simode0);
+	ahd_outb(ahd, SIMODE1, ahd->suspend_state.channel[0].simode1);
+	ahd_outb(ahd, SELTIMER, ahd->suspend_state.channel[0].seltimer);
+	ahd_outb(ahd, SEQCTL0, ahd->suspend_state.channel[0].seqctl);
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		ahd_outb(ahd, SCSIID_ULTRA2, ahd->our_id);
+	else
+		ahd_outb(ahd, SCSIID, ahd->our_id);
+
+	ahd_outb(ahd, DSCOMMAND0, ahd->suspend_state.dscommand0);
+	ahd_outb(ahd, DSPCISTATUS, ahd->suspend_state.dspcistatus);
+
+	if ((ahd->features & AHD_DT) != 0) {
+		u_int sfunct;
+
+		sfunct = ahd_inb(ahd, SFUNCT) & ~ALT_MODE;
+		ahd_outb(ahd, SFUNCT, sfunct | ALT_MODE);
+		ahd_outb(ahd, OPTIONMODE, ahd->suspend_state.optionmode);
+		ahd_outb(ahd, SFUNCT, sfunct);
+		ahd_outb(ahd, CRCCONTROL1, ahd->suspend_state.crccontrol1);
+	}
+
+	if ((ahd->features & AHD_MULTI_FUNC) != 0)
+		ahd_outb(ahd, SCBBADDR, ahd->suspend_state.scbbaddr);
+
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		ahd_outb(ahd, DFF_THRSH, ahd->suspend_state.dff_thrsh);
+
+	ptr = ahd->suspend_state.scratch_ram;
+	for (i = 0; i < 64; i++)
+		ahd_outb(ahd, SRAM_BASE + i, *ptr++);
+
+	if ((ahd->features & AHD_MORE_SRAM) != 0) {
+		for (i = 0; i < 16; i++)
+			ahd_outb(ahd, TARG_OFFSET + i, *ptr++);
+	}
+
+	ptr = ahd->suspend_state.btt;
+	for (i = 0;i < AHD_NUM_TARGETS; i++) {
+		int j;
+
+		for (j = 0;j < AHD_NUM_LUNS; j++) {
+			u_int tcl;
+
+			tcl = BUILD_TCL(i << 4, j);
+			ahd_busy_tcl(ahd, tcl, *ptr);
+		}
+	}
+#endif
+	return (0);
+}
+
+/************************** Busy Target Table *********************************/
+/*
+ * Set SCBPTR to the SCB that contains the busy
+ * table entry for TCL.  Return the offset into
+ * the SCB that contains the entry for TCL.
+ * saved_scbid is dereferenced and set to the
+ * scbid that should be restored once manipualtion
+ * of the TCL entry is complete.
+ */
+static __inline u_int
+ahd_index_busy_tcl(struct ahd_softc *ahd, u_int *saved_scbid, u_int tcl)
+{
+	/*
+	 * Index to the SCB that contains the busy entry.
+	 */
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	*saved_scbid = ahd_get_scbptr(ahd);
+	ahd_set_scbptr(ahd, TCL_LUN(tcl)
+		     | ((TCL_TARGET_OFFSET(tcl) & 0xC) << 4));
+
+	/*
+	 * And now calculate the SCB offset to the entry.
+	 * Each entry is 2 bytes wide, hence the
+	 * multiplication by 2.
+	 */
+	return (((TCL_TARGET_OFFSET(tcl) & 0x3) << 1) + SCB_DISCONNECTED_LISTS);
+}
+
+/*
+ * Return the untagged transaction id for a given target/channel lun.
+ * Optionally, clear the entry.
+ */
+u_int
+ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl)
+{
+	u_int scbid;
+	u_int scb_offset;
+	u_int saved_scbptr;
+		
+	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
+	scbid = ahd_inw_scbram(ahd, scb_offset);
+	ahd_set_scbptr(ahd, saved_scbptr);
+	return (scbid);
+}
+
+void
+ahd_busy_tcl(struct ahd_softc *ahd, u_int tcl, u_int scbid)
+{
+	u_int scb_offset;
+	u_int saved_scbptr;
+		
+	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
+	ahd_outw(ahd, scb_offset, scbid);
+	ahd_set_scbptr(ahd, saved_scbptr);
+}
+
+/************************** SCB and SCB queue management **********************/
+int
+ahd_match_scb(struct ahd_softc *ahd, struct scb *scb, int target,
+	      char channel, int lun, u_int tag, role_t role)
+{
+	int targ = SCB_GET_TARGET(ahd, scb);
+	char chan = SCB_GET_CHANNEL(ahd, scb);
+	int slun = SCB_GET_LUN(scb);
+	int match;
+
+	match = ((chan == channel) || (channel == ALL_CHANNELS));
+	if (match != 0)
+		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
+	if (match != 0)
+		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
+	if (match != 0) {
+#if AHD_TARGET_MODE
+		int group;
+
+		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
+		if (role == ROLE_INITIATOR) {
+			match = (group != XPT_FC_GROUP_TMODE)
+			      && ((tag == SCB_GET_TAG(scb))
+			       || (tag == SCB_LIST_NULL));
+		} else if (role == ROLE_TARGET) {
+			match = (group == XPT_FC_GROUP_TMODE)
+			      && ((tag == scb->io_ctx->csio.tag_id)
+			       || (tag == SCB_LIST_NULL));
+		}
+#else /* !AHD_TARGET_MODE */
+		match = ((tag == SCB_GET_TAG(scb)) || (tag == SCB_LIST_NULL));
+#endif /* AHD_TARGET_MODE */
+	}
+
+	return match;
+}
+
+void
+ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
+{
+	int	target;
+	char	channel;
+	int	lun;
+
+	target = SCB_GET_TARGET(ahd, scb);
+	lun = SCB_GET_LUN(scb);
+	channel = SCB_GET_CHANNEL(ahd, scb);
+	
+	ahd_search_qinfifo(ahd, target, channel, lun,
+			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
+			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+
+	ahd_platform_freeze_devq(ahd, scb);
+}
+
+void
+ahd_qinfifo_requeue_tail(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct scb *prev_scb;
+
+	prev_scb = NULL;
+	if (ahd_qinfifo_count(ahd) != 0) {
+		u_int prev_tag;
+		u_int prev_pos;
+
+		prev_pos = AHD_QIN_WRAP(ahd->qinfifonext - 1);
+		prev_tag = ahd->qinfifo[prev_pos];
+		prev_scb = ahd_lookup_scb(ahd, prev_tag);
+	}
+	ahd_qinfifo_requeue(ahd, prev_scb, scb);
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+}
+
+static void
+ahd_qinfifo_requeue(struct ahd_softc *ahd, struct scb *prev_scb,
+		    struct scb *scb)
+{
+	if (prev_scb == NULL) {
+		uint32_t busaddr;
+
+		busaddr = ahd_le32toh(scb->hscb->hscb_busaddr);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+	} else {
+		prev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
+		ahd_sync_scb(ahd, prev_scb, 
+			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+	}
+	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
+	ahd->qinfifonext++;
+	scb->hscb->next_hscb_busaddr = ahd->next_queued_hscb->hscb_busaddr;
+	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+}
+
+static int
+ahd_qinfifo_count(struct ahd_softc *ahd)
+{
+	u_int qinpos;
+	u_int wrap_qinpos;
+	u_int wrap_qinfifonext;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	qinpos = ahd_get_snscb_qoff(ahd);
+	wrap_qinpos = AHD_QIN_WRAP(qinpos);
+	wrap_qinfifonext = AHD_QIN_WRAP(ahd->qinfifonext);
+	if (wrap_qinfifonext > wrap_qinpos)
+		return (wrap_qinfifonext - wrap_qinpos);
+	else
+		return (wrap_qinfifonext
+		      + NUM_ELEMENTS(ahd->qinfifo) - wrap_qinpos);
+}
+
+int
+ahd_search_qinfifo(struct ahd_softc *ahd, int target, char channel,
+		   int lun, u_int tag, role_t role, uint32_t status,
+		   ahd_search_action action)
+{
+	struct scb	*scb;
+	struct scb	*prev_scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 qinstart;
+	u_int		 qinpos;
+	u_int		 qintail;
+	u_int		 tid_next;
+	u_int		 tid_prev;
+	u_int		 scbid;
+	u_int		 savedscbptr;
+	uint32_t	 busaddr;
+	int		 found;
+	int		 targets;
+
+	/* Must be in CCHAN mode */
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+
+	/*
+	 * Halt any pending SCB DMA.  The sequencer will reinitiate
+	 * this dma if the qinfifo is not empty once we unpause.
+	 */
+	if ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN|CCSCBDIR))
+	 == (CCARREN|CCSCBEN|CCSCBDIR)) {
+		ahd_outb(ahd, CCSCBCTL,
+			 ahd_inb(ahd, CCSCBCTL) & ~(CCARREN|CCSCBEN));
+		while ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0)
+			;
+	}
+	/* Determine sequencer's position in the qinfifo. */
+	qintail = AHD_QIN_WRAP(ahd->qinfifonext);
+	qinstart = ahd_get_snscb_qoff(ahd);
+	qinpos = AHD_QIN_WRAP(qinstart);
+	found = 0;
+	prev_scb = NULL;
+
+	if (action == SEARCH_PRINT) {
+		printf("qinstart = %d qinfifonext = %d\nQINFIFO:",
+		       qinstart, ahd->qinfifonext);
+	}
+
+	/*
+	 * Start with an empty queue.  Entries that are not chosen
+	 * for removal will be re-added to the queue as we go.
+	 */
+	ahd->qinfifonext = qinstart;
+	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+
+	while (qinpos != qintail) {
+		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
+		if (scb == NULL) {
+			printf("qinpos = %d, SCB index = %d\n",
+				qinpos, ahd->qinfifo[qinpos]);
+			panic("Loop 1\n");
+		}
+
+		if (ahd_match_scb(ahd, scb, target, channel, lun, tag, role)) {
+			/*
+			 * We found an scb that needs to be acted on.
+			 */
+			found++;
+			switch (action) {
+			case SEARCH_COMPLETE:
+			{
+				cam_status ostat;
+				cam_status cstat;
+
+				ostat = ahd_get_transaction_status(scb);
+				if (ostat == CAM_REQ_INPROG)
+					ahd_set_transaction_status(scb,
+								   status);
+				cstat = ahd_get_transaction_status(scb);
+				if (cstat != CAM_REQ_CMP)
+					ahd_freeze_scb(scb);
+				if ((scb->flags & SCB_ACTIVE) == 0)
+					printf("Inactive SCB in qinfifo\n");
+				ahd_done(ahd, scb);
+
+				/* FALLTHROUGH */
+			}
+			case SEARCH_REMOVE:
+				break;
+			case SEARCH_PRINT:
+				printf(" 0x%x", ahd->qinfifo[qinpos]);
+				/* FALLTHROUGH */
+			case SEARCH_COUNT:
+				ahd_qinfifo_requeue(ahd, prev_scb, scb);
+				prev_scb = scb;
+				break;
+			}
+		} else {
+			ahd_qinfifo_requeue(ahd, prev_scb, scb);
+			prev_scb = scb;
+		}
+		qinpos = AHD_QIN_WRAP(qinpos+1);
+	}
+
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+
+	if (action == SEARCH_PRINT)
+		printf("\nWAITING_TID_QUEUES:\n");
+
+	/*
+	 * Search waiting for selection lists.  We traverse the
+	 * list of "their ids" waiting for selection and, if
+	 * appropriate, traverse the SCBs of each "their id"
+	 * looking for matches.
+	 */
+	savedscbptr = ahd_get_scbptr(ahd);
+	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
+	tid_prev = SCB_LIST_NULL;
+	targets = 0;
+	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
+		u_int tid_head;
+
+		/*
+		 * We limit based on the number of SCBs since
+		 * MK_MESSAGE SCBs are not in the per-tid lists.
+		 */
+		targets++;
+		if (targets > AHD_SCB_MAX) {
+			panic("TID LIST LOOP");
+		}
+		if (scbid >= ahd->scb_data.numscbs) {
+			printf("%s: Waiting TID List inconsistency. "
+			       "SCB index == 0x%x, yet numscbs == 0x%x.",
+			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
+			ahd_dump_card_state(ahd);
+			panic("for safety");
+		}
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: SCB = 0x%x Not Active!\n",
+			       ahd_name(ahd), scbid);
+			panic("Waiting TID List traversal\n");
+		}
+		ahd_set_scbptr(ahd, scbid);
+		tid_next = ahd_inw_scbram(ahd, SCB_NEXT2);
+		if (ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,
+				  SCB_LIST_NULL, ROLE_UNKNOWN) == 0) {
+			tid_prev = scbid;
+			continue;
+		}
+
+		/*
+		 * We found a list of scbs that needs to be searched.
+		 */
+		if (action == SEARCH_PRINT)
+			printf("       %d ( ", SCB_GET_TARGET(ahd, scb));
+		tid_head = scbid;
+		found += ahd_search_scb_list(ahd, target, channel,
+					     lun, tag, role, status,
+					     action, &tid_head,
+					     SCB_GET_TARGET(ahd, scb));
+		if (tid_head != scbid)
+			ahd_stitch_tid_list(ahd, tid_prev, tid_head, tid_next);
+		if (!SCBID_IS_NULL(tid_head))
+			tid_prev = tid_head;
+		if (action == SEARCH_PRINT)
+			printf(")\n");
+	}
+	ahd_set_scbptr(ahd, savedscbptr);
+
+	ahd_restore_modes(ahd, saved_modes);
+	return (found);
+}
+
+static int
+ahd_search_scb_list(struct ahd_softc *ahd, int target, char channel,
+		    int lun, u_int tag, role_t role, uint32_t status,
+		    ahd_search_action action, u_int *list_head, u_int tid)
+{
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	next;
+	u_int	prev;
+	int	found;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	found = 0;
+	prev = SCB_LIST_NULL;
+	next = *list_head;
+	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
+		if (scbid >= ahd->scb_data.numscbs) {
+			printf("%s:SCB List inconsistency. "
+			       "SCB == 0x%x, yet numscbs == 0x%x.",
+			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
+			ahd_dump_card_state(ahd);
+			panic("for safety");
+		}
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: SCB = %d Not Active!\n",
+			       ahd_name(ahd), scbid);
+			panic("Waiting List traversal\n");
+		}
+		ahd_set_scbptr(ahd, scbid);
+		next = ahd_inw_scbram(ahd, SCB_NEXT);
+		if (ahd_match_scb(ahd, scb, target, channel,
+				  lun, SCB_LIST_NULL, role) == 0) {
+			prev = scbid;
+			continue;
+		}
+		found++;
+		switch (action) {
+		case SEARCH_COMPLETE:
+		{
+			cam_status ostat;
+			cam_status cstat;
+
+			ostat = ahd_get_transaction_status(scb);
+			if (ostat == CAM_REQ_INPROG)
+				ahd_set_transaction_status(scb, status);
+			cstat = ahd_get_transaction_status(scb);
+			if (cstat != CAM_REQ_CMP)
+				ahd_freeze_scb(scb);
+			if ((scb->flags & SCB_ACTIVE) == 0)
+				printf("Inactive SCB in Waiting List\n");
+			ahd_done(ahd, scb);
+			/* FALLTHROUGH */
+		}
+		case SEARCH_REMOVE:
+			ahd_rem_wscb(ahd, scbid, prev, next, tid);
+			if (prev == SCB_LIST_NULL)
+				*list_head = next;
+			break;
+		case SEARCH_PRINT:
+			printf("0x%x ", scbid);
+		case SEARCH_COUNT:
+			prev = scbid;
+			break;
+		}
+		if (found > AHD_SCB_MAX)
+			panic("SCB LIST LOOP");
+	}
+	return (found);
+}
+
+static void
+ahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,
+		    u_int tid_cur, u_int tid_next)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+
+	if (SCBID_IS_NULL(tid_cur)) {
+
+		/* Bypass current TID list */
+		if (SCBID_IS_NULL(tid_prev)) {
+			ahd_outw(ahd, WAITING_TID_HEAD, tid_next);
+		} else {
+			ahd_set_scbptr(ahd, tid_prev);
+			ahd_outw(ahd, SCB_NEXT2, tid_next);
+		}
+		if (SCBID_IS_NULL(tid_next))
+			ahd_outw(ahd, WAITING_TID_TAIL, tid_prev);
+	} else {
+
+		/* Stitch through tid_cur */
+		if (SCBID_IS_NULL(tid_prev)) {
+			ahd_outw(ahd, WAITING_TID_HEAD, tid_cur);
+		} else {
+			ahd_set_scbptr(ahd, tid_prev);
+			ahd_outw(ahd, SCB_NEXT2, tid_cur);
+		}
+		ahd_set_scbptr(ahd, tid_cur);
+		ahd_outw(ahd, SCB_NEXT2, tid_next);
+
+		if (SCBID_IS_NULL(tid_next))
+			ahd_outw(ahd, WAITING_TID_TAIL, tid_cur);
+	}
+}
+
+/*
+ * Manipulate the waiting for selection list and return the
+ * scb that follows the one that we remove.
+ */
+static u_int
+ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
+	     u_int prev, u_int next, u_int tid)
+{
+	u_int tail_offset;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	if (!SCBID_IS_NULL(prev)) {
+		ahd_set_scbptr(ahd, prev);
+		ahd_outw(ahd, SCB_NEXT, next);
+	}
+
+	/*
+	 * SCBs that had MK_MESSAGE set in them will not
+	 * be queued to the per-target lists, so don't
+	 * blindly clear the tail pointer.
+	 */
+	tail_offset = WAITING_SCB_TAILS + (2 * tid);
+	if (SCBID_IS_NULL(next)
+	 && ahd_inw(ahd, tail_offset) == scbid)
+		ahd_outw(ahd, tail_offset, prev);
+	ahd_add_scb_to_free_list(ahd, scbid);
+	return (next);
+}
+
+/*
+ * Add the SCB as selected by SCBPTR onto the on chip list of
+ * free hardware SCBs.  This list is empty/unused if we are not
+ * performing SCB paging.
+ */
+static void
+ahd_add_scb_to_free_list(struct ahd_softc *ahd, u_int scbid)
+{
+/* XXX Need some other mechanism to designate "free". */
+	/*
+	 * Invalidate the tag so that our abort
+	 * routines don't think it's active.
+	ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL);
+	 */
+}
+
+/******************************** Error Handling ******************************/
+/*
+ * Abort all SCBs that match the given description (target/channel/lun/tag),
+ * setting their status to the passed in status if the status has not already
+ * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
+ * is paused before it is called.
+ */
+int
+ahd_abort_scbs(struct ahd_softc *ahd, int target, char channel,
+	       int lun, u_int tag, role_t role, uint32_t status)
+{
+	struct		scb *scbp;
+	struct		scb *scbp_next;
+	u_int		active_scb;
+	u_int		i, j;
+	u_int		maxtarget;
+	u_int		minlun;
+	u_int		maxlun;
+	int		found;
+	ahd_mode_state	saved_modes;
+
+	/* restore these when we're done */
+	active_scb = ahd_get_scbptr(ahd);
+	saved_modes = ahd_save_modes(ahd);
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	found = ahd_search_qinfifo(ahd, target, channel, lun, SCB_LIST_NULL,
+				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+
+	/*
+	 * Clean out the busy target table for any untagged commands.
+	 */
+	i = 0;
+	maxtarget = 16;
+	if (target != CAM_TARGET_WILDCARD) {
+		i = target;
+		if (channel == 'B')
+			i += 8;
+		maxtarget = i + 1;
+	}
+
+	if (lun == CAM_LUN_WILDCARD) {
+		minlun = 0;
+		maxlun = AHD_NUM_LUNS_NONPKT;
+	} else if (lun >= AHD_NUM_LUNS_NONPKT) {
+		minlun = maxlun = 0;
+	} else {
+		minlun = lun;
+		maxlun = lun + 1;
+	}
+
+	if (role != ROLE_TARGET) {
+		for (;i < maxtarget; i++) {
+			for (j = minlun;j < maxlun; j++) {
+				u_int scbid;
+				u_int tcl;
+
+				tcl = BUILD_TCL_RAW(i, 'A', j);
+				scbid = ahd_find_busy_tcl(ahd, tcl);
+				scbp = ahd_lookup_scb(ahd, scbid);
+				if (scbp == NULL
+				 || ahd_match_scb(ahd, scbp, target, channel,
+						  lun, tag, role) == 0)
+					continue;
+				ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(i, 'A', j));
+			}
+		}
+	}
+
+	/*
+	 * Go through the pending CCB list and look for
+	 * commands for this target that are still active.
+	 * These are other tagged commands that were
+	 * disconnected when the reset occurred.
+	 */
+	scbp_next = LIST_FIRST(&ahd->pending_scbs);
+	while (scbp_next != NULL) {
+		scbp = scbp_next;
+		scbp_next = LIST_NEXT(scbp, pending_links);
+		if (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {
+			cam_status ostat;
+
+			ostat = ahd_get_transaction_status(scbp);
+			if (ostat == CAM_REQ_INPROG)
+				ahd_set_transaction_status(scbp, status);
+			if (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)
+				ahd_freeze_scb(scbp);
+			if ((scbp->flags & SCB_ACTIVE) == 0)
+				printf("Inactive SCB on pending list\n");
+			ahd_done(ahd, scbp);
+			found++;
+		}
+	}
+	ahd_set_scbptr(ahd, active_scb);
+	ahd_restore_modes(ahd, saved_modes);
+	ahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status);
+	return found;
+}
+
+static void
+ahd_reset_current_bus(struct ahd_softc *ahd)
+{
+	uint8_t scsiseq;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) & ~ENSCSIRST);
+	scsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);
+	ahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);
+	ahd_delay(AHD_BUSRESET_DELAY);
+	/* Turn off the bus reset */
+	ahd_outb(ahd, SCSISEQ0, scsiseq);
+	if ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {
+		/*
+		 * 2A Razor #474
+		 * Certain chip state is not cleared for
+		 * SCSI bus resets that we initiate, so
+		 * we must reset the chip.
+		 */
+		ahd_delay(AHD_BUSRESET_DELAY);
+		ahd_reset(ahd);
+		ahd_intr_enable(ahd, /*enable*/TRUE);
+		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	}
+
+	ahd_clear_intstat(ahd);
+}
+
+int
+ahd_reset_channel(struct ahd_softc *ahd, char channel, int initiate_reset)
+{
+	struct	ahd_devinfo devinfo;
+	u_int	initiator;
+	u_int	target;
+	u_int	max_scsiid;
+	int	found;
+	u_int	fifo;
+	u_int	next_fifo;
+
+	ahd->pending_device = NULL;
+
+	ahd_compile_devinfo(&devinfo,
+			    CAM_TARGET_WILDCARD,
+			    CAM_TARGET_WILDCARD,
+			    CAM_LUN_WILDCARD,
+			    channel, ROLE_UNKNOWN);
+	ahd_pause(ahd);
+
+	/* Make sure the sequencer is in a safe location. */
+	ahd_clear_critical_section(ahd);
+
+	/*
+	 * Run our command complete fifos to ensure that we perform
+	 * completion processing on any commands that 'completed'
+	 * before the reset occurred.
+	 */
+	ahd_run_qoutfifo(ahd);
+#if AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		ahd_run_tqinfifo(ahd, /*paused*/TRUE);
+	}
+#endif
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	/*
+	 * Disable selections so no automatic hardware
+	 * functions will modify chip state.
+	 */
+	ahd_outb(ahd, SCSISEQ0, 0);
+	ahd_outb(ahd, SCSISEQ1, 0);
+
+	/*
+	 * Safely shut down our DMA engines.  Always start with
+	 * the FIFO that is not currently active (if any are
+	 * actively connected).
+	 */
+	next_fifo = fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
+	do {
+		next_fifo = next_fifo ^ CURRFIFO;
+		ahd_set_modes(ahd, next_fifo, next_fifo);
+		ahd_outb(ahd, DFCNTRL,
+			 ahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));
+		while ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)
+			ahd_delay(10);
+		/*
+		 * Set CURRFIFO to the now inactive channel.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		ahd_outb(ahd, DFFSTAT, next_fifo);
+	} while (next_fifo != fifo);
+	
+	/*
+	 * Reset the bus if we are initiating this reset
+	 */
+	ahd_clear_msg_state(ahd);
+	ahd_outb(ahd, SIMODE1,
+		 ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST|ENBUSFREE));
+	if (initiate_reset)
+		ahd_reset_current_bus(ahd);
+	ahd_clear_intstat(ahd);
+
+	/*
+	 * Clean up all the state information for the
+	 * pending transactions on this bus.
+	 */
+	found = ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, channel,
+			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
+			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
+
+	/*
+	 * Cleanup anything left in the FIFOs.
+	 */
+	ahd_clear_fifo(ahd, 0);
+	ahd_clear_fifo(ahd, 1);
+
+	/*
+	 * Revert to async/narrow transfers until we renegotiate.
+	 */
+	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
+	for (target = 0; target <= max_scsiid; target++) {
+
+		if (ahd->enabled_targets[target] == NULL)
+			continue;
+		for (initiator = 0; initiator <= max_scsiid; initiator++) {
+			struct ahd_devinfo devinfo;
+
+			ahd_compile_devinfo(&devinfo, target, initiator,
+					    CAM_LUN_WILDCARD,
+					    'A', ROLE_UNKNOWN);
+			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_CUR, /*paused*/TRUE);
+			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
+					 /*offset*/0, /*ppr_options*/0,
+					 AHD_TRANS_CUR, /*paused*/TRUE);
+		}
+	}
+
+#ifdef AHD_TARGET_MODE
+	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
+
+	/*
+	 * Send an immediate notify ccb to all target more peripheral
+	 * drivers affected by this action.
+	 */
+	for (target = 0; target <= max_scsiid; target++) {
+		struct ahd_tmode_tstate* tstate;
+		u_int lun;
+
+		tstate = ahd->enabled_targets[target];
+		if (tstate == NULL)
+			continue;
+		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[lun];
+			if (lstate == NULL)
+				continue;
+
+			ahd_queue_lstate_event(ahd, lstate, CAM_TARGET_WILDCARD,
+					       EVENT_TYPE_BUS_RESET, /*arg*/0);
+			ahd_send_lstate_events(ahd, lstate);
+		}
+	}
+#endif
+	/* Notify the XPT that a bus reset occurred */
+	ahd_send_async(ahd, devinfo.channel, CAM_TARGET_WILDCARD,
+		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
+	ahd_restart(ahd);
+	/*
+	 * Freeze the SIMQ until our poller can determine that
+	 * the bus reset has really gone away.  We set the initial
+	 * timer to 0 to have the check performed as soon as possible
+	 * from the timer context.
+	 */
+	if ((ahd->flags & AHD_RESET_POLL_ACTIVE) == 0) {
+		ahd->flags |= AHD_RESET_POLL_ACTIVE;
+		ahd_freeze_simq(ahd);
+		ahd_timer_reset(&ahd->reset_timer, 0, ahd_reset_poll, ahd);
+	}
+	return (found);
+}
+
+
+#define AHD_RESET_POLL_US 1000
+static void
+ahd_reset_poll(void *arg)
+{
+	struct	ahd_softc *ahd;
+	u_int	scsiseq1;
+	u_long	l;
+	u_long	s;
+	
+	ahd_list_lock(&l);
+	ahd = ahd_find_softc((struct ahd_softc *)arg);
+	if (ahd == NULL) {
+		printf("ahd_reset_poll: Instance %p no longer exists\n", arg);
+		ahd_list_unlock(&l);
+		return;
+	}
+	ahd_lock(ahd, &s);
+	ahd_pause(ahd);
+	ahd_update_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
+	if ((ahd_inb(ahd, SSTAT1) & SCSIRSTI) != 0) {
+		ahd_timer_reset(&ahd->reset_timer, AHD_RESET_POLL_US,
+				ahd_reset_poll, ahd);
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+		ahd_list_unlock(&l);
+		return;
+	}
+
+	/* Reset is now low.  Complete chip reinitialization. */
+	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) | ENSCSIRST);
+	scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+	ahd_outb(ahd, SCSISEQ1, scsiseq1 & (ENSELI|ENRSELI|ENAUTOATNP));
+	ahd_unpause(ahd);
+	ahd->flags &= ~AHD_RESET_POLL_ACTIVE;
+	ahd_unlock(ahd, &s);
+	ahd_release_simq(ahd);
+	ahd_list_unlock(&l);
+}
+
+
+/****************************** Status Processing *****************************/
+void
+ahd_handle_scb_status(struct ahd_softc *ahd, struct scb *scb)
+{
+	if (scb->hscb->shared_data.istatus.scsi_status != 0) {
+		ahd_handle_scsi_status(ahd, scb);
+	} else {
+		ahd_calc_residual(ahd, scb);
+		ahd_done(ahd, scb);
+	}
+}
+
+void
+ahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	u_int  qfreeze_cnt;
+	ahd_mode_state saved_modes;
+
+	/*
+	 * The sequencer freezes its select-out queue
+	 * anytime a SCSI status error occurs.  We must
+	 * handle the error and decrement the QFREEZE count
+	 * to allow the sequencer to continue.
+	 */
+	hscb = scb->hscb; 
+
+	/* Freeze the queue until the client sees the error. */
+	ahd_pause(ahd);
+	saved_modes = ahd_save_modes(ahd);
+	ahd_clear_critical_section(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_freeze_devq(ahd, scb);
+	ahd_freeze_scb(scb);
+	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
+	if (qfreeze_cnt == 0) {
+		printf("%s: Bad status with 0 qfreeze count!\n", ahd_name(ahd));
+	} else {
+		qfreeze_cnt--;
+		ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
+	}
+	if (qfreeze_cnt == 0)
+		ahd_outb(ahd, SEQ_FLAGS2,
+			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
+	ahd_unpause(ahd);
+	/* Don't want to clobber the original sense code */
+	if ((scb->flags & SCB_SENSE) != 0) {
+		/*
+		 * Clear the SCB_SENSE Flag and perform
+		 * a normal command completion.
+		 */
+		scb->flags &= ~SCB_SENSE;
+		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+		ahd_done(ahd, scb);
+		return;
+	}
+	ahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
+	ahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);
+	switch (hscb->shared_data.istatus.scsi_status) {
+	case STATUS_PKT_SENSE:
+	{
+		struct scsi_status_iu_header *siu;
+
+		ahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);
+		siu = (struct scsi_status_iu_header *)scb->sense_data;
+		ahd_set_scsi_status(scb, siu->status);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_SENSE) != 0)
+			ahd_print_path(ahd, scb);
+			printf("SCB 0x%x Received PKT Status of 0x%x\n",
+			       SCB_GET_TAG(scb), siu->status);
+			printf("\tflags = 0x%x, sense len = 0x%x, "
+			       "pktfail = 0x%x\n",
+			       siu->flags, scsi_4btoul(siu->sense_length),
+			       scsi_4btoul(siu->pkt_failures_length));
+#endif
+		if ((siu->flags & SIU_RSPVALID) != 0) {
+			ahd_print_path(ahd, scb);
+			if (scsi_4btoul(siu->pkt_failures_length) < 4) {
+				printf("Unable to parse pkt_failures\n");
+			} else {
+
+				switch (SIU_PKTFAIL_CODE(siu)) {
+				case SIU_PFC_NONE:
+					printf("No packet failure found\n");
+					break;
+				case SIU_PFC_CIU_FIELDS_INVALID:
+					printf("Invalid Command IU Field\n");
+					break;
+				case SIU_PFC_TMF_NOT_SUPPORTED:
+					printf("TMF not supportd\n");
+					break;
+				case SIU_PFC_TMF_FAILED:
+					printf("TMF failed\n");
+					break;
+				case SIU_PFC_INVALID_TYPE_CODE:
+					printf("Invalid L_Q Type code\n");
+					break;
+				case SIU_PFC_ILLEGAL_REQUEST:
+					printf("Illegal request\n");
+				default:
+					break;
+				}
+			}
+			if (siu->status == SCSI_STATUS_OK)
+				ahd_set_transaction_status(scb,
+							   CAM_REQ_CMP_ERR);
+		}
+		if ((siu->flags & SIU_SNSVALID) != 0) {
+			scb->flags |= SCB_PKT_SENSE;
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_SENSE) != 0)
+				printf("Sense data available\n");
+#endif
+		}
+		ahd_done(ahd, scb);
+		break;
+	}
+	case SCSI_STATUS_CMD_TERMINATED:
+	case SCSI_STATUS_CHECK_COND:
+	{
+		struct ahd_devinfo devinfo;
+		struct ahd_dma_seg *sg;
+		struct scsi_sense *sc;
+		struct ahd_initiator_tinfo *targ_info;
+		struct ahd_tmode_tstate *tstate;
+		struct ahd_transinfo *tinfo;
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_SENSE) {
+			ahd_print_path(ahd, scb);
+			printf("SCB %d: requests Check Status\n",
+			       SCB_GET_TAG(scb));
+		}
+#endif
+
+		if (ahd_perform_autosense(scb) == 0)
+			break;
+
+		ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
+				    SCB_GET_TARGET(ahd, scb),
+				    SCB_GET_LUN(scb),
+				    SCB_GET_CHANNEL(ahd, scb),
+				    ROLE_INITIATOR);
+		targ_info = ahd_fetch_transinfo(ahd,
+						devinfo.channel,
+						devinfo.our_scsiid,
+						devinfo.target,
+						&tstate);
+		tinfo = &targ_info->curr;
+		sg = scb->sg_list;
+		sc = (struct scsi_sense *)hscb->shared_data.idata.cdb;
+		/*
+		 * Save off the residual if there is one.
+		 */
+		ahd_update_residual(ahd, scb);
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_SENSE) {
+			ahd_print_path(ahd, scb);
+			printf("Sending Sense\n");
+		}
+#endif
+		scb->sg_count = 0;
+		sg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),
+				  ahd_get_sense_bufsize(ahd, scb),
+				  /*last*/TRUE);
+		sc->opcode = REQUEST_SENSE;
+		sc->byte2 = 0;
+		if (tinfo->protocol_version <= SCSI_REV_2
+		 && SCB_GET_LUN(scb) < 8)
+			sc->byte2 = SCB_GET_LUN(scb) << 5;
+		sc->unused[0] = 0;
+		sc->unused[1] = 0;
+		sc->length = ahd_get_sense_bufsize(ahd, scb);
+		sc->control = 0;
+
+		/*
+		 * We can't allow the target to disconnect.
+		 * This will be an untagged transaction and
+		 * having the target disconnect will make this
+		 * transaction indestinguishable from outstanding
+		 * tagged transactions.
+		 */
+		hscb->control = 0;
+
+		/*
+		 * This request sense could be because the
+		 * the device lost power or in some other
+		 * way has lost our transfer negotiations.
+		 * Renegotiate if appropriate.  Unit attention
+		 * errors will be reported before any data
+		 * phases occur.
+		 */
+		if (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {
+			ahd_update_neg_request(ahd, &devinfo,
+					       tstate, targ_info,
+					       /*force*/TRUE);
+		}
+		if (tstate->auto_negotiate & devinfo.target_mask) {
+			hscb->control |= MK_MESSAGE;
+			scb->flags &=
+			    ~(SCB_NEGOTIATE|SCB_ABORT|SCB_DEVICE_RESET);
+			scb->flags |= SCB_AUTO_NEGOTIATE;
+		}
+		hscb->cdb_len = sizeof(*sc);
+		ahd_setup_data_scb(ahd, scb);
+		scb->flags |= SCB_SENSE;
+		ahd_queue_scb(ahd, scb);
+#ifdef __FreeBSD__
+		/*
+		 * Ensure we have enough time to actually
+		 * retrieve the sense.
+		 */
+		untimeout(ahd_timeout, (caddr_t)scb,
+			  scb->io_ctx->ccb_h.timeout_ch);
+		scb->io_ctx->ccb_h.timeout_ch =
+		    timeout(ahd_timeout, (caddr_t)scb, 5 * hz);
+#endif
+		break;
+	}
+	case SCSI_STATUS_OK:
+		printf("%s: Interrupted for staus of 0???\n",
+		       ahd_name(ahd));
+		/* FALLTHROUGH */
+	default:
+		ahd_done(ahd, scb);
+		break;
+	}
+}
+
+/*
+ * Calculate the residual for a just completed SCB.
+ */
+void
+ahd_calc_residual(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	struct initiator_status *spkt;
+	uint32_t sgptr;
+	uint32_t resid_sgptr;
+	uint32_t resid;
+
+	/*
+	 * 5 cases.
+	 * 1) No residual.
+	 *    SG_STATUS_VALID clear in sgptr.
+	 * 2) Transferless command
+	 * 3) Never performed any transfers.
+	 *    sgptr has SG_FULL_RESID set.
+	 * 4) No residual but target did not
+	 *    save data pointers after the
+	 *    last transfer, so sgptr was
+	 *    never updated.
+	 * 5) We have a partial residual.
+	 *    Use residual_sgptr to determine
+	 *    where we are.
+	 */
+
+	hscb = scb->hscb;
+	sgptr = ahd_le32toh(hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) == 0)
+		/* Case 1 */
+		return;
+	sgptr &= ~SG_STATUS_VALID;
+
+	if ((sgptr & SG_LIST_NULL) != 0)
+		/* Case 2 */
+		return;
+
+	/*
+	 * Residual fields are the same in both
+	 * target and initiator status packets,
+	 * so we can always use the initiator fields
+	 * regardless of the role for this SCB.
+	 */
+	spkt = &hscb->shared_data.istatus;
+	resid_sgptr = ahd_le32toh(spkt->residual_sgptr);
+	if ((sgptr & SG_FULL_RESID) != 0) {
+		/* Case 3 */
+		resid = ahd_get_transfer_length(scb);
+	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
+		/* Case 4 */
+		return;
+	} else if ((resid_sgptr & SG_OVERRUN_RESID) != 0) {
+		ahd_print_path(ahd, scb);
+		printf("data overrun detected Tag == 0x%x.\n",
+		       SCB_GET_TAG(scb));
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		ahd_freeze_scb(scb);
+		return;
+	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
+		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
+		/* NOTREACHED */
+	} else {
+		struct ahd_dma_seg *sg;
+
+		/*
+		 * Remainder of the SG where the transfer
+		 * stopped.  
+		 */
+		resid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;
+		sg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		/*
+		 * Add up the contents of all residual
+		 * SG segments that are after the SG where
+		 * the transfer stopped.
+		 */
+		while ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
+			sg++;
+			resid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+		}
+	}
+	if ((scb->flags & SCB_SENSE) == 0)
+		ahd_set_residual(scb, resid);
+	else
+		ahd_set_sense_residual(scb, resid);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0) {
+		ahd_print_path(ahd, scb);
+		printf("Handled Residual of %d bytes\n", resid);
+	}
+#endif
+}
+
+/******************************* Target Mode **********************************/
+#ifdef AHD_TARGET_MODE
+/*
+ * Add a target mode event to this lun's queue
+ */
+static void
+ahd_queue_lstate_event(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate,
+		       u_int initiator_id, u_int event_type, u_int event_arg)
+{
+	struct ahd_tmode_event *event;
+	int pending;
+
+	xpt_freeze_devq(lstate->path, /*count*/1);
+	if (lstate->event_w_idx >= lstate->event_r_idx)
+		pending = lstate->event_w_idx - lstate->event_r_idx;
+	else
+		pending = AHD_TMODE_EVENT_BUFFER_SIZE + 1
+			- (lstate->event_r_idx - lstate->event_w_idx);
+
+	if (event_type == EVENT_TYPE_BUS_RESET
+	 || event_type == MSG_BUS_DEV_RESET) {
+		/*
+		 * Any earlier events are irrelevant, so reset our buffer.
+		 * This has the effect of allowing us to deal with reset
+		 * floods (an external device holding down the reset line)
+		 * without losing the event that is really interesting.
+		 */
+		lstate->event_r_idx = 0;
+		lstate->event_w_idx = 0;
+		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
+	}
+
+	if (pending == AHD_TMODE_EVENT_BUFFER_SIZE) {
+		xpt_print_path(lstate->path);
+		printf("immediate event %x:%x lost\n",
+		       lstate->event_buffer[lstate->event_r_idx].event_type,
+		       lstate->event_buffer[lstate->event_r_idx].event_arg);
+		lstate->event_r_idx++;
+		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+			lstate->event_r_idx = 0;
+		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
+	}
+
+	event = &lstate->event_buffer[lstate->event_w_idx];
+	event->initiator_id = initiator_id;
+	event->event_type = event_type;
+	event->event_arg = event_arg;
+	lstate->event_w_idx++;
+	if (lstate->event_w_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+		lstate->event_w_idx = 0;
+}
+
+/*
+ * Send any target mode events queued up waiting
+ * for immediate notify resources.
+ */
+void
+ahd_send_lstate_events(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate)
+{
+	struct ccb_hdr *ccbh;
+	struct ccb_immed_notify *inot;
+
+	while (lstate->event_r_idx != lstate->event_w_idx
+	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
+		struct ahd_tmode_event *event;
+
+		event = &lstate->event_buffer[lstate->event_r_idx];
+		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
+		inot = (struct ccb_immed_notify *)ccbh;
+		switch (event->event_type) {
+		case EVENT_TYPE_BUS_RESET:
+			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
+			break;
+		default:
+			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
+			inot->message_args[0] = event->event_type;
+			inot->message_args[1] = event->event_arg;
+			break;
+		}
+		inot->initiator_id = event->initiator_id;
+		inot->sense_len = 0;
+		xpt_done((union ccb *)inot);
+		lstate->event_r_idx++;
+		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+			lstate->event_r_idx = 0;
+	}
+}
+#endif
+
+/******************** Sequencer Program Patching/Download *********************/
+
+#ifdef AHD_DUMP_SEQ
+void
+ahd_dumpseq(struct ahd_softc* ahd)
+{
+	int i;
+	int max_prog;
+
+	max_prog = 2048;
+
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
+	ahd_outb(ahd, PRGMCNT, 0);
+	ahd_outb(ahd, PRGMCNT+1, 0);
+	for (i = 0; i < max_prog; i++) {
+		uint8_t ins_bytes[4];
+
+		ahd_insb(ahd, SEQRAM, ins_bytes, 4);
+		printf("0x%08x\n", ins_bytes[0] << 24
+				 | ins_bytes[1] << 16
+				 | ins_bytes[2] << 8
+				 | ins_bytes[3]);
+	}
+}
+#endif
+
+static void
+ahd_loadseq(struct ahd_softc *ahd)
+{
+	struct	cs cs_table[num_critical_sections];
+	u_int	begin_set[num_critical_sections];
+	u_int	end_set[num_critical_sections];
+	struct	patch *cur_patch;
+	u_int	cs_count;
+	u_int	cur_cs;
+	u_int	i;
+	int	downloaded;
+	u_int	skip_addr;
+	u_int	sg_prefetch_cnt;
+	u_int	sg_prefetch_cnt_limit;
+	u_int	sg_prefetch_align;
+	u_int	sg_size;
+	uint8_t	download_consts[DOWNLOAD_CONST_COUNT];
+
+	if (bootverbose)
+		printf("%s: Downloading Sequencer Program...",
+		       ahd_name(ahd));
+
+#if DOWNLOAD_CONST_COUNT != 7
+#error "Download Const Mismatch"
+#endif
+	/*
+	 * Start out with 0 critical sections
+	 * that apply to this firmware load.
+	 */
+	cs_count = 0;
+	cur_cs = 0;
+	memset(begin_set, 0, sizeof(begin_set));
+	memset(end_set, 0, sizeof(end_set));
+
+	/*
+	 * Setup downloadable constant table.
+	 * 
+	 * The computation for the S/G prefetch variables is
+	 * a bit complicated.  We would like to always fetch
+	 * in terms of cachelined sized increments.  However,
+	 * if the cacheline is not an even multiple of the
+	 * SG element size or is larger than our SG RAM, using
+	 * just the cache size might leave us with only a portion
+	 * of an SG element at the tail of a prefetch.  If the
+	 * cacheline is larger than our S/G prefetch buffer less
+	 * the size of an SG element, we may round down to a cacheline
+	 * that doesn't contain any or all of the S/G of interest
+	 * within the bounds of our S/G ram.  Provide variables to
+	 * the sequencer that will allow it to handle these edge
+	 * cases.
+	 */
+	/* Start by aligning to the nearest cacheline. */
+	sg_prefetch_align = ahd->pci_cachesize;
+	if (sg_prefetch_align == 0)
+		sg_prefetch_cnt = 8;
+	/* Round down to the nearest power of 2. */
+	while (powerof2(sg_prefetch_align) == 0)
+		sg_prefetch_align--;
+	/*
+	 * If the cacheline boundary is greater than half our prefetch RAM
+	 * we risk not being able to fetch even a single complete S/G
+	 * segment if we align to that boundary.
+	 */
+	if (sg_prefetch_align > CCSGADDR_MAX/2)
+		sg_prefetch_align = CCSGADDR_MAX/2;
+	/* Start by fetching a single cacheline. */
+	sg_prefetch_cnt = sg_prefetch_align;
+	/*
+	 * Increment the prefetch count by cachelines until
+	 * at least one S/G element will fit.
+	 */
+	sg_size = sizeof(struct ahd_dma_seg);
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		sg_size = sizeof(struct ahd_dma64_seg);
+	while (sg_prefetch_cnt < sg_size)
+		sg_prefetch_cnt += sg_prefetch_align;
+	/*
+	 * If the cacheline is not an even multiple of
+	 * the S/G size, we may only get a partial S/G when
+	 * we align. Add a cacheline if this is the case.
+	 */
+	if ((sg_prefetch_align % sg_size) != 0
+	 && (sg_prefetch_cnt < CCSGADDR_MAX))
+		sg_prefetch_cnt += sg_prefetch_align;
+	/*
+	 * Lastly, compute a value that the sequencer can use
+	 * to determine if the remainder of the CCSGRAM buffer
+	 * has a full S/G element in it.
+	 */
+	sg_prefetch_cnt_limit = -(sg_prefetch_cnt - sg_size + 1);
+	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
+	download_consts[SG_PREFETCH_CNT_LIMIT] = sg_prefetch_cnt_limit;
+	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_align - 1);
+	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_align - 1);
+	download_consts[SG_SIZEOF] = sg_size;
+	download_consts[PKT_OVERRUN_BUFOFFSET] =
+		(ahd->overrun_buf - (uint8_t *)ahd->qoutfifo) / 256;
+	download_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_1BYTE_LUN;
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0)
+		download_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_FULL_LUN;
+	cur_patch = patches;
+	downloaded = 0;
+	skip_addr = 0;
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
+	ahd_outb(ahd, PRGMCNT, 0);
+	ahd_outb(ahd, PRGMCNT+1, 0);
+
+	for (i = 0; i < sizeof(seqprog)/4; i++) {
+		if (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {
+			/*
+			 * Don't download this instruction as it
+			 * is in a patch that was removed.
+			 */
+			continue;
+		}
+		/*
+		 * Move through the CS table until we find a CS
+		 * that might apply to this instruction.
+		 */
+		for (; cur_cs < num_critical_sections; cur_cs++) {
+			if (critical_sections[cur_cs].end <= i) {
+				if (begin_set[cs_count] == TRUE
+				 && end_set[cs_count] == FALSE) {
+					cs_table[cs_count].end = downloaded;
+				 	end_set[cs_count] = TRUE;
+					cs_count++;
+				}
+				continue;
+			}
+			if (critical_sections[cur_cs].begin <= i
+			 && begin_set[cs_count] == FALSE) {
+				cs_table[cs_count].begin = downloaded;
+				begin_set[cs_count] = TRUE;
+			}
+			break;
+		}
+		ahd_download_instr(ahd, i, download_consts);
+		downloaded++;
+	}
+
+	ahd->num_critical_sections = cs_count;
+	if (cs_count != 0) {
+
+		cs_count *= sizeof(struct cs);
+		ahd->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
+		if (ahd->critical_sections == NULL)
+			panic("ahd_loadseq: Could not malloc");
+		memcpy(ahd->critical_sections, cs_table, cs_count);
+	}
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE);
+
+	if (bootverbose)
+		printf(" %d instructions downloaded\n", downloaded);
+}
+
+static int
+ahd_check_patch(struct ahd_softc *ahd, struct patch **start_patch,
+		u_int start_instr, u_int *skip_addr)
+{
+	struct	patch *cur_patch;
+	struct	patch *last_patch;
+	u_int	num_patches;
+
+	num_patches = sizeof(patches)/sizeof(struct patch);
+	last_patch = &patches[num_patches];
+	cur_patch = *start_patch;
+
+	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
+
+		if (cur_patch->patch_func(ahd) == 0) {
+
+			/* Start rejecting code */
+			*skip_addr = start_instr + cur_patch->skip_instr;
+			cur_patch += cur_patch->skip_patch;
+		} else {
+			/* Accepted this patch.  Advance to the next
+			 * one and wait for our intruction pointer to
+			 * hit this point.
+			 */
+			cur_patch++;
+		}
+	}
+
+	*start_patch = cur_patch;
+	if (start_instr < *skip_addr)
+		/* Still skipping */
+		return (0);
+
+	return (1);
+}
+
+static u_int
+ahd_resolve_seqaddr(struct ahd_softc *ahd, u_int address)
+{
+	struct patch *cur_patch;
+	int address_offset;
+	u_int skip_addr;
+	u_int i;
+
+	address_offset = 0;
+	cur_patch = patches;
+	skip_addr = 0;
+
+	for (i = 0; i < address;) {
+
+		ahd_check_patch(ahd, &cur_patch, i, &skip_addr);
+
+		if (skip_addr > i) {
+			int end_addr;
+
+			end_addr = MIN(address, skip_addr);
+			address_offset += end_addr - i;
+			i = skip_addr;
+		} else {
+			i++;
+		}
+	}
+	return (address - address_offset);
+}
+
+static void
+ahd_download_instr(struct ahd_softc *ahd, u_int instrptr, uint8_t *dconsts)
+{
+	union	ins_formats instr;
+	struct	ins_format1 *fmt1_ins;
+	struct	ins_format3 *fmt3_ins;
+	u_int	opcode;
+
+	/*
+	 * The firmware is always compiled into a little endian format.
+	 */
+	instr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
+
+	fmt1_ins = &instr.format1;
+	fmt3_ins = NULL;
+
+	/* Pull the opcode */
+	opcode = instr.format1.opcode;
+	switch (opcode) {
+	case AIC_OP_JMP:
+	case AIC_OP_JC:
+	case AIC_OP_JNC:
+	case AIC_OP_CALL:
+	case AIC_OP_JNE:
+	case AIC_OP_JNZ:
+	case AIC_OP_JE:
+	case AIC_OP_JZ:
+	{
+		fmt3_ins = &instr.format3;
+		fmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);
+		/* FALLTHROUGH */
+	}
+	case AIC_OP_OR:
+	case AIC_OP_AND:
+	case AIC_OP_XOR:
+	case AIC_OP_ADD:
+	case AIC_OP_ADC:
+	case AIC_OP_BMOV:
+		if (fmt1_ins->parity != 0) {
+			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
+		}
+		fmt1_ins->parity = 0;
+		/* FALLTHROUGH */
+	case AIC_OP_ROL:
+	{
+		int i, count;
+
+		/* Calculate odd parity for the instruction */
+		for (i = 0, count = 0; i < 31; i++) {
+			uint32_t mask;
+
+			mask = 0x01 << i;
+			if ((instr.integer & mask) != 0)
+				count++;
+		}
+		if ((count & 0x01) == 0)
+			instr.format1.parity = 1;
+
+		/* The sequencer is a little endian cpu */
+		instr.integer = ahd_htole32(instr.integer);
+		ahd_outsb(ahd, SEQRAM, instr.bytes, 4);
+		break;
+	}
+	default:
+		panic("Unknown opcode encountered in seq program");
+		break;
+	}
+}
+
+void
+ahd_dump_all_cards_state()
+{
+	struct ahd_softc *list_ahd;
+
+	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+		ahd_dump_card_state(list_ahd);
+	}
+}
+
+int
+ahd_print_register(ahd_reg_parse_entry_t *table, u_int num_entries,
+		   const char *name, u_int address, u_int value,
+		   u_int *cur_column, u_int wrap_point)
+{
+	int	printed;
+	u_int	printed_mask;
+
+	if (*cur_column >= wrap_point) {
+		printf("\n");
+		*cur_column = 0;
+	}
+	printed = printf("%s[0x%x]", name, value);
+	if (table == NULL) {
+		printed += printf(" ");
+		*cur_column += printed;
+		return (printed);
+	}
+	printed_mask = 0;
+	while (printed_mask != 0xFF) {
+		int entry;
+
+		for (entry = 0; entry < num_entries; entry++) {
+			if (((value & table[entry].mask)
+			  != table[entry].value)
+			 || ((printed_mask & table[entry].mask)
+			  == table[entry].mask))
+				continue;
+
+			printed += printf("%s%s",
+					  printed_mask == 0 ? ":(" : "|",
+					  table[entry].name);
+			printed_mask |= table[entry].mask;
+			
+			break;
+		}
+		if (entry >= num_entries)
+			break;
+	}
+	if (printed_mask != 0)
+		printed += printf(") ");
+	else
+		printed += printf(" ");
+	*cur_column += printed;
+	return (printed);
+}
+
+void
+ahd_dump_card_state(struct ahd_softc *ahd)
+{
+	struct scb	*scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 dffstat;
+	int		 paused;
+	u_int		 scb_index;
+	u_int		 saved_scb_index;
+	u_int		 i;
+	u_int		 cur_col;
+
+	if (ahd_is_paused(ahd)) {
+		paused = 1;
+	} else {
+		paused = 0;
+		ahd_pause(ahd);
+	}
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
+	       "%s: Dumping Card State at program address 0x%x Mode 0x%x\n",
+	       ahd_name(ahd), 
+	       ahd_inb(ahd, CURADDR) | (ahd_inb(ahd, CURADDR+1) << 8),
+	       ahd_build_mode_state(ahd, ahd->saved_src_mode,
+				    ahd->saved_dst_mode));
+	if (paused)
+		printf("Card was paused\n");
+	/*
+	 * Mode independent registers.
+	 */
+	cur_col = 0;
+	ahd_scsiseq0_print(ahd_inb(ahd, SCSISEQ0), &cur_col, 50);
+	ahd_scsiseq1_print(ahd_inb(ahd, SCSISEQ1), &cur_col, 50);
+	ahd_seqintctl_print(ahd_inb(ahd, SEQINTCTL), &cur_col, 50);
+	ahd_scsisigi_print(ahd_inb(ahd, SCSISIGI), &cur_col, 50);
+	ahd_scsiphase_print(ahd_inb(ahd, SCSIPHASE), &cur_col, 50);
+	ahd_scsibus_print(ahd_inb(ahd, SCSIBUS), &cur_col, 50);
+	ahd_lastphase_print(ahd_inb(ahd, LASTPHASE), &cur_col, 50);
+	ahd_seq_flags_print(ahd_inb(ahd, SEQ_FLAGS), &cur_col, 50);
+	ahd_seq_flags2_print(ahd_inb(ahd, SEQ_FLAGS2), &cur_col, 50);
+	ahd_sstat0_print(ahd_inb(ahd, SSTAT0), &cur_col, 50);
+	ahd_sstat1_print(ahd_inb(ahd, SSTAT1), &cur_col, 50);
+	ahd_sstat2_print(ahd_inb(ahd, SSTAT2), &cur_col, 50);
+	ahd_sstat3_print(ahd_inb(ahd, SSTAT3), &cur_col, 50);
+	ahd_perrdiag_print(ahd_inb(ahd, PERRDIAG), &cur_col, 50);
+	ahd_simode1_print(ahd_inb(ahd, SIMODE1), &cur_col, 50);
+	ahd_lqistat0_print(ahd_inb(ahd, LQISTAT0), &cur_col, 50);
+	ahd_lqistat1_print(ahd_inb(ahd, LQISTAT1), &cur_col, 50);
+	ahd_lqistat2_print(ahd_inb(ahd, LQISTAT2), &cur_col, 50);
+	ahd_lqostat0_print(ahd_inb(ahd, LQOSTAT0), &cur_col, 50);
+	ahd_lqostat1_print(ahd_inb(ahd, LQOSTAT1), &cur_col, 50);
+	ahd_lqostat2_print(ahd_inb(ahd, LQOSTAT2), &cur_col, 50);
+	printf("\n");
+	printf("\nSCB Count = %d LASTSCB 0x%x CURRSCB 0x%x NEXTSCB 0x%x\n",
+	       ahd->scb_data.numscbs, ahd_inw(ahd, LASTSCB),
+	       ahd_inw(ahd, CURRSCB), ahd_inw(ahd, NEXTSCB));
+	cur_col = 0;
+	/* QINFIFO */
+	ahd_search_qinfifo(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+			   CAM_LUN_WILDCARD, SCB_LIST_NULL,
+			   ROLE_UNKNOWN, /*status*/0, SEARCH_PRINT);
+	saved_scb_index = ahd_get_scbptr(ahd);
+	printf("Pending list:");
+	i = 0;
+	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+		if (i++ > AHD_SCB_MAX)
+			break;
+		cur_col = printf("\n%3d ", SCB_GET_TAG(scb));
+		ahd_set_scbptr(ahd, SCB_GET_TAG(scb));
+		ahd_scb_control_print(ahd_inb(ahd, SCB_CONTROL), &cur_col, 60);
+		ahd_scb_scsiid_print(ahd_inb(ahd, SCB_SCSIID), &cur_col, 60);
+		ahd_scb_tag_print(ahd_inb(ahd, SCB_TAG), &cur_col, 60);
+	}
+	printf("\n");
+
+	printf("Kernel Free SCB list: ");
+	i = 0;
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		struct scb *list_scb;
+
+		list_scb = scb;
+		do {
+			printf("%d ", SCB_GET_TAG(list_scb));
+			list_scb = LIST_NEXT(list_scb, collision_links);
+		} while (list_scb && i++ < AHD_SCB_MAX);
+	}
+
+	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
+		if (i++ > AHD_SCB_MAX)
+			break;
+		printf("%d ", SCB_GET_TAG(scb));
+	}
+	printf("\n");
+
+	printf("Sequencer Complete DMA-inprog list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_SCB_DMAINPROG_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+
+	printf("Sequencer Complete list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_SCB_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+
+	
+	printf("Sequencer DMA-Up and Complete list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+	ahd_set_scbptr(ahd, saved_scb_index);
+	dffstat = ahd_inb(ahd, DFFSTAT);
+	for (i = 0; i < 2; i++) {
+#ifdef AHD_DEBUG
+		struct scb *fifo_scb;
+#endif
+		u_int	    fifo_scbptr;
+
+		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
+		fifo_scbptr = ahd_get_scbptr(ahd);
+		printf("\n%s: FIFO%d %s, LONGJMP == 0x%x, "
+		       "SCB 0x%x, LJSCB 0x%x\n",
+		       ahd_name(ahd), i,
+		       (dffstat & (FIFO0FREE << i)) ? "Free" : "Active",
+		       ahd_inw(ahd, LONGJMP_ADDR), fifo_scbptr,
+		       ahd_inw(ahd, LONGJMP_SCB));
+		cur_col = 0;
+		ahd_seqimode_print(ahd_inb(ahd, SEQIMODE), &cur_col, 50);
+		ahd_seqintsrc_print(ahd_inb(ahd, SEQINTSRC), &cur_col, 50);
+		ahd_dfcntrl_print(ahd_inb(ahd, DFCNTRL), &cur_col, 50);
+		ahd_dfstatus_print(ahd_inb(ahd, DFSTATUS), &cur_col, 50);
+		ahd_sg_cache_shadow_print(ahd_inb(ahd, SG_CACHE_SHADOW),
+					  &cur_col, 50);
+		ahd_sg_state_print(ahd_inb(ahd, SG_STATE), &cur_col, 50);
+		ahd_dffsxfrctl_print(ahd_inb(ahd, DFFSXFRCTL), &cur_col, 50);
+		ahd_soffcnt_print(ahd_inb(ahd, SOFFCNT), &cur_col, 50);
+		ahd_mdffstat_print(ahd_inb(ahd, MDFFSTAT), &cur_col, 50);
+		if (cur_col > 50) {
+			printf("\n");
+			cur_col = 0;
+		}
+		cur_col += printf("SHADDR = 0x%x%x, SHCNT = 0x%x",
+				  ahd_inl(ahd, SHADDR+4),
+				  ahd_inl(ahd, SHADDR),
+				  (ahd_inb(ahd, SHCNT)
+				| (ahd_inb(ahd, SHCNT + 1) << 8)
+				| (ahd_inb(ahd, SHCNT + 2) << 16)));
+		if (cur_col > 50) {
+			printf("\n");
+			cur_col = 0;
+		}
+		cur_col += printf("HADDR = 0x%x%x, HCNT = 0x%x",
+				  ahd_inl(ahd, HADDR+4),
+				  ahd_inl(ahd, HADDR),
+				  (ahd_inb(ahd, HCNT)
+				| (ahd_inb(ahd, HCNT + 1) << 8)
+				| (ahd_inb(ahd, HCNT + 2) << 16)));
+		ahd_ccsgctl_print(ahd_inb(ahd, CCSGCTL), &cur_col, 50);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_SG) != 0) {
+			fifo_scb = ahd_lookup_scb(ahd, fifo_scbptr);
+			if (fifo_scb != NULL)
+				ahd_dump_sglist(fifo_scb);
+		}
+#endif
+	}
+	printf("\nLQIN: ");
+	for (i = 0; i < 20; i++)
+		printf("0x%x ", ahd_inb(ahd, LQIN + i));
+	printf("\n");
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	printf("%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\n",
+	       ahd_name(ahd), ahd_inb(ahd, LQISTATE), ahd_inb(ahd, LQOSTATE),
+	       ahd_inb(ahd, OPTIONMODE));
+	printf("%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\n",
+	       ahd_name(ahd), ahd_inb(ahd, OS_SPACE_CNT),
+	       ahd_inb(ahd, MAXCMDCNT));
+	ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+	printf("%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\n",
+	       ahd_name(ahd), ahd_inw(ahd, REG0), ahd_inw(ahd, SINDEX),
+	       ahd_inw(ahd, DINDEX));
+	printf("%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\n",
+	       ahd_name(ahd), ahd_get_scbptr(ahd), ahd_inw(ahd, SCB_NEXT),
+	       ahd_inw(ahd, SCB_NEXT2));
+	printf("CDB %x %x %x %x %x %x\n",
+	       ahd_inb(ahd, SCB_CDB_STORE),
+	       ahd_inb(ahd, SCB_CDB_STORE+1),
+	       ahd_inb(ahd, SCB_CDB_STORE+2),
+	       ahd_inb(ahd, SCB_CDB_STORE+3),
+	       ahd_inb(ahd, SCB_CDB_STORE+4),
+	       ahd_inb(ahd, SCB_CDB_STORE+5));
+	printf("STACK:");
+	for(i = 0; i < SEQ_STACK_SIZE; i++)
+	       printf(" 0x%x", ahd_inb(ahd, STACK)|(ahd_inb(ahd, STACK) << 8));
+	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
+	ahd_platform_dump_card_state(ahd);
+	ahd_restore_modes(ahd, saved_modes);
+	if (paused == 0)
+		ahd_unpause(ahd);
+}
+
+void
+ahd_dump_scbs(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+	u_int	       saved_scb_index;
+	int	       i;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	saved_scb_index = ahd_get_scbptr(ahd);
+	for (i = 0; i < AHD_SCB_MAX; i++) {
+		ahd_set_scbptr(ahd, i);
+		printf("%3d", i);
+		printf("(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\n",
+		       ahd_inb(ahd, SCB_CONTROL),
+		       ahd_inb(ahd, SCB_SCSIID), ahd_inw(ahd, SCB_NEXT),
+		       ahd_inw(ahd, SCB_NEXT2), ahd_inl(ahd, SCB_SGPTR),
+		       ahd_inl(ahd, SCB_RESIDUAL_SGPTR));
+	}
+	printf("\n");
+	ahd_set_scbptr(ahd, saved_scb_index);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/**************************** Flexport Logic **********************************/
+/*
+ * Read count 16bit words from 16bit word address start_addr from the
+ * SEEPROM attached to the controller, into buf, using the controller's
+ * SEEPROM reading state machine.
+ */
+int
+ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+		 u_int start_addr, u_int count)
+{
+	u_int cur_addr;
+	u_int end_addr;
+	int   error;
+
+	/*
+	 * If we never make it through the loop even once,
+	 * we were passed invalid arguments.
+	 */
+	error = EINVAL;
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	end_addr = start_addr + count;
+	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
+		ahd_outb(ahd, SEEADR, cur_addr);
+		ahd_outb(ahd, SEECTL, SEEOP_READ | SEESTART);
+		
+		error = ahd_wait_seeprom(ahd);
+		if (error)
+			break;
+		*buf++ = ahd_inw(ahd, SEEDAT);
+	}
+	return (error);
+}
+
+/*
+ * Write count 16bit words from buf, into SEEPROM attache to the
+ * controller starting at 16bit word address start_addr, using the
+ * controller's SEEPROM writing state machine.
+ */
+int
+ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+		  u_int start_addr, u_int count)
+{
+	u_int cur_addr;
+	u_int end_addr;
+	int   error;
+	int   retval;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	error = ENOENT;
+
+	/* Place the chip into write-enable mode */
+	ahd_outb(ahd, SEEADR, SEEOP_EWEN_ADDR);
+	ahd_outb(ahd, SEECTL, SEEOP_EWEN | SEESTART);
+	error = ahd_wait_seeprom(ahd);
+	if (error)
+		return (error);
+
+	/*
+	 * Write the data.  If we don't get throught the loop at
+	 * least once, the arguments were invalid.
+	 */
+	retval = EINVAL;
+	end_addr = start_addr + count;
+	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
+		ahd_outw(ahd, SEEDAT, *buf++);
+		ahd_outb(ahd, SEEADR, cur_addr);
+		ahd_outb(ahd, SEECTL, SEEOP_WRITE | SEESTART);
+		
+		retval = ahd_wait_seeprom(ahd);
+		if (retval)
+			break;
+	}
+
+	/*
+	 * Disable writes.
+	 */
+	ahd_outb(ahd, SEEADR, SEEOP_EWDS_ADDR);
+	ahd_outb(ahd, SEECTL, SEEOP_EWDS | SEESTART);
+	error = ahd_wait_seeprom(ahd);
+	if (error)
+		return (error);
+	return (retval);
+}
+
+/*
+ * Wait ~100us for the serial eeprom to satisfy our request.
+ */
+int
+ahd_wait_seeprom(struct ahd_softc *ahd)
+{
+	int cnt;
+
+	cnt = 20;
+	while ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)
+		ahd_delay(5);
+
+	if (cnt == 0)
+		return (ETIMEDOUT);
+	return (0);
+}
+
+int
+ahd_verify_cksum(struct seeprom_config *sc)
+{
+	int i;
+	int maxaddr;
+	uint32_t checksum;
+	uint16_t *scarray;
+
+	maxaddr = (sizeof(*sc)/2) - 1;
+	checksum = 0;
+	scarray = (uint16_t *)sc;
+
+	for (i = 0; i < maxaddr; i++)
+		checksum = checksum + scarray[i];
+	if (checksum == 0
+	 || (checksum & 0xFFFF) != sc->checksum) {
+		return (0);
+	} else {
+		return (1);
+	}
+}
+
+int
+ahd_acquire_seeprom(struct ahd_softc *ahd)
+{
+	/*
+	 * We should be able to determine the SEEPROM type
+	 * from the flexport logic, but unfortunately not
+	 * all implementations have this logic and there is
+	 * no programatic method for determining if the logic
+	 * is present.
+	 */
+	return (1);
+#if 0
+	uint8_t	seetype;
+	int	error;
+
+	error = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &seetype);
+	if (error != 0
+         || ((seetype & FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))
+		return (0);
+	return (1);
+#endif
+}
+
+void
+ahd_release_seeprom(struct ahd_softc *ahd)
+{
+	/* Currently a no-op */
+}
+
+int
+ahd_write_flexport(struct ahd_softc *ahd, u_int addr, u_int value)
+{
+	int error;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	if (addr > 7)
+		panic("ahd_write_flexport: address out of range");
+	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
+	error = ahd_wait_flexport(ahd);
+	if (error != 0)
+		return (error);
+	ahd_outb(ahd, BRDDAT, value);
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, BRDSTB|BRDEN|(addr << 3));
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, 0);
+	ahd_flush_device_writes(ahd);
+	return (0);
+}
+
+int
+ahd_read_flexport(struct ahd_softc *ahd, u_int addr, uint8_t *value)
+{
+	int	error;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	if (addr > 7)
+		panic("ahd_read_flexport: address out of range");
+	ahd_outb(ahd, BRDCTL, BRDRW|BRDEN|(addr << 3));
+	error = ahd_wait_flexport(ahd);
+	if (error != 0)
+		return (error);
+	*value = ahd_inb(ahd, BRDDAT);
+	ahd_outb(ahd, BRDCTL, 0);
+	ahd_flush_device_writes(ahd);
+	return (0);
+}
+
+/*
+ * Wait at most 2 seconds for flexport arbitration to succeed.
+ */
+int
+ahd_wait_flexport(struct ahd_softc *ahd)
+{
+	int cnt;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	cnt = 1000000 * 2 / 5;
+	while ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)
+		ahd_delay(5);
+
+	if (cnt == 0)
+		return (ETIMEDOUT);
+	return (0);
+}
+
+/************************* Target Mode ****************************************/
+#ifdef AHD_TARGET_MODE
+cam_status
+ahd_find_tmode_devs(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb,
+		    struct ahd_tmode_tstate **tstate,
+		    struct ahd_tmode_lstate **lstate,
+		    int notfound_failure)
+{
+
+	if ((ahd->features & AHD_TARGETMODE) == 0)
+		return (CAM_REQ_INVALID);
+
+	/*
+	 * Handle the 'black hole' device that sucks up
+	 * requests to unattached luns on enabled targets.
+	 */
+	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
+	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
+		*tstate = NULL;
+		*lstate = ahd->black_hole;
+	} else {
+		u_int max_id;
+
+		max_id = (ahd->features & AHD_WIDE) ? 15 : 7;
+		if (ccb->ccb_h.target_id > max_id)
+			return (CAM_TID_INVALID);
+
+		if (ccb->ccb_h.target_lun >= AHD_NUM_LUNS)
+			return (CAM_LUN_INVALID);
+
+		*tstate = ahd->enabled_targets[ccb->ccb_h.target_id];
+		*lstate = NULL;
+		if (*tstate != NULL)
+			*lstate =
+			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
+	}
+
+	if (notfound_failure != 0 && *lstate == NULL)
+		return (CAM_PATH_INVALID);
+
+	return (CAM_REQ_CMP);
+}
+
+void
+ahd_handle_en_lun(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb)
+{
+#if NOT_YET
+	struct	   ahd_tmode_tstate *tstate;
+	struct	   ahd_tmode_lstate *lstate;
+	struct	   ccb_en_lun *cel;
+	cam_status status;
+	u_int	   target;
+	u_int	   lun;
+	u_int	   target_mask;
+	u_long	   s;
+	char	   channel;
+
+	status = ahd_find_tmode_devs(ahd, sim, ccb, &tstate, &lstate,
+				     /*notfound_failure*/FALSE);
+
+	if (status != CAM_REQ_CMP) {
+		ccb->ccb_h.status = status;
+		return;
+	}
+
+	if ((ahd->features & AHD_MULTIROLE) != 0) {
+		u_int	   our_id;
+
+		our_id = ahd->our_id;
+		if (ccb->ccb_h.target_id != our_id) {
+			if ((ahd->features & AHD_MULTI_TID) != 0
+		   	 && (ahd->flags & AHD_INITIATORROLE) != 0) {
+				/*
+				 * Only allow additional targets if
+				 * the initiator role is disabled.
+				 * The hardware cannot handle a re-select-in
+				 * on the initiator id during a re-select-out
+				 * on a different target id.
+				 */
+				status = CAM_TID_INVALID;
+			} else if ((ahd->flags & AHD_INITIATORROLE) != 0
+				|| ahd->enabled_luns > 0) {
+				/*
+				 * Only allow our target id to change
+				 * if the initiator role is not configured
+				 * and there are no enabled luns which
+				 * are attached to the currently registered
+				 * scsi id.
+				 */
+				status = CAM_TID_INVALID;
+			}
+		}
+	}
+
+	if (status != CAM_REQ_CMP) {
+		ccb->ccb_h.status = status;
+		return;
+	}
+
+	/*
+	 * We now have an id that is valid.
+	 * If we aren't in target mode, switch modes.
+	 */
+	if ((ahd->flags & AHD_TARGETROLE) == 0
+	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
+		u_long	s;
+
+		printf("Configuring Target Mode\n");
+		ahd_lock(ahd, &s);
+		if (LIST_FIRST(&ahd->pending_scbs) != NULL) {
+			ccb->ccb_h.status = CAM_BUSY;
+			ahd_unlock(ahd, &s);
+			return;
+		}
+		ahd->flags |= AHD_TARGETROLE;
+		if ((ahd->features & AHD_MULTIROLE) == 0)
+			ahd->flags &= ~AHD_INITIATORROLE;
+		ahd_pause(ahd);
+		ahd_loadseq(ahd);
+		ahd_unlock(ahd, &s);
+	}
+	cel = &ccb->cel;
+	target = ccb->ccb_h.target_id;
+	lun = ccb->ccb_h.target_lun;
+	channel = SIM_CHANNEL(ahd, sim);
+	target_mask = 0x01 << target;
+	if (channel == 'B')
+		target_mask <<= 8;
+
+	if (cel->enable != 0) {
+		u_int scsiseq1;
+
+		/* Are we already enabled?? */
+		if (lstate != NULL) {
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Lun already enabled\n");
+			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
+			return;
+		}
+
+		if (cel->grp6_len != 0
+		 || cel->grp7_len != 0) {
+			/*
+			 * Don't (yet?) support vendor
+			 * specific commands.
+			 */
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+			printf("Non-zero Group Codes\n");
+			return;
+		}
+
+		/*
+		 * Seems to be okay.
+		 * Setup our data structures.
+		 */
+		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
+			tstate = ahd_alloc_tstate(ahd, target, channel);
+			if (tstate == NULL) {
+				xpt_print_path(ccb->ccb_h.path);
+				printf("Couldn't allocate tstate\n");
+				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+				return;
+			}
+		}
+		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
+		if (lstate == NULL) {
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Couldn't allocate lstate\n");
+			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+			return;
+		}
+		memset(lstate, 0, sizeof(*lstate));
+		status = xpt_create_path(&lstate->path, /*periph*/NULL,
+					 xpt_path_path_id(ccb->ccb_h.path),
+					 xpt_path_target_id(ccb->ccb_h.path),
+					 xpt_path_lun_id(ccb->ccb_h.path));
+		if (status != CAM_REQ_CMP) {
+			free(lstate, M_DEVBUF);
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Couldn't allocate path\n");
+			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+			return;
+		}
+		SLIST_INIT(&lstate->accept_tios);
+		SLIST_INIT(&lstate->immed_notifies);
+		ahd_lock(ahd, &s);
+		ahd_pause(ahd);
+		if (target != CAM_TARGET_WILDCARD) {
+			tstate->enabled_luns[lun] = lstate;
+			ahd->enabled_luns++;
+
+			if ((ahd->features & AHD_MULTI_TID) != 0) {
+				u_int targid_mask;
+
+				targid_mask = ahd_inb(ahd, TARGID)
+					    | (ahd_inb(ahd, TARGID + 1) << 8);
+
+				targid_mask |= target_mask;
+				ahd_outb(ahd, TARGID, targid_mask);
+				ahd_outb(ahd, TARGID+1, (targid_mask >> 8));
+				
+				ahd_update_scsiid(ahd, targid_mask);
+			} else {
+				u_int our_id;
+				char  channel;
+
+				channel = SIM_CHANNEL(ahd, sim);
+				our_id = SIM_SCSI_ID(ahd, sim);
+
+				/*
+				 * This can only happen if selections
+				 * are not enabled
+				 */
+				if (target != our_id) {
+					u_int sblkctl;
+					char  cur_channel;
+					int   swap;
+
+					sblkctl = ahd_inb(ahd, SBLKCTL);
+					cur_channel = (sblkctl & SELBUSB)
+						    ? 'B' : 'A';
+					if ((ahd->features & AHD_TWIN) == 0)
+						cur_channel = 'A';
+					swap = cur_channel != channel;
+					ahd->our_id = target;
+
+					if (swap)
+						ahd_outb(ahd, SBLKCTL,
+							 sblkctl ^ SELBUSB);
+
+					ahd_outb(ahd, SCSIID, target);
+
+					if (swap)
+						ahd_outb(ahd, SBLKCTL, sblkctl);
+				}
+			}
+		} else
+			ahd->black_hole = lstate;
+		/* Allow select-in operations */
+		if (ahd->black_hole != NULL && ahd->enabled_luns > 0) {
+			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+			scsiseq1 |= ENSELI;
+			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
+			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
+			scsiseq1 |= ENSELI;
+			ahd_outb(ahd, SCSISEQ1, scsiseq1);
+		}
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		xpt_print_path(ccb->ccb_h.path);
+		printf("Lun now enabled for target mode\n");
+	} else {
+		struct scb *scb;
+		int i, empty;
+
+		if (lstate == NULL) {
+			ccb->ccb_h.status = CAM_LUN_INVALID;
+			return;
+		}
+
+		ahd_lock(ahd, &s);
+		
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+			struct ccb_hdr *ccbh;
+
+			ccbh = &scb->io_ctx->ccb_h;
+			if (ccbh->func_code == XPT_CONT_TARGET_IO
+			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
+				printf("CTIO pending\n");
+				ccb->ccb_h.status = CAM_REQ_INVALID;
+				ahd_unlock(ahd, &s);
+				return;
+			}
+		}
+
+		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
+			printf("ATIOs pending\n");
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+		}
+
+		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
+			printf("INOTs pending\n");
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+		}
+
+		if (ccb->ccb_h.status != CAM_REQ_CMP) {
+			ahd_unlock(ahd, &s);
+			return;
+		}
+
+		xpt_print_path(ccb->ccb_h.path);
+		printf("Target mode disabled\n");
+		xpt_free_path(lstate->path);
+		free(lstate, M_DEVBUF);
+
+		ahd_pause(ahd);
+		/* Can we clean up the target too? */
+		if (target != CAM_TARGET_WILDCARD) {
+			tstate->enabled_luns[lun] = NULL;
+			ahd->enabled_luns--;
+			for (empty = 1, i = 0; i < 8; i++)
+				if (tstate->enabled_luns[i] != NULL) {
+					empty = 0;
+					break;
+				}
+
+			if (empty) {
+				ahd_free_tstate(ahd, target, channel,
+						/*force*/FALSE);
+				if (ahd->features & AHD_MULTI_TID) {
+					u_int targid_mask;
+
+					targid_mask = ahd_inb(ahd, TARGID)
+						    | (ahd_inb(ahd, TARGID + 1)
+						       << 8);
+
+					targid_mask &= ~target_mask;
+					ahd_outb(ahd, TARGID, targid_mask);
+					ahd_outb(ahd, TARGID+1,
+					 	 (targid_mask >> 8));
+					ahd_update_scsiid(ahd, targid_mask);
+				}
+			}
+		} else {
+
+			ahd->black_hole = NULL;
+
+			/*
+			 * We can't allow selections without
+			 * our black hole device.
+			 */
+			empty = TRUE;
+		}
+		if (ahd->enabled_luns == 0) {
+			/* Disallow select-in */
+			u_int scsiseq1;
+
+			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+			scsiseq1 &= ~ENSELI;
+			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
+			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
+			scsiseq1 &= ~ENSELI;
+			ahd_outb(ahd, SCSISEQ1, scsiseq1);
+
+			if ((ahd->features & AHD_MULTIROLE) == 0) {
+				printf("Configuring Initiator Mode\n");
+				ahd->flags &= ~AHD_TARGETROLE;
+				ahd->flags |= AHD_INITIATORROLE;
+				ahd_pause(ahd);
+				ahd_loadseq(ahd);
+			}
+		}
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+	}
+#endif
+}
+
+static void
+ahd_update_scsiid(struct ahd_softc *ahd, u_int targid_mask)
+{
+#if NOT_YET
+	u_int scsiid_mask;
+	u_int scsiid;
+
+	if ((ahd->features & AHD_MULTI_TID) == 0)
+		panic("ahd_update_scsiid called on non-multitid unit\n");
+
+	/*
+	 * Since we will rely on the TARGID mask
+	 * for selection enables, ensure that OID
+	 * in SCSIID is not set to some other ID
+	 * that we don't want to allow selections on.
+	 */
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		scsiid = ahd_inb(ahd, SCSIID_ULTRA2);
+	else
+		scsiid = ahd_inb(ahd, SCSIID);
+	scsiid_mask = 0x1 << (scsiid & OID);
+	if ((targid_mask & scsiid_mask) == 0) {
+		u_int our_id;
+
+		/* ffs counts from 1 */
+		our_id = ffs(targid_mask);
+		if (our_id == 0)
+			our_id = ahd->our_id;
+		else
+			our_id--;
+		scsiid &= TID;
+		scsiid |= our_id;
+	}
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		ahd_outb(ahd, SCSIID_ULTRA2, scsiid);
+	else
+		ahd_outb(ahd, SCSIID, scsiid);
+#endif
+}
+
+void
+ahd_run_tqinfifo(struct ahd_softc *ahd, int paused)
+{
+	struct target_cmd *cmd;
+
+	ahd_sync_tqinfifo(ahd, BUS_DMASYNC_POSTREAD);
+	while ((cmd = &ahd->targetcmds[ahd->tqinfifonext])->cmd_valid != 0) {
+
+		/*
+		 * Only advance through the queue if we
+		 * have the resources to process the command.
+		 */
+		if (ahd_handle_target_cmd(ahd, cmd) != 0)
+			break;
+
+		cmd->cmd_valid = 0;
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, ahd->tqinfifonext),
+				sizeof(struct target_cmd),
+				BUS_DMASYNC_PREREAD);
+		ahd->tqinfifonext++;
+
+		/*
+		 * Lazily update our position in the target mode incoming
+		 * command queue as seen by the sequencer.
+		 */
+		if ((ahd->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
+			u_int hs_mailbox;
+
+			hs_mailbox = ahd_inb(ahd, HS_MAILBOX);
+			hs_mailbox &= ~HOST_TQINPOS;
+			hs_mailbox |= ahd->tqinfifonext & HOST_TQINPOS;
+			ahd_outb(ahd, HS_MAILBOX, hs_mailbox);
+		}
+	}
+}
+
+static int
+ahd_handle_target_cmd(struct ahd_softc *ahd, struct target_cmd *cmd)
+{
+	struct	  ahd_tmode_tstate *tstate;
+	struct	  ahd_tmode_lstate *lstate;
+	struct	  ccb_accept_tio *atio;
+	uint8_t *byte;
+	int	  initiator;
+	int	  target;
+	int	  lun;
+
+	initiator = SCSIID_TARGET(ahd, cmd->scsiid);
+	target = SCSIID_OUR_ID(cmd->scsiid);
+	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);
+
+	byte = cmd->bytes;
+	tstate = ahd->enabled_targets[target];
+	lstate = NULL;
+	if (tstate != NULL)
+		lstate = tstate->enabled_luns[lun];
+
+	/*
+	 * Commands for disabled luns go to the black hole driver.
+	 */
+	if (lstate == NULL)
+		lstate = ahd->black_hole;
+
+	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
+	if (atio == NULL) {
+		ahd->flags |= AHD_TQINFIFO_BLOCKED;
+		/*
+		 * Wait for more ATIOs from the peripheral driver for this lun.
+		 */
+		return (1);
+	} else
+		ahd->flags &= ~AHD_TQINFIFO_BLOCKED;
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_TQIN) != 0)
+		printf("Incoming command from %d for %d:%d%s\n",
+		       initiator, target, lun,
+		       lstate == ahd->black_hole ? "(Black Holed)" : "");
+#endif
+	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);
+
+	if (lstate == ahd->black_hole) {
+		/* Fill in the wildcards */
+		atio->ccb_h.target_id = target;
+		atio->ccb_h.target_lun = lun;
+	}
+
+	/*
+	 * Package it up and send it off to
+	 * whomever has this lun enabled.
+	 */
+	atio->sense_len = 0;
+	atio->init_id = initiator;
+	if (byte[0] != 0xFF) {
+		/* Tag was included */
+		atio->tag_action = *byte++;
+		atio->tag_id = *byte++;
+		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
+	} else {
+		atio->ccb_h.flags = 0;
+	}
+	byte++;
+
+	/* Okay.  Now determine the cdb size based on the command code */
+	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
+	case 0:
+		atio->cdb_len = 6;
+		break;
+	case 1:
+	case 2:
+		atio->cdb_len = 10;
+		break;
+	case 4:
+		atio->cdb_len = 16;
+		break;
+	case 5:
+		atio->cdb_len = 12;
+		break;
+	case 3:
+	default:
+		/* Only copy the opcode. */
+		atio->cdb_len = 1;
+		printf("Reserved or VU command code type encountered\n");
+		break;
+	}
+	
+	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
+
+	atio->ccb_h.status |= CAM_CDB_RECVD;
+
+	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
+		/*
+		 * We weren't allowed to disconnect.
+		 * We're hanging on the bus until a
+		 * continue target I/O comes in response
+		 * to this accept tio.
+		 */
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_TQIN) != 0)
+			printf("Received Immediate Command %d:%d:%d - %p\n",
+			       initiator, target, lun, ahd->pending_device);
+#endif
+		ahd->pending_device = lstate;
+		ahd_freeze_ccb((union ccb *)atio);
+		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
+	}
+	xpt_done((union ccb*)atio);
+	return (0);
+}
+
+#endif
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.h	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,1320 @@
+/*
+ * Core definitions and data structures shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2002 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.h#61 $
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _AIC79XX_H_
+#define _AIC79XX_H_
+
+/* Register Definitions */
+#include "aic79xx_reg.h"
+
+/************************* Forward Declarations *******************************/
+struct ahd_platform_data;
+struct scb_platform_data;
+
+/****************************** Useful Macros *********************************/
+#ifndef MAX
+#define MAX(a,b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a,b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))
+
+#define ALL_CHANNELS '\0'
+#define ALL_TARGETS_MASK 0xFFFF
+#define INITIATOR_WILDCARD	(~0)
+#define	SCB_LIST_NULL		0xFF00
+#define	SCB_LIST_NULL_LE	(ahd_htole16(SCB_LIST_NULL))
+#define QOUTFIFO_ENTRY_VALID 0x8000
+#define QOUTFIFO_ENTRY_VALID_LE (ahd_htole16(0x8000))
+#define SCBID_IS_NULL(scbid) (((scbid) & 0xFF00 ) == SCB_LIST_NULL)
+
+#define SCSIID_TARGET(ahd, scsiid)	\
+	(((scsiid) & TID) >> TID_SHIFT)
+#define SCSIID_OUR_ID(scsiid)		\
+	((scsiid) & OID)
+#define SCSIID_CHANNEL(ahd, scsiid) ('A')
+#define	SCB_IS_SCSIBUS_B(ahd, scb) (0)
+#define	SCB_GET_OUR_ID(scb) \
+	SCSIID_OUR_ID((scb)->hscb->scsiid)
+#define	SCB_GET_TARGET(ahd, scb) \
+	SCSIID_TARGET((ahd), (scb)->hscb->scsiid)
+#define	SCB_GET_CHANNEL(ahd, scb) \
+	SCSIID_CHANNEL(ahd, (scb)->hscb->scsiid)
+#define	SCB_GET_LUN(scb) \
+	((scb)->hscb->lun)
+#define SCB_GET_TARGET_OFFSET(ahd, scb)	\
+	SCB_GET_TARGET(ahd, scb)
+#define SCB_GET_TARGET_MASK(ahd, scb) \
+	(0x01 << (SCB_GET_TARGET_OFFSET(ahd, scb)))
+/*
+ * TCLs have the following format: TTTTLLLLLLLL
+ */
+#define TCL_TARGET_OFFSET(tcl) \
+	((((tcl) >> 4) & TID) >> 4)
+#define TCL_LUN(tcl) \
+	(tcl & (AHD_NUM_LUNS - 1))
+#define BUILD_TCL(scsiid, lun) \
+	((lun) | (((scsiid) & TID) << 4))
+#define BUILD_TCL_RAW(target, channel, lun) \
+	((lun) | ((target) << 8))
+
+#define SCB_GET_TAG(scb) \
+	ahd_le16toh(scb->hscb->tag)
+
+#ifndef	AHD_TARGET_MODE
+#undef	AHD_TMODE_ENABLE
+#define	AHD_TMODE_ENABLE 0
+#endif
+
+#define AHD_BUILD_COL_IDX(target, lun)				\
+	(((lun) << 4) | target)
+
+#define AHD_GET_SCB_COL_IDX(ahd, scb)				\
+	((SCB_GET_LUN(scb) << 4) | SCB_GET_TARGET(ahd, scb))
+
+#define AHD_SET_SCB_COL_IDX(scb, col_idx)				\
+do {									\
+	(scb)->hscb->scsiid = ((col_idx) << TID_SHIFT) & TID;		\
+	(scb)->hscb->lun = ((col_idx) >> 4) & (AHD_NUM_LUNS_NONPKT-1);	\
+} while (0)
+
+#define AHD_COPY_SCB_COL_IDX(dst, src)				\
+do {								\
+	dst->hscb->scsiid = src->hscb->scsiid;			\
+	dst->hscb->lun = src->hscb->lun;			\
+} while (0)
+
+#define	AHD_NEVER_COL_IDX 0xFFFF
+
+/**************************** Driver Constants ********************************/
+/*
+ * The maximum number of supported targets.
+ */
+#define AHD_NUM_TARGETS 16
+
+/*
+ * The maximum number of supported luns.
+ * The identify message only supports 64 luns in non-packetized transfers.
+ * You can have 2^64 luns when information unit transfers are enabled,
+ * but until we see a need to support that many, we support 256.
+ */
+#define AHD_NUM_LUNS_NONPKT 64
+#define AHD_NUM_LUNS 256
+
+/*
+ * The maximum transfer per S/G segment.
+ */
+#define AHD_MAXTRANSFER_SIZE	 0x00ffffff	/* limited by 24bit counter */
+
+/*
+ * The maximum amount of SCB storage in hardware on a controller.
+ * This value represents an upper bound.  Due to software design,
+ * we may not be able to use this number.
+ */
+#define AHD_SCB_MAX	512
+
+/*
+ * The maximum number of concurrent transactions supported per driver instance.
+ * Sequencer Control Blocks (SCBs) store per-transaction information.
+ */
+#define AHD_MAX_QUEUE	AHD_SCB_MAX
+
+/*
+ * Define the size of our QIN and QOUT FIFOs.  They must be a power of 2
+ * in size and accomodate as many transactions as can be queued concurrently.
+ */
+#define	AHD_QIN_SIZE	AHD_MAX_QUEUE
+#define	AHD_QOUT_SIZE	AHD_MAX_QUEUE
+
+#define AHD_QIN_WRAP(x) ((x) & (AHD_QIN_SIZE-1))
+/*
+ * The maximum amount of SCB storage we allocate in host memory.
+ */
+#define AHD_SCB_MAX_ALLOC AHD_MAX_QUEUE
+
+/*
+ * Ring Buffer of incoming target commands.
+ * We allocate 256 to simplify the logic in the sequencer
+ * by using the natural wrap point of an 8bit counter.
+ */
+#define AHD_TMODE_CMDS	256
+
+/* Reset line assertion time in us */
+#define AHD_BUSRESET_DELAY	25
+
+/******************* Chip Characteristics/Operating Settings  *****************/
+/*
+ * Chip Type
+ * The chip order is from least sophisticated to most sophisticated.
+ */
+typedef enum {
+	AHD_NONE	= 0x0000,
+	AHD_CHIPID_MASK	= 0x00FF,
+	AHD_AIC7901	= 0x0001,
+	AHD_AIC7902	= 0x0002,
+	AHD_AIC7901A	= 0x0003,
+	AHD_PCI		= 0x0100,	/* Bus type PCI */
+	AHD_PCIX	= 0x0200,	/* Bus type PCIX */
+	AHD_BUS_MASK	= 0x0F00
+} ahd_chip;
+
+/*
+ * Features available in each chip type.
+ */
+typedef enum {
+	AHD_FENONE	= 0x00000,
+	AHD_WIDE  	= 0x00001,	/* Wide Channel */
+	AHD_MULTI_FUNC	= 0x00100,	/* Multi-Function Twin Channel Device */
+	AHD_TARGETMODE	= 0x01000,	/* Has tested target mode support */
+	AHD_MULTIROLE	= 0x02000,	/* Space for two roles at a time */
+	AHD_REMOVABLE	= 0x00000,	/* Hot-Swap supported - None so far*/
+	AHD_AIC7901_FE	= AHD_FENONE,
+	AHD_AIC7902_FE	= AHD_MULTI_FUNC
+} ahd_feature;
+
+/*
+ * Bugs in the silicon that we work around in software.
+ */
+typedef enum {
+	AHD_BUGNONE		= 0x0000,
+	AHD_SENT_SCB_UPDATE_BUG	= 0x0001,
+	AHD_ABORT_LQI_BUG	= 0x0002,
+	AHD_PKT_BITBUCKET_BUG	= 0x0004,
+	AHD_LONG_SETIMO_BUG	= 0x0008,
+	AHD_NLQICRC_DELAYED_BUG	= 0x0010,
+	AHD_SCSIRST_BUG		= 0x0020,
+	AHD_PCIX_CHIPRST_BUG	= 0x0040,
+	AHD_PCIX_MMAPIO_BUG	= 0x0080,
+	/* Bug workarounds that can be disabled on non-PCIX busses. */
+	AHD_PCIX_BUG_MASK	= AHD_PCIX_CHIPRST_BUG
+				| AHD_PCIX_MMAPIO_BUG,
+	AHD_LQO_ATNO_BUG	= 0x0100,
+	AHD_AUTOFLUSH_BUG	= 0x0200,
+	AHD_CLRLQO_AUTOCLR_BUG	= 0x0400,
+	AHD_PKTIZED_STATUS_BUG  = 0x0800,
+	AHD_PKT_LUN_BUG		= 0x1000,
+	AHD_MDFF_WSCBPTR_BUG	= 0x2000,
+	AHD_REG_SLOW_SETTLE_BUG	= 0x4000,
+	AHD_SET_MODE_BUG	= 0x8000,
+	AHD_BUSFREEREV_BUG	= 0x10000
+} ahd_bug;
+
+/*
+ * Configuration specific settings.
+ * The driver determines these settings by probing the
+ * chip/controller's configuration.
+ */
+typedef enum {
+	AHD_FNONE	      = 0x00000,
+	AHD_PRIMARY_CHANNEL   = 0x00003,/*
+					 * The channel that should
+					 * be probed first.
+					 */
+	AHD_USEDEFAULTS	      = 0x00004,/*
+					 * For cards without an seeprom
+					 * or a BIOS to initialize the chip's
+					 * SRAM, we use the default target
+					 * settings.
+					 */
+	AHD_SEQUENCER_DEBUG   = 0x00008,
+	AHD_RESET_BUS_A	      = 0x00010,
+	AHD_EXTENDED_TRANS_A  = 0x00020,
+	AHD_TERM_ENB_A	      = 0x00040,
+	AHD_SPCHK_ENB_A	      = 0x00080,
+	AHD_STPWLEVEL_A	      = 0x00100,
+	AHD_INITIATORROLE     = 0x00200,/*
+					 * Allow initiator operations on
+					 * this controller.
+					 */
+	AHD_TARGETROLE	      = 0x00400,/*
+					 * Allow target operations on this
+					 * controller.
+					 */
+	AHD_RESOURCE_SHORTAGE = 0x00800,
+	AHD_TQINFIFO_BLOCKED  = 0x01000,/* Blocked waiting for ATIOs */
+	AHD_INT50_SPEEDFLEX   = 0x02000,/*
+					 * Internal 50pin connector
+					 * sits behind an aic3860
+					 */
+	AHD_BIOS_ENABLED      = 0x04000,
+	AHD_ALL_INTERRUPTS    = 0x08000,
+	AHD_39BIT_ADDRESSING  = 0x10000,/* Use 39 bit addressing scheme. */
+	AHD_64BIT_ADDRESSING  = 0x20000,/* Use 64 bit addressing scheme. */
+	AHD_CURRENT_SENSING   = 0x40000,
+	AHD_SCB_CONFIG_USED   = 0x80000,/* No SEEPROM but SCB had info. */
+	AHD_CPQ_BOARD	      = 0x100000,
+	AHD_RESET_POLL_ACTIVE = 0x200000
+} ahd_flag;
+
+/************************* Hardware  SCB Definition ***************************/
+
+/*
+ * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
+ * consists of a "hardware SCB" mirroring the fields availible on the card
+ * and additional information the kernel stores for each transaction.
+ *
+ * To minimize space utilization, a portion of the hardware scb stores
+ * different data during different portions of a SCSI transaction.
+ * As initialized by the host driver for the initiator role, this area
+ * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After
+ * the cdb has been presented to the target, this area serves to store
+ * residual transfer information and the SCSI status byte.
+ * For the target role, the contents of this area do not change, but
+ * still serve a different purpose than for the initiator role.  See
+ * struct target_data for details.
+ */
+
+/*
+ * Status information embedded in the shared poriton of
+ * an SCB after passing the cdb to the target.  The kernel
+ * driver will only read this data for transactions that
+ * complete abnormally.
+ */
+struct initiator_status {
+	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
+	uint32_t residual_sgptr;	/* The next S/G for this transfer */
+	uint8_t	 scsi_status;		/* Standard SCSI status byte */
+};
+
+struct target_status {
+	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
+	uint32_t residual_sgptr;	/* The next S/G for this transfer */
+	uint8_t  scsi_status;		/* SCSI status to give to initiator */
+	uint8_t  target_phases;		/* Bitmap of phases to execute */
+	uint8_t  data_phase;		/* Data-In or Data-Out */
+	uint8_t  initiator_tag;		/* Initiator's transaction tag */
+};
+
+/*
+ * Initiator mode SCB shared data area.
+ * If the embedded CDB is 12 bytes or less, we embed
+ * the sense buffer address in the SCB.  This allows
+ * us to retrieve sense information without interupting
+ * the host in packetized mode.
+ */
+typedef uint32_t sense_addr_t;
+#define MAX_CDB_LEN 16
+#define MAX_CDB_LEN_WITH_SENSE_ADDR (MAX_CDB_LEN - sizeof(sense_addr_t))
+union initiator_data {
+	uint64_t cdbptr;
+	uint8_t	 cdb[MAX_CDB_LEN];
+	struct {
+		uint8_t	 cdb[MAX_CDB_LEN_WITH_SENSE_ADDR];
+		sense_addr_t sense_addr;
+	} cdb_plus_saddr;
+};
+
+/*
+ * Target mode version of the shared data SCB segment.
+ */
+struct target_data {
+	uint32_t spare[2];	
+	uint8_t  scsi_status;		/* SCSI status to give to initiator */
+	uint8_t  target_phases;		/* Bitmap of phases to execute */
+	uint8_t  data_phase;		/* Data-In or Data-Out */
+	uint8_t  initiator_tag;		/* Initiator's transaction tag */
+};
+
+struct hardware_scb {
+/*0*/	union {
+		union	initiator_data idata;
+		struct	target_data tdata;
+		struct	initiator_status istatus;
+		struct	target_status tstatus;
+	} shared_data;
+/*
+ * A word about residuals.
+ * The scb is presented to the sequencer with the dataptr and datacnt
+ * fields initialized to the contents of the first S/G element to
+ * transfer.  The sgptr field is initialized to the bus address for
+ * the S/G element that follows the first in the in core S/G array
+ * or'ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid
+ * S/G entry for this transfer (single S/G element transfer with the
+ * first elements address and length preloaded in the dataptr/datacnt
+ * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.
+ * The SG_FULL_RESID flag ensures that the residual will be correctly
+ * noted even if no data transfers occur.  Once the data phase is entered,
+ * the residual sgptr and datacnt are loaded from the sgptr and the
+ * datacnt fields.  After each S/G element's dataptr and length are
+ * loaded into the hardware, the residual sgptr is advanced.  After
+ * each S/G element is expired, its datacnt field is checked to see
+ * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the
+ * residual sg ptr and the transfer is considered complete.  If the
+ * sequencer determines that there is a residual in the tranfer, or
+ * there is non-zero status, it will set the SG_STATUS_VALID flag in
+ * sgptr and dma the scb back into host memory.  To sumarize:
+ *
+ * Sequencer:
+ *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
+ *	  or residual_sgptr does not have SG_LIST_NULL set.
+ *
+ *	o We are transfering the last segment if residual_datacnt has
+ *	  the SG_LAST_SEG flag set.
+ *
+ * Host:
+ *	o A residual can only have occurred if a completed scb has the
+ *	  SG_STATUS_VALID flag set.  Inspection of the SCSI status field,
+ *	  the residual_datacnt, and the residual_sgptr field will tell
+ *	  for sure.
+ *
+ *	o residual_sgptr and sgptr refer to the "next" sg entry
+ *	  and so may point beyond the last valid sg entry for the
+ *	  transfer.
+ */ 
+#define SG_PTR_MASK	0xFFFFFFF8
+/*16*/	uint16_t tag;
+/*18*/	uint8_t  cdb_len;
+/*19*/	uint8_t  task_management;
+/*20*/	uint32_t next_hscb_busaddr;
+/*24*/	uint64_t dataptr;
+/*32*/	uint32_t datacnt;	/* Byte 3 is spare. */
+/*36*/	uint32_t sgptr;
+/*40*/	uint8_t  control;	/* See SCB_CONTROL in aic79xx.reg for details */
+/*41*/	uint8_t	 scsiid;	/*
+				 * Selection out Id
+				 * Our Id (bits 0-3) Their ID (bits 4-7)
+				 */
+/*42*/	uint8_t  lun;
+/*43*/	uint8_t  task_attribute;
+/*44*/	uint32_t hscb_busaddr;
+/******* Long lun field only downloaded for full 8 byte lun support *******/
+/*48*/  uint8_t	 pkt_long_lun[8];
+/******* Fields below are not Downloaded (Sequencer may use for scratch) ******/
+/*56*/  uint8_t	 spare[8];
+};
+
+/************************ Kernel SCB Definitions ******************************/
+/*
+ * Some fields of the SCB are OS dependent.  Here we collect the
+ * definitions for elements that all OS platforms need to include
+ * in there SCB definition.
+ */
+
+/*
+ * Definition of a scatter/gather element as transfered to the controller.
+ * The aic7xxx chips only support a 24bit length.  We use the top byte of
+ * the length to store additional address bits and a flag to indicate
+ * that a given segment terminates the transfer.  This gives us an
+ * addressable range of 512GB on machines with 64bit PCI or with chips
+ * that can support dual address cycles on 32bit PCI busses.
+ */
+struct ahd_dma_seg {
+	uint32_t	addr;
+	uint32_t	len;
+#define	AHD_DMA_LAST_SEG	0x80000000
+#define	AHD_SG_HIGH_ADDR_MASK	0x7F000000
+#define	AHD_SG_LEN_MASK		0x00FFFFFF
+};
+
+struct ahd_dma64_seg {
+	uint64_t	addr;
+	uint32_t	len;
+	uint32_t	pad;
+};
+
+struct map_node {
+	bus_dmamap_t		 dmamap;
+	bus_addr_t		 physaddr;
+	uint8_t			*vaddr;
+	SLIST_ENTRY(map_node)	 links;
+};
+
+/*
+ * The current state of this SCB.
+ */
+typedef enum {
+	SCB_FLAG_NONE		= 0x00000,
+	SCB_TRANSMISSION_ERROR	= 0x00001,/*
+					   * We detected a parity or CRC
+					   * error that has effected the
+					   * payload of the command.  This
+					   * flag is checked when normal
+					   * status is returned to catch
+					   * the case of a target not
+					   * responding to our attempt
+					   * to report the error.
+					   */
+	SCB_OTHERTCL_TIMEOUT	= 0x00002,/*
+					   * Another device was active
+					   * during the first timeout for
+					   * this SCB so we gave ourselves
+					   * an additional timeout period
+					   * in case it was hogging the
+					   * bus.
+				           */
+	SCB_DEVICE_RESET	= 0x00004,
+	SCB_SENSE		= 0x00008,
+	SCB_CDB32_PTR		= 0x00010,
+	SCB_RECOVERY_SCB	= 0x00020,
+	SCB_AUTO_NEGOTIATE	= 0x00040,/* Negotiate to achieve goal. */
+	SCB_NEGOTIATE		= 0x00080,/* Negotiation forced for command. */
+	SCB_ABORT		= 0x00100,
+	SCB_ACTIVE		= 0x00400,
+	SCB_TARGET_IMMEDIATE	= 0x00800,
+	SCB_PACKETIZED		= 0x01000,
+	SCB_EXPECT_PPR_BUSFREE	= 0x02000,
+	SCB_PKT_SENSE		= 0x04000,
+	SCB_CMDPHASE_ABORT	= 0x08000,
+	SCB_ON_COL_LIST		= 0x10000
+} scb_flag;
+
+struct scb {
+	struct	hardware_scb	 *hscb;
+	union {
+		SLIST_ENTRY(scb)  sle;
+		LIST_ENTRY(scb)	  le;
+		TAILQ_ENTRY(scb)  tqe;
+	} links;
+	union {
+		SLIST_ENTRY(scb)  sle;
+		LIST_ENTRY(scb)	  le;
+		TAILQ_ENTRY(scb)  tqe;
+	} links2;
+#define pending_links links2.le
+#define collision_links links2.le
+	struct scb		 *col_scb;
+	ahd_io_ctx_t		  io_ctx;
+	struct ahd_softc	 *ahd_softc;
+	scb_flag		  flags;
+#ifndef __linux__
+	bus_dmamap_t		  dmamap;
+#endif
+	struct scb_platform_data *platform_data;
+	struct map_node	 	 *hscb_map;
+	struct map_node	 	 *sg_map;
+	struct map_node	 	 *sense_map;
+	void			 *sg_list;
+	uint8_t			 *sense_data;
+	bus_addr_t		  sg_list_busaddr;
+	bus_addr_t		  sense_busaddr;
+	u_int			  sg_count;/* How full ahd_dma_seg is */
+};
+
+TAILQ_HEAD(scb_tailq, scb);
+LIST_HEAD(scb_list, scb);
+
+struct scb_data {
+	/*
+	 * TAILQ of lists of free SCBs grouped by device
+	 * collision domains.
+	 */
+	struct scb_tailq free_scbs;
+
+	/*
+	 * Per-device lists of SCBs whose tag ID would collide
+	 * with an already active tag on the device.
+	 */
+	struct scb_list free_scb_lists[AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT];
+
+	/*
+	 * SCBs that will not collide with any active device.
+	 */
+	struct scb_list any_dev_free_scb_list;
+
+	/*
+	 * Mapping from tag to SCB.
+	 */
+	struct	scb *scbindex[AHD_SCB_MAX];
+
+	/*
+	 * "Bus" addresses of our data structures.
+	 */
+	bus_dma_tag_t	 hscb_dmat;	/* dmat for our hardware SCB array */
+	bus_dma_tag_t	 sg_dmat;	/* dmat for our sg segments */
+	bus_dma_tag_t	 sense_dmat;	/* dmat for our sense buffers */
+	SLIST_HEAD(, map_node) hscb_maps;
+	SLIST_HEAD(, map_node) sg_maps;
+	SLIST_HEAD(, map_node) sense_maps;
+	int		 scbs_left;	/* unallocated scbs in head map_node */
+	int		 sgs_left;	/* unallocated sgs in head map_node */
+	int		 sense_left;	/* unallocated sense in head map_node */
+	uint16_t	 numscbs;
+	uint16_t	 maxhscbs;	/* Number of SCBs on the card */
+	uint8_t		 init_level;	/*
+					 * How far we've initialized
+					 * this structure.
+					 */
+};
+
+/************************ Target Mode Definitions *****************************/
+
+/*
+ * Connection desciptor for select-in requests in target mode.
+ */
+struct target_cmd {
+	uint8_t scsiid;		/* Our ID and the initiator's ID */
+	uint8_t identify;	/* Identify message */
+	uint8_t bytes[22];	/* 
+				 * Bytes contains any additional message
+				 * bytes terminated by 0xFF.  The remainder
+				 * is the cdb to execute.
+				 */
+	uint8_t cmd_valid;	/*
+				 * When a command is complete, the firmware
+				 * will set cmd_valid to all bits set.
+				 * After the host has seen the command,
+				 * the bits are cleared.  This allows us
+				 * to just peek at host memory to determine
+				 * if more work is complete. cmd_valid is on
+				 * an 8 byte boundary to simplify setting
+				 * it on aic7880 hardware which only has
+				 * limited direct access to the DMA FIFO.
+				 */
+	uint8_t pad[7];
+};
+
+/*
+ * Number of events we can buffer up if we run out
+ * of immediate notify ccbs.
+ */
+#define AHD_TMODE_EVENT_BUFFER_SIZE 8
+struct ahd_tmode_event {
+	uint8_t initiator_id;
+	uint8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
+#define	EVENT_TYPE_BUS_RESET 0xFF
+	uint8_t event_arg;
+};
+
+/*
+ * Per enabled lun target mode state.
+ * As this state is directly influenced by the host OS'es target mode
+ * environment, we let the OS module define it.  Forward declare the
+ * structure here so we can store arrays of them, etc. in OS neutral
+ * data structures.
+ */
+#ifdef AHD_TARGET_MODE 
+struct ahd_tmode_lstate {
+	struct cam_path *path;
+	struct ccb_hdr_slist accept_tios;
+	struct ccb_hdr_slist immed_notifies;
+	struct ahd_tmode_event event_buffer[AHD_TMODE_EVENT_BUFFER_SIZE];
+	uint8_t event_r_idx;
+	uint8_t event_w_idx;
+};
+#else
+struct ahd_tmode_lstate;
+#endif
+
+/******************** Transfer Negotiation Datastructures *********************/
+#define AHD_TRANS_CUR		0x01	/* Modify current neogtiation status */
+#define AHD_TRANS_ACTIVE	0x03	/* Assume this target is on the bus */
+#define AHD_TRANS_GOAL		0x04	/* Modify negotiation goal */
+#define AHD_TRANS_USER		0x08	/* Modify user negotiation settings */
+#define AHD_PERIOD_ASYNC	0xFF
+#define AHD_PERIOD_10MHz	0x19
+
+/*
+ * Transfer Negotiation Information.
+ */
+struct ahd_transinfo {
+	uint8_t protocol_version;	/* SCSI Revision level */
+	uint8_t transport_version;	/* SPI Revision level */
+	uint8_t width;			/* Bus width */
+	uint8_t period;			/* Sync rate factor */
+	uint8_t offset;			/* Sync offset */
+	uint8_t ppr_options;		/* Parallel Protocol Request options */
+};
+
+/*
+ * Per-initiator current, goal and user transfer negotiation information. */
+struct ahd_initiator_tinfo {
+	struct ahd_transinfo curr;
+	struct ahd_transinfo goal;
+	struct ahd_transinfo user;
+};
+
+/*
+ * Per enabled target ID state.
+ * Pointers to lun target state as well as sync/wide negotiation information
+ * for each initiator<->target mapping.  For the initiator role we pretend
+ * that we are the target and the targets are the initiators since the
+ * negotiation is the same regardless of role.
+ */
+struct ahd_tmode_tstate {
+	struct ahd_tmode_lstate*	enabled_luns[AHD_NUM_LUNS];
+	struct ahd_initiator_tinfo	transinfo[AHD_NUM_TARGETS];
+
+	/*
+	 * Per initiator state bitmasks.
+	 */
+	uint16_t	 auto_negotiate;/* Auto Negotiation Required */
+	uint16_t	 discenable;	/* Disconnection allowed  */
+	uint16_t	 tagenable;	/* Tagged Queuing allowed */
+};
+
+/*
+ * Points of interest along the negotiated transfer scale.
+ */
+#define AHD_SYNCRATE_MAX	0x8
+#define AHD_SYNCRATE_160	0x8
+#define AHD_SYNCRATE_PACED	0x8
+#define AHD_SYNCRATE_DT		0x9
+#define AHD_SYNCRATE_ULTRA2	0xa
+#define AHD_SYNCRATE_ULTRA	0xc
+#define AHD_SYNCRATE_FAST	0x19
+#define AHD_SYNCRATE_MIN_DT	AHD_SYNCRATE_FAST
+#define AHD_SYNCRATE_SYNC	0x32
+#define AHD_SYNCRATE_MIN	0x60
+#define	AHD_SYNCRATE_ASYNC	0xFF
+
+/*
+ * In RevA, the synctable uses a 120MHz rate for the period
+ * factor 8 and 160MHz for the period factor 7.  The 120MHz
+ * rate never made it into the official SCSI spec, so we must
+ * compensate when setting the negotiation table for Rev A
+ * parts.
+ */
+#define AHD_SYNCRATE_REVA_120	0x8
+#define AHD_SYNCRATE_REVA_160	0x7
+
+/***************************** Lookup Tables **********************************/
+/*
+ * Phase -> name and message out response
+ * to parity errors in each phase table. 
+ */
+struct ahd_phase_table_entry {
+        uint8_t phase;
+        uint8_t mesg_out; /* Message response to parity errors */
+	char *phasemsg;
+};
+
+/************************** Serial EEPROM Format ******************************/
+
+struct seeprom_config {
+/*
+ * Per SCSI ID Configuration Flags
+ */
+	uint16_t device_flags[16];	/* words 0-15 */
+#define		CFXFER		0x003F	/* synchronous transfer rate */
+#define			CFXFER_ASYNC	0x3F
+#define		CFQAS		0x0040	/* Negotiate QAS */
+#define		CFPACKETIZED	0x0080	/* Negotiate Packetized Transfers */
+#define		CFSTART		0x0100	/* send start unit SCSI command */
+#define		CFINCBIOS	0x0200	/* include in BIOS scan */
+#define		CFDISC		0x0400	/* enable disconnection */
+#define		CFMULTILUNDEV	0x0800	/* Probe multiple luns in BIOS scan */
+#define		CFWIDEB		0x1000	/* wide bus device */
+#define		CFHOSTMANAGED	0x8000	/* Managed by a RAID controller */
+
+/*
+ * BIOS Control Bits
+ */
+	uint16_t bios_control;		/* word 16 */
+#define		CFSUPREM	0x0001	/* support all removeable drives */
+#define		CFSUPREMB	0x0002	/* support removeable boot drives */
+#define		CFBIOSSTATE	0x000C	/* BIOS Action State */
+#define		    CFBS_DISABLED	0x00
+#define		    CFBS_ENABLED	0x04
+#define		    CFBS_DISABLED_SCAN	0x08
+#define		CFENABLEDV	0x0010	/* Perform Domain Validation */
+#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */	
+#define		CFSPARITY	0x0040	/* SCSI parity */
+#define		CFEXTEND	0x0080	/* extended translation enabled */
+#define		CFBOOTCD	0x0100  /* Support Bootable CD-ROM */
+#define		CFMSG_LEVEL	0x0600	/* BIOS Message Level */
+#define			CFMSG_VERBOSE	0x0000
+#define			CFMSG_SILENT	0x0200
+#define			CFMSG_DIAG	0x0400
+#define		CFRESETB	0x0800	/* reset SCSI bus at boot */
+/*		UNUSED		0xf000	*/
+
+/*
+ * Host Adapter Control Bits
+ */
+	uint16_t adapter_control;	/* word 17 */	
+#define		CFAUTOTERM	0x0001	/* Perform Auto termination */
+#define		CFSTERM		0x0002	/* SCSI low byte termination */
+#define		CFWSTERM	0x0004	/* SCSI high byte termination */
+#define		CFSEAUTOTERM	0x0008	/* Ultra2 Perform secondary Auto Term*/
+#define		CFSELOWTERM	0x0010	/* Ultra2 secondary low term */
+#define		CFSEHIGHTERM	0x0020	/* Ultra2 secondary high term */
+#define		CFSTPWLEVEL	0x0040	/* Termination level control */
+#define		CFBIOSAUTOTERM	0x0080	/* Perform Auto termination */
+#define		CFTERM_MENU	0x0100	/* BIOS displays termination menu */	
+#define		CFCLUSTERENB	0x8000	/* Cluster Enable */
+
+/*
+ * Bus Release Time, Host Adapter ID
+ */
+	uint16_t brtime_id;		/* word 18 */
+#define		CFSCSIID	0x000f	/* host adapter SCSI ID */
+/*		UNUSED		0x00f0	*/
+#define		CFBRTIME	0xff00	/* bus release time/PCI Latency Time */
+
+/*
+ * Maximum targets
+ */
+	uint16_t max_targets;		/* word 19 */	
+#define		CFMAXTARG	0x00ff	/* maximum targets */
+#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
+#define		CFBOOTID	0xf000	/* Target to boot from */
+	uint16_t res_1[10];		/* words 20-29 */
+	uint16_t signature;		/* BIOS Signature */
+#define		CFSIGNATURE	0x400
+	uint16_t checksum;		/* word 31 */
+};
+
+/****************************** Flexport Logic ********************************/
+#define FLXADDR_TERMCTL			0x0
+#define		FLX_TERMCTL_ENSECHIGH	0x8
+#define		FLX_TERMCTL_ENSECLOW	0x4
+#define		FLX_TERMCTL_ENPRIHIGH	0x2
+#define		FLX_TERMCTL_ENPRILOW	0x1
+#define FLXADDR_ROMSTAT_CURSENSECTL	0x1
+#define		FLX_ROMSTAT_SEECFG	0xF0
+#define		FLX_ROMSTAT_EECFG	0x0F
+#define		FLX_ROMSTAT_SEE_93C66	0x00
+#define		FLX_ROMSTAT_SEE_NONE	0xF0
+#define		FLX_ROMSTAT_EE_512x8	0x0
+#define		FLX_ROMSTAT_EE_1MBx8	0x1
+#define		FLX_ROMSTAT_EE_2MBx8	0x2
+#define		FLX_ROMSTAT_EE_4MBx8	0x3
+#define		FLX_ROMSTAT_EE_16MBx8	0x4
+#define 		CURSENSE_ENB	0x1
+#define	FLXADDR_FLEXSTAT		0x2
+#define		FLX_FSTAT_BUSY		0x1
+#define FLXADDR_CURRENT_STAT		0x4
+#define		FLX_CSTAT_SEC_HIGH	0xC0
+#define		FLX_CSTAT_SEC_LOW	0x30
+#define		FLX_CSTAT_PRI_HIGH	0x0C
+#define		FLX_CSTAT_PRI_LOW	0x03
+#define		FLX_CSTAT_MASK		0x03
+#define		FLX_CSTAT_SHIFT		2
+#define		FLX_CSTAT_OKAY		0x0
+#define		FLX_CSTAT_OVER		0x1
+#define		FLX_CSTAT_UNDER		0x2
+#define		FLX_CSTAT_INVALID	0x3
+
+int		ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+				 u_int start_addr, u_int count);
+
+int		ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+				  u_int start_addr, u_int count);
+int		ahd_wait_seeprom(struct ahd_softc *ahd);
+int		ahd_verify_cksum(struct seeprom_config *sc);
+int		ahd_acquire_seeprom(struct ahd_softc *ahd);
+void		ahd_release_seeprom(struct ahd_softc *ahd);
+
+/****************************  Message Buffer *********************************/
+typedef enum {
+	MSG_FLAG_NONE			= 0x00,
+	MSG_FLAG_EXPECT_PPR_BUSFREE	= 0x01,
+	MSG_FLAG_IU_REQ_CHANGED		= 0x02,
+	MSG_FLAG_EXPECT_IDE_BUSFREE	= 0x04,
+	MSG_FLAG_PACKETIZED		= 0x08
+} ahd_msg_flags;
+
+typedef enum {
+	MSG_TYPE_NONE			= 0x00,
+	MSG_TYPE_INITIATOR_MSGOUT	= 0x01,
+	MSG_TYPE_INITIATOR_MSGIN	= 0x02,
+	MSG_TYPE_TARGET_MSGOUT		= 0x03,
+	MSG_TYPE_TARGET_MSGIN		= 0x04
+} ahd_msg_type;
+
+typedef enum {
+	MSGLOOP_IN_PROG,
+	MSGLOOP_MSGCOMPLETE,
+	MSGLOOP_TERMINATED
+} msg_loop_stat;
+
+/*********************** Software Configuration Structure *********************/
+struct ahd_suspend_channel_state {
+	uint8_t	scsiseq;
+	uint8_t	sxfrctl0;
+	uint8_t	sxfrctl1;
+	uint8_t	simode0;
+	uint8_t	simode1;
+	uint8_t	seltimer;
+	uint8_t	seqctl;
+};
+
+struct ahd_suspend_state {
+	struct	ahd_suspend_channel_state channel[2];
+	uint8_t	optionmode;
+	uint8_t	dscommand0;
+	uint8_t	dspcistatus;
+	/* hsmailbox */
+	uint8_t	crccontrol1;
+	uint8_t	scbbaddr;
+	/* Host and sequencer SCB counts */
+	uint8_t	dff_thrsh;
+	uint8_t	*scratch_ram;
+	uint8_t	*btt;
+};
+
+typedef void (*ahd_bus_intr_t)(struct ahd_softc *);
+
+typedef enum {
+	AHD_MODE_DFF0,
+	AHD_MODE_DFF1,
+	AHD_MODE_CCHAN,
+	AHD_MODE_SCSI,
+	AHD_MODE_CFG,
+	AHD_MODE_UNKNOWN
+} ahd_mode;
+
+#define AHD_MK_MSK(x) (0x01 << (x))
+#define AHD_MODE_DFF0_MSK	AHD_MK_MSK(AHD_MODE_DFF0)
+#define AHD_MODE_DFF1_MSK	AHD_MK_MSK(AHD_MODE_DFF1)
+#define AHD_MODE_CCHAN_MSK	AHD_MK_MSK(AHD_MODE_CCHAN)
+#define AHD_MODE_SCSI_MSK	AHD_MK_MSK(AHD_MODE_SCSI)
+#define AHD_MODE_CFG_MSK	AHD_MK_MSK(AHD_MODE_CFG)
+#define AHD_MODE_UNKNOWN_MSK	AHD_MK_MSK(AHD_MODE_UNKNOWN)
+#define AHD_MODE_ANY_MSK (~0)
+
+typedef uint8_t ahd_mode_state;
+
+typedef void ahd_callback_t (void *);
+
+struct ahd_softc {
+	bus_space_tag_t           tags[2];
+	bus_space_handle_t        bshs[2];
+#ifndef __linux__
+	bus_dma_tag_t		  buffer_dmat;   /* dmat for buffer I/O */
+#endif
+	struct scb_data		  scb_data;
+
+	struct hardware_scb	 *next_queued_hscb;
+
+	/*
+	 * SCBs that have been sent to the controller
+	 */
+	LIST_HEAD(, scb)	  pending_scbs;
+
+	/*
+	 * Current register window mode information.
+	 */
+	ahd_mode		  dst_mode;
+	ahd_mode		  src_mode;
+
+	/*
+	 * Saved register window mode information
+	 * used for restore on next unpause.
+	 */
+	ahd_mode		  saved_dst_mode;
+	ahd_mode		  saved_src_mode;
+
+	/*
+	 * Platform specific data.
+	 */
+	struct ahd_platform_data *platform_data;
+
+	/*
+	 * Platform specific device information.
+	 */
+	ahd_dev_softc_t		  dev_softc;
+
+	/*
+	 * Bus specific device information.
+	 */
+	ahd_bus_intr_t		  bus_intr;
+
+	/*
+	 * Target mode related state kept on a per enabled lun basis.
+	 * Targets that are not enabled will have null entries.
+	 * As an initiator, we keep one target entry for our initiator
+	 * ID to store our sync/wide transfer settings.
+	 */
+	struct ahd_tmode_tstate  *enabled_targets[AHD_NUM_TARGETS];
+
+	/*
+	 * The black hole device responsible for handling requests for
+	 * disabled luns on enabled targets.
+	 */
+	struct ahd_tmode_lstate  *black_hole;
+
+	/*
+	 * Device instance currently on the bus awaiting a continue TIO
+	 * for a command that was not given the disconnect priveledge.
+	 */
+	struct ahd_tmode_lstate  *pending_device;
+
+	/*
+	 * Timer handles for timer driven callbacks.
+	 */
+	ahd_timer_t		  reset_timer;
+
+	/*
+	 * Card characteristics
+	 */
+	ahd_chip		  chip;
+	ahd_feature		  features;
+	ahd_bug			  bugs;
+	ahd_flag		  flags;
+	struct seeprom_config	 *seep_config;
+
+	/* Values to store in the SEQCTL register for pause and unpause */
+	uint8_t			  unpause;
+	uint8_t			  pause;
+
+	/* Command Queues */
+	uint16_t		  qoutfifonext;
+	uint16_t		  qoutfifonext_valid_tag;
+	uint16_t		  qinfifonext;
+	uint16_t		  qinfifo[AHD_SCB_MAX];
+	uint16_t		 *qoutfifo;
+
+	/* Critical Section Data */
+	struct cs		 *critical_sections;
+	u_int			  num_critical_sections;
+
+	/* Buffer for handling packetized bitbucket. */
+	uint8_t			 *overrun_buf;
+
+	/* Links for chaining softcs */
+	TAILQ_ENTRY(ahd_softc)	  links;
+
+	/* Channel Names ('A', 'B', etc.) */
+	char			  channel;
+
+	/* Initiator Bus ID */
+	uint8_t			  our_id;
+
+	/*
+	 * PCI error detection.
+	 */
+	int			  unsolicited_ints;
+
+	/*
+	 * Target incoming command FIFO.
+	 */
+	struct target_cmd	 *targetcmds;
+	uint8_t			  tqinfifonext;
+
+	/*
+	 * Incoming and outgoing message handling.
+	 */
+	uint8_t			  send_msg_perror;
+	ahd_msg_flags		  msg_flags;
+	ahd_msg_type		  msg_type;
+	uint8_t			  msgout_buf[12];/* Message we are sending */
+	uint8_t			  msgin_buf[12];/* Message we are receiving */
+	u_int			  msgout_len;	/* Length of message to send */
+	u_int			  msgout_index;	/* Current index in msgout */
+	u_int			  msgin_index;	/* Current index in msgin */
+
+	/*
+	 * Mapping information for data structures shared
+	 * between the sequencer and kernel.
+	 */
+	bus_dma_tag_t		  parent_dmat;
+	bus_dma_tag_t		  shared_data_dmat;
+	bus_dmamap_t		  shared_data_dmamap;
+	bus_addr_t		  shared_data_busaddr;
+
+	/* Information saved through suspend/resume cycles */
+	struct ahd_suspend_state  suspend_state;
+
+	/* Number of enabled target mode device on this card */
+	u_int			  enabled_luns;
+
+	/* Initialization level of this data structure */
+	u_int			  init_level;
+
+	/* PCI cacheline size. */
+	u_int			  pci_cachesize;
+
+	/* Per-Unit descriptive information */
+	const char		 *description;
+	const char		 *bus_description;
+	char			 *name;
+	int			  unit;
+
+	/* Selection Timer settings */
+	int			  seltime;
+
+	uint16_t	 	  user_discenable;/* Disconnection allowed  */
+	uint16_t		  user_tagenable;/* Tagged Queuing allowed */
+};
+
+TAILQ_HEAD(ahd_softc_tailq, ahd_softc);
+extern struct ahd_softc_tailq ahd_tailq;
+
+/************************ Active Device Information ***************************/
+typedef enum {
+	ROLE_UNKNOWN,
+	ROLE_INITIATOR,
+	ROLE_TARGET
+} role_t;
+
+struct ahd_devinfo {
+	int	 our_scsiid;
+	int	 target_offset;
+	uint16_t target_mask;
+	u_int	 target;
+	u_int	 lun;
+	char	 channel;
+	role_t	 role;		/*
+				 * Only guaranteed to be correct if not
+				 * in the busfree state.
+				 */
+};
+
+/****************************** PCI Structures ********************************/
+#define AHD_PCI_IOADDR0	PCIR_MAPS	/* I/O BAR*/
+#define AHD_PCI_MEMADDR	(PCIR_MAPS + 4)	/* Memory BAR */
+#define AHD_PCI_IOADDR1	(PCIR_MAPS + 12)/* Second I/O BAR */
+
+typedef int (ahd_device_setup_t)(struct ahd_softc *);
+
+struct ahd_pci_identity {
+	uint64_t		 full_id;
+	uint64_t		 id_mask;
+	char			*name;
+	ahd_device_setup_t	*setup;
+};
+extern struct ahd_pci_identity ahd_pci_ident_table [];
+extern const u_int ahd_num_pci_devs;
+
+/***************************** VL/EISA Declarations ***************************/
+struct aic7770_identity {
+	uint32_t		 full_id;
+	uint32_t		 id_mask;
+	char			*name;
+	ahd_device_setup_t	*setup;
+};
+extern struct aic7770_identity aic7770_ident_table [];
+extern const int ahd_num_aic7770_devs;
+
+#define AHD_EISA_SLOT_OFFSET	0xc00
+#define AHD_EISA_IOSIZE		0x100
+
+/*************************** Function Declarations ****************************/
+/******************************************************************************/
+u_int			ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl);
+void			ahd_busy_tcl(struct ahd_softc *ahd,
+				     u_int tcl, u_int busyid);
+static __inline void	ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl);
+static __inline void
+ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)
+{
+	ahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);
+}
+
+/***************************** PCI Front End *********************************/
+struct ahd_pci_identity	*ahd_find_pci_device(ahd_dev_softc_t);
+int			 ahd_pci_config(struct ahd_softc *,
+					struct ahd_pci_identity *);
+
+/*************************** EISA/VL Front End ********************************/
+struct aic7770_identity *aic7770_find_device(uint32_t);
+int			 aic7770_config(struct ahd_softc *ahd,
+					struct aic7770_identity *);
+
+/************************** SCB and SCB queue management **********************/
+int		ahd_probe_scbs(struct ahd_softc *);
+void		ahd_qinfifo_requeue_tail(struct ahd_softc *ahd,
+					 struct scb *scb);
+int		ahd_match_scb(struct ahd_softc *ahd, struct scb *scb,
+			      int target, char channel, int lun,
+			      u_int tag, role_t role);
+
+/****************************** Initialization ********************************/
+struct ahd_softc	*ahd_alloc(void *platform_arg, char *name);
+int			 ahd_softc_init(struct ahd_softc *);
+void			 ahd_controller_info(struct ahd_softc *ahd, char *buf);
+int			 ahd_init(struct ahd_softc *ahd);
+int			 ahd_default_config(struct ahd_softc *ahd);
+int			 ahd_parse_cfgdata(struct ahd_softc *ahd,
+					   struct seeprom_config *sc);
+void			 ahd_intr_enable(struct ahd_softc *ahd, int enable);
+void			 ahd_pause_and_flushwork(struct ahd_softc *ahd);
+int			 ahd_suspend(struct ahd_softc *ahd); 
+int			 ahd_resume(struct ahd_softc *ahd);
+void			 ahd_softc_insert(struct ahd_softc *);
+struct ahd_softc	*ahd_find_softc(struct ahd_softc *ahd);
+void			 ahd_set_unit(struct ahd_softc *, int);
+void			 ahd_set_name(struct ahd_softc *, char *);
+struct scb		*ahd_get_scb(struct ahd_softc *ahd, u_int col_idx);
+void			 ahd_free_scb(struct ahd_softc *ahd, struct scb *scb);
+void			 ahd_alloc_scbs(struct ahd_softc *ahd);
+void			 ahd_free(struct ahd_softc *ahd);
+int			 ahd_reset(struct ahd_softc *ahd);
+void			 ahd_shutdown(void *arg);
+int			ahd_write_flexport(struct ahd_softc *ahd,
+					   u_int addr, u_int value);
+int			ahd_read_flexport(struct ahd_softc *ahd, u_int addr,
+					  uint8_t *value);
+int			ahd_wait_flexport(struct ahd_softc *ahd);
+
+/*************************** Interrupt Services *******************************/
+void			ahd_pci_intr(struct ahd_softc *ahd);
+void			ahd_clear_intstat(struct ahd_softc *ahd);
+void			ahd_run_qoutfifo(struct ahd_softc *ahd);
+#ifdef AHD_TARGET_MODE
+void			ahd_run_tqinfifo(struct ahd_softc *ahd, int paused);
+#endif
+void			ahd_handle_hwerrint(struct ahd_softc *ahd);
+void			ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat);
+void			ahd_handle_scsiint(struct ahd_softc *ahd,
+					   u_int intstat);
+void			ahd_clear_critical_section(struct ahd_softc *ahd);
+
+/***************************** Error Recovery *********************************/
+typedef enum {
+	SEARCH_COMPLETE,
+	SEARCH_COUNT,
+	SEARCH_REMOVE,
+	SEARCH_PRINT
+} ahd_search_action;
+int			ahd_search_qinfifo(struct ahd_softc *ahd, int target,
+					   char channel, int lun, u_int tag,
+					   role_t role, uint32_t status,
+					   ahd_search_action action);
+int			ahd_search_disc_list(struct ahd_softc *ahd, int target,
+					     char channel, int lun, u_int tag,
+					     int stop_on_first, int remove,
+					     int save_state);
+void			ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
+int			ahd_reset_channel(struct ahd_softc *ahd, char channel,
+					  int initiate_reset);
+int			ahd_abort_scbs(struct ahd_softc *ahd, int target,
+				       char channel, int lun, u_int tag,
+				       role_t role, uint32_t status);
+void			ahd_restart(struct ahd_softc *ahd);
+void			ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo);
+void			ahd_handle_scb_status(struct ahd_softc *ahd,
+					      struct scb *scb);
+void			ahd_handle_scsi_status(struct ahd_softc *ahd,
+					       struct scb *scb);
+void			ahd_calc_residual(struct ahd_softc *ahd,
+					  struct scb *scb);
+/*************************** Utility Functions ********************************/
+struct ahd_phase_table_entry*
+			ahd_lookup_phase_entry(int phase);
+void			ahd_compile_devinfo(struct ahd_devinfo *devinfo,
+					    u_int our_id, u_int target,
+					    u_int lun, char channel,
+					    role_t role);
+/************************** Transfer Negotiation ******************************/
+void			ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
+					  u_int *ppr_options, u_int maxsync);
+void			ahd_validate_offset(struct ahd_softc *ahd,
+					    struct ahd_initiator_tinfo *tinfo,
+					    u_int period, u_int *offset,
+					    int wide, role_t role);
+void			ahd_validate_width(struct ahd_softc *ahd,
+					   struct ahd_initiator_tinfo *tinfo,
+					   u_int *bus_width,
+					   role_t role);
+int			ahd_update_neg_request(struct ahd_softc*,
+					       struct ahd_devinfo*,
+					       struct ahd_tmode_tstate*,
+					       struct ahd_initiator_tinfo*,
+					       int /*force*/);
+void			ahd_set_width(struct ahd_softc *ahd,
+				      struct ahd_devinfo *devinfo,
+				      u_int width, u_int type, int paused);
+void			ahd_set_syncrate(struct ahd_softc *ahd,
+					 struct ahd_devinfo *devinfo,
+					 u_int period, u_int offset,
+					 u_int ppr_options,
+					 u_int type, int paused);
+typedef enum {
+	AHD_QUEUE_NONE,
+	AHD_QUEUE_BASIC,
+	AHD_QUEUE_TAGGED
+} ahd_queue_alg;
+
+void			ahd_set_tags(struct ahd_softc *ahd,
+				     struct ahd_devinfo *devinfo,
+				     ahd_queue_alg alg);
+
+/**************************** Target Mode *************************************/
+#ifdef AHD_TARGET_MODE
+void		ahd_send_lstate_events(struct ahd_softc *,
+				       struct ahd_tmode_lstate *);
+void		ahd_handle_en_lun(struct ahd_softc *ahd,
+				  struct cam_sim *sim, union ccb *ccb);
+cam_status	ahd_find_tmode_devs(struct ahd_softc *ahd,
+				    struct cam_sim *sim, union ccb *ccb,
+				    struct ahd_tmode_tstate **tstate,
+				    struct ahd_tmode_lstate **lstate,
+				    int notfound_failure);
+#ifndef AHD_TMODE_ENABLE
+#define AHD_TMODE_ENABLE 0
+#endif
+#endif
+/******************************* Debug ***************************************/
+#ifdef AHD_DEBUG
+extern uint32_t ahd_debug;
+#define AHD_SHOW_MISC		0x0001
+#define AHD_SHOW_SENSE		0x0002
+#define AHD_DUMP_SEEPROM	0x0004
+#define AHD_SHOW_TERMCTL	0x0008
+#define AHD_SHOW_MEMORY		0x0010
+#define AHD_SHOW_MESSAGES	0x0020
+#define AHD_SHOW_MODEPTR	0x0040
+#define AHD_SHOW_SELTO		0x0080
+#define AHD_SHOW_FIFOS		0x0100
+#define AHD_SHOW_QFULL		0x0200
+#define AHD_SHOW_QUEUE		0x0400
+#define AHD_SHOW_TQIN		0x0800
+#define AHD_SHOW_SG		0x1000
+#define AHD_DEBUG_SEQUENCER	0x2000
+#endif
+void			ahd_print_scb(struct scb *scb);
+void			ahd_dump_sglist(struct scb *scb);
+void			ahd_dump_all_cards_state(void);
+void			ahd_dump_card_state(struct ahd_softc *ahd);
+int			ahd_print_register(ahd_reg_parse_entry_t *table,
+					   u_int num_entries,
+					   const char *name,
+					   u_int address,
+					   u_int value,
+					   u_int *cur_column,
+					   u_int wrap_point);
+void			ahd_dump_scbs(struct ahd_softc *ahd);
+#endif /* _AIC79XX_H_ */
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_host.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_host.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_host.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_host.h	2002-09-24 15:05:58.000000000 -0600
@@ -0,0 +1,95 @@
+/*
+ * Adaptec AIC79xx device driver host template for Linux.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#6 $
+ */
+
+#ifndef _AIC79XX_LINUX_HOST_H_
+#define _AIC79XX_LINUX_HOST_H_
+
+int		 ahd_linux_proc_info(char *, char **, off_t, int, int, int);
+int		 ahd_linux_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+int		 ahd_linux_detect(Scsi_Host_Template *);
+int		 ahd_linux_release(struct Scsi_Host *);
+const char	*ahd_linux_info(struct Scsi_Host *);
+int		 ahd_linux_biosparam(Disk *, kdev_t, int[]);
+int		 ahd_linux_bus_reset(Scsi_Cmnd *);
+int		 ahd_linux_dev_reset(Scsi_Cmnd *);
+int		 ahd_linux_abort(Scsi_Cmnd *);
+
+#if defined(__i386__)
+#  define AIC79XX_BIOSPARAM ahd_linux_biosparam
+#else
+#  define AIC79XX_BIOSPARAM NULL
+#endif
+
+/*
+ * Scsi_Host_Template (see hosts.h) for AIC-79xx - some fields
+ * to do with card config are filled in after the card is detected.
+ */
+#define AIC79XX	{						\
+	next: NULL,						\
+	module: NULL,						\
+	proc_dir: NULL,						\
+	proc_info: ahd_linux_proc_info,				\
+	name: NULL,						\
+	detect: ahd_linux_detect,				\
+	release: ahd_linux_release,				\
+	info: ahd_linux_info,					\
+	command: NULL,						\
+	queuecommand: ahd_linux_queue,				\
+	eh_strategy_handler: NULL,				\
+	eh_abort_handler: ahd_linux_abort,			\
+	eh_device_reset_handler: ahd_linux_dev_reset,		\
+	eh_bus_reset_handler: ahd_linux_bus_reset,		\
+	eh_host_reset_handler: NULL,				\
+	abort: NULL,						\
+	reset: NULL,						\
+	slave_attach: NULL,					\
+	bios_param: AIC79XX_BIOSPARAM,				\
+	can_queue: AHD_MAX_QUEUE,/* max simultaneous cmds     */\
+	this_id: -1,		 /* scsi id of host adapter   */\
+	sg_tablesize: AHD_NSEG,	 /* max scatter-gather cmds   */\
+	cmd_per_lun: 2,		 /* cmds per lun	      */\
+	present: 0,		 /* number of 7xxx's present  */\
+	unchecked_isa_dma: 0,	 /* no memory DMA restrictions*/\
+	use_clustering: ENABLE_CLUSTERING,			\
+	use_new_eh_code: 1					\
+}
+
+#endif /* _AIC79XX_LINUX_HOST_H_ */
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_inline.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_inline.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_inline.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_inline.h	2002-09-11 15:08:12.000000000 -0600
@@ -0,0 +1,933 @@
+/*
+ * Inline routines shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx_inline.h#36 $
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _AIC79XX_INLINE_H_
+#define _AIC79XX_INLINE_H_
+
+/******************************** Debugging ***********************************/
+static __inline char *ahd_name(struct ahd_softc *ahd);
+
+static __inline char *
+ahd_name(struct ahd_softc *ahd)
+{
+	return (ahd->name);
+}
+
+/************************ Sequencer Execution Control *************************/
+static __inline void ahd_known_modes(struct ahd_softc *ahd,
+				     ahd_mode src, ahd_mode dst);
+static __inline ahd_mode_state ahd_build_mode_state(struct ahd_softc *ahd,
+						    ahd_mode src,
+						    ahd_mode dst);
+static __inline void ahd_extract_mode_state(struct ahd_softc *ahd,
+					    ahd_mode_state state,
+					    ahd_mode *src, ahd_mode *dst);
+static __inline void ahd_set_modes(struct ahd_softc *ahd, ahd_mode src,
+				   ahd_mode dst);
+static __inline void ahd_update_modes(struct ahd_softc *ahd);
+static __inline void ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
+				      ahd_mode dstmode, const char *file,
+				      int line);
+static __inline ahd_mode_state ahd_save_modes(struct ahd_softc *ahd);
+static __inline void ahd_restore_modes(struct ahd_softc *ahd,
+				       ahd_mode_state state);
+static __inline int  ahd_is_paused(struct ahd_softc *ahd);
+static __inline void ahd_pause(struct ahd_softc *ahd);
+static __inline void ahd_unpause(struct ahd_softc *ahd);
+
+static __inline void
+ahd_known_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	ahd->src_mode = src;
+	ahd->dst_mode = dst;
+	ahd->saved_src_mode = src;
+	ahd->saved_dst_mode = dst;
+}
+
+static __inline ahd_mode_state
+ahd_build_mode_state(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	return ((src << SRC_MODE_SHIFT) | (dst << DST_MODE_SHIFT));
+}
+
+static __inline void
+ahd_extract_mode_state(struct ahd_softc *ahd, ahd_mode_state state,
+		       ahd_mode *src, ahd_mode *dst)
+{
+	*src = (state & SRC_MODE) >> SRC_MODE_SHIFT;
+	*dst = (state & DST_MODE) >> DST_MODE_SHIFT;
+}
+
+static __inline void
+ahd_set_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	if (ahd->src_mode == src && ahd->dst_mode == dst)
+		return;
+#ifdef AHD_DEBUG
+	if (ahd->src_mode == AHD_MODE_UNKNOWN
+	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
+		panic("Setting mode prior to saving it.\n");
+	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
+		printf("Setting mode 0x%x\n",
+		       ahd_build_mode_state(ahd, src, dst));
+#endif
+	ahd_outb(ahd, MODE_PTR, ahd_build_mode_state(ahd, src, dst));
+	ahd->src_mode = src;
+	ahd->dst_mode = dst;
+}
+
+static __inline void
+ahd_update_modes(struct ahd_softc *ahd)
+{
+	ahd_mode_state mode_ptr;
+	ahd_mode src;
+	ahd_mode dst;
+
+	mode_ptr = ahd_inb(ahd, MODE_PTR);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
+		printf("Reading mode 0x%x\n", mode_ptr);
+#endif
+	ahd_extract_mode_state(ahd, mode_ptr, &src, &dst);
+	ahd_known_modes(ahd, src, dst);
+}
+
+static __inline void
+ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
+		 ahd_mode dstmode, const char *file, int line)
+{
+#ifdef AHD_DEBUG
+	if ((srcmode & AHD_MK_MSK(ahd->src_mode)) == 0
+	 || (dstmode & AHD_MK_MSK(ahd->dst_mode)) == 0) {
+		panic("%s:%s:%d: Mode assertion failed.\n",
+		       ahd_name(ahd), file, line);
+	}
+#endif
+}
+
+static __inline ahd_mode_state
+ahd_save_modes(struct ahd_softc *ahd)
+{
+	if (ahd->src_mode == AHD_MODE_UNKNOWN
+	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
+		ahd_update_modes(ahd);
+
+	return (ahd_build_mode_state(ahd, ahd->src_mode, ahd->dst_mode));
+}
+
+static __inline void
+ahd_restore_modes(struct ahd_softc *ahd, ahd_mode_state state)
+{
+	ahd_mode src;
+	ahd_mode dst;
+
+	ahd_extract_mode_state(ahd, state, &src, &dst);
+	ahd_set_modes(ahd, src, dst);
+}
+
+#define AHD_ASSERT_MODES(ahd, source, dest) \
+	ahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);
+
+/*
+ * Determine whether the sequencer has halted code execution.
+ * Returns non-zero status if the sequencer is stopped.
+ */
+static __inline int
+ahd_is_paused(struct ahd_softc *ahd)
+{
+	return ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);
+}
+
+/*
+ * Request that the sequencer stop and wait, indefinitely, for it
+ * to stop.  The sequencer will only acknowledge that it is paused
+ * once it has reached an instruction boundary and PAUSEDIS is
+ * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS
+ * for critical sections.
+ */
+static __inline void
+ahd_pause(struct ahd_softc *ahd)
+{
+	ahd_outb(ahd, HCNTRL, ahd->pause);
+
+	/*
+	 * Since the sequencer can disable pausing in a critical section, we
+	 * must loop until it actually stops.
+	 */
+	while (ahd_is_paused(ahd) == 0)
+		;
+}
+
+/*
+ * Allow the sequencer to continue program execution.
+ * We check here to ensure that no additional interrupt
+ * sources that would cause the sequencer to halt have been
+ * asserted.  If, for example, a SCSI bus reset is detected
+ * while we are fielding a different, pausing, interrupt type,
+ * we don't want to release the sequencer before going back
+ * into our interrupt handler and dealing with this new
+ * condition.
+ */
+static __inline void
+ahd_unpause(struct ahd_softc *ahd)
+{
+	/*
+	 * Automatically restore our modes to those saved
+	 * prior to the first change of the mode.
+	 */
+	if (ahd->saved_src_mode != AHD_MODE_UNKNOWN
+	 && ahd->saved_dst_mode != AHD_MODE_UNKNOWN)
+		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+
+	if ((ahd_inb(ahd, INTSTAT) & ~(SWTMINT | CMDCMPLT)) == 0)
+		ahd_outb(ahd, HCNTRL, ahd->unpause);
+
+	ahd_known_modes(ahd, AHD_MODE_UNKNOWN, AHD_MODE_UNKNOWN);
+}
+
+/*********************** Scatter Gather List Handling *************************/
+static __inline void	*ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+				      void *sgptr, bus_addr_t addr,
+				      bus_size_t len, int last);
+static __inline void	 ahd_setup_scb_common(struct ahd_softc *ahd,
+					      struct scb *scb);
+static __inline void	 ahd_setup_data_scb(struct ahd_softc *ahd,
+					    struct scb *scb);
+static __inline void	 ahd_setup_noxfer_scb(struct ahd_softc *ahd,
+					      struct scb *scb);
+
+static __inline void *
+ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+	     void *sgptr, bus_addr_t addr, bus_size_t len, int last)
+{
+	scb->sg_count++;
+	if (sizeof(bus_addr_t) > 4
+	 && (ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = (struct ahd_dma64_seg *)sgptr;
+		sg->addr = ahd_htole64(addr);
+		sg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));
+		return (sg + 1);
+	} else {
+		struct ahd_dma_seg *sg;
+
+		sg = (struct ahd_dma_seg *)sgptr;
+		sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
+		sg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)
+				    | (last ? AHD_DMA_LAST_SEG : 0));
+		return (sg + 1);
+	}
+}
+
+static __inline void
+ahd_setup_scb_common(struct ahd_softc *ahd, struct scb *scb)
+{
+	/* XXX Handle target mode SCBs. */
+	if ((scb->flags & SCB_PACKETIZED) != 0) {
+		/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */
+		scb->hscb->task_attribute= scb->hscb->control & SCB_TAG_TYPE;
+		scb->hscb->task_management = 0;
+		/*
+		 * For Rev A short lun workaround.
+		 */
+		scb->hscb->pkt_long_lun[6] = scb->hscb->lun;
+	}
+
+	if (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR
+	 || (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)
+		scb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =
+		    ahd_htole32(scb->sense_busaddr);
+}
+
+static __inline void
+ahd_setup_data_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	/*
+	 * Copy the first SG into the "current" data ponter area.
+	 */
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = (struct ahd_dma64_seg *)scb->sg_list;
+		scb->hscb->dataptr = sg->addr;
+		scb->hscb->datacnt = sg->len;
+	} else {
+		struct ahd_dma_seg *sg;
+
+		sg = (struct ahd_dma_seg *)scb->sg_list;
+		scb->hscb->dataptr = sg->addr;
+		if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
+			uint64_t high_addr;
+
+			high_addr = ahd_le32toh(sg->len) & 0x7F000000;
+			scb->hscb->dataptr |= ahd_htole64(high_addr << 8);
+		}
+		scb->hscb->datacnt = sg->len;
+	}
+	/*
+	 * Note where to find the SG entries in bus space.
+	 * We also set the full residual flag which the 
+	 * sequencer will clear as soon as a data transfer
+	 * occurs.
+	 */
+	scb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);
+}
+
+static __inline void
+ahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	scb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);
+	scb->hscb->dataptr = 0;
+	scb->hscb->datacnt = 0;
+}
+
+/************************** Memory mapping routines ***************************/
+static __inline size_t	ahd_sg_size(struct ahd_softc *ahd);
+static __inline void *
+			ahd_sg_bus_to_virt(struct ahd_softc *ahd,
+					   struct scb *scb,
+					   uint32_t sg_busaddr);
+static __inline uint32_t
+			ahd_sg_virt_to_bus(struct ahd_softc *ahd,
+					   struct scb *scb,
+					   void *sg);
+static __inline void	ahd_sync_scb(struct ahd_softc *ahd,
+				     struct scb *scb, int op);
+static __inline void	ahd_sync_sglist(struct ahd_softc *ahd,
+					struct scb *scb, int op);
+static __inline void	ahd_sync_sense(struct ahd_softc *ahd,
+				       struct scb *scb, int op);
+static __inline uint32_t
+			ahd_targetcmd_offset(struct ahd_softc *ahd,
+					     u_int index);
+
+static __inline size_t
+ahd_sg_size(struct ahd_softc *ahd)
+{
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		return (sizeof(struct ahd_dma64_seg));
+	return (sizeof(struct ahd_dma_seg));
+}
+
+static __inline void *
+ahd_sg_bus_to_virt(struct ahd_softc *ahd, struct scb *scb, uint32_t sg_busaddr)
+{
+	bus_addr_t sg_offset;
+
+	/* sg_list_phys points to entry 1, not 0 */
+	sg_offset = sg_busaddr - (scb->sg_list_busaddr - ahd_sg_size(ahd));
+	return ((uint8_t *)scb->sg_list + sg_offset);
+}
+
+static __inline uint32_t
+ahd_sg_virt_to_bus(struct ahd_softc *ahd, struct scb *scb, void *sg)
+{
+	bus_addr_t sg_offset;
+
+	/* sg_list_phys points to entry 1, not 0 */
+	sg_offset = ((uint8_t *)sg - (uint8_t *)scb->sg_list)
+		  - ahd_sg_size(ahd);
+
+	return (scb->sg_list_busaddr + sg_offset);
+}
+
+static __inline void
+ahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
+			scb->hscb_map->dmamap,
+			/*offset*/(uint8_t*)scb->hscb - scb->hscb_map->vaddr,
+			/*len*/sizeof(*scb->hscb), op);
+}
+
+static __inline void
+ahd_sync_sglist(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	if (scb->sg_count == 0)
+		return;
+
+	ahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,
+			scb->sg_map->dmamap,
+			/*offset*/scb->sg_list_busaddr - ahd_sg_size(ahd),
+			/*len*/ahd_sg_size(ahd) * scb->sg_count, op);
+}
+
+static __inline void
+ahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
+			scb->sense_map->dmamap,
+			/*offset*/scb->sense_busaddr,
+			/*len*/AHD_SENSE_BUFSIZE, op);
+}
+
+static __inline uint32_t
+ahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)
+{
+	return (((uint8_t *)&ahd->targetcmds[index])
+	       - (uint8_t *)ahd->qoutfifo);
+}
+
+/*********************** Miscelaneous Support Functions ***********************/
+static __inline void	ahd_complete_scb(struct ahd_softc *ahd,
+					 struct scb *scb);
+static __inline void	ahd_update_residual(struct ahd_softc *ahd,
+					    struct scb *scb);
+static __inline struct ahd_initiator_tinfo *
+			ahd_fetch_transinfo(struct ahd_softc *ahd,
+					    char channel, u_int our_id,
+					    u_int remote_id,
+					    struct ahd_tmode_tstate **tstate);
+static __inline uint16_t
+			ahd_inw(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outw(struct ahd_softc *ahd, u_int port,
+				 u_int value);
+static __inline uint32_t
+			ahd_inl(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outl(struct ahd_softc *ahd, u_int port,
+				 uint32_t value);
+static __inline uint64_t
+			ahd_inq(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outq(struct ahd_softc *ahd, u_int port,
+				 uint64_t value);
+static __inline u_int	ahd_get_scbptr(struct ahd_softc *ahd);
+static __inline void	ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr);
+static __inline u_int	ahd_get_hnscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_hescb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_snscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_sescb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_sdscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_inb_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline u_int	ahd_inw_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline uint32_t
+			ahd_inl_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline void	ahd_swap_with_next_hscb(struct ahd_softc *ahd,
+						struct scb *scb);
+static __inline void	ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb);
+static __inline uint8_t *
+			ahd_get_sense_buf(struct ahd_softc *ahd,
+					  struct scb *scb);
+static __inline uint32_t
+			ahd_get_sense_bufaddr(struct ahd_softc *ahd,
+					      struct scb *scb);
+
+static __inline void
+ahd_complete_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	uint32_t sgptr;
+
+	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) != 0)
+		ahd_handle_scb_status(ahd, scb);
+	else
+		ahd_done(ahd, scb);
+}
+
+/*
+ * Determine whether the sequencer reported a residual
+ * for this SCB/transaction.
+ */
+static __inline void
+ahd_update_residual(struct ahd_softc *ahd, struct scb *scb)
+{
+	uint32_t sgptr;
+
+	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) != 0)
+		ahd_calc_residual(ahd, scb);
+}
+
+/*
+ * Return pointers to the transfer negotiation information
+ * for the specified our_id/remote_id pair.
+ */
+static __inline struct ahd_initiator_tinfo *
+ahd_fetch_transinfo(struct ahd_softc *ahd, char channel, u_int our_id,
+		    u_int remote_id, struct ahd_tmode_tstate **tstate)
+{
+	/*
+	 * Transfer data structures are stored from the perspective
+	 * of the target role.  Since the parameters for a connection
+	 * in the initiator role to a given target are the same as
+	 * when the roles are reversed, we pretend we are the target.
+	 */
+	if (channel == 'B')
+		our_id += 8;
+	*tstate = ahd->enabled_targets[our_id];
+	return (&(*tstate)->transinfo[remote_id]);
+}
+
+#define AHD_COPY_COL_IDX(dst, src)				\
+do {								\
+	dst->hscb->scsiid = src->hscb->scsiid;			\
+	dst->hscb->lun = src->hscb->lun;			\
+} while (0)
+
+static __inline uint16_t
+ahd_inw(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port+1) << 8) | ahd_inb(ahd, port));
+}
+
+static __inline void
+ahd_outw(struct ahd_softc *ahd, u_int port, u_int value)
+{
+	ahd_outb(ahd, port, value & 0xFF);
+	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
+}
+
+static __inline uint32_t
+ahd_inl(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port))
+	      | (ahd_inb(ahd, port+1) << 8)
+	      | (ahd_inb(ahd, port+2) << 16)
+	      | (ahd_inb(ahd, port+3) << 24));
+}
+
+static __inline void
+ahd_outl(struct ahd_softc *ahd, u_int port, uint32_t value)
+{
+	ahd_outb(ahd, port, (value) & 0xFF);
+	ahd_outb(ahd, port+1, ((value) >> 8) & 0xFF);
+	ahd_outb(ahd, port+2, ((value) >> 16) & 0xFF);
+	ahd_outb(ahd, port+3, ((value) >> 24) & 0xFF);
+}
+
+static __inline uint64_t
+ahd_inq(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port))
+	      | (ahd_inb(ahd, port+1) << 8)
+	      | (ahd_inb(ahd, port+2) << 16)
+	      | (ahd_inb(ahd, port+3) << 24)
+	      | (((uint64_t)ahd_inb(ahd, port+4)) << 32)
+	      | (((uint64_t)ahd_inb(ahd, port+5)) << 40)
+	      | (((uint64_t)ahd_inb(ahd, port+6)) << 48)
+	      | (((uint64_t)ahd_inb(ahd, port+7)) << 56));
+}
+
+static __inline void
+ahd_outq(struct ahd_softc *ahd, u_int port, uint64_t value)
+{
+	ahd_outb(ahd, port, value & 0xFF);
+	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
+	ahd_outb(ahd, port+2, (value >> 16) & 0xFF);
+	ahd_outb(ahd, port+3, (value >> 24) & 0xFF);
+	ahd_outb(ahd, port+4, (value >> 32) & 0xFF);
+	ahd_outb(ahd, port+5, (value >> 40) & 0xFF);
+	ahd_outb(ahd, port+6, (value >> 48) & 0xFF);
+	ahd_outb(ahd, port+7, (value >> 56) & 0xFF);
+}
+
+static __inline u_int
+ahd_get_scbptr(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	return (ahd_inb(ahd, SCBPTR) | (ahd_inb(ahd, SCBPTR + 1) << 8));
+}
+
+static __inline void
+ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	ahd_outb(ahd, SCBPTR, scbptr & 0xFF);
+	ahd_outb(ahd, SCBPTR+1, (scbptr >> 8) & 0xFF);
+}
+
+static __inline u_int
+ahd_get_hnscb_qoff(struct ahd_softc *ahd)
+{
+	return (ahd_inw_atomic(ahd, HNSCB_QOFF));
+}
+
+static __inline void
+ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	ahd_outw_atomic(ahd, HNSCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_hescb_qoff(struct ahd_softc *ahd)
+{
+	return (ahd_inb(ahd, HESCB_QOFF));
+}
+
+static __inline void
+ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	ahd_outb(ahd, HESCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_snscb_qoff(struct ahd_softc *ahd)
+{
+	u_int oldvalue;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	oldvalue = ahd_inw(ahd, SNSCB_QOFF);
+	ahd_outw(ahd, SNSCB_QOFF, oldvalue);
+	return (oldvalue);
+}
+
+static __inline void
+ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outw(ahd, SNSCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_sescb_qoff(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	return (ahd_inb(ahd, SESCB_QOFF));
+}
+
+static __inline void
+ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outb(ahd, SESCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_sdscb_qoff(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	return (ahd_inb(ahd, SDSCB_QOFF) | (ahd_inb(ahd, SDSCB_QOFF + 1) << 8));
+}
+
+static __inline void
+ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outb(ahd, SDSCB_QOFF, value & 0xFF);
+	ahd_outb(ahd, SDSCB_QOFF+1, (value >> 8) & 0xFF);
+}
+
+static __inline u_int
+ahd_inb_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	u_int value;
+
+	/*
+	 * Workaround PCI-X Rev A. hardware bug.
+	 * After a host read of SCB memory, the chip
+	 * may become confused into thinking prefetch
+	 * was required.  This starts the discard timer
+	 * running and can cause an unexpected discard
+	 * timer interrupt.  The work around is to read
+	 * a normal register prior to the exhaustion of
+	 * the discard timer.  The mode pointer register
+	 * has no side effects and so serves well for
+	 * this purpose.
+	 *
+	 * Razor #528
+	 */
+	value = ahd_inb(ahd, offset);
+	ahd_inb(ahd, MODE_PTR);
+	return (value);
+}
+
+static __inline u_int
+ahd_inw_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	return (ahd_inb_scbram(ahd, offset)
+	      | (ahd_inb_scbram(ahd, offset+1) << 8));
+}
+
+static __inline uint32_t
+ahd_inl_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	return (ahd_inb_scbram(ahd, offset)
+	      | (ahd_inb_scbram(ahd, offset+1) << 8)
+	      | (ahd_inb_scbram(ahd, offset+2) << 16)
+	      | (ahd_inb_scbram(ahd, offset+3) << 24));
+}
+
+static __inline struct scb *
+ahd_lookup_scb(struct ahd_softc *ahd, u_int tag)
+{
+	struct scb* scb;
+
+	if (tag >= AHD_SCB_MAX)
+		return (NULL);
+	scb = ahd->scb_data.scbindex[tag];
+	if (scb != NULL)
+		ahd_sync_scb(ahd, scb,
+			     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
+	return (scb);
+}
+
+static __inline void
+ahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *q_hscb;
+	uint32_t saved_hscb_busaddr;
+
+	/*
+	 * Our queuing method is a bit tricky.  The card
+	 * knows in advance which HSCB (by address) to download,
+	 * and we can't disappoint it.  To achieve this, the next
+	 * HSCB to download is saved off in ahd->next_queued_hscb.
+	 * When we are called to queue "an arbitrary scb",
+	 * we copy the contents of the incoming HSCB to the one
+	 * the sequencer knows about, swap HSCB pointers and
+	 * finally assign the SCB to the tag indexed location
+	 * in the scb_array.  This makes sure that we can still
+	 * locate the correct SCB by SCB_TAG.
+	 */
+	q_hscb = ahd->next_queued_hscb;
+	saved_hscb_busaddr = q_hscb->hscb_busaddr;
+	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
+	q_hscb->hscb_busaddr = saved_hscb_busaddr;
+	q_hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
+
+	/* Now swap HSCB pointers. */
+	ahd->next_queued_hscb = scb->hscb;
+	scb->hscb = q_hscb;
+
+	/* Now define the mapping from tag to SCB in the scbindex */
+	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;
+}
+
+/*
+ * Tell the sequencer about a new transaction to execute.
+ */
+static __inline void
+ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd_swap_with_next_hscb(ahd, scb);
+
+	if (SCBID_IS_NULL(SCB_GET_TAG(scb)))
+		panic("Attempt to queue invalid SCB tag %x\n",
+		      SCB_GET_TAG(scb));
+
+	/*
+	 * Keep a history of SCBs we've downloaded in the qinfifo.
+	 */
+	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
+	ahd->qinfifonext++;
+
+	if (scb->sg_count != 0)
+		ahd_setup_data_scb(ahd, scb);
+	else
+		ahd_setup_noxfer_scb(ahd, scb);
+	ahd_setup_scb_common(ahd, scb);
+
+	/*
+	 * Make sure our data is consistant from the
+	 * perspective of the adapter.
+	 */
+	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_QUEUE) != 0) {
+		printf("%s: Queueing SCB 0x%x bus addr 0x%x - 0x%x%x/0x%x\n",
+		       ahd_name(ahd),
+		       SCB_GET_TAG(scb), scb->hscb->hscb_busaddr,
+		       (u_int)((scb->hscb->dataptr >> 32) & 0xFFFFFFFF),
+		       (u_int)(scb->hscb->dataptr & 0xFFFFFFFF),
+		       scb->hscb->datacnt);
+	}
+#endif
+	/* Tell the adapter about the newly queued SCB */
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+}
+
+static __inline uint8_t *
+ahd_get_sense_buf(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (scb->sense_data);
+}
+
+static __inline uint32_t
+ahd_get_sense_bufaddr(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (scb->sense_busaddr);
+}
+
+/************************** Interrupt Processing ******************************/
+static __inline void	ahd_sync_qoutfifo(struct ahd_softc *ahd, int op);
+static __inline void	ahd_sync_tqinfifo(struct ahd_softc *ahd, int op);
+static __inline u_int	ahd_check_cmdcmpltqueues(struct ahd_softc *ahd);
+static __inline void	ahd_intr(struct ahd_softc *ahd);
+
+static __inline void
+ahd_sync_qoutfifo(struct ahd_softc *ahd, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			/*offset*/0, /*len*/AHC_SCB_MAX * sizeof(uint16_t), op);
+}
+
+static __inline void
+ahd_sync_tqinfifo(struct ahd_softc *ahd, int op)
+{
+#ifdef AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, 0),
+				sizeof(struct target_cmd) * AHD_TMODE_CMDS,
+				op);
+	}
+#endif
+}
+
+/*
+ * See if the firmware has posted any completed commands
+ * into our in-core command complete fifos.
+ */
+#define AHD_RUN_QOUTFIFO 0x1
+#define AHD_RUN_TQINFIFO 0x2
+static __inline u_int
+ahd_check_cmdcmpltqueues(struct ahd_softc *ahd)
+{
+	u_int retval;
+
+	retval = 0;
+	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			/*offset*/ahd->qoutfifonext, /*len*/2,
+			BUS_DMASYNC_POSTREAD);
+	if ((ahd->qoutfifo[ahd->qoutfifonext]
+	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag)
+		retval |= AHD_RUN_QOUTFIFO;
+#ifdef AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0
+	 && (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, ahd->tqinfifofnext),
+				/*len*/sizeof(struct target_cmd),
+				BUS_DMASYNC_POSTREAD);
+		if (ahd->targetcmds[ahd->tqinfifonext].cmd_valid != 0)
+			retval |= AHD_RUN_TQINFIFO;
+	}
+#endif
+	return (retval);
+}
+
+/*
+ * Catch an interrupt from the adapter
+ */
+static __inline void
+ahd_intr(struct ahd_softc *ahd)
+{
+	u_int	intstat;
+
+	if ((ahd->pause & INTEN) == 0) {
+		/*
+		 * Our interrupt is not enabled on the chip
+		 * and may be disabled for re-entrancy reasons,
+		 * so just return.  This is likely just a shared
+		 * interrupt.
+		 */
+		return;
+	}
+
+	/*
+	 * Instead of directly reading the interrupt status register,
+	 * infer the cause of the interrupt by checking our in-core
+	 * completion queues.  This avoids a costly PCI bus read in
+	 * most cases.
+	 */
+	if ((ahd->flags & AHD_ALL_INTERRUPTS) == 0
+	 && (ahd_check_cmdcmpltqueues(ahd) != 0))
+		intstat = CMDCMPLT;
+	else
+		intstat = ahd_inb(ahd, INTSTAT);
+
+	if (intstat & CMDCMPLT) {
+		ahd_outb(ahd, CLRINT, CLRCMDINT);
+
+		/*
+		 * Ensure that the chip sees that we've cleared
+		 * this interrupt before we walk the output fifo.
+		 * Otherwise, we may, due to posted bus writes,
+		 * clear the interrupt after we finish the scan,
+		 * and after the sequencer has added new entries
+		 * and asserted the interrupt again.
+		 */
+		ahd_flush_device_writes(ahd);
+		ahd_run_qoutfifo(ahd);
+#ifdef AHD_TARGET_MODE
+		if ((ahd->flags & AHD_TARGETROLE) != 0)
+			ahd_run_tqinfifo(ahd, /*paused*/FALSE);
+#endif
+	}
+
+	if (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0)
+		/* Hot eject */
+		return;
+
+	if ((intstat & INT_PEND) == 0)
+		return;
+
+	if (intstat & HWERRINT) {
+		ahd_handle_hwerrint(ahd);
+		return;
+	}
+
+	if ((intstat & (PCIINT|SPLTINT)) != 0) {
+		ahd->bus_intr(ahd);
+		return;
+	}
+
+	if ((intstat & SEQINT) != 0)
+		ahd_handle_seqint(ahd, intstat);
+
+	if ((intstat & SCSIINT) != 0)
+		ahd_handle_scsiint(ahd, intstat);
+}
+
+#endif  /* _AIC79XX_INLINE_H_ */
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm.c	2002-09-24 15:05:58.000000000 -0600
@@ -0,0 +1,2964 @@
+/*
+ * Adaptec AIC79xx device driver for Linux.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#50 $
+ *
+ * --------------------------------------------------------------------------
+ * Copyright (c) 1994-2000 Justin T. Gibbs.
+ * Copyright (c) 1997-1999 Doug Ledford
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+/*
+ * This is the only file where module.h should
+ * embed module global version info.
+ */
+#define AHD_MODVERSION_FILE
+
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#include <linux/init.h>		/* __setup */
+#endif
+
+#include "../sd.h"		/* For geometry detection */
+
+#include <linux/mm.h>		/* For fetching system memory size */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+/*
+ * Lock protecting manipulation of the ahd softc list.
+ */
+spinlock_t ahd_list_spinlock;
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+struct proc_dir_entry proc_scsi_aic79xx = {
+	PROC_SCSI_AIC79XX, 7, "aic79xx",
+	S_IFDIR | S_IRUGO | S_IXUGO, 2,
+	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
+/*
+ * Set this to the delay in seconds after SCSI bus reset.
+ * Note, we honor this only for the initial bus reset.
+ * The scsi error recovery code performs its own bus settle
+ * delay handling for error recovery actions.
+ */
+#ifdef CONFIG_AIC79XX_RESET_DELAY_MS
+#define AIC79XX_RESET_DELAY CONFIG_AIC79XX_RESET_DELAY_MS
+#else
+#define AIC79XX_RESET_DELAY 5000
+#endif
+
+/*
+ * To change the default number of tagged transactions allowed per-device,
+ * add a line to the lilo.conf file like:
+ * append="aic79xx=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}"
+ * which will result in the first four devices on the first two
+ * controllers being set to a tagged queue depth of 32.
+ *
+ * The tag_commands is an array of 16 to allow for wide and twin adapters.
+ * Twin adapters will use indexes 0-7 for channel 0, and indexes 8-15
+ * for channel 1.
+ */
+typedef struct {
+	uint16_t tag_commands[16];	/* Allow for wide/twin adapters. */
+} adapter_tag_info_t;
+
+/*
+ * Modify this as you see fit for your system.
+ *
+ * 0			tagged queuing disabled
+ * 1 <= n <= 253	n == max tags ever dispatched.
+ *
+ * The driver will throttle the number of commands dispatched to a
+ * device if it returns queue full.  For devices with a fixed maximum
+ * queue depth, the driver will eventually determine this depth and
+ * lock it in (a console message is printed to indicate that a lock
+ * has occurred).  On some devices, queue full is returned for a temporary
+ * resource shortage.  These devices will return queue full at varying
+ * depths.  The driver will throttle back when the queue fulls occur and
+ * attempt to slowly increase the depth over time as the device recovers
+ * from the resource shortage.
+ *
+ * In this example, the first line will disable tagged queueing for all
+ * the devices on the first probed aic79xx adapter.
+ *
+ * The second line enables tagged queueing with 4 commands/LUN for IDs
+ * (0, 2-11, 13-15), disables tagged queueing for ID 12, and tells the
+ * driver to attempt to use up to 64 tags for ID 1.
+ *
+ * The third line is the same as the first line.
+ *
+ * The fourth line disables tagged queueing for devices 0 and 3.  It
+ * enables tagged queueing for the other IDs, with 16 commands/LUN
+ * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for
+ * IDs 2, 5-7, and 9-15.
+ */
+
+/*
+ * NOTE: The below structure is for reference only, the actual structure
+ *       to modify in order to change things is just below this comment block.
+adapter_tag_info_t aic79xx_tag_info[] =
+{
+	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+	{{4, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4}},
+	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+	{{0, 16, 4, 0, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}
+};
+*/
+
+#ifdef CONFIG_AIC79XX_CMDS_PER_DEVICE
+#define AIC79XX_CMDS_PER_DEVICE CONFIG_AIC79XX_CMDS_PER_DEVICE
+#else
+#define AIC79XX_CMDS_PER_DEVICE AHD_MAX_QUEUE
+#endif
+
+#define AIC79XX_CONFIGED_TAG_COMMANDS {					\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE		\
+}
+
+/*
+ * By default, use the number of commands specified by
+ * the users kernel configuration.
+ */
+static adapter_tag_info_t aic79xx_tag_info[] =
+{
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS}
+};
+
+/*
+ * By default, read streaming is disabled.  In theory,
+ * read streaming should enhance performance, but early
+ * U320 drive firmware actually performs slower with
+ * read streaming enabled.
+ */
+#ifdef CONFIG_AIC79XX_ENABLE_RD_STRM
+#define AIC79XX_CONFIGED_RD_STRM 0xFFFF
+#else
+#define AIC79XX_CONFIGED_RD_STRM 0
+#endif
+
+static uint16_t aic79xx_rd_strm_info[] =
+{
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM
+};
+
+/*
+ * There should be a specific return value for this in scsi.h, but
+ * it seems that most drivers ignore it.
+ */
+#define DID_UNDERFLOW   DID_ERROR
+
+void
+ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
+{
+	printk("(scsi%d:%c:%d:%d): ",
+	       ahd->platform_data->host->host_no,
+	       scb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',
+	       scb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,
+	       scb != NULL ? SCB_GET_LUN(scb) : -1);
+}
+
+/*
+ * XXX - these options apply unilaterally to _all_ adapters
+ *       cards in the system.  This should be fixed.  Exceptions to this
+ *       rule are noted in the comments.
+ */
+
+/*
+ * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This
+ * has no effect on any later resets that might occur due to things like
+ * SCSI bus timeouts.
+ */
+static uint32_t aic79xx_no_reset;
+
+/*
+ * Certain PCI motherboards will scan PCI devices from highest to lowest,
+ * others scan from lowest to highest, and they tend to do all kinds of
+ * strange things when they come into contact with PCI bridge chips.  The
+ * net result of all this is that the PCI card that is actually used to boot
+ * the machine is very hard to detect.  Most motherboards go from lowest
+ * PCI slot number to highest, and the first SCSI controller found is the
+ * one you boot from.  The only exceptions to this are when a controller
+ * has its BIOS disabled.  So, we by default sort all of our SCSI controllers
+ * from lowest PCI slot number to highest PCI slot number.  We also force
+ * all controllers with their BIOS disabled to the end of the list.  This
+ * works on *almost* all computers.  Where it doesn't work, we have this
+ * option.  Setting this option to non-0 will reverse the order of the sort
+ * to highest first, then lowest, but will still leave cards with their BIOS
+ * disabled at the very end.  That should fix everyone up unless there are
+ * really strange cirumstances.
+ */
+static int aic79xx_reverse_scan = 0;
+
+/*
+ * Should we force EXTENDED translation on a controller.
+ *     0 == Use whatever is in the SEEPROM or default to off
+ *     1 == Use whatever is in the SEEPROM or default to on
+ */
+static uint32_t aic79xx_extended = 0;
+
+/*
+ * PCI bus parity checking of the Adaptec controllers.  This is somewhat
+ * dubious at best.  To my knowledge, this option has never actually
+ * solved a PCI parity problem, but on certain machines with broken PCI
+ * chipset configurations, it can generate tons of false error messages.
+ * It's included in the driver for completeness.
+ *   0 = Shut off PCI parity check
+ *  -1 = Normal polarity pci parity checking
+ *   1 = reverse polarity pci parity checking
+ *
+ * NOTE: you can't actually pass -1 on the lilo prompt.  So, to set this
+ * variable to -1 you would actually want to simply pass the variable
+ * name without a number.  That will invert the 0 which will result in
+ * -1.
+ */
+static int aic79xx_pci_parity = 0;
+
+/*
+ * aic79xx_detect() has been run, so register all device arrivals
+ * immediately with the system rather than deferring to the sorted
+ * attachment performed by aic79xx_detect().
+ */
+int aic79xx_detect_complete;
+
+/*
+ * So that we can set how long each device is given as a selection timeout.
+ * The table of values goes like this:
+ *   0 - 256ms
+ *   1 - 128ms
+ *   2 - 64ms
+ *   3 - 32ms
+ * We default to 256ms because some older devices need a longer time
+ * to respond to initial selection.
+ */
+static int aic79xx_seltime = 0x00;
+
+/*
+ * Certain devices do not perform any aging on commands.  Should the
+ * device be saturated by commands in one portion of the disk, it is
+ * possible for transactions on far away sectors to never be serviced.
+ * To handle these devices, we can periodically send an ordered tag to
+ * force all outstanding transactions to be serviced prior to a new
+ * transaction.
+ */
+int aic79xx_periodic_otag;
+
+/*
+ * Module information and settable options.
+ */
+#ifdef MODULE
+static char *aic79xx = NULL;
+/*
+ * Just in case someone uses commas to separate items on the insmod
+ * command line, we define a dummy buffer here to avoid having insmod
+ * write wild stuff into our code segment
+ */
+static char dummy_buffer[60] = "Please don't trounce on me insmod!!\n";
+
+MODULE_AUTHOR("Maintainer: Justin T. Gibbs <gibbs@scsiguy.com>");
+MODULE_DESCRIPTION("Adaptec Aic77XX/78XX SCSI Host Bus Adapter driver");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Dual BSD/GPL");
+#endif
+MODULE_PARM(aic79xx, "s");
+MODULE_PARM_DESC(aic79xx,
+"period delimited, options string.\n"
+"	verbose			Enable verbose/diagnostic logging\n"
+"	debug			Bitmask of debug values to enable\n"
+"	no_reset		Supress initial bus resets\n"
+"	extended		Enable extended geometry on all controllers\n"
+"	periodic_otag		Send an ordered tagged transaction\n"
+"				periodically to prevent tag starvation.\n"
+"				This may be required by some older disk\n"
+"				or drives/RAID arrays.\n"
+"	reverse_scan		Sort PCI devices highest Bus/Slot to lowest\n"
+"	tag_info:<tag_str>	Set per-target tag depth\n"
+"	global_tag_depth:<int>	Global tag depth for all targets on all buses\n"
+"	rd_strm:<rd_strm_masks> Set per-target read streaming setting.\n"
+"	seltime:<int>		Selection Timeout:\n"
+"				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
+"\n"
+"	Sample /etc/modules.conf line:\n"
+"		Enable verbose logging\n"
+"		Set tag depth on Controller 2/Target 2 to 10 tags\n"
+"		Shorten the selection timeout to 128ms\n"
+"\n"
+"	options aic79xx='\"verbose.tag_info:{{}.{}.{..10}}.seltime:1\"'\n"
+"\n"
+"	Sample /etc/modules.conf line:\n"
+"		Change Read Streaming for Controller's 2 and 3\n"
+"\n"
+"	options aic79xx='\"rd_strm:{..0xFFF0.0xC0F0}\"'");
+#endif
+
+static void ahd_linux_handle_scsi_status(struct ahd_softc *,
+					 struct ahd_linux_device *,
+					 struct scb *);
+static void ahd_linux_filter_command(struct ahd_softc*, Scsi_Cmnd*,
+				     struct scb*);
+static void ahd_linux_dev_timed_unfreeze(u_long arg);
+#if NO_YET
+static void ahd_linux_sem_timeout(u_long arg);
+static int  ahd_linux_queue_recovery_cmd(Scsi_Cmnd *cmd, scb_flag flag);
+#endif 
+static void ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd);
+static void ahd_linux_select_queue_depth(struct Scsi_Host *host,
+					 Scsi_Device *scsi_devs);
+static u_int ahd_linux_user_tagdepth(struct ahd_softc *ahd,
+				     struct ahd_devinfo *devinfo);
+static void ahd_linux_device_queue_depth(struct ahd_softc *ahd,
+					 Scsi_Device *device);
+static struct ahd_linux_target*	ahd_linux_alloc_target(struct ahd_softc*,
+						       u_int, u_int);
+static void			ahd_linux_free_target(struct ahd_softc*,
+						      struct ahd_linux_target*);
+static struct ahd_linux_device*	ahd_linux_alloc_device(struct ahd_softc*,
+						       struct ahd_linux_target*,
+						       u_int);
+static void			ahd_linux_free_device(struct ahd_softc*,
+						      struct ahd_linux_device*);
+static void ahd_linux_run_device_queue(struct ahd_softc*,
+				       struct ahd_linux_device*);
+static void ahd_linux_setup_tag_info(char *p, char *end);
+static void ahd_linux_setup_tag_info_global(char *p);
+static void ahd_linux_setup_rd_strm_info(char *p, char *end);
+static int ahd_linux_next_unit(void);
+static void ahd_runq_tasklet(unsigned long data);
+static int ahd_linux_halt(struct notifier_block *nb, u_long event, void *buf);
+
+static __inline struct ahd_linux_device*
+		     ahd_linux_get_device(struct ahd_softc *ahd, u_int channel,
+					  u_int target, u_int lun, int alloc);
+static __inline void ahd_linux_queue_cmd_complete(struct ahd_softc *ahd,
+						  Scsi_Cmnd *cmd);
+static __inline void ahd_linux_run_complete_queue(struct ahd_softc *ahd,
+						  struct ahd_cmd *acmd);
+static __inline void ahd_linux_check_device_queue(struct ahd_softc *ahd,
+						  struct ahd_linux_device *dev);
+static __inline struct ahd_linux_device *
+		     ahd_linux_next_device_to_run(struct ahd_softc *ahd);
+static __inline void ahd_linux_run_device_queues(struct ahd_softc *ahd);
+static __inline void ahd_linux_sniff_command(struct ahd_softc*, Scsi_Cmnd*,
+					     struct scb*);
+static __inline void ahd_linux_unmap_scb(struct ahd_softc*, struct scb*);
+
+static __inline int ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
+		 		      struct ahd_dma_seg *sg,
+				      bus_addr_t addr, bus_size_t len);
+
+static __inline struct ahd_linux_device*
+ahd_linux_get_device(struct ahd_softc *ahd, u_int channel, u_int target,
+	       u_int lun, int alloc)
+{
+	struct ahd_linux_target *targ;
+	struct ahd_linux_device *dev;
+	u_int target_offset;
+
+	target_offset = target;
+	if (channel != 0)
+		target_offset += 8;
+	targ = ahd->platform_data->targets[target_offset];
+	if (targ == NULL) {
+		if (alloc != 0) {
+			targ = ahd_linux_alloc_target(ahd, channel, target);
+			if (targ == NULL)
+				return (NULL);
+		} else
+			return (NULL);
+	}
+	dev = targ->devices[lun];
+	if (dev == NULL && alloc != 0)
+		dev = ahd_linux_alloc_device(ahd, targ, lun);
+	return (dev);
+}
+
+static __inline void
+ahd_linux_queue_cmd_complete(struct ahd_softc *ahd, Scsi_Cmnd *cmd)
+{
+	/*
+	 * Typically, the complete queue has very few entries
+	 * queued to it before the queue is emptied by
+	 * ahd_linux_run_complete_queue, so sorting the entries
+	 * by generation number should be inexpensive.
+	 * We perform the sort so that commands that complete
+	 * with an error are retuned in the order origionally
+	 * queued to the controller so that any subsequent retries
+	 * are performed in order.  The underlying ahd routines do
+	 * not guarantee the order that aborted commands will be
+	 * returned to us.
+	 */
+	struct ahd_completeq *completeq;
+	struct ahd_cmd *list_cmd;
+	struct ahd_cmd *acmd;
+
+	/*
+	 * If we want the request requeued, make sure there
+	 * are sufficent retries.  In the old scsi error code,
+	 * we used to be able to specify a result code that
+	 * bypassed the retry count.  Now we must use this
+	 * hack.  We also "fake" a check condition with
+	 * a sense code of ABORTED COMMAND.  This seems to
+	 * evoke a retry even if this command is being sent
+	 * via the eh thread.  Ick!  Ick!  Ick!
+	 */
+	if (cmd->result == (CAM_REQUEUE_REQ << 16))
+	if (cmd->result == (CAM_REQUEUE_REQ << 16)) {
+		cmd->retries--;
+		cmd->result = DID_OK << 16
+			    | SCSI_STATUS_CHECK_COND
+			    | (DRIVER_SENSE << 24);
+		memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+		cmd->sense_buffer[0] = SSD_ERRCODE_VALID
+				     | SSD_CURRENT_ERROR;
+		cmd->sense_buffer[2] = SSD_KEY_ABORTED_COMMAND;
+	}
+	completeq = &ahd->platform_data->completeq;
+	list_cmd = TAILQ_FIRST(completeq);
+	acmd = (struct ahd_cmd *)cmd;
+	while (list_cmd != NULL
+	    && acmd_scsi_cmd(list_cmd).serial_number
+	     < acmd_scsi_cmd(acmd).serial_number)
+		list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
+	if (list_cmd != NULL)
+		TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
+	else
+		TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
+}
+
+static __inline void
+ahd_linux_run_complete_queue(struct ahd_softc *ahd, struct ahd_cmd *acmd)
+{	
+	u_long done_flags;
+
+	ahd_done_lock(ahd, &done_flags);
+	while (acmd != NULL) {
+		Scsi_Cmnd *cmd;
+
+		cmd = &acmd_scsi_cmd(acmd);
+		acmd = TAILQ_NEXT(acmd, acmd_links.tqe);
+		cmd->host_scribble = NULL;
+		cmd->scsi_done(cmd);
+	}
+	ahd_done_unlock(ahd, &done_flags);
+}
+
+static __inline void
+ahd_linux_check_device_queue(struct ahd_softc *ahd,
+			     struct ahd_linux_device *dev)
+{
+	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) != 0
+	 && dev->active == 0) {
+		dev->flags &= ~AHD_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen--;
+	}
+
+	if (TAILQ_FIRST(&dev->busyq) == NULL
+	 || dev->openings == 0 || dev->qfrozen != 0)
+		return;
+
+	ahd_linux_run_device_queue(ahd, dev);
+}
+
+static __inline struct ahd_linux_device *
+ahd_linux_next_device_to_run(struct ahd_softc *ahd)
+{
+	
+	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0
+	 || ahd->platform_data->qfrozen != 0)
+		return (NULL);
+	return (TAILQ_FIRST(&ahd->platform_data->device_runq));
+}
+
+static __inline void
+ahd_linux_run_device_queues(struct ahd_softc *ahd)
+{
+	struct ahd_linux_device *dev;
+
+	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
+		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
+		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
+		ahd_linux_check_device_queue(ahd, dev);
+	}
+}
+
+static __inline void
+ahd_linux_sniff_command(struct ahd_softc *ahd, Scsi_Cmnd *cmd, struct scb *scb)
+{
+	/*
+	 * Determine whether we care to filter
+	 * information out of this command.  If so,
+	 * pass it on to ahd_linux_filter_command() for more
+	 * heavy weight processing.
+	 */
+	if (cmd->cmnd[0] == INQUIRY)
+		ahd_linux_filter_command(ahd, cmd, scb);
+}
+
+static __inline void
+ahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	Scsi_Cmnd *cmd;
+	int direction;
+
+	cmd = scb->io_ctx;
+	direction = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+	ahd_sync_sglist(ahd, scb, BUS_DMASYNC_POSTWRITE);
+	if (cmd->use_sg != 0) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *)cmd->request_buffer;
+		pci_unmap_sg(ahd->dev_softc, sg, cmd->use_sg, direction);
+	} else if (cmd->request_bufflen != 0) {
+		pci_unmap_single(ahd->dev_softc,
+				 scb->platform_data->buf_busaddr,
+				 cmd->request_bufflen, direction);
+	}
+}
+
+static __inline int
+ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
+		  struct ahd_dma_seg *sg, bus_addr_t addr, bus_size_t len)
+{
+	int	 consumed;
+
+	if ((scb->sg_count + 1) > AHD_NSEG)
+		panic("Too few segs for dma mapping.  "
+		      "Increase AHD_NSEG\n");
+
+	consumed = 1;
+	sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
+	scb->platform_data->xfer_len += len;
+	if (sizeof(bus_addr_t) > 4
+	 && (ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
+		/*
+		 * Due to DAC restrictions, we can't
+		 * cross a 4GB boundary.
+		 */
+		if ((addr ^ (addr + len - 1)) & ~0xFFFFFFFF) {
+			struct	 ahd_dma_seg *next_sg;
+			uint32_t next_len;
+
+			printf("Crossed Seg\n");
+			if ((scb->sg_count + 2) > AHD_NSEG)
+				panic("Too few segs for dma mapping.  "
+				      "Increase AHD_NSEG\n");
+
+			consumed++;
+			next_sg = sg + 1;
+			next_sg->addr = 0;
+			next_len = 0x100000000 - (addr & 0xFFFFFFFF);
+			len -= next_len;
+			next_len |= ((addr >> 8) + 0x1000000) & 0x7F000000;
+			next_sg->len = ahd_htole32(next_len);
+		}
+		len |= (addr >> 8) & 0x7F000000;
+	}
+	sg->len = ahd_htole32(len);
+	return (consumed);
+}
+
+/**************************** Tasklet Handler *********************************/
+
+static void
+ahd_runq_tasklet(unsigned long data)
+{
+	struct ahd_softc* ahd;
+	struct ahd_linux_device *dev;
+	u_long flags;
+
+	ahd = (struct ahd_softc *)data;
+	ahd_lock(ahd, &flags);
+	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
+	
+		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
+		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
+		ahd_linux_check_device_queue(ahd, dev);
+		/* Yeild to our interrupt handler */
+		ahd_unlock(ahd, &flags);
+		ahd_lock(ahd, &flags);
+	}
+	ahd_unlock(ahd, &flags);
+}
+
+/************************ Shutdown/halt/reboot hook ***************************/
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+
+static struct notifier_block ahd_linux_notifier = {
+	ahd_linux_halt, NULL, 0
+};
+
+static int ahd_linux_halt(struct notifier_block *nb, u_long event, void *buf)
+{
+	struct ahd_softc *ahd;
+
+	if (event == SYS_DOWN || event == SYS_HALT) {
+		TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+			ahd_shutdown(ahd);
+		}
+	}
+	return (NOTIFY_OK);
+}
+
+/******************************** Macros **************************************/
+#define BUILD_SCSIID(ahd, cmd)						\
+	((((cmd)->target << TID_SHIFT) & TID) | (ahd)->our_id)
+
+/******************************** Bus DMA *************************************/
+int
+ahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,
+		   bus_size_t alignment, bus_size_t boundary,
+		   bus_addr_t lowaddr, bus_addr_t highaddr,
+		   bus_dma_filter_t *filter, void *filterarg,
+		   bus_size_t maxsize, int nsegments,
+		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
+{
+	bus_dma_tag_t dmat;
+
+	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
+	if (dmat == NULL)
+		return (ENOMEM);
+
+	/*
+	 * Linux is very simplistic about DMA memory.  For now don't
+	 * maintain all specification information.  Once Linux supplies
+	 * better facilities for doing these operations, or the
+	 * needs of this particular driver change, we might need to do
+	 * more here.
+	 */
+	dmat->alignment = alignment;
+	dmat->boundary = boundary;
+	dmat->maxsize = maxsize;
+	*ret_tag = dmat;
+	return (0);
+}
+
+void
+ahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)
+{
+	free(dmat, M_DEVBUF);
+}
+
+int
+ahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,
+		 int flags, bus_dmamap_t *mapp)
+{
+	bus_dmamap_t map;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
+	if (map == NULL)
+		return (ENOMEM);
+	/*
+	 * Although we can dma data above 4GB, our
+	 * "consistent" memory is below 4GB for
+	 * space efficiency reasons (only need a 4byte
+	 * address).  For this reason, we have to reset
+	 * our dma mask when doing allocations.
+	 */
+	if (ahd->dev_softc != NULL)
+		ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF);
+	*vaddr = pci_alloc_consistent(ahd->dev_softc,
+				      dmat->maxsize, &map->bus_addr);
+	if (ahd->dev_softc != NULL)
+		ahd_pci_set_dma_mask(ahd->dev_softc,
+				     ahd->platform_data->hw_dma_mask);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
+	/*
+	 * At least in 2.2.14, malloc is a slab allocator so all
+	 * allocations are aligned.  We assume for these kernel versions
+	 * that all allocations will be bellow 4Gig, physically contiguous,
+	 * and accessable via DMA by the controller.
+	 */
+	map = NULL; /* No additional information to store */
+	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
+#endif
+	if (*vaddr == NULL)
+		return (ENOMEM);
+	*mapp = map;
+	return(0);
+}
+
+void
+ahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,
+		void* vaddr, bus_dmamap_t map)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	pci_free_consistent(ahd->dev_softc, dmat->maxsize,
+			    vaddr, map->bus_addr);
+#else
+	free(vaddr, M_DEVBUF);
+#endif
+}
+
+int
+ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,
+		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
+		void *cb_arg, int flags)
+{
+	/*
+	 * Assume for now that this will only be used during
+	 * initialization and not for per-transaction buffer mapping.
+	 */
+	bus_dma_segment_t stack_sg;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	stack_sg.ds_addr = map->bus_addr;
+#else
+#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
+	stack_sg.ds_addr = VIRT_TO_BUS(buf);
+#endif
+	stack_sg.ds_len = dmat->maxsize;
+	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
+	return (0);
+}
+
+void
+ahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/*
+	 * The map may is NULL in our < 2.3.X implementation.
+	 */
+	if (map != NULL)
+		free(map, M_DEVBUF);
+}
+
+int
+ahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/* Nothing to do */
+	return (0);
+}
+
+/********************* Platform Dependent Functions ***************************/
+int
+ahd_softc_comp(struct ahd_softc *lahd, struct ahd_softc *rahd)
+{
+	int	value;
+	char	primary_channel;
+
+	/*
+	 * Under Linux, cards are ordered as follows:
+	 *	1) PCI devices with BIOS enabled sorted by bus/slot/func.
+	 *	2) All remaining PCI devices sorted by bus/slot/func.
+	 */
+	value = (lahd->flags & AHD_BIOS_ENABLED)
+	      - (rahd->flags & AHD_BIOS_ENABLED);
+	if (value != 0)
+		/* Controllers with BIOS enabled have a *higher* priority */
+		return (-value);
+
+	/* Still equal.  Sort by bus/slot/func. */
+	if (aic79xx_reverse_scan != 0)
+		value = ahd_get_pci_bus(rahd->dev_softc)
+		      - ahd_get_pci_bus(lahd->dev_softc);
+	else
+		value = ahd_get_pci_bus(lahd->dev_softc)
+		      - ahd_get_pci_bus(rahd->dev_softc);
+	if (value != 0)
+		return (value);
+	if (aic79xx_reverse_scan != 0)
+		value = ahd_get_pci_slot(rahd->dev_softc)
+		      - ahd_get_pci_slot(lahd->dev_softc);
+	else
+		value = ahd_get_pci_slot(lahd->dev_softc)
+		      - ahd_get_pci_slot(rahd->dev_softc);
+	if (value != 0)
+		return (value);
+
+	/*
+	 * On multi-function devices, the user can choose
+	 * to have function 1 probed before function 0.
+	 * Give whichever channel is the primary channel
+	 * the lowest priority.
+	 */
+	primary_channel = (lahd->flags & AHD_PRIMARY_CHANNEL) + 'A';
+	value = 1;
+	if (lahd->channel == primary_channel)
+		value = -1;
+	return (value);
+}
+
+static void
+ahd_linux_setup_tag_info(char *p, char *end)
+{
+	char	*base;
+	char	*tok;
+	char	*tok_end;
+	char	*tok_end2;
+	int      i;
+	int      instance;
+	int	 targ;
+	int	 done;
+	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
+
+	if (*p != ':')
+		return;
+
+	instance = -1;
+	targ = -1;
+	done = FALSE;
+	base = p;
+	/* Forward us just past the ':' */
+	tok = base + 1;
+	tok_end = strchr(tok, '\0');
+	if (tok_end < end)
+		*tok_end = ',';
+	while (!done) {
+		switch (*tok) {
+		case '{':
+			if (instance == -1)
+				instance = 0;
+			else if (targ == -1)
+				targ = 0;
+			tok++;
+			break;
+		case '}':
+			if (targ != -1)
+				targ = -1;
+			else if (instance != -1)
+				instance = -1;
+			tok++;
+			break;
+		case ',':
+		case '.':
+			if (instance == -1)
+				done = TRUE;
+			else if (targ >= 0)
+				targ++;
+			else if (instance >= 0)
+				instance++;
+			if ((targ >= AHD_NUM_TARGETS) ||
+			    (instance >= NUM_ELEMENTS(aic79xx_tag_info)))
+				done = TRUE;
+			tok++;
+			if (!done) {
+				base = tok;
+			}
+			break;
+		case '\0':
+			done = TRUE;
+			break;
+		default:
+			done = TRUE;
+			tok_end = strchr(tok, '\0');
+			for (i = 0; tok_list[i]; i++) {
+				tok_end2 = strchr(tok, tok_list[i]);
+				if ((tok_end2) && (tok_end2 < tok_end)) {
+					tok_end = tok_end2;
+					done = FALSE;
+				}
+			}
+			if ((instance >= 0) && (targ >= 0)
+			 && (instance < NUM_ELEMENTS(aic79xx_tag_info))
+			 && (targ < AHD_NUM_TARGETS)) {
+				aic79xx_tag_info[instance].tag_commands[targ] =
+				    simple_strtoul(tok, NULL, 0) & 0xff;
+			}
+			tok = tok_end;
+			break;
+		}
+	}
+	while ((p != base) && (p != NULL))
+		p = strtok(NULL, ",.");
+}
+
+static void
+ahd_linux_setup_rd_strm_info(char *p, char *end)
+{
+	char	*base;
+	char	*tok;
+	char	*tok_end;
+	char	*tok_end2;
+	int      i;
+	int      instance;
+	int	 targ;
+	int	 done;
+	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
+
+	if (*p != ':')
+		return;
+
+	instance = -1;
+	targ = -1;
+	done = FALSE;
+	base = p;
+	/* Forward us just past the ':' */
+	tok = base + 1;
+	tok_end = strchr(tok, '\0');
+	if (tok_end < end)
+		*tok_end = ',';
+	while (!done) {
+		switch (*tok) {
+		case '{':
+			if (instance == -1)
+				instance = 0;
+			tok++;
+			break;
+		case '}':
+			if (instance != -1)
+				instance = -1;
+			tok++;
+			break;
+		case ',':
+		case '.':
+			if (instance == -1)
+				done = TRUE;
+			else if (instance >= 0)
+				instance++;
+			if (instance >= NUM_ELEMENTS(aic79xx_rd_strm_info))
+				done = TRUE;
+			tok++;
+			if (!done) {
+				base = tok;
+			}
+			break;
+		case '\0':
+			done = TRUE;
+			break;
+		default:
+			done = TRUE;
+			tok_end = strchr(tok, '\0');
+			for (i = 0; tok_list[i]; i++) {
+				tok_end2 = strchr(tok, tok_list[i]);
+				if ((tok_end2) && (tok_end2 < tok_end)) {
+					tok_end = tok_end2;
+					done = FALSE;
+				}
+			}
+			if ((instance >= 0)
+			 && (instance < NUM_ELEMENTS(aic79xx_rd_strm_info))) {
+				aic79xx_rd_strm_info[instance] =
+				    simple_strtoul(tok, NULL, 0) & 0xffff;
+			}
+			tok = tok_end;
+			break;
+		}
+	}
+	while ((p != base) && (p != NULL))
+		p = strtok(NULL, ",.");
+}
+
+static void
+ahd_linux_setup_tag_info_global(char *p)
+{
+	int tags, i, j;
+
+	tags = simple_strtoul(p + 1, NULL, 0) & 0xff;
+	printf("Setting Global Tags= %d\n", tags);
+
+	for (i = 0; i < NUM_ELEMENTS(aic79xx_tag_info); i++) {
+		for (j = 0; j < AHD_NUM_TARGETS; j++) {
+			aic79xx_tag_info[i].tag_commands[j] = tags;
+		}
+	}
+}
+
+/*
+ * Handle Linux boot parameters. This routine allows for assigning a value
+ * to a parameter with a ':' between the parameter and the value.
+ * ie. aic79xx=stpwlev:1,extended
+ */
+int
+aic79xx_setup(char *s)
+{
+	int	i, n;
+	char   *p;
+	char   *end;
+
+	static struct {
+		const char *name;
+		uint32_t *flag;
+	} options[] = {
+		{ "extended", &aic79xx_extended },
+		{ "no_reset", &aic79xx_no_reset },
+		{ "verbose", &aic79xx_verbose },
+#ifdef AHD_DEBUG
+		{ "debug", &ahd_debug },
+#endif
+		{ "reverse_scan", &aic79xx_reverse_scan },
+		{ "periodic_otag", &aic79xx_periodic_otag },
+		{ "pci_parity", &aic79xx_pci_parity },
+		{ "seltime", &aic79xx_seltime },
+		{ "tag_info", NULL },
+		{ "global_tag_depth", NULL},
+		{ "rd_strm", NULL }
+	};
+
+	end = strchr(s, '\0');
+
+	for (p = strtok(s, ",."); p; p = strtok(NULL, ",.")) {
+		for (i = 0; i < NUM_ELEMENTS(options); i++) {
+			n = strlen(options[i].name);
+
+			if (strncmp(options[i].name, p, n) != 0)
+				continue;
+
+			if (!strncmp(p, "global_tag_depth", n)) {
+				ahd_linux_setup_tag_info_global(p + n);
+			} else if (!strncmp(p, "tag_info", n)) {
+				ahd_linux_setup_tag_info(p + n, end);
+			} else if (strncmp(p, "rd_strm", n) == 0) {
+				ahd_linux_setup_rd_strm_info(p + n, end);
+			} else if (p[n] == ':') {
+				*(options[i].flag) =
+				    simple_strtoul(p + n + 1, NULL, 0);
+			} else if (!strncmp(p, "verbose", n)) {
+				*(options[i].flag) = 1;
+			} else {
+				*(options[i].flag) = ~(*(options[i].flag));
+			}
+			break;
+		}
+	}
+	return 1;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+__setup("aic79xx=", aic79xx_setup);
+#endif
+
+int aic79xx_verbose;
+
+/*
+ * Try to detect an Adaptec 79XX controller.
+ */
+int
+ahd_linux_detect(Scsi_Host_Template *template)
+{
+	struct	ahd_softc *ahd;
+	int     found;
+
+	/*
+	 * It is a bug that the upper layer takes
+	 * this lock just prior to calling us.
+	 */
+	spin_unlock_irq(&io_request_lock);
+
+	/*
+	 * Sanity checking of Linux SCSI data structures so
+	 * that some of our hacks^H^H^H^H^Hassumptions aren't
+	 * violated.
+	 */
+	if (offsetof(struct ahd_cmd_internal, end)
+	  > offsetof(struct scsi_cmnd, host_scribble)) {
+		printf("ahd_linux_detect: SCSI data structures changed.\n");
+		printf("ahd_linux_detect: Unable to attach\n");
+		return (0);
+	}
+#ifdef MODULE
+	/*
+	 * If we've been passed any parameters, process them now.
+	 */
+	if (aic79xx)
+		aic79xx_setup(aic79xx);
+	if (dummy_buffer[0] != 'P')
+		printk(KERN_WARNING
+"aic79xx: Please read the file /usr/src/linux/drivers/scsi/README.aic79xx\n"
+"aic79xx: to see the proper way to specify options to the aic79xx module\n"
+"aic79xx: Specifically, don't use any commas when passing arguments to\n"
+"aic79xx: insmod or else it might trash certain memory areas.\n");
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+	template->proc_name = "aic79xx";
+#else
+	template->proc_dir = &proc_scsi_aic79xx;
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
+	/*
+	 * We can only map 16MB per-SG
+	 * so create a sector limit of
+	 * "16MB" in 2K sectors.
+	 */
+	template->max_sectors = 8192;
+#endif
+
+	/*
+	 * Initialize our softc list lock prior to
+	 * probing for any adapters.
+	 */
+	ahd_list_lockinit();
+
+#ifdef CONFIG_PCI
+	ahd_linux_pci_probe(template);
+#endif
+
+	/*
+	 * Register with the SCSI layer all
+	 * controllers we've found.
+	 */
+	spin_lock_irq(&io_request_lock);
+	found = 0;
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+
+		if (ahd_linux_register_host(ahd, template) == 0)
+			found++;
+	}
+	aic79xx_detect_complete++;
+	return (found);
+}
+
+int
+ahd_linux_register_host(struct ahd_softc *ahd, Scsi_Host_Template *template)
+{
+	char  buf[80];
+	struct Scsi_Host *host;
+	char *new_name;
+	u_long s;
+
+	template->name = ahd->description;
+	host = scsi_register(template, sizeof(struct ahd_softc *));
+	if (host == NULL)
+		return (ENOMEM);
+
+	ahd_lock(ahd, &s);
+	*((struct ahd_softc **)host->hostdata) = ahd;
+	ahd->platform_data->host = host;
+	host->can_queue = AHD_MAX_QUEUE;
+	host->cmd_per_lun = 2;
+	host->sg_tablesize = AHD_NSEG;
+	host->select_queue_depths = ahd_linux_select_queue_depth;
+	host->this_id = ahd->our_id;
+	host->irq = ahd->platform_data->irq;
+	host->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;
+	host->max_lun = AHD_NUM_LUNS;
+	host->max_channel = 0;
+	ahd_set_unit(ahd, ahd_linux_next_unit());
+	sprintf(buf, "scsi%d", host->host_no);
+	new_name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (new_name != NULL) {
+		strcpy(new_name, buf);
+		ahd_set_name(ahd, new_name);
+	}
+	host->unique_id = ahd->unit;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
+	scsi_set_pci_device(host, ahd->dev_softc);
+#endif
+	ahd_linux_initialize_scsi_bus(ahd);
+	ahd_intr_enable(ahd, TRUE);
+	ahd_unlock(ahd, &s);
+	return (0);
+}
+
+uint64_t
+ahd_linux_get_memsize()
+{
+	struct sysinfo si;
+
+	si_meminfo(&si);
+	return (si.totalram << PAGE_SHIFT);
+}
+
+/*
+ * Find the smallest available unit number to use
+ * for a new device.  We don't just use a static
+ * count to handle the "repeated hot-(un)plug"
+ * scenario.
+ */
+static int
+ahd_linux_next_unit()
+{
+	struct ahd_softc *ahd;
+	int unit;
+
+	unit = 0;
+retry:
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		if (ahd->unit == unit) {
+			unit++;
+			goto retry;
+		}
+	}
+	return (unit);
+}
+
+/*
+ * Place the SCSI bus into a known state by either resetting it,
+ * or forcing transfer negotiations on the next command to any
+ * target.
+ */
+void
+ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd)
+{
+	int i;
+	int numtarg;
+
+	i = 0;
+	numtarg = 0;
+
+	if (aic79xx_no_reset != 0)
+		ahd->flags &= ~AHD_RESET_BUS_A;
+
+	if ((ahd->flags & AHD_RESET_BUS_A) != 0)
+		ahd_reset_channel(ahd, 'A', /*initiate_reset*/TRUE);
+	else
+		numtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
+
+	for (; i < numtarg; i++) {
+		struct ahd_devinfo devinfo;
+		struct ahd_initiator_tinfo *tinfo;
+		struct ahd_tmode_tstate *tstate;
+		u_int our_id;
+		u_int target_id;
+		char channel;
+
+		channel = 'A';
+		our_id = ahd->our_id;
+		target_id = i;
+		tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
+					    target_id, &tstate);
+		tinfo->goal = tinfo->user;
+		/*
+		 * Don't try negotiations that require PPR messages
+		 * until we successfully retrieve Inquiry data.
+		 */
+		tinfo->goal.ppr_options = 0;
+		if (tinfo->goal.transport_version > SCSI_REV_2)
+			tinfo->goal.transport_version = SCSI_REV_2;
+		ahd_compile_devinfo(&devinfo, our_id, target_id,
+				   CAM_LUN_WILDCARD, channel, ROLE_INITIATOR);
+		ahd_update_neg_request(ahd, &devinfo, tstate,
+				       tinfo, /*force*/FALSE);
+	}
+	/* Give the bus some time to recover */
+	if ((ahd->flags & AHD_RESET_BUS_A) != 0) {
+		ahd_freeze_simq(ahd);
+		init_timer(&ahd->platform_data->reset_timer);
+		ahd->platform_data->reset_timer.data = (u_long)ahd;
+		ahd->platform_data->reset_timer.expires =
+		    jiffies + (AIC79XX_RESET_DELAY * HZ)/1000;
+		ahd->platform_data->reset_timer.function =
+		    (ahd_linux_callback_t *)ahd_release_simq;
+		add_timer(&ahd->platform_data->reset_timer);
+	}
+}
+
+int
+ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)
+{
+	ahd->platform_data =
+	    malloc(sizeof(struct ahd_platform_data), M_DEVBUF, M_NOWAIT);
+	if (ahd->platform_data == NULL)
+		return (ENOMEM);
+	memset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->device_runq);
+	ahd->platform_data->irq = AHD_LINUX_NOIRQ;
+	ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
+	ahd_lockinit(ahd);
+	ahd_done_lockinit(ahd);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	init_MUTEX_LOCKED(&ahd->platform_data->eh_sem);
+#else
+	ahd->platform_data->eh_sem = MUTEX_LOCKED;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_init(&ahd->platform_data->runq_tasklet, ahd_runq_tasklet,
+		     (unsigned long)ahd);
+#endif
+	ahd->seltime = (aic79xx_seltime & 0x3) << 4;
+	
+	if (TAILQ_EMPTY(&ahd_tailq))
+		register_reboot_notifier(&ahd_linux_notifier);
+	return (0);
+}
+
+void
+ahd_platform_free(struct ahd_softc *ahd)
+{
+	if (ahd->platform_data != NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		tasklet_kill(&ahd->platform_data->runq_tasklet);
+#endif
+		if (ahd->platform_data->host != NULL)
+			scsi_unregister(ahd->platform_data->host);
+		if (ahd->platform_data->irq != AHD_LINUX_NOIRQ)
+			free_irq(ahd->platform_data->irq, ahd);
+		if (ahd->tags[0] == BUS_SPACE_PIO
+		 && ahd->bshs[0].ioport != 0)
+			release_region(ahd->bshs[0].ioport, 256);
+		if (ahd->tags[1] == BUS_SPACE_PIO
+		 && ahd->bshs[1].ioport != 0)
+			release_region(ahd->bshs[1].ioport, 256);
+		if (ahd->tags[0] == BUS_SPACE_MEMIO
+		 && ahd->bshs[0].maddr != NULL) {
+			u_long base_addr;
+
+			base_addr = (u_long)ahd->bshs[0].maddr;
+			base_addr &= PAGE_MASK;
+			iounmap((void *)base_addr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+			release_mem_region(ahd->platform_data->mem_busaddr,
+					   0x1000);
+#endif
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		/* XXX Need an instance detach in the PCI code */
+		if (ahd->dev_softc != NULL)
+			ahd->dev_softc->driver = NULL;
+#endif
+		free(ahd->platform_data, M_DEVBUF);
+	}
+	if (TAILQ_EMPTY(&ahd_tailq)) {
+		unregister_reboot_notifier(&ahd_linux_notifier);
+#ifdef CONFIG_PCI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		pci_unregister_driver(&aic79xx_pci_driver);
+#endif
+#endif
+	}
+}
+
+void
+ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
+				SCB_GET_CHANNEL(ahd, scb),
+				SCB_GET_LUN(scb), SCB_LIST_NULL,
+				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
+}
+
+void
+ahd_platform_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		      ahd_queue_alg alg)
+{
+	struct ahd_linux_device *dev;
+	int was_queuing;
+	int now_queuing;
+
+	dev = ahd_linux_get_device(ahd, devinfo->channel - 'A',
+				   devinfo->target,
+				   devinfo->lun, /*alloc*/FALSE);
+	if (dev == NULL)
+		return;
+	was_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);
+	now_queuing = alg != AHD_QUEUE_NONE;
+	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0
+	 && (was_queuing != now_queuing)
+	 && (dev->active != 0)) {
+		dev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen++;
+	}
+
+	dev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);
+	if (now_queuing) {
+		u_int usertags;
+
+		usertags = ahd_linux_user_tagdepth(ahd, devinfo);
+		if (!was_queuing) {
+			/*
+			 * Start out agressively and allow our
+			 * dynamic queue depth algorithm to take
+			 * care of the rest.
+			 */
+			dev->maxtags = usertags;
+			dev->openings = dev->maxtags - dev->active;
+		}
+		if (alg == AHD_QUEUE_TAGGED) {
+			dev->flags |= AHD_DEV_Q_TAGGED;
+			if (aic79xx_periodic_otag != 0)
+				dev->flags |= AHD_DEV_PERIODIC_OTAG;
+		} else
+			dev->flags |= AHD_DEV_Q_BASIC;
+	} else {
+		/* We can only have one opening. */
+		dev->maxtags = 0;
+		dev->openings =  1 - dev->active;
+	}
+}
+
+int
+ahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,
+			int lun, u_int tag, role_t role, uint32_t status)
+{
+	int targ;
+	int maxtarg;
+	int maxlun;
+	int clun;
+	int count;
+
+	if (tag != SCB_LIST_NULL)
+		return (0);
+
+	targ = 0;
+	if (target != CAM_TARGET_WILDCARD) {
+		targ = target;
+		maxtarg = targ + 1;
+	} else {
+		maxtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
+	}
+	clun = 0;
+	if (lun != CAM_LUN_WILDCARD) {
+		clun = lun;
+		maxlun = clun + 1;
+	} else {
+		maxlun = AHD_NUM_LUNS;
+	}
+
+	count = 0;
+	for (; targ < maxtarg; targ++) {
+
+		for (; clun < maxlun; clun++) {
+			struct ahd_linux_device *dev;
+			struct ahd_busyq *busyq;
+			struct ahd_cmd *acmd;
+
+			dev = ahd_linux_get_device(ahd, /*chan*/0, targ,
+						   clun, /*alloc*/FALSE);
+			if (dev == NULL)
+				continue;
+
+			busyq = &dev->busyq;
+			while ((acmd = TAILQ_FIRST(busyq)) != NULL) {
+				Scsi_Cmnd *cmd;
+
+				cmd = &acmd_scsi_cmd(acmd);
+				TAILQ_REMOVE(busyq, acmd,
+					     acmd_links.tqe);
+				count++;
+				cmd->result = status << 16;
+				ahd_linux_queue_cmd_complete(ahd, cmd);
+			}
+		}
+	}
+
+	return (count);
+}
+
+/*
+ * Sets the queue depth for each SCSI device hanging
+ * off the input host adapter.
+ */
+static void
+ahd_linux_select_queue_depth(struct Scsi_Host * host,
+			     Scsi_Device * scsi_devs)
+{
+	Scsi_Device *device;
+	struct	ahd_softc *ahd;
+	u_long	flags;
+	int	scbnum;
+
+	ahd = *((struct ahd_softc **)host->hostdata);
+	ahd_lock(ahd, &flags);
+	scbnum = 0;
+	for (device = scsi_devs; device != NULL; device = device->next) {
+		if (device->host == host) {
+			ahd_linux_device_queue_depth(ahd, device);
+			scbnum += device->queue_depth;
+		}
+	}
+	ahd_unlock(ahd, &flags);
+}
+
+static u_int
+ahd_linux_user_tagdepth(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	static int warned_user;
+	u_int tags;
+
+	tags = 0;
+	if ((ahd->user_discenable & devinfo->target_mask) != 0) {
+		if (warned_user == 0
+		 && ahd->unit >= NUM_ELEMENTS(aic79xx_tag_info)) {
+
+			printf("aic79xx: WARNING, insufficient "
+			       "tag_info instances for installed "
+			       "controllers. Using defaults\n");
+			printf("aic79xx: Please update the "
+			       "aic79xx_tag_info array in the "
+			       "aic79xx.c source file.\n");
+			tags = AHD_MAX_QUEUE;
+			warned_user++;
+		} else {
+			adapter_tag_info_t *tag_info;
+
+			tag_info = &aic79xx_tag_info[ahd->unit];
+			tags = tag_info->tag_commands[devinfo->target_offset];
+			if (tags > AHD_MAX_QUEUE)
+				tags = AHD_MAX_QUEUE;
+		}
+	}
+	return (tags);
+}
+
+/*
+ * Determines the queue depth for a given device.
+ */
+static void
+ahd_linux_device_queue_depth(struct ahd_softc *ahd, Scsi_Device * device)
+{
+	struct	ahd_devinfo devinfo;
+	u_int	tags;
+
+	ahd_compile_devinfo(&devinfo,
+			    ahd->our_id,
+			    device->id, device->lun,
+			    device->channel == 0 ? 'A' : 'B',
+			    ROLE_INITIATOR);
+	tags = ahd_linux_user_tagdepth(ahd, &devinfo);
+	if (tags != 0
+	 && device->tagged_supported != 0) {
+
+		device->queue_depth = tags;
+		ahd_set_tags(ahd, &devinfo, AHD_QUEUE_TAGGED);
+		printf("scsi%d:%c:%d:%d: Tagged Queuing enabled.  Depth %d\n",
+	       	       ahd->platform_data->host->host_no, devinfo.channel,
+		       devinfo.target, devinfo.lun, tags);
+	} else {
+		/*
+		 * We allow the OS to queue 2 untagged transactions to
+		 * us at any time even though we can only execute them
+		 * serially on the controller/device.  This should remove
+		 * some latency.
+		 */
+		device->queue_depth = 2;
+	}
+}
+
+/*
+ * Queue an SCB to the controller.
+ */
+int
+ahd_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
+{
+	struct	 ahd_softc *ahd;
+	struct	 ahd_linux_device *dev;
+	u_long	 flags;
+
+	ahd = *(struct ahd_softc **)cmd->host->hostdata;
+
+	/*
+	 * Save the callback on completion function.
+	 */
+	cmd->scsi_done = scsi_done;
+
+	ahd_lock(ahd, &flags);
+	dev = ahd_linux_get_device(ahd, cmd->channel, cmd->target,
+				   cmd->lun, /*alloc*/TRUE);
+	if (dev == NULL) {
+		ahd_unlock(ahd, &flags);
+		printf("aic79xx_linux_queue: Unable to allocate device!\n");
+		return (-ENOMEM);
+	}
+	if (cmd->cmd_len > MAX_CDB_LEN)
+		return (-EINVAL);
+	cmd->result = CAM_REQ_INPROG << 16;
+	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahd_cmd *)cmd, acmd_links.tqe);
+	if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
+		dev->flags |= AHD_DEV_ON_RUN_LIST;
+		ahd_linux_run_device_queues(ahd);
+	}
+	ahd_unlock(ahd, &flags);
+	return (0);
+}
+
+static void
+ahd_linux_run_device_queue(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+{
+	struct	 ahd_cmd *acmd;
+	struct	 scsi_cmnd *cmd;
+	struct	 scb *scb;
+	struct	 hardware_scb *hscb;
+	struct	 ahd_initiator_tinfo *tinfo;
+	struct	 ahd_tmode_tstate *tstate;
+	u_int	 col_idx;
+	uint16_t mask;
+
+	if ((dev->flags & AHD_DEV_ON_RUN_LIST) != 0)
+		panic("running device on run list");
+
+	while ((acmd = TAILQ_FIRST(&dev->busyq)) != NULL
+	    && dev->openings > 0 && dev->qfrozen == 0) {
+
+		/*
+		 * Schedule us to run later.  The only reason we are not
+		 * running is because the whole controller Q is frozen.
+		 */
+		if (ahd->platform_data->qfrozen != 0) {
+
+			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
+					  dev, links);
+			dev->flags |= AHD_DEV_ON_RUN_LIST;
+			return;
+		}
+
+		cmd = &acmd_scsi_cmd(acmd);
+
+		/*
+		 * Get an scb to use.
+		 */
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    cmd->target, &tstate);
+		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0
+		 || (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+			col_idx = AHD_NEVER_COL_IDX;
+		} else {
+			col_idx = AHD_BUILD_COL_IDX(cmd->target, cmd->lun);
+		}
+		if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
+			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
+					 dev, links);
+			dev->flags |= AHD_DEV_ON_RUN_LIST;
+			ahd->flags |= AHD_RESOURCE_SHORTAGE;
+			return;
+		}
+		TAILQ_REMOVE(&dev->busyq, acmd, acmd_links.tqe);
+		scb->io_ctx = cmd;
+		scb->platform_data->dev = dev;
+		hscb = scb->hscb;
+		cmd->host_scribble = (char *)scb;
+
+		/*
+		 * Fill out basics of the HSCB.
+		 */
+		hscb->control = 0;
+		hscb->scsiid = BUILD_SCSIID(ahd, cmd);
+		hscb->lun = cmd->lun;
+		mask = SCB_GET_TARGET_MASK(ahd, scb);
+
+		if ((ahd->user_discenable & mask) != 0)
+			hscb->control |= DISCENB;
+
+		if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)
+			scb->flags |= SCB_PACKETIZED;
+
+		if ((tstate->auto_negotiate & mask) != 0) {
+			scb->flags |= SCB_AUTO_NEGOTIATE;
+			scb->hscb->control |= MK_MESSAGE;
+		}
+
+		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {
+			if (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH
+			 && (dev->flags & AHD_DEV_Q_TAGGED) != 0) {
+				hscb->control |= MSG_ORDERED_TASK;
+				dev->commands_since_idle_or_otag = 0;
+			} else {
+				hscb->control |= MSG_SIMPLE_TASK;
+			}
+		}
+
+		hscb->cdb_len = cmd->cmd_len;
+		memcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);
+
+		scb->sg_count = 0;
+		ahd_set_residual(scb, 0);
+		ahd_set_sense_residual(scb, 0);
+		if (cmd->use_sg != 0) {
+			void	*sg;
+			struct	 scatterlist *cur_seg;
+			u_int	 nseg;
+			int	 dir;
+
+			cur_seg = (struct scatterlist *)cmd->request_buffer;
+			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+			nseg = pci_map_sg(ahd->dev_softc, cur_seg,
+					  cmd->use_sg, dir);
+			scb->platform_data->xfer_len = 0;
+			for (sg = scb->sg_list; nseg > 0; nseg--, cur_seg++) {
+				bus_addr_t addr;
+				bus_size_t len;
+
+				addr = sg_dma_address(cur_seg);
+				len = sg_dma_len(cur_seg);
+				scb->platform_data->xfer_len += len;
+				sg = ahd_sg_setup(ahd, scb, sg, addr, len,
+						  /*last*/nseg == 1);
+			}
+		} else if (cmd->request_bufflen != 0) {
+			void *sg;
+			bus_addr_t addr;
+			int dir;
+
+			sg = scb->sg_list;
+			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+			addr = pci_map_single(ahd->dev_softc,
+					      cmd->request_buffer,
+					      cmd->request_bufflen, dir);
+			scb->platform_data->xfer_len = cmd->request_bufflen;
+			scb->platform_data->buf_busaddr = addr;
+			sg = ahd_sg_setup(ahd, scb, sg, addr,
+					  cmd->request_bufflen, /*last*/TRUE);
+		}
+
+		LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
+		dev->openings--;
+		dev->active++;
+		dev->commands_issued++;
+		if ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)
+			dev->commands_since_idle_or_otag++;
+		scb->flags |= SCB_ACTIVE;
+		ahd_queue_scb(ahd, scb);
+	}
+}
+
+/*
+ * SCSI controller interrupt handler.
+ */
+void
+ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct	ahd_softc *ahd;
+	struct	ahd_cmd *acmd;
+	u_long	flags;
+	struct	ahd_linux_device *next_dev;
+
+	ahd = (struct ahd_softc *) dev_id;
+	ahd_lock(ahd, &flags); 
+	ahd_intr(ahd);
+	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	next_dev = ahd_linux_next_device_to_run(ahd);
+	ahd_unlock(ahd, &flags);
+	if (next_dev) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		tasklet_schedule(&ahd->platform_data->runq_tasklet);
+#else
+		ahd_runq_tasklet((unsigned long)ahd);
+#endif
+	}
+	if (acmd != NULL)
+		ahd_linux_run_complete_queue(ahd, acmd);
+}
+
+void
+ahd_platform_flushwork(struct ahd_softc *ahd)
+{
+	struct ahd_cmd *acmd;
+
+	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	if (acmd != NULL)
+		ahd_linux_run_complete_queue(ahd, acmd);
+}
+
+static struct ahd_linux_target*
+ahd_linux_alloc_target(struct ahd_softc *ahd, u_int channel, u_int target)
+{
+	struct ahd_linux_target *targ;
+	u_int target_offset;
+
+	targ = malloc(sizeof(*targ), M_DEVBUG, M_NOWAIT);
+	if (targ == NULL)
+		return (NULL);
+	memset(targ, 0, sizeof(*targ));
+	targ->channel = channel;
+	targ->target = target;
+	targ->ahd = ahd;
+	target_offset = target;
+	if (channel != 0)
+		target_offset += 8;
+	ahd->platform_data->targets[target_offset] = targ;
+	return (targ);
+}
+
+static void
+ahd_linux_free_target(struct ahd_softc *ahd, struct ahd_linux_target *targ)
+{
+	u_int target_offset;
+
+	target_offset = targ->target;
+	if (targ->channel != 0)
+		target_offset += 8;
+	ahd->platform_data->targets[target_offset] = NULL;
+	free(targ, M_DEVBUF);
+}
+
+static struct ahd_linux_device*
+ahd_linux_alloc_device(struct ahd_softc *ahd,
+		 struct ahd_linux_target *targ, u_int lun)
+{
+	struct ahd_linux_device *dev;
+
+	dev = malloc(sizeof(*dev), M_DEVBUG, M_NOWAIT);
+	if (dev == NULL)
+		return (NULL);
+	memset(dev, 0, sizeof(*dev));
+	init_timer(&dev->timer);
+	TAILQ_INIT(&dev->busyq);
+	dev->flags = AHD_DEV_UNCONFIGURED;
+	dev->lun = lun;
+	dev->target = targ;
+
+	/*
+	 * We start out life using untagged
+	 * transactions of which we allow one.
+	 */
+	dev->openings = 1;
+
+	/*
+	 * Set maxtags to 0.  This will be changed if we
+	 * later determine that we are dealing with
+	 * a tagged queuing capable device.
+	 */
+	dev->maxtags = 0;
+	
+	targ->refcount++;
+	targ->devices[lun] = dev;
+	return (dev);
+}
+
+static void
+ahd_linux_free_device(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+{
+	struct ahd_linux_target *targ;
+
+	del_timer(&dev->timer);
+	targ = dev->target;
+	targ->devices[dev->lun] = NULL;
+	free(dev, M_DEVBUF);
+	targ->refcount--;
+	if (targ->refcount == 0)
+		ahd_linux_free_target(ahd, targ);
+}
+
+/*
+ * Return a string describing the driver.
+ */
+const char *
+ahd_linux_info(struct Scsi_Host *host)
+{
+	static char buffer[512];
+	char	ahd_info[256];
+	char   *bp;
+	struct ahd_softc *ahd;
+
+	bp = &buffer[0];
+	ahd = *(struct ahd_softc **)host->hostdata;
+	memset(bp, 0, sizeof(buffer));
+	strcpy(bp, "Adaptec AIC79XX PCI-X SCSI HBA DRIVER, Rev ");
+	strcat(bp, AIC79XX_DRIVER_VERSION);
+	strcat(bp, "\n");
+	strcat(bp, "        <");
+	strcat(bp, ahd->description);
+	strcat(bp, ">\n");
+	strcat(bp, "        ");
+	ahd_controller_info(ahd, ahd_info);
+	strcat(bp, ahd_info);
+	strcat(bp, "\n");
+
+	return (bp);
+}
+
+void
+ahd_send_async(struct ahd_softc *ahd, char channel,
+	       u_int target, u_int lun, ac_code code, void *arg)
+{
+	switch (code) {
+	case AC_TRANSFER_NEG:
+	{
+		char	buf[80];
+		struct	ahd_linux_target *targ;
+		struct	info_str info;
+		struct	ahd_initiator_tinfo *tinfo;
+		struct	ahd_tmode_tstate *tstate;
+
+		info.buffer = buf;
+		info.length = sizeof(buf);
+		info.offset = 0;
+		info.pos = 0;
+		tinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,
+					    target, &tstate);
+
+		/*
+		 * Don't bother reporting results while
+		 * negotiations are still pending.
+		 */
+		if (tinfo->curr.period != tinfo->goal.period
+		 || tinfo->curr.width != tinfo->goal.width
+		 || tinfo->curr.offset != tinfo->goal.offset
+		 || tinfo->curr.ppr_options != tinfo->goal.ppr_options)
+			if (bootverbose == 0)
+				break;
+
+		/*
+		 * Don't bother reporting results that
+		 * are identical to those last reported.
+		 */
+		targ = ahd->platform_data->targets[target];
+		if (targ == NULL)
+			break;
+		if (tinfo->curr.period == targ->last_tinfo.period
+		 && tinfo->curr.width == targ->last_tinfo.width
+		 && tinfo->curr.offset == targ->last_tinfo.offset
+		 && tinfo->curr.ppr_options == targ->last_tinfo.ppr_options)
+			if (bootverbose == 0)
+				break;
+
+		targ->last_tinfo.period = tinfo->curr.period;
+		targ->last_tinfo.width = tinfo->curr.width;
+		targ->last_tinfo.offset = tinfo->curr.offset;
+		targ->last_tinfo.ppr_options = tinfo->curr.ppr_options;
+
+		printf("(%s:%c:", ahd_name(ahd), channel);
+		if (target == CAM_TARGET_WILDCARD)
+			printf("*): ");
+		else
+			printf("%d): ", target);
+		ahd_format_transinfo(&info, &tinfo->curr);
+		if (info.pos < info.length)
+			*info.buffer = '\0';
+		else
+			buf[info.length - 1] = '\0';
+		printf("%s", buf);
+		break;
+	}
+        case AC_SENT_BDR:
+		break;
+        case AC_BUS_RESET:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+		if (ahd->platform_data->host != NULL) {
+			scsi_report_bus_reset(ahd->platform_data->host,
+					      channel - 'A');
+		}
+#endif
+                break;
+        default:
+                panic("ahd_send_async: Unexpected async event");
+        }
+}
+
+/*
+ * Calls the higher level scsi done function and frees the scb.
+ */
+void
+ahd_done(struct ahd_softc *ahd, struct scb * scb)
+{
+	Scsi_Cmnd *cmd;
+	struct ahd_linux_device *dev;
+
+	LIST_REMOVE(scb, pending_links);
+
+	if ((scb->flags & SCB_ACTIVE) == 0) {
+		printf("SCB %d done'd twice\n", scb->hscb->tag);
+		ahd_dump_card_state(ahd);
+		panic("Stopping for safety");
+	}
+	cmd = scb->io_ctx;
+	dev = scb->platform_data->dev;
+	dev->active--;
+	dev->openings++;
+	ahd_linux_unmap_scb(ahd, scb);
+	if (scb->flags & SCB_SENSE) {
+		memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+		memcpy(cmd->sense_buffer, ahd_get_sense_buf(ahd, scb),
+		       MIN(sizeof(struct scsi_sense_data),
+			   sizeof(cmd->sense_buffer)));
+		cmd->result |= (DRIVER_SENSE << 24);
+	} else if (scb->flags & SCB_PKT_SENSE) {
+		struct scsi_status_iu_header *siu;
+		u_int sense_len;
+
+		/*
+		 * Copy only the sense data into the provided buffer.
+		 */
+		siu = (struct scsi_status_iu_header *)scb->sense_data;
+		sense_len = MIN(scsi_4btoul(siu->sense_length),
+				sizeof(cmd->sense_buffer));
+		memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+		memcpy(cmd->sense_buffer,
+		       ahd_get_sense_buf(ahd, scb) + SIU_SENSE_OFFSET(siu),
+		       sense_len);
+
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_SENSE) {
+			int i;
+
+			printf("Copied %d bytes of sense data offset %d:",
+			       sense_len, SIU_SENSE_OFFSET(siu));
+			for (i = 0; i < sense_len; i++)
+				printf(" 0x%x", cmd->sense_buffer[i]);
+			printf("\n");
+		}
+#endif
+		cmd->result |= (DRIVER_SENSE << 24);
+	} else {
+		/*
+		 * Guard against stale sense data.
+		 * The Linux mid-layer assumes that sense
+		 * was retrieved anytime the first byte of
+		 * the sense buffer looks "sane".
+		 */
+		cmd->sense_buffer[0] = 0;
+	}
+	if (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {
+		uint32_t amount_xferred;
+
+		amount_xferred =
+		    ahd_get_transfer_length(scb) - ahd_get_residual(scb);
+		if (amount_xferred < scb->io_ctx->underflow) {
+			printf("Saw underflow (%ld of %ld bytes). "
+			       "Treated as error\n",
+				ahd_get_residual(scb),
+				ahd_get_transfer_length(scb));
+			ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		} else {
+			ahd_set_transaction_status(scb, CAM_REQ_CMP);
+			ahd_linux_sniff_command(ahd, cmd, scb);
+		}
+	} else if (ahd_get_transaction_status(scb) == DID_OK) {
+		ahd_linux_handle_scsi_status(ahd, dev, scb);
+	} else if (ahd_get_transaction_status(scb) == DID_NO_CONNECT) {
+		/*
+		 * Should a selection timeout kill the device?
+		 * That depends on whether the selection timeout
+		 * is persistent.  Since we have no guarantee that
+		 * the mid-layer will issue an inquiry for this device
+		 * again, we can't just kill it off.
+		dev->flags |= AHD_DEV_UNCONFIGURED;
+		 */
+	}
+
+	if (dev->openings == 1
+	 && ahd_get_transaction_status(scb) == CAM_REQ_CMP
+	 && ahd_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
+		dev->tag_success_count++;
+	/*
+	 * Some devices deal with temporary internal resource
+	 * shortages by returning queue full.  When the queue
+	 * full occurrs, we throttle back.  Slowly try to get
+	 * back to our previous queue depth.
+	 */
+	if ((dev->openings + dev->active) < dev->maxtags
+	 && dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {
+		dev->tag_success_count = 0;
+		dev->openings++;
+	}
+
+	if (dev->active == 0)
+		dev->commands_since_idle_or_otag = 0;
+
+	if (TAILQ_EMPTY(&dev->busyq)) {
+		if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
+		 && dev->active == 0)
+			ahd_linux_free_device(ahd, dev);
+	} else if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
+		dev->flags |= AHD_DEV_ON_RUN_LIST;
+	}
+
+	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
+		printf("Recovery SCB completes\n");
+		up(&ahd->platform_data->eh_sem);
+	}
+
+	ahd_free_scb(ahd, scb);
+	ahd_linux_queue_cmd_complete(ahd, cmd);
+}
+
+static void
+ahd_linux_handle_scsi_status(struct ahd_softc *ahd,
+			     struct ahd_linux_device *dev, struct scb *scb)
+{
+	/*
+	 * We don't currently trust the mid-layer to
+	 * properly deal with queue full or busy.  So,
+	 * when one occurs, we tell the mid-layer to
+	 * unconditionally requeue the command to us
+	 * so that we can retry it ourselves.  We also
+	 * implement our own throttling mechanism so
+	 * we don't clobber the device with too many
+	 * commands.
+	 */
+	switch (ahd_get_scsi_status(scb)) {
+	default:
+		break;
+	case SCSI_STATUS_QUEUE_FULL:
+	{
+		/*
+		 * By the time the core driver has returned this
+		 * command, all other commands that were queued
+		 * to us but not the device have been returned.
+		 * This ensures that dev->active is equal to
+		 * the number of commands actually queued to
+		 * the device.
+		 */
+		dev->tag_success_count = 0;
+		if (dev->active != 0) {
+			/*
+			 * Drop our opening count to the number
+			 * of commands currently outstanding.
+			 */
+			dev->openings = 0;
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_QFULL) {
+				ahd_print_path(ahd, scb);
+				printf("Dropping tag count to %d\n",
+				       dev->active);
+			}
+#endif
+			if (dev->active == dev->tags_on_last_queuefull) {
+
+				dev->last_queuefull_same_count++;
+				/*
+				 * If we repeatedly see a queue full
+				 * at the same queue depth, this
+				 * device has a fixed number of tag
+				 * slots.  Lock in this tag depth
+				 * so we stop seeing queue fulls from
+				 * this device.
+				 */
+				if (dev->last_queuefull_same_count
+				 == AHD_LOCK_TAGS_COUNT) {
+					dev->maxtags = dev->active;
+					ahd_print_path(ahd, scb);
+					printf("Locking max tag count at %d\n",
+					       dev->active);
+				}
+			} else {
+				dev->tags_on_last_queuefull = dev->active;
+				dev->last_queuefull_same_count = 0;
+			}
+			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			ahd_set_scsi_status(scb, SCSI_STATUS_OK);
+			break;
+		}
+		/*
+		 * Drop down to a single opening, and treat this
+		 * as if the target return BUSY SCSI status.
+		 */
+		dev->openings = 1;
+		ahd_set_scsi_status(scb, SCSI_STATUS_BUSY);
+		/* FALLTHROUGH */
+	}
+	case SCSI_STATUS_BUSY:
+		/*
+		 * Set a short timer to defer sending commands for
+		 * a bit since Linux will not delay in this case.
+		 */
+		if ((dev->flags & AHD_DEV_TIMER_ACTIVE) != 0) {
+			printf("%s:%c:%d: Device Timer still active during "
+			       "busy processing\n", ahd_name(ahd),
+				dev->target->channel, dev->target->target);
+			break;
+		}
+		dev->flags |= AHD_DEV_TIMER_ACTIVE;
+		dev->qfrozen++;
+		init_timer(&dev->timer);
+		dev->timer.data = (u_long)dev;
+		dev->timer.expires = jiffies + (HZ/2);
+		dev->timer.function = ahd_linux_dev_timed_unfreeze;
+		add_timer(&dev->timer);
+		break;
+	}
+}
+
+static void
+ahd_linux_filter_command(struct ahd_softc *ahd, Scsi_Cmnd *cmd, struct scb *scb)
+{
+	switch (cmd->cmnd[0]) {
+	case INQUIRY:
+	{
+		struct	ahd_devinfo devinfo;
+		struct	scsi_inquiry *inq;
+		struct	scsi_inquiry_data *sid;
+		struct	ahd_initiator_tinfo *tinfo;
+		struct	ahd_transinfo *user;
+		struct	ahd_transinfo *goal;
+		struct	ahd_transinfo *curr;
+		struct	ahd_tmode_tstate *tstate;
+		struct	ahd_linux_device *dev;
+		u_int	scsiid;
+		int	transferred_len;
+		int	minlen;
+		int	was_configured;
+		u_int	width;
+		u_int	period;
+		u_int	offset;
+		u_int	ppr_options;
+		u_int	trans_version;
+		u_int	prot_version;
+		static	int warned_user;
+
+		 /*
+		  * Validate the command.  We only want to filter
+		  * standard inquiry commands, not those querying
+		  * Vital Product Data.
+		  */
+		inq = (struct scsi_inquiry *)cmd->cmnd;
+		if ((inq->byte2 & SI_EVPD) != 0
+		 || inq->page_code != 0)
+			break;
+
+		if (cmd->use_sg != 0) {
+			printf("%s: SG Inquiry response ignored\n",
+			       ahd_name(ahd));
+			break;
+		}
+		transferred_len = ahd_get_transfer_length(scb)
+				- ahd_get_residual(scb);
+		sid = (struct scsi_inquiry_data *)cmd->request_buffer;
+
+		/*
+		 * Determine if this lun actually exists.  If so,
+		 * hold on to its corresponding device structure.
+		 * If not, make sure we release the device and
+		 * don't bother processing the rest of this inquiry
+		 * command.
+		 */
+		dev = ahd_linux_get_device(ahd, cmd->channel,
+					   cmd->target, cmd->lun,
+					   /*alloc*/FALSE);
+		was_configured = dev->flags & AHD_DEV_UNCONFIGURED;
+		if (transferred_len >= 1
+		 && SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
+
+			dev->flags &= ~AHD_DEV_UNCONFIGURED;
+		} else {
+			dev->flags |= AHD_DEV_UNCONFIGURED;
+			break;
+		}
+
+		/*
+		 * Update our notion of this device's transfer
+		 * negotiation capabilities.
+		 */
+		scsiid = BUILD_SCSIID(ahd, cmd);
+		ahd_compile_devinfo(&devinfo, SCSIID_OUR_ID(scsiid),
+				    cmd->target, cmd->lun,
+				    SCSIID_CHANNEL(ahd, scsiid),
+				    ROLE_INITIATOR);
+		tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
+					    devinfo.our_scsiid,
+					    devinfo.target, &tstate);
+		user = &tinfo->user;
+		goal = &tinfo->goal;
+		curr = &tinfo->curr;
+		width = user->width;
+		period = user->period;
+		offset = user->offset;
+		ppr_options = user->ppr_options;
+		trans_version = user->transport_version;
+		prot_version = user->protocol_version;
+		/*
+		 * If we have read streaming info for this controller,
+		 * apply it to this target.
+		 */
+		if (warned_user == 0
+		 && ahd->unit >= NUM_ELEMENTS(aic79xx_rd_strm_info)) {
+
+			printf("aic79xx: WARNING, insufficient "
+			       "rd_strm instances for installed "
+			       "controllers. Using defaults\n");
+			printf("aic79xx: Please update the "
+			       "aic79xx_rd_strm_info array in the "
+			       "aic79xx_osm.c source file.\n");
+			warned_user++;
+		} else {
+			uint16_t rd_strm_mask;
+
+			rd_strm_mask = aic79xx_rd_strm_info[ahd->unit];
+			if ((rd_strm_mask & devinfo.target_mask) == 0)
+				ppr_options &= ~MSG_EXT_PPR_RD_STRM;
+		}
+		
+		minlen = offsetof(struct scsi_inquiry_data, version) + 1;
+		if (transferred_len >= minlen) {
+			prot_version = SID_ANSI_REV(sid);
+
+			/*
+			 * Only attempt SPI3/4 once we've verified that
+			 * the device claims to support SPI3/4 features.
+			 */
+			if (prot_version < SCSI_REV_2)
+				trans_version = SID_ANSI_REV(sid);
+			else
+				trans_version = SCSI_REV_2;
+		}
+
+		minlen = offsetof(struct scsi_inquiry_data, flags) + 1;
+		if (transferred_len >= minlen
+		 && (sid->additional_length + 5) >= minlen) {
+			if ((sid->flags & SID_WBus16) == 0)
+				width = MSG_EXT_WDTR_BUS_8_BIT;
+			if ((sid->flags & SID_Sync) == 0) {
+				period = 0;
+				offset = 0;
+				ppr_options = 0;
+			}
+		} else {
+			/* Keep current settings */
+			break;
+		}
+		minlen = offsetof(struct scsi_inquiry_data, spi3data) + 1;
+		/*
+		 * This is a kludge to deal with inquiry requests that
+		 * are not large enough for us to pull the spi3/4 bits.
+		 * In this case, we assume that a device that tells us
+		 * they can provide inquiry data that spans the SPI3
+		 * bits and says its SCSI3 can handle a PPR request.
+		 * If the inquiry request has sufficient buffer space to
+		 * cover SPI3 bits, we honor them regardless of reported
+		 * SCSI REV.  We also allow any device that has been
+		 * configured in the past to keep any previously determined
+		 * options if a short inquiry occurs that would fail the
+		 * normal tests outlined above.
+		 */
+		if ((sid->additional_length + 5) >= minlen) {
+			if (transferred_len >= minlen) {
+				 if ((sid->spi3data & SID_SPI_QAS) == 0)
+					ppr_options &= ~MSG_EXT_PPR_QAS_REQ;
+				 if ((sid->spi3data & SID_SPI_CLOCK_DT) == 0)
+					ppr_options &= MSG_EXT_PPR_QAS_REQ;
+				 if ((sid->spi3data & SID_SPI_IUS) == 0)
+					ppr_options &= (MSG_EXT_PPR_DT_REQ
+						      | MSG_EXT_PPR_QAS_REQ);
+			} else if (was_configured
+				&& (curr->transport_version
+				 == user->transport_version)) {
+
+				/* Keep original settings. */
+				break;
+			} else if (prot_version <= SCSI_REV_2)
+				ppr_options = 0;
+
+			if (prot_version > SCSI_REV_2)
+				trans_version = user->transport_version;
+		} else {
+			ppr_options = 0;
+		}
+		ahd_validate_width(ahd, /*tinfo limit*/NULL, &width,
+				   ROLE_UNKNOWN);
+
+		ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_MAX);
+		ahd_validate_offset(ahd, /*tinfo limit*/NULL, period,
+				    &offset, width, ROLE_UNKNOWN);
+		if (offset == 0 || period == 0) {
+			period = 0;
+			offset = 0;
+			ppr_options = 0;
+		}
+		/* Apply our filtered user settings. */
+		curr->transport_version = trans_version;
+		curr->protocol_version = prot_version;
+		ahd_set_width(ahd, &devinfo, width,
+			      AHD_TRANS_GOAL, /*paused*/FALSE);
+		ahd_set_syncrate(ahd, &devinfo, period, offset, ppr_options,
+				 AHD_TRANS_GOAL, /*paused*/FALSE);
+		break;
+	}
+	default:
+		panic("ahd_linux_filter_command: Unexpected Command type  %x\n",
+		      cmd->cmnd[0]);
+		break;
+	}
+}
+
+void
+ahd_freeze_simq(struct ahd_softc *ahd)
+{
+	ahd->platform_data->qfrozen++;
+	if (ahd->platform_data->qfrozen == 1)
+		scsi_block_requests(ahd->platform_data->host);
+}
+
+void
+ahd_release_simq(struct ahd_softc *ahd)
+{
+	u_long s;
+	int    unblock_reqs;
+
+	unblock_reqs = 0;
+	ahd_lock(ahd, &s);
+	if (ahd->platform_data->qfrozen > 0)
+		ahd->platform_data->qfrozen--;
+	if (ahd->platform_data->qfrozen == 0) {
+		unblock_reqs = 1;
+	}
+	ahd_unlock(ahd, &s);
+	/*
+	 * There is still a race here.  The mid-layer
+	 * should keep its own freeze count and use
+	 * a bottom half handler to run the queues
+	 * so we can unblock with our own lock held.
+	 */
+	if (unblock_reqs) {
+		scsi_unblock_requests(ahd->platform_data->host);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		tasklet_schedule(&ahd->platform_data->runq_tasklet);
+#else
+		ahd_runq_tasklet((unsigned long)ahd);
+#endif
+	}
+}
+
+#if NOT_YET
+static void
+ahd_linux_sem_timeout(u_long arg)
+{
+	struct semaphore *sem;
+
+	sem = (struct semaphore *)arg;
+	up(sem);
+}
+
+static int
+ahd_linux_queue_recovery_cmd(Scsi_Cmnd *cmd, scb_flag flag)
+{
+	struct ahd_softc *ahd;
+	struct ahd_cmd *acmd;
+	struct ahd_cmd *list_acmd;
+	struct ahd_linux_device *dev;
+	struct scb *pending_scb;
+	u_long s;
+	u_int  saved_scbptr;
+	u_int  active_scb_index;
+	u_int  last_phase;
+	int    retval;
+	int    paused;
+	int    wait;
+	int    disconnected;
+
+	paused = FALSE;
+	wait = FALSE;
+	ahd = *(struct ahd_softc **)cmd->host->hostdata;
+	acmd = (struct ahd_cmd *)cmd;
+
+	printf("%s:%d:%d:%d: Attempting to queue a%s message\n",
+	       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun,
+	       flag == SCB_ABORT ? "n ABORT" : " TARGET RESET");
+
+	/*
+	 * It is a bug that the upper layer takes
+	 * this lock just prior to calling us.
+	 */
+	spin_unlock_irq(&io_request_lock);
+
+	ahd_lock(ahd, &s);
+
+	/*
+	 * First determine if we currently own this command.
+	 * Start by searching the device queue.  If not found
+	 * there, check the pending_scb list.  If not found
+	 * at all, and the system wanted us to just abort the
+	 * command return success.
+	 */
+	dev = ahd_linux_get_device(ahd, cmd->channel, cmd->target,
+				   cmd->lun, /*alloc*/FALSE);
+
+	if (dev == NULL) {
+		/*
+		 * No target device for this command exists,
+		 * so we must not still own the command.
+		 */
+		printf("%s:%d:%d:%d: Is not an active device\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		retval = SUCCESS;
+		goto no_cmd;
+	}
+
+	TAILQ_FOREACH(list_acmd, &dev->busyq, acmd_links.tqe) {
+		if (list_acmd == acmd)
+			break;
+	}
+
+	if (list_acmd != NULL) {
+		printf("%s:%d:%d:%d: Command found on device queue\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		if (flag == SCB_ABORT) {
+			TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
+			cmd->result = DID_ABORT << 16;
+			ahd_linux_queue_cmd_complete(ahd, cmd);
+			retval = SUCCESS;
+			goto done;
+		}
+	}
+
+	/*
+	 * See if we can find a matching cmd in the pending list.
+	 */
+	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
+		if (pending_scb->io_ctx == cmd)
+			break;
+	}
+
+	if (pending_scb == NULL && flag == SCB_DEVICE_RESET) {
+
+		/* Any SCB for this device will do for a target reset */
+		LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
+		  	if (ahd_match_scb(ahd, pending_scb, cmd->target,
+					  cmd->channel, CAM_LUN_WILDCARD,
+					  SCB_LIST_NULL, ROLE_INITIATOR) == 0)
+				break;
+		}
+	}
+
+	if (pending_scb == NULL) {
+		printf("%s:%d:%d:%d: Command not found\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		goto no_cmd;
+	}
+
+	if ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {
+		/*
+		 * We can't queue two recovery actions using the same SCB
+		 */
+		retval = FAILED;
+		goto  done;
+	}
+
+	/*
+	 * Ensure that the card doesn't do anything
+	 * behind our back.  Also make sure that we
+	 * didn't "just" miss an interrupt that would
+	 * affect this cmd.
+	 */
+	ahd->flags |= AHD_ALL_INTERRUPTS;
+	do {
+		ahd_intr(ahd);
+		ahd_pause(ahd);
+		ahd_clear_critical_section(ahd);
+	} while (ahd_inb(ahd, INTSTAT) & INT_PEND);
+	ahd->flags &= ~AHD_ALL_INTERRUPTS;
+	paused = TRUE;
+
+	ahd_dump_card_state(ahd);
+
+	if ((pending_scb->flags & SCB_ACTIVE) == 0) {
+		printf("%s:%d:%d:%d: Command already completed\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		goto no_cmd;
+	}
+
+	disconnected = TRUE;
+	if (flag == SCB_ABORT) {
+		if (ahd_search_qinfifo(ahd, cmd->target, cmd->channel + 'A',
+				       cmd->lun, pending_scb->hscb->tag,
+				       ROLE_INITIATOR, CAM_REQ_ABORTED,
+				       SEARCH_COMPLETE) > 0) {
+			printf("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",
+			       ahd_name(ahd), cmd->channel, cmd->target,
+					cmd->lun);
+			retval = SUCCESS;
+			goto done;
+		}
+	} else if (ahd_search_qinfifo(ahd, cmd->target, cmd->channel + 'A',
+				      cmd->lun, pending_scb->hscb->tag,
+				      ROLE_INITIATOR, /*status*/0,
+				      SEARCH_COUNT) > 0) {
+		disconnected = FALSE;
+	}
+
+	/*
+	 * At this point, pending_scb is the scb associated with the
+	 * passed in command.  That command is currently active on the
+	 * bus, is in the disconnected state, or we're hoping to find
+	 * a command for the same target active on the bus to abuse to
+	 * send a BDR.  Queue the appropriate message based on which of
+	 * these states we are in.
+	 */
+	last_phase = ahd_inb(ahd, LASTPHASE);
+	saved_scbptr = ahd_inb(ahd, SCBPTR);
+	active_scb_index = ahd_inb(ahd, SCB_TAG);
+	if (last_phase != P_BUSFREE
+	 && (pending_scb->hscb->tag == active_scb_index
+	  || (flag == SCB_DEVICE_RESET
+	   && SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)) == cmd->target))) {
+
+		/*
+		 * We're active on the bus, so assert ATN
+		 * and hope that the target responds.
+		 */
+		pending_scb = ahd_lookup_scb(ahd, active_scb_index);
+		pending_scb->flags |= SCB_RECOVERY_SCB|flag;
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		ahd_outb(ahd, SCSISIGO, last_phase|ATNO);
+		printf("%s:%d:%d:%d: Device is active, asserting ATN\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		wait = TRUE;
+	} else if (disconnected) {
+
+		/*
+		 * Actually re-queue this SCB in an attempt
+		 * to select the device before it reconnects.
+		 * In either case (selection or reselection),
+		 * we will now issue the approprate message
+		 * to the timed-out device.
+		 *
+		 * Set the MK_MESSAGE control bit indicating
+		 * that we desire to send a message.  We
+		 * also set the disconnected flag since
+		 * in the paging case there is no guarantee
+		 * that our SCB control byte matches the
+		 * version on the card.  We don't want the
+		 * sequencer to abort the command thinking
+		 * an unsolicited reselection occurred.
+		 */
+		pending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
+		pending_scb->flags |= SCB_RECOVERY_SCB|flag;
+
+		/*
+		 * In the non-paging case, the sequencer will
+		 * never re-reference the in-core SCB.
+		 * To make sure we are notified during
+		 * reslection, set the MK_MESSAGE flag in
+		 * the card's copy of the SCB.
+		 */
+		ahd_outb(ahd, SCBPTR, pending_scb->hscb->tag);
+		ahd_outb(ahd, SCB_CONTROL,
+			 ahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);
+
+		/*
+		 * Clear out any entries in the QINFIFO first
+		 * so we are the next SCB for this target
+		 * to run.
+		 */
+		ahd_search_qinfifo(ahd, cmd->target, cmd->channel + 'A',
+				   cmd->lun, SCB_LIST_NULL, ROLE_INITIATOR,
+				   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+		ahd_print_path(ahd, pending_scb);
+		printf("Queuing a recovery SCB\n");
+		ahd_qinfifo_requeue_tail(ahd, pending_scb);
+		ahd_outb(ahd, SCBPTR, saved_scbptr);
+		printf("%s:%d:%d:%d: Device is disconnected, re-queuing SCB\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		wait = TRUE;
+	} else {
+		printf("%s:%d:%d:%d: Unable to deliver message\n",
+		       ahd_name(ahd), cmd->channel, cmd->target, cmd->lun);
+		retval = FAILED;
+		goto done;
+	}
+
+no_cmd:
+	/*
+	 * Our assumption is that if we don't have the command, no
+	 * recovery action was required, so we return success.  Again,
+	 * the semantics of the mid-layer recovery engine are not
+	 * well defined, so this may change in time.
+	 */
+	retval = SUCCESS;
+done:
+	if (paused)
+		ahd_unpause(ahd);
+	if (wait) {
+		struct timer_list timer;
+		int ret;
+
+		ahd_unlock(ahd, &s);
+		init_timer(&timer);
+		timer.data = (u_long)&ahd->platform_data->eh_sem;
+		timer.expires = jiffies + (5 * HZ);
+		timer.function = ahd_linux_sem_timeout;
+		add_timer(&timer);
+		printf("Recovery code sleeping\n");
+		down(&ahd->platform_data->eh_sem);
+		printf("Recovery code awake\n");
+        	ret = del_timer(&timer);
+		if (ret == 0) {
+			printf("Timer Expired\n");
+			retval = FAILED;
+		}
+		ahd_lock(ahd, &s);
+	}
+	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	ahd_unlock(ahd, &s);
+	if (acmd != NULL)
+		ahd_linux_run_complete_queue(ahd, acmd);
+	ahd_runq_tasklet((unsigned long)ahd);
+	spin_lock_irq(&io_request_lock);
+	return (retval);
+}
+#endif
+
+static void
+ahd_linux_dev_timed_unfreeze(u_long arg)
+{
+	struct ahd_linux_device *dev;
+	struct ahd_softc *ahd;
+	u_long s;
+
+	dev = (struct ahd_linux_device *)arg;
+	ahd = dev->target->ahd;
+	ahd_lock(ahd, &s);
+	dev->flags &= ~AHD_DEV_TIMER_ACTIVE;
+	if (dev->qfrozen > 0)
+		dev->qfrozen--;
+	if (dev->qfrozen == 0
+	 && (dev->flags & AHD_DEV_ON_RUN_LIST) == 0)
+		ahd_linux_run_device_queue(ahd, dev);
+	ahd_unlock(ahd, &s);
+}
+
+/*
+ * Abort the current SCSI command(s).
+ */
+int
+ahd_linux_abort(Scsi_Cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+	u_long s;
+#if NOTYET
+	struct ahd_cmd *acmd;
+	int    found;
+#endif
+
+	ahd = *(struct ahd_softc **)cmd->host->hostdata;
+#if NOTYET
+	int error;
+
+	error = ahd_linux_queue_recovery_cmd(cmd, SCB_ABORT);
+	if (error != 0)
+		printf("aic79xx_abort returns 0x%x\n", error);
+	return (error);
+#else
+	printf("Abort called for cmd %p\n", cmd);
+	ahd_lock(ahd, &s);
+	ahd_dump_card_state(ahd);
+	ahd_unlock(ahd, &s);
+	return (FAILED);
+#endif
+}
+
+/*
+ * Attempt to send a target reset message to the device that timed out.
+ */
+int
+ahd_linux_dev_reset(Scsi_Cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+#if NOTYET
+	struct ahd_cmd *acmd;
+	u_long s;
+	int    found;
+#endif
+
+	printf("dev reset called for cmd %p\n", cmd);
+	ahd = *(struct ahd_softc **)cmd->host->hostdata;
+#if NOTYET
+	int error;
+
+	error = ahd_linux_queue_recovery_cmd(cmd, SCB_DEVICE_RESET);
+	if (error != 0)
+		printf("aic79xx_dev_reset returns 0x%x\n", error);
+	return (error);
+#else
+	return (FAILED);
+#endif
+}
+
+/*
+ * Reset the SCSI bus.
+ */
+int
+ahd_linux_bus_reset(Scsi_Cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+	struct ahd_cmd *acmd;
+	u_long s;
+	int    found;
+
+	printf("bus reset called for cmd %p\n", cmd);
+	/*
+	 * It is a bug that the upper layer takes
+	 * this lock just prior to calling us.
+	 */
+	spin_unlock_irq(&io_request_lock);
+
+	ahd = *(struct ahd_softc **)cmd->host->hostdata;
+	ahd_lock(ahd, &s);
+	found = ahd_reset_channel(ahd, cmd->channel + 'A',
+				  /*initiate reset*/TRUE);
+	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	ahd_unlock(ahd, &s);
+	if (bootverbose)
+		printf("%s: SCSI bus reset delivered. "
+		       "%d SCBs aborted.\n", ahd_name(ahd), found);
+
+	if (acmd != NULL)
+		ahd_linux_run_complete_queue(ahd, acmd);
+
+	spin_lock_irq(&io_request_lock);
+	return (SUCCESS);
+}
+
+/*
+ * Return the disk geometry for the given SCSI device.
+ */
+int
+ahd_linux_biosparam(Disk *disk, kdev_t dev, int geom[])
+{
+	int	heads;
+	int	sectors;
+	int	cylinders;
+	int	ret;
+	int	extended;
+	struct	ahd_softc *ahd;
+	struct	buffer_head *bh;
+
+	ahd = *((struct ahd_softc **)disk->device->host->hostdata);
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, 1024);
+
+	if (bh) {
+		ret = scsi_partsize(bh, disk->capacity,
+				    &geom[2], &geom[0], &geom[1]);
+		brelse(bh);
+		if (ret != -1)
+			return (ret);
+	}
+	heads = 64;
+	sectors = 32;
+	cylinders = disk->capacity / (heads * sectors);
+
+	if (aic79xx_extended != 0)
+		extended = 1;
+	else
+		extended = (ahd->flags & AHD_EXTENDED_TRANS_A) != 0;
+	if (extended && cylinders >= 1024) {
+		heads = 255;
+		sectors = 63;
+		cylinders = disk->capacity / (heads * sectors);
+	}
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+	return (0);
+}
+
+/*
+ * Free the passed in Scsi_Host memory structures prior to unloading the
+ * module.
+ */
+int
+ahd_linux_release(struct Scsi_Host * host)
+{
+	struct ahd_softc *ahd;
+	u_long l;
+
+	ahd_list_lock(&l);
+	if (host != NULL) {
+
+		/*
+		 * We should be able to just perform
+		 * the free directly, but check our
+		 * list for extra sanity.
+		 */
+		ahd = ahd_find_softc(*(struct ahd_softc **)host->hostdata);
+		if (ahd != NULL) {
+			u_long s;
+
+			ahd_lock(ahd, &s);
+			ahd_intr_enable(ahd, FALSE);
+			ahd_unlock(ahd, &s);
+			ahd_free(ahd);
+		}
+	}
+	ahd_list_unlock(&l);
+	return (0);
+}
+
+void
+ahd_platform_dump_card_state(struct ahd_softc *ahd)
+{
+	struct ahd_linux_device *dev;
+	int target;
+	int maxtarget;
+	int lun;
+	int i;
+
+	maxtarget = (ahd->features & AHD_WIDE) ? 15 : 7;
+	for (target = 0; target <=maxtarget; target++) {
+
+		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+			struct ahd_cmd *acmd;
+
+			dev = ahd_linux_get_device(ahd, 0, target,
+						   lun, /*alloc*/FALSE);
+			if (dev == NULL)
+				continue;
+
+			printf("DevQ(%d:%d:%d): ", 0, target, lun);
+			i = 0;
+			TAILQ_FOREACH(acmd, &dev->busyq, acmd_links.tqe) {
+				if (i++ > AHD_SCB_MAX)
+					break;
+			}
+			printf("%d waiting\n", i);
+		}
+	}
+}
+
+#if defined(MODULE) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+static Scsi_Host_Template driver_template = AIC79XX;
+Scsi_Host_Template *aic79xx_driver_template = &driver_template;
+#include "../scsi_module.c"
+#endif
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm.h	2002-09-24 15:05:58.000000000 -0600
@@ -0,0 +1,1303 @@
+/*
+ * Adaptec AIC79xx device driver for Linux.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#61 $
+ *
+ */
+#ifndef _AIC79XX_LINUX_H_
+#define _AIC79XX_LINUX_H_
+
+#include <linux/types.h>
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#ifndef AHD_MODVERSION_FILE
+#define __NO_VERSION__
+#endif
+#include <linux/module.h>
+#include <asm/byteorder.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/interrupt.h> /* For tasklet support. */
+#include <linux/config.h>
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+
+/* Core SCSI definitions */
+#include "../scsi.h"
+#include "../hosts.h"
+
+/* Name space conflict with BSD queue macros */
+#ifdef LIST_HEAD
+#undef LIST_HEAD
+#endif
+
+#include "cam.h"
+#include "queue.h"
+#include "scsi_message.h"
+#include "scsi_iu.h"
+
+/*********************************** Debugging ********************************/
+#ifdef CONFIG_AIC79XX_DEBUG_ENABLE
+#ifdef CONFIG_AIC79XX_DEBUG_MASK
+#define AHD_DEBUG 1
+#define AHD_DEBUG_OPTS CONFIG_AIC79XX_DEBUG_MASK
+#else
+/*
+ * Compile in debugging code, but do not enable any printfs.
+ */
+#define AHD_DEBUG 1
+#endif
+#endif
+
+/********************************** Misc Macros *******************************/
+#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
+#define	powerof2(x)	((((x)-1)&(x))==0)
+
+/************************* Forward Declarations *******************************/
+struct ahd_softc;
+typedef struct pci_dev *ahd_dev_softc_t;
+typedef Scsi_Cmnd      *ahd_io_ctx_t;
+
+/******************************* Byte Order ***********************************/
+#define ahd_htobe16(x)	cpu_to_be16(x)
+#define ahd_htobe32(x)	cpu_to_be32(x)
+#define ahd_htobe64(x)	cpu_to_be64(x)
+#define ahd_htole16(x)	cpu_to_le16(x)
+#define ahd_htole32(x)	cpu_to_le32(x)
+#define ahd_htole64(x)	cpu_to_le64(x)
+
+#define ahd_be16toh(x)	be16_to_cpu(x)
+#define ahd_be32toh(x)	be32_to_cpu(x)
+#define ahd_be64toh(x)	be64_to_cpu(x)
+#define ahd_le16toh(x)	le16_to_cpu(x)
+#define ahd_le32toh(x)	le32_to_cpu(x)
+#define ahd_le64toh(x)	le64_to_cpu(x)
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__BIG_ENDIAN)
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#if defined(__LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#endif /* BYTE_ORDER */
+
+/************************* Configuration Data *********************************/
+extern int aic79xx_detect_complete;
+extern Scsi_Host_Template* aic79xx_driver_template;
+
+/***************************** Bus Space/DMA **********************************/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
+typedef dma_addr_t bus_addr_t;
+#else
+typedef uint32_t bus_addr_t;
+#endif
+typedef uint32_t bus_size_t;
+
+typedef enum {
+	BUS_SPACE_MEMIO,
+	BUS_SPACE_PIO
+} bus_space_tag_t;
+
+typedef union {
+	u_long		  ioport;
+	volatile uint8_t *maddr;
+} bus_space_handle_t;
+
+typedef struct bus_dma_segment
+{
+	bus_addr_t	ds_addr;
+	bus_size_t	ds_len;
+} bus_dma_segment_t;
+
+struct ahd_linux_dma_tag
+{
+	bus_size_t	alignment;
+	bus_size_t	boundary;
+	bus_size_t	maxsize;
+};
+typedef struct ahd_linux_dma_tag* bus_dma_tag_t;
+
+struct ahd_linux_dmamap
+{
+	bus_addr_t	bus_addr;
+};
+typedef struct ahd_linux_dmamap* bus_dmamap_t;
+
+typedef int bus_dma_filter_t(void*, bus_addr_t);
+typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
+
+#define BUS_DMA_WAITOK		0x0
+#define BUS_DMA_NOWAIT		0x1
+#define BUS_DMA_ALLOCNOW	0x2
+#define BUS_DMA_LOAD_SEGS	0x4	/*
+					 * Argument is an S/G list not
+					 * a single buffer.
+					 */
+
+#define BUS_SPACE_MAXADDR	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
+
+int	ahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t /*parent*/,
+			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
+			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
+			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
+			   bus_size_t /*maxsize*/, int /*nsegments*/,
+			   bus_size_t /*maxsegsz*/, int /*flags*/,
+			   bus_dma_tag_t */*dma_tagp*/);
+
+void	ahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/);
+
+int	ahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			 void** /*vaddr*/, int /*flags*/,
+			 bus_dmamap_t* /*mapp*/);
+
+void	ahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			void* /*vaddr*/, bus_dmamap_t /*map*/);
+
+void	ahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/,
+			   bus_dmamap_t /*map*/);
+
+int	ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t /*dmat*/,
+			bus_dmamap_t /*map*/, void * /*buf*/,
+			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
+			void */*callback_arg*/, int /*flags*/);
+
+int	ahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);
+
+/*
+ * Operations performed by ahd_dmamap_sync().
+ */
+#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
+#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
+#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
+#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
+
+/*
+ * XXX
+ * ahd_dmamap_sync is only used on buffers allocated with
+ * the pci_alloc_consistent() API.  Although I'm not sure how
+ * this works on architectures with a write buffer, Linux does
+ * not have an API to sync "coherent" memory.  Perhaps we need
+ * to do an mb()?
+ */
+#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)
+
+/************************** SCSI Constants/Structures *************************/
+#define SCSI_REV_2 2
+#define	SCSI_STATUS_OK			0x00
+#define	SCSI_STATUS_CHECK_COND		0x02
+#define	SCSI_STATUS_COND_MET		0x04
+#define	SCSI_STATUS_BUSY		0x08
+#define SCSI_STATUS_INTERMED		0x10
+#define SCSI_STATUS_INTERMED_COND_MET	0x14
+#define SCSI_STATUS_RESERV_CONFLICT	0x18
+#define SCSI_STATUS_CMD_TERMINATED	0x22
+#define SCSI_STATUS_QUEUE_FULL		0x28
+
+/*
+ * 6 byte request sense CDB format.
+ */
+struct scsi_sense
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_sense_data
+{
+	uint8_t	error_code;
+#define	SSD_ERRCODE			0x7F
+#define		SSD_CURRENT_ERROR	0x70
+#define		SSD_DEFERRED_ERROR	0x71
+#define	SSD_ERRCODE_VALID		0x80
+	uint8_t	segment;
+	uint8_t	flags;
+#define	SSD_KEY				0x0F
+#define		SSD_KEY_NO_SENSE	0x00
+#define		SSD_KEY_RECOVERED_ERROR	0x01
+#define		SSD_KEY_NOT_READY	0x02
+#define		SSD_KEY_MEDIUM_ERROR	0x03
+#define		SSD_KEY_HARDWARE_ERROR	0x04
+#define		SSD_KEY_ILLEGAL_REQUEST	0x05
+#define		SSD_KEY_UNIT_ATTENTION	0x06
+#define		SSD_KEY_DATA_PROTECT	0x07
+#define		SSD_KEY_BLANK_CHECK	0x08
+#define		SSD_KEY_Vendor_Specific	0x09
+#define		SSD_KEY_COPY_ABORTED	0x0a
+#define		SSD_KEY_ABORTED_COMMAND	0x0b
+#define		SSD_KEY_EQUAL		0x0c
+#define		SSD_KEY_VOLUME_OVERFLOW	0x0d
+#define		SSD_KEY_MISCOMPARE	0x0e
+#define		SSD_KEY_RESERVED	0x0f
+#define	SSD_ILI		0x20
+#define	SSD_EOM		0x40
+#define	SSD_FILEMARK	0x80
+	uint8_t	info[4];
+	uint8_t	extra_len;
+	uint8_t	cmd_spec_info[4];
+	uint8_t add_sense_code;
+	uint8_t add_sense_code_qual;
+	uint8_t	fru;
+	uint8_t	sense_key_spec[3];
+#define	SSD_SCS_VALID		0x80
+#define	SSD_FIELDPTR_CMD	0x40
+#define	SSD_BITPTR_VALID	0x08
+#define	SSD_BITPTR_VALUE	0x07
+#define	SSD_MIN_SIZE	18
+	uint8_t	extra_bytes[14];
+};
+
+struct scsi_inquiry
+{ 
+	u_int8_t opcode;
+	u_int8_t byte2;
+#define	SI_EVPD 0x01
+	u_int8_t page_code;
+	u_int8_t reserved;
+	u_int8_t length;
+	u_int8_t control;
+};
+
+struct scsi_inquiry_data
+{
+	uint8_t device;
+#define	SID_TYPE(inq_data) ((inq_data)->device & 0x1f)
+#define	SID_QUAL(inq_data) (((inq_data)->device & 0xE0) >> 5)
+#define	SID_QUAL_LU_CONNECTED	0x00	/*
+					 * The specified peripheral device
+					 * type is currently connected to
+					 * logical unit.  If the target cannot
+					 * determine whether or not a physical
+					 * device is currently connected, it
+					 * shall also use this peripheral
+					 * qualifier when returning the INQUIRY
+					 * data.  This peripheral qualifier
+					 * does not mean that the device is
+					 * ready for access by the initiator.
+					 */
+#define	SID_QUAL_LU_OFFLINE	0x01	/*
+					 * The target is capable of supporting
+					 * the specified peripheral device type
+					 * on this logical unit; however, the
+					 * physical device is not currently
+					 * connected to this logical unit.
+					 */
+#define SID_QUAL_RSVD		0x02
+#define	SID_QUAL_BAD_LU		0x03	/*
+					 * The target is not capable of
+					 * supporting a physical device on
+					 * this logical unit. For this
+					 * peripheral qualifier the peripheral
+					 * device type shall be set to 1Fh to
+					 * provide compatibility with previous
+					 * versions of SCSI. All other
+					 * peripheral device type values are
+					 * reserved for this peripheral
+					 * qualifier.
+					 */
+#define	SID_QUAL_IS_VENDOR_UNIQUE(inq_data) ((SID_QUAL(inq_data) & 0x08) != 0)
+	uint8_t dev_qual2;
+#define	SID_QUAL2	0x7F
+#define	SID_IS_REMOVABLE(inq_data) (((inq_data)->dev_qual2 & 0x80) != 0)
+	uint8_t version;
+#define SID_ANSI_REV(inq_data) ((inq_data)->version & 0x07)
+#define		SCSI_REV_0		0
+#define		SCSI_REV_CCS		1
+#define		SCSI_REV_2		2
+#define		SCSI_REV_SPC		3
+#define		SCSI_REV_SPC2		4
+
+#define SID_ECMA	0x38
+#define SID_ISO		0xC0
+	uint8_t response_format;
+#define SID_AENC	0x80
+#define SID_TrmIOP	0x40
+	uint8_t additional_length;
+	uint8_t reserved[2];
+	uint8_t flags;
+#define	SID_SftRe	0x01
+#define	SID_CmdQue	0x02
+#define	SID_Linked	0x08
+#define	SID_Sync	0x10
+#define	SID_WBus16	0x20
+#define	SID_WBus32	0x40
+#define	SID_RelAdr	0x80
+#define SID_VENDOR_SIZE   8
+	char	 vendor[SID_VENDOR_SIZE];
+#define SID_PRODUCT_SIZE  16
+	char	 product[SID_PRODUCT_SIZE];
+#define SID_REVISION_SIZE 4
+	char	 revision[SID_REVISION_SIZE];
+	/*
+	 * The following fields were taken from SCSI Primary Commands - 2
+	 * (SPC-2) Revision 14, Dated 11 November 1999
+	 */
+#define	SID_VENDOR_SPECIFIC_0_SIZE	20
+	u_int8_t vendor_specific0[SID_VENDOR_SPECIFIC_0_SIZE];
+	/*
+	 * An extension of SCSI Parallel Specific Values
+	 */
+#define	SID_SPI_IUS		0x01
+#define	SID_SPI_QAS		0x02
+#define	SID_SPI_CLOCK_ST	0x00
+#define	SID_SPI_CLOCK_DT	0x04
+#define	SID_SPI_CLOCK_DT_ST	0x0C
+#define	SID_SPI_MASK		0x0F
+	uint8_t spi3data;
+	uint8_t reserved2;
+	/*
+	 * Version Descriptors, stored 2 byte values.
+	 */
+	uint8_t version1[2];
+	uint8_t version2[2];
+	uint8_t version3[2];
+	uint8_t version4[2];
+	uint8_t version5[2];
+	uint8_t version6[2];
+	uint8_t version7[2];
+	uint8_t version8[2];
+
+	uint8_t reserved3[22];
+
+#define	SID_VENDOR_SPECIFIC_1_SIZE	160
+	uint8_t vendor_specific1[SID_VENDOR_SPECIFIC_1_SIZE];
+};
+
+static __inline uint32_t scsi_4btoul(uint8_t *bytes);
+static __inline uint32_t
+scsi_4btoul(uint8_t *bytes)
+{
+	return ((bytes[0] << 24)|(bytes[1] << 16)|(bytes[2] << 8)|bytes[3]);
+}
+/************************** Timer DataStructures ******************************/
+typedef struct timer_list ahd_timer_t;
+
+/********************************** Includes **********************************/
+/* Host template and function declarations referenced by the template. */
+#include "aic79xx_host.h"
+
+/* Core driver definitions */
+#define AIC_DEBUG_REGISTERS 1
+#include "aic79xx.h"
+
+/***************************** Timer Facilities *******************************/
+#define ahd_timer_init init_timer
+#define ahd_timer_stop del_timer
+typedef void ahd_linux_callback_t (u_long);  
+static __inline void
+ahd_timer_reset(ahd_timer_t *timer, int usec, ahd_callback_t *func, void *arg)
+{
+	struct ahd_softc *ahd;
+
+	ahd = (struct ahd_softc *)arg;
+	del_timer(timer);
+	timer->data = (u_long)arg;
+	timer->expires = jiffies + (usec * HZ)/1000000;
+	timer->function = (ahd_linux_callback_t*)func;
+	add_timer(timer);
+}
+
+/***************************** SMP support ************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
+#include <linux/spinlock.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
+#include <linux/smp.h>
+#endif
+
+#define AIC79XX_DRIVER_VERSION "1.1.0"
+
+/**************************** Front End Queues ********************************/
+/*
+ * Data structure used to cast the Linux struct scsi_cmnd to something
+ * that allows us to use the queue macros.  The linux structure has
+ * plenty of space to hold the links fields as required by the queue
+ * macros, but the queue macors require them to have the correct type.
+ */
+struct ahd_cmd_internal {
+	/* Area owned by the Linux scsi layer. */
+	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
+	union {
+		STAILQ_ENTRY(ahd_cmd)	ste;
+		LIST_ENTRY(ahd_cmd)	le;
+		TAILQ_ENTRY(ahd_cmd)	tqe;
+	} links;
+	uint32_t			end;
+};
+
+struct ahd_cmd {
+	union {
+		struct ahd_cmd_internal	icmd;
+		struct scsi_cmnd	scsi_cmd;
+	} un;
+};
+
+#define acmd_icmd(cmd) ((cmd)->un.icmd)
+#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
+#define acmd_links un.icmd.links
+
+/*************************** Device Data Structures ***************************/
+/*
+ * A per probed device structure used to deal with some error recovery
+ * scenarios that the Linux mid-layer code just doesn't know how to
+ * handle.  The structure allocated for a device only becomes persistant
+ * after a successfully completed inquiry command to the target when
+ * that inquiry data indicates a lun is present.
+ */
+TAILQ_HEAD(ahd_busyq, ahd_cmd);
+typedef enum {
+	AHD_DEV_UNCONFIGURED	 = 0x01,
+	AHD_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
+	AHD_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
+	AHD_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
+	AHD_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
+	AHD_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
+	AHD_DEV_PERIODIC_OTAG	 = 0x40	 /* Send OTAG to prevent starvation */
+} ahd_dev_flags;
+
+struct ahd_linux_target;
+struct ahd_linux_device {
+	TAILQ_ENTRY(ahd_linux_device) links;
+	struct			ahd_busyq busyq;
+
+	/*
+	 * The number of transactions currently
+	 * queued to the device.
+	 */
+	int			active;
+
+	/*
+	 * The currently allowed number of 
+	 * transactions that can be queued to
+	 * the device.  Must be signed for
+	 * conversion from tagged to untagged
+	 * mode where the device may have more
+	 * than one outstanding active transaction.
+	 */
+	int			openings;
+
+	/*
+	 * A positive count indicates that this
+	 * device's queue is halted.
+	 */
+	u_int			qfrozen;
+	
+	/*
+	 * Cumulative command counter.
+	 */
+	u_long			commands_issued;
+
+	/*
+	 * The number of tagged transactions when
+	 * running at our current opening level
+	 * that have been successfully received by
+	 * this device since the last QUEUE FULL.
+	 */
+	u_int			tag_success_count;
+#define AHD_TAG_SUCCESS_INTERVAL 50
+
+	ahd_dev_flags		flags;
+
+	/*
+	 * Per device timer.
+	 */
+	struct timer_list	timer;
+
+	/*
+	 * The high limit for the tags variable.
+	 */
+	u_int			maxtags;
+
+	/*
+	 * The computed number of tags outstanding
+	 * at the time of the last QUEUE FULL event.
+	 */
+	u_int			tags_on_last_queuefull;
+
+	/*
+	 * How many times we have seen a queue full
+	 * with the same number of tags.  This is used
+	 * to stop our adaptive queue depth algorithm
+	 * on devices with a fixed number of tags.
+	 */
+	u_int			last_queuefull_same_count;
+#define AHD_LOCK_TAGS_COUNT 50
+
+	/*
+	 * How many transactions have been queued
+	 * without the device going idle.  We use
+	 * this statistic to determine when to issue
+	 * an ordered tag to prevent transaction
+	 * starvation.  This statistic is only updated
+	 * if the AHD_DEV_PERIODIC_OTAG flag is set
+	 * on this device.
+	 */
+	u_int			commands_since_idle_or_otag;
+#define AHD_OTAG_THRESH	500
+
+	int			lun;
+	struct			ahd_linux_target *target;
+};
+
+struct ahd_linux_target {
+	struct	ahd_linux_device *devices[AHD_NUM_LUNS];
+	int	channel;
+	int	target;
+	int	refcount;
+	struct	ahd_transinfo last_tinfo;
+	struct	ahd_softc *ahd;
+};
+
+/********************* Definitions Required by the Core ***********************/
+/*
+ * Number of SG segments we require.  So long as the S/G segments for
+ * a particular transaction are allocated in a physically contiguous
+ * manner and are allocated below 4GB, the number of S/G segments is
+ * unrestricted.
+ */
+#define        AHD_NSEG 128
+
+/*
+ * Per-SCB OSM storage.
+ */
+struct scb_platform_data {
+	struct ahd_linux_device	*dev;
+	bus_addr_t		 buf_busaddr;
+	uint32_t		 xfer_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+	uint32_t		 resid;		/* Transfer residual */
+#endif
+};
+
+/*
+ * Define a structure used for each host adapter.  All members are
+ * aligned on a boundary >= the size of the member to honor the
+ * alignment restrictions of the various platforms supported by
+ * this driver.
+ */
+TAILQ_HEAD(ahd_completeq, ahd_cmd);
+struct ahd_platform_data {
+	/*
+	 * Fields accessed from interrupt context.
+	 */
+	struct ahd_linux_target *targets[AHD_NUM_TARGETS]; 
+	TAILQ_HEAD(, ahd_linux_device) device_runq;
+	struct ahd_completeq	 completeq;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+	spinlock_t		 spin_lock;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	struct tasklet_struct	 runq_tasklet;
+#endif
+	u_int			 qfrozen;
+	struct timer_list	 reset_timer;
+	struct semaphore	 eh_sem;
+	struct Scsi_Host        *host;		/* pointer to scsi host */
+#define AHD_LINUX_NOIRQ	((uint32_t)~0)
+	uint32_t		 irq;		/* IRQ for this adapter */
+	uint32_t		 bios_address;
+	uint32_t		 mem_busaddr;	/* Mem Base Addr */
+	bus_addr_t		 hw_dma_mask;
+};
+
+/************************** OS Utility Wrappers *******************************/
+#define printf printk
+#define M_NOWAIT GFP_ATOMIC
+#define M_WAITOK 0
+#define malloc(size, type, flags) kmalloc(size, flags)
+#define free(ptr, type) kfree(ptr)
+
+static __inline void ahd_delay(long);
+static __inline void
+ahd_delay(long usec)
+{
+	/*
+	 * udelay on Linux can have problems for
+	 * multi-millisecond waits.  Wait at most
+	 * 1024us per call.
+	 */
+	while (usec > 0) {
+		udelay(usec % 1024);
+		usec -= 1024;
+	}
+}
+
+
+/***************************** Low Level I/O **********************************/
+#if defined(__powerpc__) || defined(__i386__) || defined(__ia64__)
+#define MMAPIO
+#endif
+
+static __inline uint8_t ahd_inb(struct ahd_softc * ahd, long port);
+static __inline uint16_t ahd_inw_atomic(struct ahd_softc * ahd, long port);
+static __inline void ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);
+static __inline void ahd_outw_atomic(struct ahd_softc * ahd,
+				     long port, uint16_t val);
+static __inline void ahd_outsb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+static __inline void ahd_insb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+
+static __inline uint8_t
+ahd_inb(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readb(ahd->bshs[0].maddr + port);
+	} else {
+		x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline uint16_t
+ahd_inw_atomic(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readw(ahd->bshs[0].maddr + port);
+	} else {
+		x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline void
+ahd_outb(struct ahd_softc * ahd, long port, uint8_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writeb(val, ahd->bshs[0].maddr + port);
+	} else {
+		outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writew(val, ahd->bshs[0].maddr + port);
+	} else {
+		outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		ahd_outb(ahd, port, *array++);
+}
+
+static __inline void
+ahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		*array++ = ahd_inb(ahd, port);
+}
+
+/**************************** Initialization **********************************/
+int		ahd_linux_register_host(struct ahd_softc *,
+					Scsi_Host_Template *);
+
+uint64_t	ahd_linux_get_memsize(void);
+
+/*************************** Pretty Printing **********************************/
+struct info_str {
+	char *buffer;
+	int length;
+	off_t offset;
+	int pos;
+};
+
+void	ahd_format_transinfo(struct info_str *info,
+			     struct ahd_transinfo *tinfo);
+
+/******************************** Locking *************************************/
+/* Lock protecting internal data structures */
+static __inline void ahd_lockinit(struct ahd_softc *);
+static __inline void ahd_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock held during command compeletion to the upper layer */
+static __inline void ahd_done_lockinit(struct ahd_softc *);
+static __inline void ahd_done_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_done_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock held during ahd_list manipulation and ahd softc frees */
+extern spinlock_t ahd_list_spinlock;
+static __inline void ahd_list_lockinit(void);
+static __inline void ahd_list_lock(unsigned long *flags);
+static __inline void ahd_list_unlock(unsigned long *flags);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
+static __inline void
+ahd_lockinit(struct ahd_softc *ahd)
+{
+	spin_lock_init(&ahd->platform_data->spin_lock);
+}
+
+static __inline void
+ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_done_lockinit(struct ahd_softc *ahd)
+{
+	/* We don't own the iorequest lock, so we don't initialize it. */
+}
+
+static __inline void
+ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&io_request_lock, *flags);
+}
+
+static __inline void
+ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&io_request_lock, *flags);
+}
+
+static __inline void
+ahd_list_lockinit()
+{
+	spin_lock_init(&ahd_list_spinlock);
+}
+
+static __inline void
+ahd_list_lock(unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&ahd_list_spinlock, *flags);
+}
+
+static __inline void
+ahd_list_unlock(unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd_list_spinlock, *flags);
+}
+
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
+
+ahd_lockinit(struct ahd_softc *ahd)
+{
+}
+
+static __inline void
+ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	save_flags(*flags);
+	cli();
+}
+
+static __inline void
+ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	restore_flags(*flags);
+}
+
+ahd_done_lockinit(struct ahd_softc *ahd)
+{
+}
+
+static __inline void
+ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	/*
+	 * The done lock is always held while
+	 * the ahd lock is held so blocking
+	 * interrupts again would have no effect.
+	 */
+}
+
+static __inline void
+ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+}
+
+static __inline void
+ahd_list_lockinit()
+{
+}
+
+static __inline void
+ahd_list_lock(unsigned long *flags)
+{
+	*flags = 0;
+	save_flags(*flags);
+	cli();
+}
+
+static __inline void
+ahd_list_unlock(unsigned long *flags)
+{
+	restore_flags(*flags);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
+
+/******************************* PCI Definitions ******************************/
+/*
+ * PCIM_xxx: mask to locate subfield in register
+ * PCIR_xxx: config register offset
+ * PCIC_xxx: device class
+ * PCIS_xxx: device subclass
+ * PCIP_xxx: device programming interface
+ * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
+ * PCID_xxx: device ID
+ */
+#define PCIR_DEVVENDOR		0x00
+#define PCIR_VENDOR		0x00
+#define PCIR_DEVICE		0x02
+#define PCIR_COMMAND		0x04
+#define PCIM_CMD_PORTEN		0x0001
+#define PCIM_CMD_MEMEN		0x0002
+#define PCIM_CMD_BUSMASTEREN	0x0004
+#define PCIM_CMD_MWRICEN	0x0010
+#define PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
+#define PCIR_STATUS		0x06
+#define PCIR_REVID		0x08
+#define PCIR_PROGIF		0x09
+#define PCIR_SUBCLASS		0x0a
+#define PCIR_CLASS		0x0b
+#define PCIR_CACHELNSZ		0x0c
+#define PCIR_LATTIMER		0x0d
+#define PCIR_HEADERTYPE		0x0e
+#define PCIM_MFDEV		0x80
+#define PCIR_BIST		0x0f
+#define PCIR_CAP_PTR		0x34
+
+/* config registers for header type 0 devices */
+#define PCIR_MAPS	0x10
+#define PCIR_SUBVEND_0	0x2c
+#define PCIR_SUBDEV_0	0x2e
+
+/****************************** PCI-X definitions *****************************/
+#define PCIXR_COMMAND	0x96
+#define PCIXR_DEVADDR	0x98
+#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
+#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
+#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
+#define PCIXR_STATUS	0x9A
+#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
+#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
+#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
+#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
+#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
+#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
+#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
+#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
+#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+extern struct pci_driver aic79xx_pci_driver;
+#endif
+
+typedef enum
+{
+	AHD_POWER_STATE_D0,
+	AHD_POWER_STATE_D1,
+	AHD_POWER_STATE_D2,
+	AHD_POWER_STATE_D3
+} ahd_power_state;
+
+void ahd_power_state_change(struct ahd_softc *ahd,
+			    ahd_power_state new_state);
+
+/******************************* PCI Routines *********************************/
+/*
+ * We need to use the bios32.h routines if we are kernel version 2.1.92 or less.
+ */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
+#if defined(__sparc_v9__) || defined(__powerpc__)
+#error "PPC and Sparc platforms are only support under 2.1.92 and above"
+#endif
+#include <linux/bios32.h>
+#endif
+
+int			 ahd_linux_pci_probe(Scsi_Host_Template *);
+int			 ahd_pci_map_registers(struct ahd_softc *ahd);
+int			 ahd_pci_map_int(struct ahd_softc *ahd);
+
+static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t pci,
+					     int reg, int width);
+
+static __inline uint32_t
+ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
+{
+	switch (width) {
+	case 1:
+	{
+		uint8_t retval;
+
+		pci_read_config_byte(pci, reg, &retval);
+		return (retval);
+	}
+	case 2:
+	{
+		uint16_t retval;
+		pci_read_config_word(pci, reg, &retval);
+		return (retval);
+	}
+	case 4:
+	{
+		uint32_t retval;
+		pci_read_config_dword(pci, reg, &retval);
+		return (retval);
+	}
+	default:
+		panic("ahd_pci_read_config: Read size too big");
+		/* NOTREACHED */
+		return (0);
+	}
+}
+
+static __inline void ahd_pci_write_config(ahd_dev_softc_t pci,
+					  int reg, uint32_t value,
+					  int width);
+
+static __inline void
+ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
+{
+	switch (width) {
+	case 1:
+		pci_write_config_byte(pci, reg, value);
+		break;
+	case 2:
+		pci_write_config_word(pci, reg, value);
+		break;
+	case 4:
+		pci_write_config_dword(pci, reg, value);
+		break;
+	default:
+		panic("ahd_pci_write_config: Write size too big");
+		/* NOTREACHED */
+	}
+}
+
+static __inline int ahd_get_pci_function(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_function(ahd_dev_softc_t pci)
+{
+	return (PCI_FUNC(pci->devfn));
+}
+
+static __inline int ahd_get_pci_slot(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_slot(ahd_dev_softc_t pci)
+{
+	return (PCI_SLOT(pci->devfn));
+}
+
+static __inline int ahd_get_pci_bus(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_bus(ahd_dev_softc_t pci)
+{
+	return (pci->bus->number);
+}
+
+static __inline void ahd_flush_device_writes(struct ahd_softc *);
+static __inline void
+ahd_flush_device_writes(struct ahd_softc *ahd)
+{
+	/* XXX Is this sufficient for all architectures??? */
+	ahd_inb(ahd, INTSTAT);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
+#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
+#define pci_unmap_sg(pdev, sg_list, nseg, direction)
+#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
+#define sg_dma_len(sg) ((sg)->length)
+#define pci_map_single(pdev, buffer, bufflen, direction) \
+	(VIRT_TO_BUS(buffer))
+#define pci_unmap_single(pdev, buffer, buflen, direction)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+#define ahd_pci_set_dma_mask pci_set_dma_mask
+#else
+/*
+ * Always "return" 0 for success.
+ */
+#define ahd_pci_set_dma_mask(dev_softc, mask)	\
+	(((dev_softc)->dma_mask = mask) && 0)
+#endif
+/*********************** Transaction Access Wrappers **************************/
+static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
+static __inline
+void ahd_set_transaction_status(struct scb *scb, uint32_t status)
+{
+	scb->io_ctx->result &= ~(CAM_STATUS_MASK << 16);
+	scb->io_ctx->result |= status << 16;
+}
+
+static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
+static __inline
+void ahd_set_scsi_status(struct scb *scb, uint32_t status)
+{
+	scb->io_ctx->result &= ~0xFFFF;
+	scb->io_ctx->result |= status;
+}
+
+static __inline uint32_t ahd_get_transaction_status(struct scb *);
+static __inline
+uint32_t ahd_get_transaction_status(struct scb *scb)
+{
+	return ((scb->io_ctx->result >> 16) & CAM_STATUS_MASK);
+}
+
+static __inline uint32_t ahd_get_scsi_status(struct scb *);
+static __inline
+uint32_t ahd_get_scsi_status(struct scb *scb)
+{
+	return (scb->io_ctx->result & 0xFFFF);
+}
+
+static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
+static __inline
+void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
+{
+	/*
+	 * Nothing to do for linux as the incoming transaction
+	 * has no concept of tag/non tagged, etc.
+	 */
+}
+
+static __inline u_long ahd_get_transfer_length(struct scb *);
+static __inline
+u_long ahd_get_transfer_length(struct scb *scb)
+{
+	return (scb->platform_data->xfer_len);
+}
+
+static __inline int ahd_get_transfer_dir(struct scb *);
+static __inline
+int ahd_get_transfer_dir(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
+	return (scb->io_ctx->sc_data_direction);
+#else
+	if (scb->io_ctx->bufflen == 0)
+		return (CAM_DIR_NONE);
+
+	switch(scb->io_ctx->cmnd[0]) {
+	case 0x08:  /* READ(6)  */
+	case 0x28:  /* READ(10) */
+	case 0xA8:  /* READ(12) */
+		return (CAM_DIR_IN);
+        case 0x0A:  /* WRITE(6)  */
+        case 0x2A:  /* WRITE(10) */
+        case 0xAA:  /* WRITE(12) */
+		return (CAM_DIR_OUT);
+        default:
+		return (CAM_DIR_NONE);
+        }
+#endif
+}
+
+static __inline void ahd_set_residual(struct scb *, u_long);
+static __inline
+void ahd_set_residual(struct scb *scb, u_long resid)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	scb->io_ctx->resid = resid;
+#else
+	scb->platform_data->resid = resid;
+#endif
+}
+
+static __inline void ahd_set_sense_residual(struct scb *, u_long);
+static __inline
+void ahd_set_sense_residual(struct scb *scb, u_long resid)
+{
+	/* This can't be reported in Linux */
+}
+
+static __inline u_long ahd_get_residual(struct scb *);
+static __inline
+u_long ahd_get_residual(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	return (scb->io_ctx->resid);
+#else
+	return (scb->platform_data->resid);
+#endif
+}
+
+static __inline int ahd_perform_autosense(struct scb *);
+static __inline
+int ahd_perform_autosense(struct scb *scb)
+{
+	/*
+	 * We always perform autosense in Linux.
+	 * On other platforms this is set on a
+	 * per-transaction basis.
+	 */
+	return (1);
+}
+
+static __inline uint32_t
+ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (sizeof(struct scsi_sense_data));
+}
+
+static __inline void ahd_notify_xfer_settings_change(struct ahd_softc *,
+						     struct ahd_devinfo *);
+static __inline void
+ahd_notify_xfer_settings_change(struct ahd_softc *ahd,
+				struct ahd_devinfo *devinfo)
+{
+	/* Nothing to do here for linux */
+}
+
+static __inline void ahd_platform_scb_free(struct ahd_softc *ahd,
+					   struct scb *scb);
+static __inline void
+ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
+}
+
+int	ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);
+void	ahd_platform_free(struct ahd_softc *ahd);
+void	ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
+void	ahd_freeze_simq(struct ahd_softc *ahd);
+void	ahd_release_simq(struct ahd_softc *ahd);
+static __inline void	ahd_freeze_scb(struct scb *scb);
+static __inline void
+ahd_freeze_scb(struct scb *scb)
+{
+	/* Noting to do here for linux */
+}
+
+void	ahd_platform_set_tags(struct ahd_softc *ahd,
+			      struct ahd_devinfo *devinfo, ahd_queue_alg);
+int	ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
+				char channel, int lun, u_int tag,
+				role_t role, uint32_t status);
+void	ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
+void	ahd_platform_flushwork(struct ahd_softc *ahd);
+int	ahd_softc_comp(struct ahd_softc *, struct ahd_softc *);
+void	ahd_done(struct ahd_softc*, struct scb*);
+void	ahd_send_async(struct ahd_softc *, char channel,
+		       u_int target, u_int lun, ac_code, void *);
+void	ahd_print_path(struct ahd_softc *, struct scb *);
+void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
+
+#ifdef CONFIG_PCI
+#define AHD_PCI_CONFIG 1
+#else
+#define AHD_PCI_CONFIG 0
+#endif
+#define bootverbose aic79xx_verbose
+extern int aic79xx_verbose;
+#endif /* _AIC79XX_LINUX_H_ */
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm_pci.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_osm_pci.c	2002-09-24 15:05:58.000000000 -0600
@@ -0,0 +1,428 @@
+/*
+ * Linux driver attachment glue for PCI based U320 controllers.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#12 $
+ */
+
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+struct pci_device_id
+{
+};
+#endif
+
+static int	ahd_linux_pci_dev_probe(struct pci_dev *pdev,
+					const struct pci_device_id *ent);
+static int	ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd,
+						 u_long *base, u_long *base2);
+static int	ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
+						 u_long *bus_addr,
+						 uint8_t **maddr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+static void	ahd_linux_pci_dev_remove(struct pci_dev *pdev);
+
+/* We do our own ID filtering.  So, grab all SCSI storage class devices. */
+static struct pci_device_id ahd_linux_pci_id_table[] = {
+	{
+		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_SCSI << 8, 0xFFFF00, 0
+	},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, ahd_linux_pci_id_table);
+
+struct pci_driver aic79xx_pci_driver = {
+	name:		"aic79xx",
+	probe:		ahd_linux_pci_dev_probe,
+	remove:		ahd_linux_pci_dev_remove,
+	id_table:	ahd_linux_pci_id_table
+};
+
+static void
+ahd_linux_pci_dev_remove(struct pci_dev *pdev)
+{
+	struct ahd_softc *ahd;
+	u_long l;
+
+	/*
+	 * We should be able to just perform
+	 * the free directly, but check our
+	 * list for extra sanity.
+	 */
+	ahd_list_lock(&l);
+	ahd = ahd_find_softc((struct ahd_softc *)pdev->driver_data);
+	if (ahd != NULL) {
+		u_long s;
+
+		ahd_lock(ahd, &s);
+		ahd_intr_enable(ahd, FALSE);
+		ahd_unlock(ahd, &s);
+		ahd_free(ahd);
+	}
+	ahd_list_unlock(&l);
+}
+#endif /* !LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) */
+
+static int
+ahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	char		 buf[80];
+	struct		 ahd_softc *ahd;
+	ahd_dev_softc_t	 pci;
+	struct		 ahd_pci_identity *entry;
+	char		*name;
+	int		 error;
+
+	/*
+	 * Some BIOSen report the same device multiple times.
+	 */
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		struct pci_dev *probed_pdev;
+
+		probed_pdev = ahd->dev_softc;
+		if (probed_pdev->bus->number == pdev->bus->number
+		 && probed_pdev->devfn == pdev->devfn)
+			break;
+	}
+	if (ahd != NULL) {
+		/* Skip duplicate. */
+		return (-ENODEV);
+	}
+
+	pci = pdev;
+	entry = ahd_find_pci_device(pci);
+	if (entry == NULL)
+		return (-ENODEV);
+
+	/*
+	 * Allocate a softc for this card and
+	 * set it up for attachment by our
+	 * common detect routine.
+	 */
+	sprintf(buf, "ahd_pci:%d:%d:%d",
+		ahd_get_pci_bus(pci),
+		ahd_get_pci_slot(pci),
+		ahd_get_pci_function(pci));
+	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (name == NULL)
+		return (-ENOMEM);
+	strcpy(name, buf);
+	ahd = ahd_alloc(NULL, name);
+	if (ahd == NULL)
+		return (-ENOMEM);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	if (pci_enable_device(pdev)) {
+		ahd_free(ahd);
+		return (-ENODEV);
+	}
+	pci_set_master(pdev);
+
+	if (sizeof(bus_addr_t) > 4) {
+		uint64_t memsize;
+
+		memsize = ahd_linux_get_memsize();
+		if (memsize >= 0x8000000000
+	 	 && ahd_pci_set_dma_mask(pdev, 0xFFFFFFFFFFFFFFFFULL) == 0) {
+			ahd->flags |= AHD_64BIT_ADDRESSING;
+			ahd->platform_data->hw_dma_mask =
+			    (bus_addr_t)(0xFFFFFFFFFFFFFFFFULL&(bus_addr_t)~0);
+		} else if (memsize > 0x80000000
+			&& ahd_pci_set_dma_mask(pdev, 0x7FFFFFFFFFULL) == 0) {
+			ahd->flags |= AHD_39BIT_ADDRESSING;
+			ahd->platform_data->hw_dma_mask =
+			    (bus_addr_t)(0x7FFFFFFFFFULL & (bus_addr_t)~0);
+		}
+	}
+#endif
+	ahd->dev_softc = pci;
+	error = ahd_pci_config(ahd, entry);
+	if (error != 0) {
+		ahd_free(ahd);
+		return (-error);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	pdev->driver_data = ahd;
+	if (aic79xx_detect_complete)
+		ahd_linux_register_host(ahd, aic79xx_driver_template);
+#endif
+	return (0);
+}
+
+int
+ahd_linux_pci_probe(Scsi_Host_Template *template)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	return (pci_module_init(&aic79xx_pci_driver));
+#else
+	struct pci_dev *pdev;
+	u_int class;
+	int found;
+
+	/* If we don't have a PCI bus, we can't find any adapters. */
+	if (pci_present() == 0)
+		return (0);
+
+	found = 0;
+	pdev = NULL;
+	class = PCI_CLASS_STORAGE_SCSI << 8;
+	while ((pdev = pci_find_class(class, pdev)) != NULL) {
+		ahd_dev_softc_t pci;
+		int error;
+
+		pci = pdev;
+		error = ahd_linux_pci_dev_probe(pdev, /*pci_devid*/NULL);
+		if (error == 0)
+			found++;
+	}
+	return (found);
+#endif
+}
+
+static int
+ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, u_long *base,
+				 u_long *base2)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	*base = pci_resource_start(ahd->dev_softc, 0);
+	/*
+	 * This is really the 3rd bar and should be at index 2,
+	 * but the Linux PCI code doesn't know how to "count" 64bit
+	 * bars.
+	 */
+	*base2 = pci_resource_start(ahd->dev_softc, 3);
+#else
+	*base = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR0, 4);
+	*base2 = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR1, 4);
+	*base &= PCI_BASE_ADDRESS_IO_MASK;
+	*base2 &= PCI_BASE_ADDRESS_IO_MASK;
+#endif
+	if (*base == 0 || *base2 == 0)
+		return (ENOMEM);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	if (check_region(*base, 256) != 0
+	 || check_region(*base2, 256) != 0)
+		return (ENOMEM);
+	else {
+		request_region(*base, 256, "aic79xx");
+		request_region(*base2, 256, "aic79xx");
+	}
+#else
+	if (request_region(*base, 256, "aic79xx") == 0)
+		return (ENOMEM);
+	if (request_region(*base2, 256, "aic79xx") == 0) {
+		release_region(*base2, 256);
+		return (ENOMEM);
+	}
+#endif
+	return (0);
+}
+
+static int
+ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
+				 u_long *bus_addr,
+				 uint8_t **maddr)
+{
+	u_long	start;
+	u_long	base_page;
+	u_long	base_offset;
+	int	error;
+
+	if ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX
+	 && (ahd->bugs & AHD_PCIX_MMAPIO_BUG) != 0)
+		return (ENOMEM);
+
+	error = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	start = pci_resource_start(ahd->dev_softc, 1);
+	base_page = start & PAGE_MASK;
+	base_offset = start - base_page;
+#else
+	start = ahd_pci_read_config(ahd->dev_softc, PCIR_MAPS+4, 4);
+	base_offset = start & PCI_BASE_ADDRESS_MEM_MASK;
+	base_page = base_offset & PAGE_MASK;
+	base_offset -= base_page;
+#endif
+	if (start != 0) {
+		*bus_addr = start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		if (request_mem_region(start, 0x1000, "aic79xx") == 0)
+			error = ENOMEM;
+#endif
+		if (error == 0) {
+			*maddr = ioremap_nocache(base_page, base_offset + 256);
+			if (*maddr == NULL) {
+				error = ENOMEM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+				release_mem_region(start, 0x1000);
+#endif
+			} else
+				*maddr += base_offset;
+		}
+	} else
+		error = ENOMEM;
+	return (error);
+}
+
+int
+ahd_pci_map_registers(struct ahd_softc *ahd)
+{
+	uint32_t command;
+	u_long	 base;
+	uint8_t	*maddr;
+	int	 error;
+
+	/*
+	 * If its allowed, we prefer memory mapped access.
+	 */
+	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);
+	command &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);
+	base = 0;
+	maddr = NULL;
+#ifdef MMAPIO
+	error = ahd_linux_pci_reserve_mem_region(ahd, &base, &maddr);
+	if (error == 0) {
+		ahd->platform_data->mem_busaddr = base;
+		ahd->tags[0] = BUS_SPACE_MEMIO;
+		ahd->bshs[0].maddr = maddr;
+		ahd->tags[1] = BUS_SPACE_MEMIO;
+		ahd->bshs[1].maddr = maddr + 0x100;
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     command | PCIM_CMD_MEMEN, 4);
+
+		/*
+		 * Do a quick test to see if memory mapped
+		 * I/O is functioning correctly.
+		 */
+		if (ahd_inb(ahd, HCNTRL) == 0xFF) {
+
+			printf("aic79xx: PCI Device %d:%d:%d "
+			       "failed memory mapped test\n",
+			       ahd_get_pci_bus(ahd->dev_softc),
+			       ahd_get_pci_slot(ahd->dev_softc),
+			       ahd_get_pci_function(ahd->dev_softc));
+			ahd->bshs[0].maddr = NULL;
+			maddr = NULL;
+		} else
+			command |= PCIM_CMD_MEMEN;
+	} else if (bootverbose) {
+		printf("aic79xx: PCI%d:%d:%d MEM region 0x%lx "
+		       "unavailable. Cannot memory map device.\n",
+		       ahd_get_pci_bus(ahd->dev_softc),
+		       ahd_get_pci_slot(ahd->dev_softc),
+		       ahd_get_pci_function(ahd->dev_softc),
+		       base);
+	}
+#endif
+
+	if (maddr == NULL) {
+		u_long	 base2;
+
+		error = ahd_linux_pci_reserve_io_regions(ahd, &base, &base2);
+		if (error == 0) {
+			ahd->tags[0] = BUS_SPACE_PIO;
+			ahd->tags[1] = BUS_SPACE_PIO;
+			ahd->bshs[0].ioport = base;
+			ahd->bshs[1].ioport = base2;
+			command |= PCIM_CMD_PORTEN;
+		} else {
+			printf("aic79xx: PCI%d:%d:%d IO regions 0x%lx and 0x%lx"
+			       "unavailable. Cannot map device.\n",
+			       ahd_get_pci_bus(ahd->dev_softc),
+			       ahd_get_pci_slot(ahd->dev_softc),
+			       ahd_get_pci_function(ahd->dev_softc),
+			       base, base2);
+		}
+	}
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);
+	return (error);
+}
+
+int
+ahd_pci_map_int(struct ahd_softc *ahd)
+{
+	int error;
+
+	error = request_irq(ahd->dev_softc->irq, ahd_linux_isr,
+			    SA_SHIRQ, "aic79xx", ahd);
+	if (error == 0)
+		ahd->platform_data->irq = ahd->dev_softc->irq;
+	
+	return (-error);
+}
+
+void
+ahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	pci_set_power_state(ahd->dev_softc, new_state);
+#else
+	uint32_t cap;
+	u_int cap_offset;
+
+	/*
+	 * Traverse the capability list looking for
+	 * the power management capability.
+	 */
+	cap = 0;
+	cap_offset = ahd_pci_read_config(ahd->dev_softc,
+					 PCIR_CAP_PTR, /*bytes*/1);
+	while (cap_offset != 0) {
+
+		cap = ahd_pci_read_config(ahd->dev_softc,
+					  cap_offset, /*bytes*/4);
+		if ((cap & 0xFF) == 1
+		 && ((cap >> 16) & 0x3) > 0) {
+			uint32_t pm_control;
+
+			pm_control = ahd_pci_read_config(ahd->dev_softc,
+							 cap_offset + 4,
+							 /*bytes*/4);
+			pm_control &= ~0x3;
+			pm_control |= new_state;
+			ahd_pci_write_config(ahd->dev_softc,
+					     cap_offset + 4,
+					     pm_control, /*bytes*/2);
+			break;
+		}
+		cap_offset = (cap >> 8) & 0xFF;
+	}
+#endif 
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_pci.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_pci.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_pci.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_pci.c	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,816 @@
+/*
+ * Product specific probe and attach routines for:
+ *	aic7901 and aic7902 SCSI controllers
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx_pci.c#44 $
+ *
+ * $FreeBSD$
+ */
+
+#ifdef __linux__
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+#else
+#include <dev/aic7xxx/aic79xx_osm.h>
+#include <dev/aic7xxx/aic79xx_inline.h>
+#endif
+
+static __inline uint64_t
+ahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
+{
+	uint64_t id;
+
+	id = subvendor
+	   | (subdevice << 16)
+	   | ((uint64_t)vendor << 32)
+	   | ((uint64_t)device << 48);
+
+	return (id);
+}
+
+#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
+#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
+#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
+
+#define ID_AIC7901			0x800F9005FFFF9005ull
+#define ID_AIC7901_IROC			0x80089005FFFF9005ull
+#define ID_AIC7901A			0x801E9005FFFF9005ull
+#define ID_AHA_29320A			0x8000900500609005ull
+
+#define ID_AIC7902			0x801F9005FFFF9005ull
+#define ID_AIC7902_IROC			0x80189005FFFF9005ull
+#define ID_AHA_39320			0x8010900500409005ull
+#define ID_AHA_39320D			0x8011900500419005ull
+#define ID_AHA_39320D_CPQ		0x8011900500AC0E11ull
+#define ID_AHA_29320			0x8012900500429005ull
+#define ID_AHA_29320B			0x8013900500439005ull
+#define ID_AHA_29320LP			0x8014900500449005ull
+#define ID_AIC7902_PCI_REV_A4		0x3
+#define ID_AIC7902_PCI_REV_B0		0x10
+#define SUBID_CPQ			0x0E11
+
+#define DEVID_9005_TYPE(id) ((id) & 0xF)
+#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
+#define		DEVID_9005_TYPE_HBA_2EXT	0x1	/* 2 External Ports */
+#define		DEVID_9005_TYPE_IROC		0x8	/* Raid(0,1,10) Card */
+#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */
+
+#define DEVID_9005_MFUNC(id) ((id) & 0x10)
+
+#define DEVID_9005_PACKETIZED(id) ((id) & 0x8000)
+
+#define SUBID_9005_TYPE(id) ((id) & 0xF)
+#define		SUBID_9005_TYPE_HBA		0x0	/* Standard Card */
+#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */
+
+#define SUBID_9005_AUTOTERM(id)	(((id) & 0x10) == 0)
+
+#define SUBID_9005_LEGACYCONN_FUNC(id) ((id) & 0x20)
+
+#define SUBID_9005_SEEPTYPE(id) ((id) & 0x0C0) >> 6)
+#define		SUBID_9005_SEEPTYPE_NONE	0x0
+#define		SUBID_9005_SEEPTYPE_4K		0x1
+
+static ahd_device_setup_t ahd_aic7901_setup;
+static ahd_device_setup_t ahd_aic7902_setup;
+static ahd_device_setup_t ahd_aic7901A_setup;
+
+struct ahd_pci_identity ahd_pci_ident_table [] =
+{
+	/* aic7901 based controllers */
+	{
+		ID_AHA_29320A,
+		ID_ALL_MASK,
+		"Adaptec 29320A Ultra320 SCSI adapter",
+		ahd_aic7901_setup
+	},
+	/* aic7902 based controllers */	
+	{
+		ID_AHA_39320,
+		ID_ALL_MASK,
+		"Adaptec 39320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D,
+		ID_ALL_MASK,
+		"Adaptec 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D_CPQ,
+		ID_ALL_MASK,
+		"Adaptec (Compaq OEM) 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_29320,
+		ID_ALL_MASK,
+		"Adaptec 29320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_29320B,
+		ID_ALL_MASK,
+		"Adaptec 29320B Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_29320LP,
+		ID_ALL_MASK,
+		"Adaptec 29320LP Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AIC7901A & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
+		"Adaptec 7901A Ultra320 SCSI adapter",
+		ahd_aic7901A_setup
+	},
+	/* Generic chip probes for devices we don't know 'exactly' */
+	{
+		ID_AIC7901 & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
+		"Adaptec aic7901 Ultra320 SCSI adapter",
+		ahd_aic7901_setup
+	},
+	{
+		ID_AIC7902 & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
+		"Adaptec aic7902 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	}
+};
+
+const u_int ahd_num_pci_devs = NUM_ELEMENTS(ahd_pci_ident_table);
+		
+#define	DEVCONFIG		0x40
+#define		PCIXINITPAT	0x0000E000ul
+#define			PCIXINIT_PCI33_66	0x0000E000ul
+#define			PCIXINIT_PCIX50_66	0x0000C000ul
+#define			PCIXINIT_PCIX66_100	0x0000A000ul
+#define			PCIXINIT_PCIX100_133	0x00008000ul
+#define	PCI_BUS_MODES_INDEX(devconfig)	\
+	(((devconfig) & PCIXINITPAT) >> 13)
+static const char *pci_bus_modes[] =
+{
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI-X 101-133Mhz",
+	"PCI-X 67-100Mhz",
+	"PCI-X 50-66Mhz",
+	"PCI 33 or 66Mhz"
+};
+
+#define		TESTMODE	0x00000800ul
+#define		IRDY_RST	0x00000200ul
+#define		FRAME_RST	0x00000100ul
+#define		PCI64BIT	0x00000080ul
+#define		MRDCEN		0x00000040ul
+#define		ENDIANSEL	0x00000020ul
+#define		MIXQWENDIANEN	0x00000008ul
+#define		DACEN		0x00000004ul
+#define		STPWLEVEL	0x00000002ul
+#define		QWENDIANSEL	0x00000001ul
+
+#define	DEVCONFIG1		0x44
+#define		PREQDIS		0x01
+
+#define	CSIZE_LATTIME		0x0c
+#define		CACHESIZE	0x000000fful
+#define		LATTIME		0x0000ff00ul
+
+static int	ahd_check_extport(struct ahd_softc *ahd);
+static void	ahd_configure_termination(struct ahd_softc *ahd,
+					  u_int adapter_control);
+static void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);
+
+struct ahd_pci_identity *
+ahd_find_pci_device(ahd_dev_softc_t pci)
+{
+	uint64_t  full_id;
+	uint16_t  device;
+	uint16_t  vendor;
+	uint16_t  subdevice;
+	uint16_t  subvendor;
+	struct	  ahd_pci_identity *entry;
+	u_int	  i;
+
+	vendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
+	device = ahd_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
+	subvendor = ahd_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
+	subdevice = ahd_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
+	full_id = ahd_compose_id(device,
+				 vendor,
+				 subdevice,
+				 subvendor);
+
+	for (i = 0; i < ahd_num_pci_devs; i++) {
+		entry = &ahd_pci_ident_table[i];
+		if (entry->full_id == (full_id & entry->id_mask)) {
+			/* Honor exclusion entries. */
+			if (entry->name == NULL)
+				return (NULL);
+			return (entry);
+		}
+	}
+	return (NULL);
+}
+
+int
+ahd_pci_config(struct ahd_softc *ahd, struct ahd_pci_identity *entry)
+{
+	struct scb_data *shared_scb_data;
+	u_long		 l;
+	u_int		 command;
+	uint32_t	 devconfig;
+	uint16_t	 subvendor; 
+	int		 error;
+
+	shared_scb_data = NULL;
+	error = entry->setup(ahd);
+	if (error != 0)
+		return (error);
+	
+	ahd->description = entry->name;
+	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	if ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {
+		ahd->chip |= AHD_PCI;
+		/* Disable PCIX workarounds when running in PCI mode. */
+		ahd->bugs &= ~AHD_PCIX_BUG_MASK;
+	} else {
+		ahd->chip |= AHD_PCIX;
+	}
+	ahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];
+
+	/*
+	 * Record if this is a Compaq board.
+	 */
+	subvendor = ahd_pci_read_config(ahd->dev_softc,
+					PCIR_SUBVEND_0, /*bytes*/2);
+	if (subvendor == SUBID_CPQ)
+		ahd->flags |= AHD_CPQ_BOARD;
+
+	ahd_power_state_change(ahd, AHD_POWER_STATE_D0);
+
+	error = ahd_pci_map_registers(ahd);
+	if (error != 0)
+		return (error);
+
+	/*
+	 * If we need to support high memory, enable dual
+	 * address cycles.  This bit must be set to enable
+	 * high address bit generation even if we are on a
+	 * 64bit bus (PCI64BIT set in devconfig).
+	 */
+	if ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {
+		uint32_t devconfig;
+
+		if (bootverbose)
+			printf("%s: Enabling 39Bit Addressing\n",
+			       ahd_name(ahd));
+		devconfig = ahd_pci_read_config(ahd->dev_softc,
+						DEVCONFIG, /*bytes*/4);
+		devconfig |= DACEN;
+		ahd_pci_write_config(ahd->dev_softc, DEVCONFIG,
+				     devconfig, /*bytes*/4);
+	}
+	
+	/* Ensure busmastering is enabled */
+	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/1);
+	command |= PCIM_CMD_BUSMASTEREN;
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, /*bytes*/1);
+
+	error = ahd_softc_init(ahd);
+	if (error != 0)
+		return (error);
+
+	ahd->bus_intr = ahd_pci_intr;
+
+	error = ahd_reset(ahd);
+	if (error != 0)
+		return (ENXIO);
+
+	ahd->pci_cachesize =
+	    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,
+				/*bytes*/1) & CACHESIZE;
+	ahd->pci_cachesize *= 4;
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/* See if we have a SEEPROM and perform auto-term */
+	error = ahd_check_extport(ahd);
+	if (error != 0)
+		return (error);
+
+	/* Core initialization */
+	error = ahd_init(ahd);
+	if (error != 0)
+		return (error);
+
+	/*
+	 * Allow interrupts now that we are completely setup.
+	 */
+	error = ahd_pci_map_int(ahd);
+	if (error != 0)
+		return (error);
+
+	ahd_list_lock(&l);
+	/*
+	 * Link this softc in with all other ahd instances.
+	 */
+	ahd_softc_insert(ahd);
+	ahd_list_unlock(&l);
+	return (0);
+}
+
+/*
+ * Check the external port logic for a serial eeprom
+ * and termination/cable detection contrls.
+ */
+static int
+ahd_check_extport(struct ahd_softc *ahd)
+{
+	struct	seeprom_config *sc;
+	u_int	adapter_control;
+	int	have_seeprom;
+	int	error;
+
+	sc = ahd->seep_config;
+	have_seeprom = ahd_acquire_seeprom(ahd);
+	if (have_seeprom) {
+		u_int start_addr;
+
+		if (bootverbose) 
+			printf("%s: Reading SEEPROM...", ahd_name(ahd));
+
+		/* Address is always in units of 16bit words */
+		start_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');
+
+		error = ahd_read_seeprom(ahd, (uint16_t *)sc,
+					 start_addr, sizeof(*sc)/2);
+
+		if (error != 0) {
+			printf("Unable to read SEEPROM\n");
+			have_seeprom = 0;
+		} else {
+			have_seeprom = ahd_verify_cksum(sc);
+
+			if (bootverbose) {
+				if (have_seeprom == 0)
+					printf ("checksum error\n");
+				else
+					printf ("done.\n");
+			}
+		}
+		ahd_release_seeprom(ahd);
+	}
+
+	if (!have_seeprom) {
+		u_int	  nvram_scb;
+
+		/*
+		 * Pull scratch ram settings and treat them as
+		 * if they are the contents of an seeprom if
+		 * the 'ADPT', 'BIOS', or 'ASPI' signature is found
+		 * in SCB 0xFF.  We manually compose the data as 16bit
+		 * values to avoid endian issues.
+		 */
+		ahd_set_scbptr(ahd, 0xFF);
+		nvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);
+		if (nvram_scb != 0xFF
+		 && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')
+		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')
+		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {
+			uint16_t *sc_data;
+			int	  i;
+
+			ahd_set_scbptr(ahd, nvram_scb);
+			sc_data = (uint16_t *)sc;
+			for (i = 0; i < 64; i += 2)
+				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
+			have_seeprom = ahd_verify_cksum(sc);
+			if (have_seeprom)
+				ahd->flags |= AHD_SCB_CONFIG_USED;
+		}
+	}
+
+#if AHD_DEBUG
+	if (have_seeprom != 0
+	 && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {
+		uint8_t *sc_data;
+		int	 i;
+
+		printf("%s: Seeprom Contents:", ahd_name(ahd));
+		sc_data = (uint8_t *)sc;
+		for (i = 0; i < (sizeof(*sc)); i += 2)
+			printf("\n\t0x%.4x", 
+			       sc_data[i] | (sc_data[i+1] << 8));
+		printf("\n");
+	}
+#endif
+
+	if (!have_seeprom) {
+		if (bootverbose)
+			printf("%s: No SEEPROM available.\n", ahd_name(ahd));
+		ahd->flags |= AHD_USEDEFAULTS;
+		error = ahd_default_config(ahd);
+		adapter_control = CFAUTOTERM|CFSEAUTOTERM;
+		free(ahd->seep_config, M_DEVBUF);
+		ahd->seep_config = NULL;
+	} else {
+		error = ahd_parse_cfgdata(ahd, sc);
+		adapter_control = sc->adapter_control;
+	}
+	if (error != 0)
+		return (error);
+
+	ahd_configure_termination(ahd, adapter_control);
+
+	return (0);
+}
+
+static void
+ahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)
+{
+	int	 error;
+	u_int	 sxfrctl1;
+	uint8_t	 termctl;
+	uint32_t devconfig;
+
+	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig &= ~STPWLEVEL;
+	if ((ahd->flags & AHD_STPWLEVEL_A) != 0)
+		devconfig |= STPWLEVEL;
+	if (bootverbose)
+		printf("%s: STPWLEVEL is %s\n",
+		       ahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");
+	ahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+ 
+	/* Make sure current sensing is off. */
+	if ((ahd->flags & AHD_CURRENT_SENSING) != 0) {
+		(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
+	}
+
+	/*
+	 * Read to sense.  Write to set.
+	 */
+	error = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);
+	if ((adapter_control & CFAUTOTERM) == 0) {
+		if (bootverbose)
+			printf("%s: Manual Primary Termination\n",
+			       ahd_name(ahd));
+		termctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);
+		if ((adapter_control & CFSTERM) != 0)
+			termctl |= FLX_TERMCTL_ENPRILOW;
+		if ((adapter_control & CFWSTERM) != 0)
+			termctl |= FLX_TERMCTL_ENPRIHIGH;
+	} else if (error != 0) {
+		printf("%s: Primary Auto-Term Sensing failed! "
+		       "Using Defaults.\n", ahd_name(ahd));
+		termctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;
+	}
+
+	if ((adapter_control & CFSEAUTOTERM) == 0) {
+		if (bootverbose)
+			printf("%s: Manual Secondary Termination\n",
+			       ahd_name(ahd));
+		termctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);
+		if ((adapter_control & CFSELOWTERM) != 0)
+			termctl |= FLX_TERMCTL_ENSECLOW;
+		if ((adapter_control & CFSEHIGHTERM) != 0)
+			termctl |= FLX_TERMCTL_ENSECHIGH;
+	} else if (error != 0) {
+		printf("%s: Secondary Auto-Term Sensing failed! "
+		       "Using Defaults.\n", ahd_name(ahd));
+		termctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;
+	}
+
+	/*
+	 * Now set the termination based on what we found.
+	 */
+	sxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;
+	if ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {
+		ahd->flags |= AHD_TERM_ENB_A;
+		sxfrctl1 |= STPWEN;
+	}
+	/* Must set the latch once in order to be effective. */
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
+
+	error = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);
+	if (error != 0) {
+		printf("%s: Unable to set termination settings!\n",
+		       ahd_name(ahd));
+	} else if (bootverbose) {
+		printf("%s: Primary High byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENPRIHIGH) ? "En" : "Dis");
+
+		printf("%s: Primary Low byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENPRILOW) ? "En" : "Dis");
+
+		printf("%s: Secondary High byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENSECHIGH) ? "En" : "Dis");
+
+		printf("%s: Secondary Low byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENSECLOW) ? "En" : "Dis");
+	}
+	return;
+}
+
+#define	DPE	0x80
+#define SSE	0x40
+#define	RMA	0x20
+#define	RTA	0x10
+#define STA	0x08
+#define DPR	0x01
+
+static const char *split_status_source[] =
+{
+	"DFF0",
+	"DFF1",
+	"OVLY",
+	"CMC",
+};
+
+static const char *pci_status_source[] =
+{
+	"DFF0",
+	"DFF1",
+	"SG",
+	"CMC",
+	"OVLY",
+	"NONE",
+	"MSI",
+	"TARG"
+};
+
+static const char *split_status_strings[] =
+{
+	"%s: Received split response in %s.\n"
+	"%s: Received split completion error message in %s\n",
+	"%s: Receive overrun in %s\n",
+	"%s: Count not complete in %s\n",
+	"%s: Split completion data bucket in %s\n",
+	"%s: Split completion address error in %s\n",
+	"%s: Split completion byte count error in %s\n",
+	"%s: Signaled Target-abort to early terminate a split in %s\n",
+};
+
+static const char *pci_status_strings[] =
+{
+	"%s: Data Parity Error has been reported via PERR# in %s\n",
+	"%s: Target initial wait state error in %s\n",
+	"%s: Split completion read data parity error in %s\n",
+	"%s: Split completion address attribute parity error in %s\n",
+	"%s: Received a Target Abort in %s\n",
+	"%s: Received a Master Abort in %s\n",
+	"%s: Signal System Error Detected in %s\n",
+	"%s: Address or Write Phase Parity Error Detected in %s.\n"
+};
+
+void
+ahd_pci_intr(struct ahd_softc *ahd)
+{
+	uint8_t		pci_status[8];
+	ahd_mode_state	saved_modes;
+	u_int		pci_status1;
+	u_int		intstat;
+	u_int		i;
+	u_int		reg;
+	
+	intstat = ahd_inb(ahd, INTSTAT);
+
+	if ((intstat & SPLTINT) != 0)
+		ahd_pci_split_intr(ahd, intstat);
+
+	if ((intstat & PCIINT) == 0)
+		return;
+
+	printf("%s: PCI error Interrupt\n", ahd_name(ahd));
+	saved_modes = ahd_save_modes(ahd);
+	ahd_dump_card_state(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	for (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {
+
+		if (i == 5)
+			continue;
+		pci_status[i] = ahd_inb(ahd, reg);
+		/* Clear latched errors.  So our interupt deasserts. */
+		ahd_outb(ahd, reg, pci_status[i]);
+	}
+
+	for (i = 0; i < 8; i++) {
+		u_int bit;
+	
+		if (i == 5)
+			continue;
+
+		for (bit = 0; bit < 8; bit++) {
+
+			if ((pci_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = pci_status_strings[bit];
+				if (i == 7/*TARG*/ && bit == 3)
+					s = "%s: Signal Target Abort\n";
+				printf(s, ahd_name(ahd), pci_status_source[i]);
+			}
+		}	
+	}
+	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+					  PCIR_STATUS + 1, /*bytes*/1);
+	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+			     pci_status1, /*bytes*/1);
+	ahd_restore_modes(ahd, saved_modes);
+	ahd_unpause(ahd);
+}
+
+static void
+ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)
+{
+	uint8_t		split_status[4];
+	uint8_t		split_status1[4];
+	uint8_t		sg_split_status[2];
+	uint8_t		sg_split_status1[2];
+	ahd_mode_state	saved_modes;
+	u_int		i;
+	uint16_t	pcix_status;
+
+	/*
+	 * Check for splits in all modes.  Modes 0 and 1
+	 * additionally have SG engine splits to look at.
+	 */
+	pcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,
+					  /*bytes*/2);
+	printf("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",
+	       ahd_name(ahd), pcix_status);
+	saved_modes = ahd_save_modes(ahd);
+	for (i = 0; i < 4; i++) {
+		ahd_set_modes(ahd, i, i);
+
+		split_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);
+		split_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);
+		/* Clear latched errors.  So our interupt deasserts. */
+		ahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);
+		ahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);
+		if (i != 0)
+			continue;
+		sg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);
+		sg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);
+		/* Clear latched errors.  So our interupt deasserts. */
+		ahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);
+		ahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);
+	}
+
+	for (i = 0; i < 4; i++) {
+		u_int bit;
+
+		for (bit = 0; bit < 8; bit++) {
+
+			if ((split_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = split_status_strings[bit];
+				printf(s, ahd_name(ahd),
+				       split_status_source[i]);
+			}
+
+			if (i != 0)
+				continue;
+
+			if ((sg_split_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = split_status_strings[bit];
+				printf(s, ahd_name(ahd), "SG");
+			}
+		}
+	}
+	/*
+	 * Clear PCI-X status bits.
+	 */
+	ahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,
+			     pcix_status, /*bytes*/2);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static int
+ahd_aic7901_setup(struct ahd_softc *ahd)
+{
+	ahd_dev_softc_t pci;
+	
+	pci = ahd->dev_softc;
+	ahd->channel = 'A';
+	ahd->chip = AHD_AIC7901;
+	ahd->features = AHD_AIC7901_FE;
+	return (0);
+}
+
+static int
+ahd_aic7902_setup(struct ahd_softc *ahd)
+{
+	ahd_dev_softc_t pci;
+	u_int rev;
+	u_int devconfig1;
+
+	pci = ahd->dev_softc;
+	rev = ahd_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	if (rev < ID_AIC7902_PCI_REV_A4) {
+		printf("%s: Unable to attach to unsupported chip revision %d\n",
+		       ahd_name(ahd), rev);
+		ahd_pci_write_config(pci, PCIR_COMMAND, 0, /*bytes*/1);
+		return (ENXIO);
+	}
+	if (rev < ID_AIC7902_PCI_REV_B0) {
+		/*
+		 * Pending request assertion does not work on the A if we have
+		 * DMA requests outstanding on both channels.  See H2A3 Razors
+		 * #327 and #365.
+		 */
+		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+		ahd_pci_write_config(pci, DEVCONFIG1,
+				     devconfig1|PREQDIS, /*bytes*/1);
+		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+		/*
+		 * Enable A series workarounds.
+		 */
+		ahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG
+			  |  AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG
+			  |  AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG
+			  |  AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG
+			  |  AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG
+			  |  AHD_PCIX_CHIPRST_BUG|AHD_PKTIZED_STATUS_BUG
+			  |  AHD_PKT_LUN_BUG|AHD_MDFF_WSCBPTR_BUG
+			  |  AHD_REG_SLOW_SETTLE_BUG|AHD_SET_MODE_BUG
+			  |  AHD_BUSFREEREV_BUG;
+	}
+
+	ahd->channel = ahd_get_pci_function(pci) + 'A';
+	ahd->chip = AHD_AIC7902;
+	ahd->features = AHD_AIC7902_FE;
+	return (0);
+}
+
+static int
+ahd_aic7901A_setup(struct ahd_softc *ahd)
+{
+	int error;
+
+	error = ahd_aic7902_setup(ahd);
+	if (error != 0)
+		return (error);
+	ahd->chip = AHD_AIC7901A;
+	return (0);
+}
+
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_proc.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_proc.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_proc.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_proc.c	2002-09-11 15:08:12.000000000 -0600
@@ -0,0 +1,365 @@
+/*
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
+ * sym driver.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#7 $
+ */
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+
+static void	copy_mem_info(struct info_str *info, char *data, int len);
+static int	copy_info(struct info_str *info, char *fmt, ...);
+static u_int	scsi_calc_syncsrate(u_int period_factor);
+static void	ahd_dump_target_state(struct ahd_softc *ahd,
+				      struct info_str *info,
+				      u_int our_id, char channel,
+				      u_int target_id, u_int target_offset);
+static void	ahd_dump_device_state(struct info_str *info,
+				      struct ahd_linux_device *dev);
+static int	ahd_proc_write_seeprom(struct ahd_softc *ahd,
+				       char *buffer, int length);
+
+static void
+copy_mem_info(struct info_str *info, char *data, int len)
+{
+	if (info->pos + len > info->offset + info->length)
+		len = info->offset + info->length - info->pos;
+
+	if (info->pos + len < info->offset) {
+		info->pos += len;
+		return;
+	}
+
+	if (info->pos < info->offset) {
+		off_t partial;
+
+		partial = info->offset - info->pos;
+		data += partial;
+		info->pos += partial;
+		len  -= partial;
+	}
+
+	if (len > 0) {
+		memcpy(info->buffer, data, len);
+		info->pos += len;
+		info->buffer += len;
+	}
+}
+
+static int
+copy_info(struct info_str *info, char *fmt, ...)
+{
+	va_list args;
+	char buf[256];
+	int len;
+
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	copy_mem_info(info, buf, len);
+	return (len);
+}
+
+/*
+ * Table of syncrates that don't follow the "divisible by 4"
+ * rule. This table will be expanded in future SCSI specs.
+ */
+static struct {
+	u_int period_factor;
+	u_int period;	/* in 100ths of ns */
+} scsi_syncrates[] = {
+	{ 0x08,  625 },	/* FAST-160 */
+	{ 0x09, 1250 },	/* FAST-80 */
+	{ 0x0a, 2500 },	/* FAST-40 40MHz */
+	{ 0x0b, 3030 },	/* FAST-40 33MHz */
+	{ 0x0c, 5000 }	/* FAST-20 */
+};
+ 
+/*
+ * Return the frequency in kHz corresponding to the given
+ * sync period factor.
+ */
+static u_int
+scsi_calc_syncsrate(u_int period_factor)
+{
+	int i; 
+	int num_syncrates;
+ 
+	num_syncrates = sizeof(scsi_syncrates) / sizeof(scsi_syncrates[0]);
+	/* See if the period is in the "exception" table */
+	for (i = 0; i < num_syncrates; i++) {
+
+		if (period_factor == scsi_syncrates[i].period_factor) {
+       			/* Period in kHz */
+			return (100000000 / scsi_syncrates[i].period);
+		}
+	}
+
+	/*
+	 * Wasn't in the table, so use the standard
+	 * 4 times conversion.
+	 */
+	return (10000000 / (period_factor * 4 * 10));
+}
+
+void
+ahd_format_transinfo(struct info_str *info, struct ahd_transinfo *tinfo)
+{
+	u_int speed;
+	u_int freq;
+	u_int mb;
+
+        speed = 3300;
+        freq = 0;
+	if (tinfo->offset != 0) {
+		freq = scsi_calc_syncsrate(tinfo->period);
+		speed = freq;
+	}
+	speed *= (0x01 << tinfo->width);
+        mb = speed / 1000;
+        if (mb > 0)
+		copy_info(info, "%d.%03dMB/s transfers", mb, speed % 1000);
+        else
+		copy_info(info, "%dKB/s transfers", speed);
+
+	if (freq != 0) {
+		copy_info(info, " (%d.%03dMHz%s, offset %d",
+			 freq / 1000, freq % 1000,
+			 (tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0
+			 ? " DT" : "", tinfo->offset);
+	}
+
+	if (tinfo->width > 0) {
+		if (freq != 0) {
+			copy_info(info, ", ");
+		} else {
+			copy_info(info, " (");
+		}
+		copy_info(info, "%dbit)", 8 * (0x01 << tinfo->width));
+	} else if (freq != 0) {
+		copy_info(info, ")");
+	}
+	copy_info(info, "\n");
+}
+
+static void
+ahd_dump_target_state(struct ahd_softc *ahd, struct info_str *info,
+		      u_int our_id, char channel, u_int target_id,
+		      u_int target_offset)
+{
+	struct	ahd_linux_target *targ;
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	lun;
+
+	tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
+				    target_id, &tstate);
+	copy_info(info, "Channel %c Target %d Negotiation Settings\n",
+		  channel, target_id);
+	copy_info(info, "\tUser: ");
+	ahd_format_transinfo(info, &tinfo->user);
+	targ = ahd->platform_data->targets[target_offset];
+	if (targ == NULL)
+		return;
+
+	copy_info(info, "\tGoal: ");
+	ahd_format_transinfo(info, &tinfo->goal);
+	copy_info(info, "\tCurr: ");
+	ahd_format_transinfo(info, &tinfo->curr);
+
+	for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+		struct ahd_linux_device *dev;
+
+		dev = targ->devices[lun];
+
+		if (dev == NULL)
+			continue;
+
+		ahd_dump_device_state(info, dev);
+	}
+}
+
+static void
+ahd_dump_device_state(struct info_str *info, struct ahd_linux_device *dev)
+{
+	copy_info(info, "\tChannel %c Target %d Lun %d Settings\n",
+		  dev->target->channel + 'A', dev->target->target, dev->lun);
+
+	copy_info(info, "\t\tCommands Queued %ld\n", dev->commands_issued);
+	copy_info(info, "\t\tCommands Active %d\n", dev->active);
+	copy_info(info, "\t\tCommand Openings %d\n", dev->openings);
+	copy_info(info, "\t\tMax Tagged Openings %d\n", dev->maxtags);
+	copy_info(info, "\t\tDevice Queue Frozen Count %d\n", dev->qfrozen);
+}
+
+static int
+ahd_proc_write_seeprom(struct ahd_softc *ahd, char *buffer, int length)
+{
+	ahd_mode_state saved_modes;
+	int have_seeprom;
+	u_long s;
+	int paused;
+	int written;
+
+	/* Default to failure. */
+	written = -EINVAL;
+	ahd_lock(ahd, &s);
+	paused = ahd_is_paused(ahd);
+	if (!paused)
+		ahd_pause(ahd);
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	if (length != sizeof(struct seeprom_config)) {
+		printf("ahd_proc_write_seeprom: incorrect buffer size\n");
+		goto done;
+	}
+
+	have_seeprom = ahd_verify_cksum((struct seeprom_config*)buffer);
+	if (have_seeprom == 0) {
+		printf("ahd_proc_write_seeprom: cksum verification failed\n");
+		goto done;
+	}
+
+	have_seeprom = ahd_acquire_seeprom(ahd);
+	if (!have_seeprom) {
+		printf("ahd_proc_write_seeprom: No Serial EEPROM\n");
+		goto done;
+	} else {
+		u_int start_addr;
+
+		if (ahd->seep_config == NULL) {
+			ahd->seep_config = malloc(sizeof(*ahd->seep_config),
+						  M_DEVBUF, M_NOWAIT);
+			if (ahd->seep_config == NULL) {
+				printf("aic79xx: Unable to allocate serial "
+				       "eeprom buffer.  Write failing\n");
+				goto done;
+			}
+		}
+		printf("aic79xx: Writing Serial EEPROM\n");
+		start_addr = 32 * (ahd->channel - 'A');
+		ahd_write_seeprom(ahd, (u_int16_t *)buffer, start_addr,
+				  sizeof(struct seeprom_config)/2);
+		ahd_read_seeprom(ahd, (uint16_t *)ahd->seep_config,
+				 start_addr, sizeof(struct seeprom_config)/2);
+		ahd_release_seeprom(ahd);
+		written = length;
+	}
+
+done:
+	ahd_restore_modes(ahd, saved_modes);
+	if (!paused)
+		ahd_unpause(ahd);
+	ahd_unlock(ahd, &s);
+	return (written);
+}
+/*
+ * Return information to handle /proc support for the driver.
+ */
+int
+ahd_linux_proc_info(char *buffer, char **start, off_t offset,
+		  int length, int hostno, int inout)
+{
+	struct	ahd_softc *ahd;
+	struct	info_str info;
+	char	ahd_info[256];
+	u_long	l;
+	u_int	max_targ;
+	u_int	i;
+	int	retval;
+
+	retval = -EINVAL;
+	ahd_list_lock(&l);
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		if (ahd->platform_data->host->host_no == hostno)
+			break;
+	}
+
+	if (ahd == NULL)
+		goto done;
+
+	 /* Has data been written to the file? */ 
+	if (inout == TRUE) {
+		retval = ahd_proc_write_seeprom(ahd, buffer, length);
+		goto done;
+	}
+
+	if (start)
+		*start = buffer;
+
+	info.buffer	= buffer;
+	info.length	= length;
+	info.offset	= offset;
+	info.pos	= 0;
+
+	copy_info(&info, "Adaptec AIC79xx driver version: %s\n",
+		  AIC79XX_DRIVER_VERSION);
+	ahd_controller_info(ahd, ahd_info);
+	copy_info(&info, "%s\n\n", ahd_info);
+
+	if (ahd->seep_config == NULL)
+		copy_info(&info, "No Serial EEPROM\n");
+	else {
+		copy_info(&info, "Serial EEPROM:\n");
+		for (i = 0; i < sizeof(*ahd->seep_config)/2; i++) {
+			if (((i % 8) == 0) && (i != 0)) {
+				copy_info(&info, "\n");
+			}
+			copy_info(&info, "0x%.4x ",
+				  ((uint16_t*)ahd->seep_config)[i]);
+		}
+		copy_info(&info, "\n");
+	}
+	copy_info(&info, "\n");
+
+	max_targ = 15;
+	if ((ahd->features & AHD_WIDE) == 0)
+		max_targ = 7;
+
+	for (i = 0; i <= max_targ; i++) {
+
+		ahd_dump_target_state(ahd, &info, ahd->our_id, 'A',
+				      /*target_id*/i, /*target_offset*/i);
+	}
+	retval = info.pos > info.offset ? info.pos - info.offset : 0;
+done:
+	ahd_list_unlock(&l);
+	return (retval);
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.reg linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.reg
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.reg	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.reg	2002-09-11 15:08:12.000000000 -0600
@@ -0,0 +1,3790 @@
+/*
+ * Aic79xx register and scratch ram definitions.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $FreeBSD$
+ */
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#45 $"
+
+/*
+ * This file is processed by the aic7xxx_asm utility for use in assembling
+ * firmware for the aic79xx family of SCSI host adapters as well as to generate
+ * a C header file for use in the kernel portion of the Aic79xx driver.
+ */
+
+/* Register window Modes */
+#define M_DFF0		0
+#define M_DFF1		1
+#define M_CCHAN		2
+#define M_SCSI		3
+#define M_CFG		4
+#define M_DST_SHIFT	4
+
+#define MK_MODE(src, dst) ((src) | ((dst) << M_DST_SHIFT))
+#define SET_MODE(src, dst)						\
+	SET_SRC_MODE	src;						\
+	SET_DST_MODE	dst;						\
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
+		mvi	MK_MODE(src, dst) call set_mode_work_around;	\
+	} else {							\
+		mvi	MODE_PTR, MK_MODE(src, dst);			\
+	}
+
+#define TOGGLE_DFF_MODE							\
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
+		call	toggle_dff_mode_work_around;			\
+	} else {							\
+		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);		\
+	}
+	
+
+/*
+ * Mode Pointer
+ * Controls which of the 5, 512byte, address spaces should be used
+ * as the source and destination of any register accesses in our
+ * register window.
+ */
+register MODE_PTR {
+	address			0x000
+	access_mode	RW
+	field	DST_MODE	0x70
+	field	SRC_MODE	0x07
+	mode_pointer
+}
+
+const SRC_MODE_SHIFT	0
+const DST_MODE_SHIFT	4
+
+/*
+ * Host Interrupt Status
+ */
+register INTSTAT {
+	address			0x001
+	access_mode	RW
+	field	HWERRINT	0x80
+	field	BRKADRINT	0x40
+	field	SWTMINT		0x20
+	field	PCIINT		0x10
+	field	SCSIINT		0x08
+	field	SEQINT		0x04
+	field	CMDCMPLT	0x02
+	field	SPLTINT		0x01
+	mask	INT_PEND 0xFF
+}
+
+/*
+ * Sequencer Interrupt Code
+ */
+register SEQINTCODE {
+	address			0x002
+	access_mode	RW
+	field {
+		BAD_PHASE	1,		/* unknown scsi bus phase */
+		SEND_REJECT,			/* sending a message reject */
+		PROTO_VIOLATION, 		/* Protocol Violation */
+		NO_MATCH,			/* no cmd match for reconnect */
+		IGN_WIDE_RES,			/* Complex IGN Wide Res Msg */
+		PDATA_REINIT,			/*
+						 * Returned to data phase
+						 * that requires data
+						 * transfer pointers to be
+						 * recalculated from the
+						 * transfer residual.
+						 */
+		HOST_MSG_LOOP,			/*
+						 * The bus is ready for the
+						 * host to perform another
+						 * message transaction.  This
+						 * mechanism is used for things
+						 * like sync/wide negotiation
+						 * that require a kernel based
+						 * message state engine.
+						 */
+		BAD_STATUS,			/* Bad status from target */
+		DATA_OVERRUN,			/*
+						 * Target attempted to write
+						 * beyond the bounds of its
+						 * command.
+						 */
+		MKMSG_FAILED,			/*
+						 * Target completed command
+						 * without honoring our ATN
+						 * request to issue a message. 
+						 */
+		MISSED_BUSFREE,			/*
+						 * The sequencer never saw
+						 * the bus go free after
+						 * either a command complete
+						 * or disconnect message.
+						 */
+		DUMP_CARD_STATE,
+		ILLEGAL_PHASE,
+		INVALID_SEQINT,
+		CFG4ISTAT_INTR,
+		STATUS_OVERRUN,
+		CFG4OVERRUN,
+		ENTERING_NONPACK
+	}
+}
+
+/*
+ * Clear Host Interrupt
+ */
+register CLRINT {
+	address			0x003
+	access_mode	WO
+	field	CLRHWERRINT	0x80 /* Rev B or greater */
+	field	CLRBRKADRINT	0x40
+	field	CLRSWTMINT	0x20
+	field	CLRSCSIINT	0x08
+	field	CLRSEQINT	0x04
+	field	CLRCMDINT	0x02
+	field	CLRSPLTINT	0x01
+}
+
+/*
+ * Error Register
+ */
+register ERROR {
+	address			0x004
+	access_mode	RO
+	field	CIOPARERR	0x80
+	field	CIOACCESFAIL	0x40 /* Rev B or greater */
+	field	MPARERR		0x20
+	field	DPARERR		0x10
+	field	SQPARERR	0x08
+	field	ILLOPCODE	0x04
+	field	DSCTMOUT	0x02
+}
+
+/*
+ * Clear Error
+ */
+register CLRERR {
+	address			0x004
+	access_mode 	WO
+	field	CLRCIOPARERR	0x80
+	field	CLRCIOACCESFAIL	0x40 /* Rev B or greater */
+	field	CLRMPARERR	0x20
+	field	CLRDPARERR	0x10
+	field	CLRSQPARERR	0x08
+	field	CLRILLOPCODE	0x04
+	field	CLRDSCTMOUT	0x02
+}
+
+/*
+ * Host Control Register
+ * Overall host control of the device.
+ */
+register HCNTRL {
+	address			0x005
+	access_mode	RW
+	field	SEQ_RESET	0x80 /* Rev B or greater */
+	field	POWRDN		0x40
+	field	SWINT		0x10
+	field	SWTIMER_START_B	0x08 /* Rev B or greater */
+	field	PAUSE		0x04
+	field	INTEN		0x02
+	field	CHIPRST		0x01
+	field	CHIPRSTACK	0x01
+}
+
+/*
+ * Host New SCB Queue Offset
+ */
+register HNSCB_QOFF {
+	address			0x006
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Host Empty SCB Queue Offset
+ */
+register HESCB_QOFF {
+	address			0x008
+	access_mode	RW
+}
+
+/*
+ * Host Mailbox
+ */
+register HS_MAILBOX {
+	address			0x0B
+	access_mode	RW
+	mask	HOST_TQINPOS	0x80	/* Boundary at either 0 or 128 */
+}
+
+/*
+ * Sequencer Interupt Status
+ */
+register SEQINTSTAT {
+	address			0x0C
+	access_mode	RO
+	field	SEQ_SWTMRTO	0x10
+	field	SEQ_SEQINT	0x08
+	field	SEQ_SCSIINT	0x04
+	field	SEQ_PCIINT	0x02
+	field	SEQ_SPLTINT	0x01
+}
+
+/*
+ * Clear SEQ Interrupt
+ */
+register CLRSEQINTSTAT {
+	address			0x0C0
+	access_mode	WO
+	field	CLRSEQ_SWTMRTO	0x10
+	field	CLRSEQ_SEQINT	0x08
+	field	CLRSEQ_SCSIINT	0x04
+	field	CLRSEQ_PCIINT	0x02
+	field	CLRSEQ_SPLTINT	0x01
+}
+
+/*
+ * Software Timer
+ */
+register SWTIMER {
+	address			0x0E0
+	access_mode	RW
+	size		2
+}
+
+/*
+ * SEQ New SCB Queue Offset
+ */
+register SNSCB_QOFF {
+	address			0x010
+	access_mode	RW
+	size		2
+	modes		M_CCHAN
+}
+
+/*
+ * SEQ Empty SCB Queue Offset
+ */
+register SESCB_QOFF {
+	address			0x012
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * SEQ Done SCB Queue Offset
+ */
+register SDSCB_QOFF {
+	address			0x014
+	access_mode	RW
+	modes		M_CCHAN
+	size		2
+}
+
+/*
+ * Queue Offset Control & Status
+ */
+register QOFF_CTLSTA {
+	address			0x016
+	access_mode	RW
+	modes		M_CCHAN
+	field	EMPTY_SCB_AVAIL	0x80
+	field	NEW_SCB_AVAIL	0x40
+	field	SDSCB_ROLLOVR	0x20
+	field	HS_MAILBOX_ACT	0x10
+	field	SCB_QSIZE	0x0F {
+		SCB_QSIZE_4,
+		SCB_QSIZE_8,
+		SCB_QSIZE_16,
+		SCB_QSIZE_32,
+		SCB_QSIZE_64,
+		SCB_QSIZE_128,
+		SCB_QSIZE_256,
+		SCB_QSIZE_512,
+		SCB_QSIZE_1024,
+		SCB_QSIZE_2048,
+		SCB_QSIZE_4096,
+		SCB_QSIZE_8192,
+		SCB_QSIZE_16384
+	}
+}
+
+/*
+ * Interrupt Control
+ */
+register INTCTL {
+	address			0x018
+	access_mode	RW
+	field	SWTMINTMASK	0x80
+	field	SWTMINTEN	0x40
+	field	SWTIMER_START	0x20
+	field	AUTOCLRCMDINT	0x10
+	field	PCIINTEN	0x08
+	field	SCSIINTEN	0x04
+	field	SEQINTEN	0x02
+	field	SPLTINTEN	0x01
+}
+
+/*
+ * Data FIFO Control
+ */
+register DFCNTRL {
+	address			0x019
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	PRELOADEN	0x80
+	field	SCSIEN		0x20
+	field	SCSIENACK	0x20
+	field	HDMAEN		0x08
+	field	HDMAENACK	0x08
+	field	DIRECTION	0x04
+	field	DIRECTIONACK	0x04
+	field	FIFOFLUSH	0x02
+	field	FIFOFLUSHACK	0x02
+	field	DIRECTIONEN	0x01
+}
+
+/*
+ * Device Space Command 0
+ */
+register DSCOMMAND0 {
+	address			0x019
+	access_mode	RW
+	modes		M_CFG
+	field	CACHETHEN	0x80	/* Cache Threshold enable */
+	field	DPARCKEN	0x40	/* Data Parity Check Enable */
+	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
+	field	EXTREQLCK	0x10	/* External Request Lock */
+	field	DISABLE_TWATE	0x02	/* Rev B or greater */
+	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
+}
+
+/*
+ * Data FIFO Status
+ */
+register DFSTATUS {
+	address			0x01A
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	PRELOAD_AVAIL		0x80
+	field	PKT_PRELOAD_AVAIL	0x40
+	field	MREQPEND		0x10
+	field	HDONE			0x08
+	field	DFTHRESH		0x04
+	field	FIFOFULL		0x02
+	field	FIFOEMP			0x01
+}
+
+/*
+ * S/G Cache Pointer
+ */
+register SG_CACHE_PRE {
+	address			0x01B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1
+	field	SG_ADDR_MASK	0xf8
+	field	ODD_SEG		0x04
+	field	LAST_SEG	0x02
+}
+
+register SG_CACHE_SHADOW {
+	address			0x01B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	SG_ADDR_MASK	0xf8
+	field	ODD_SEG		0x04
+	field	LAST_SEG	0x02
+	field	LAST_SEG_DONE	0x01
+}
+
+/*
+ * Arbiter Control
+ */
+register ARBCTL {
+	address			0x01B
+	access_mode	RW
+	modes		M_CFG
+	field	RESET_HARB	0x80
+	field	RETRY_SWEN	0x08
+	field	USE_TIME	0x07
+}
+
+/*
+ * Data Channel Host Address
+ */
+register HADDR {
+	address			0x070
+	access_mode	RW
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Host Overlay DMA Address
+ */
+register HODMAADR {
+	address			0x070
+	access_mode	RW
+	size		8
+	modes		M_SCSI
+}
+
+/*
+ * Data Channel Host Count
+ */
+register HCNT {
+	address			0x078
+	access_mode	RW
+	size		3
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Host Overlay DMA Count
+ */
+register HODMACNT {
+	address			0x078
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Host Overlay DMA Enable
+ */
+register HODMAEN {
+	address			0x07A
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Scatter/Gather Host Address
+ */
+register SGHADDR {
+	address			0x07C
+	access_mode	RW
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * SCB Host Address
+ */
+register SCBHADDR {
+	address			0x07C
+	access_mode	RW
+	size		8
+	modes		M_CCHAN
+}
+
+/*
+ * Scatter/Gather Host Count
+ */
+register SGHCNT {
+	address			0x084
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * SCB Host Count
+ */
+register SCBHCNT {
+	address			0x084
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * Data FIFO Threshold
+ */
+register DFF_THRSH {
+	address			0x088
+	access_mode	RW
+	modes		M_CFG
+	field	WR_DFTHRSH	0x70 {
+		WR_DFTHRSH_MIN,
+		WR_DFTHRSH_25,
+		WR_DFTHRSH_50,
+		WR_DFTHRSH_63,
+		WR_DFTHRSH_75,
+		WR_DFTHRSH_85,
+		WR_DFTHRSH_90,
+		WR_DFTHRSH_MAX
+	}
+	field	RD_DFTHRSH	0x07 {
+		RD_DFTHRSH_MIN,
+		RD_DFTHRSH_25,
+		RD_DFTHRSH_50,
+		RD_DFTHRSH_63,
+		RD_DFTHRSH_75,
+		RD_DFTHRSH_85,
+		RD_DFTHRSH_90,
+		RD_DFTHRSH_MAX
+	}
+}
+
+/*
+ * ROM Address
+ */
+register ROMADDR {
+	address			0x08A
+	access_mode	RW
+	size		3
+}
+
+/*
+ * ROM Control
+ */
+register ROMCNTRL {
+	address			0x08D
+	access_mode	RW
+	field	ROMOP		0xE0
+	field	ROMSPD		0x18
+	field	REPEAT		0x02
+	field	RDY		0x01
+}
+
+/*
+ * ROM Data
+ */
+register ROMDATA {
+	address			0x08E
+	access_mode	RW
+}
+
+/*
+ * Data Channel Receive Message 0
+ */
+register DCHRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * CMC Recieve Message 0
+ */
+register CMCRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_CCHAN
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * Overlay Recieve Message 0
+ */
+register OVLYRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_SCSI
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * Relaxed Order Enable
+ */
+register ROENABLE {
+	address			0x090
+	access_mode	RW
+	modes		M_CFG
+	field	MSIROEN		0x20
+	field	OVLYROEN	0x10
+	field	CMCROEN		0x08
+	field	SGROEN		0x04
+	field	DCH1ROEN	0x02
+	field	DCH0ROEN	0x01
+}
+
+/*
+ * Data Channel Receive Message 1
+ */
+register DCHRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CBNUM		0xFF
+}
+
+/*
+ * CMC Recieve Message 1
+ */
+register CMCRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_CCHAN
+	field	CBNUM		0xFF
+}
+
+/*
+ * Overlay Recieve Message 1
+ */
+register OVLYRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_SCSI
+	field	CBNUM		0xFF
+}
+
+/*
+ * No Snoop Enable
+ */
+register NSENABLE {
+	address			0x091
+	access_mode	RW
+	modes		M_CFG
+	field	MSINSEN		0x20
+	field	OVLYNSEN	0x10
+	field	CMCNSEN		0x08
+	field	SGNSEN		0x04
+	field	DCH1NSEN	0x02
+	field	DCH0NSEN	0x01
+}
+
+/*
+ * Data Channel Receive Message 2
+ */
+register DCHRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MINDEX		0xFF
+}
+
+/*
+ * CMC Recieve Message 2
+ */
+register CMCRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_CCHAN
+	field	MINDEX		0xFF
+}
+
+/*
+ * Overlay Recieve Message 2
+ */
+register OVLYRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_SCSI
+	field	MINDEX		0xFF
+}
+
+/*
+ * Outstanding Split Transactions
+ */
+register OST {
+	address			0x092
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Data Channel Receive Message 3
+ */
+register DCHRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MCLASS		0x0F
+}
+
+/*
+ * CMC Recieve Message 3
+ */
+register CMCRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_CCHAN
+	field	MCLASS		0x0F
+}
+
+/*
+ * Overlay Recieve Message 3
+ */
+register OVLYRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_SCSI
+	field	MCLASS		0x0F
+}
+
+/*
+ * PCI-X Control
+ */
+register PCIXCTL {
+	address			0x093
+	access_mode	RW
+	modes		M_CFG
+	field	SERRPULSE	0x80
+	field	UNEXPSCIEN	0x20
+	field	SPLTSMADIS	0x10
+	field	SPLTSTADIS	0x08
+	field	SRSPDPEEN	0x04
+	field	TSCSERREN	0x02
+	field	CMPABCDIS	0x01
+}
+
+/*
+ * CMC Sequencer Byte Count
+ */
+register CMCSEQBCNT {
+	address			0x094
+	access_mode	RO
+	modes		M_CCHAN
+}
+
+/*
+ * Overlay Sequencer Byte Count
+ */
+register OVLYSEQBCNT {
+	address			0x094
+	access_mode	RO
+	modes		M_SCSI
+}
+
+/*
+ * Data Channel Sequencer Byte Count
+ */
+register DCHSEQBCNT {
+	address			0x094
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data Channel Split Status 0
+ */
+register DCHSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * CMC Split Status 0
+ */
+register CMCSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_CCHAN
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * Overlay Split Status 0
+ */
+register OVLYSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_SCSI
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * Data Channel Split Status 1
+ */
+register DCHSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * CMC Split Status 1
+ */
+register CMCSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_CCHAN
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * Overlay Split Status 1
+ */
+register OVLYSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_SCSI
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * S/G Receive Message 0
+ */
+register SGRXMSG0 {
+	address			0x098
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * S/G Receive Message 1
+ */
+register SGRXMSG1 {
+	address			0x099
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CBNUM		0xFF
+}
+
+/*
+ * S/G Receive Message 2
+ */
+register SGRXMSG2 {
+	address			0x09A
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MINDEX		0xFF
+}
+
+/*
+ * S/G Receive Message 3
+ */
+register SGRXMSG3 {
+	address			0x09B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MCLASS		0x0F
+}
+
+/*
+ * Slave Split Out Address 0
+ */
+register SLVSPLTOUTADR0 {
+	address			0x098
+	access_mode	RO
+	modes		M_SCSI
+	field	LOWER_ADDR	0x7F
+}
+
+/*
+ * Slave Split Out Address 1
+ */
+register SLVSPLTOUTADR1 {
+	address			0x099
+	access_mode	RO
+	modes		M_SCSI
+	field	REQ_DNUM	0xF8
+	field	REQ_FNUM	0x07
+}
+
+/*
+ * Slave Split Out Address 2
+ */
+register SLVSPLTOUTADR2 {
+	address			0x09A
+	access_mode	RO
+	modes		M_SCSI
+	field	REQ_BNUM	0xFF
+}
+
+/*
+ * Slave Split Out Address 3
+ */
+register SLVSPLTOUTADR3 {
+	address			0x09B
+	access_mode	RO
+	modes		M_SCSI
+	field	RLXORD		020
+	field	TAG_NUM		0x1F
+}
+
+/*
+ * SG Sequencer Byte Count
+ */
+register SGSEQBCNT {
+	address			0x09C
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Slave Split Out Attribute 0
+ */
+register SLVSPLTOUTATTR0 {
+	address			0x09C
+	access_mode	RO
+	modes		M_SCSI
+	field	LOWER_BCNT	0xFF
+}
+
+/*
+ * Slave Split Out Attribute 1
+ */
+register SLVSPLTOUTATTR1 {
+	address			0x09D
+	access_mode	RO
+	modes		M_SCSI
+	field	CMPLT_DNUM	0xF8
+	field	CMPLT_FNUM	0x07
+}
+
+/*
+ * Slave Split Out Attribute 2
+ */
+register SLVSPLTOUTATTR2 {
+	address			0x09E
+	access_mode	RO
+	size		2
+	modes		M_SCSI
+	field	CMPLT_BNUM	0xFF
+}
+/*
+ * S/G Split Status 0
+ */
+register SGSPLTSTAT0 {
+	address			0x09E
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * S/G Split Status 1
+ */
+register SGSPLTSTAT1 {
+	address			0x09F
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * Special Function
+ */
+register SFUNCT {
+	address			0x09f
+	access_mode	RW
+	modes		M_CFG
+	field	TEST_GROUP	0xF0
+	field	TEST_NUM	0x0F
+}
+
+/*
+ * Data FIFO 0 PCI Status 
+ */
+register DF0PCISTAT {
+	address			0x0A0
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * Data FIFO 1 PCI Status 
+ */
+register DF1PCISTAT {
+	address			0x0A1
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * S/G PCI Status 
+ */
+register SGPCISTAT {
+	address			0x0A2
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	DPR		0x01
+}
+
+/*
+ * CMC PCI Status 
+ */
+register CMCPCISTAT {
+	address			0x0A3
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * Overlay PCI Status 
+ */
+register OVLYPCISTAT {
+	address			0x0A4
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	DPR		0x01
+}
+
+/*
+ * PCI Status for MSI Master DMA Transfer
+ */
+register MSIPCISTAT {
+	address			0x0A6
+	access_mode	RW
+	modes		M_CFG
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	CLRPENDMSI	0x08
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * PCI Status for Target
+ */
+register TARGPCISTAT {
+	address			0x0A6
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	STA		0x08
+	field	TWATERR		0x02
+}
+
+/*
+ * LQ Packet In
+ * The last LQ Packet recieved
+ */
+register LQIN {
+	address			0x020
+	access_mode	RW
+	size		20
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * SCB Type Pointer
+ * SCB offset for Target Mode SCB type information
+ */
+register TYPEPTR {
+	address			0x020
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Queue Tag Pointer
+ * SCB offset to the Two Byte tag identifier used for target mode.
+ */
+register TAGPTR {
+	address			0x021
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Logical Unit Number Pointer
+ * SCB offset to the LSB (little endian) of the lun field.
+ */
+register LUNPTR {
+	address			0x022
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Data Length Pointer
+ * SCB offset for the 4 byte data length field in target mode.
+ */
+register DATALENPTR {
+	address			0x023
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Status Length Pointer
+ * SCB offset to the two byte status field in target SCBs.
+ */
+register STATLENPTR {
+	address			0x024
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Length Pointer
+ * Scb offset for the CDB length field in initiator SCBs.
+ */
+register CMDLENPTR {
+	address			0x025
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Task Attribute Pointer
+ * Scb offset for the byte field specifying the attribute byte
+ * to be used in command packets.
+ */ 
+register ATTRPTR {
+	address			0x026
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Task Management Flags Pointer
+ * Scb offset for the byte field specifying the attribute flags
+ * byte to be used in command packets.
+ */ 
+register FLAGPTR {
+	address			0x027
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Pointer
+ * Scb offset for the first byte in the CDB for initiator SCBs.
+ */
+register CMDPTR {
+	address			0x028
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Queue Next Pointer
+ * Scb offset for the 2 byte "next scb link".
+ */
+register QNEXTPTR {
+	address			0x029
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * SCSI ID Pointer
+ * Scb offset to the value to place in the SCSIID register
+ * during target mode connections.
+ */
+register IDPTR {
+	address			0x02A
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Aborted Byte Pointer
+ * Offset to the SCB flags field that includes the
+ * "SCB aborted" status bit.
+ */
+register ABRTBYTEPTR {
+	address			0x02B
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Aborted Bit Pointer
+ * Bit offset in the SCB flags field for "SCB aborted" status.
+ */
+register ABRTBITPTR {
+	address			0x02C
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register MAXCMDBYTES {
+	address			0x02D
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register MAXCMD2RCV {
+	address			0x02E
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register SHORTTHRESH {
+	address			0x02F
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Logical Unit Number Length
+ * The length, in bytes, of the SCB lun field.
+ */
+register LUNLEN {
+	address			0x030
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * CDB Limit
+ * The size, in bytes, of the embedded CDB field in initator SCBs.
+ */
+register CDBLIMIT {
+	address			0x031
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Maximum Commands
+ * The maximum number of commands to issue during a
+ * single packetized connection.
+ */
+register MAXCMD {
+	address			0x032
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Maximum Command Counter
+ * The number of commands already sent during this connection
+ */
+register MAXCMDCNT {
+	address			0x033
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * LQ Packet Reserved Bytes
+ * The bytes to be sent in the currently reserved fileds
+ * of all LQ packets.
+ */
+register LQRSVD01 {
+	address			0x034
+	access_mode	RW
+	modes		M_SCSI
+}
+register LQRSVD16 {
+	address			0x035
+	access_mode	RW
+	modes		M_SCSI
+}
+register LQRSVD17 {
+	address			0x036
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Command Reserved 0
+ * The byte to be sent for the reserved byte 0 of
+ * outgoing command packets.
+ */
+register CMDRSVD0 {
+	address			0x037
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * LQ Manager Control 0
+ */
+register LQCTL0 {
+	address			0x038
+	access_mode	RW
+	modes		M_CFG
+	field	LQITARGCLT	0xC0
+	field	LQIINITGCLT	0x30
+	field	LQ0TARGCLT	0x0C
+	field	LQ0INITGCLT	0x03
+}
+
+/*
+ * LQ Manager Control 1
+ */
+register LQCTL1 {
+	address			0x038
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	PCI2PCI		0x04
+	field	SINGLECMD	0x02
+	field	ABORTPENDING	0x01
+}
+
+/*
+ * LQ Manager Control 2
+ */
+register LQCTL2 {
+	address			0x039
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIRETRY	0x80
+	field	LQICONTINUE	0x40
+	field	LQITOIDLE	0x20
+	field	LQIPAUSE	0x10
+	field	LQORETRY	0x08
+	field	LQOCONTINUE	0x04
+	field	LQOTOIDLE	0x02
+	field	LQOPAUSE	0x01
+}
+
+/*
+ * SCSI RAM BIST0
+ */
+register SCSBIST0 {
+	address			0x039
+	access_mode	RW
+	modes		M_CFG
+	field	GSBISTERR	0x40
+	field	GSBISTDONE	0x20
+	field	GSBISTRUN	0x10
+	field	OSBISTERR	0x04
+	field	OSBISTDONE	0x02
+	field	OSBISTRUN	0x01
+}
+
+/*
+ * SCSI Sequence Control0
+ */
+register SCSISEQ0 {
+	address			0x03A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	TEMODEO		0x80
+	field	ENSELO		0x40
+	field	ENARBO		0x20
+	field	FORCEBUSFREE	0x10
+	field	SCSIRSTO	0x01
+}
+
+/*
+ * SCSI RAM BIST 1
+ */
+register SCSBIST1 {
+	address			0x03A
+	access_mode	RW
+	modes		M_CFG
+	field	NTBISTERR	0x04
+	field	NTBISTDONE	0x02
+	field	NTBISTRUN	0x01
+}
+
+/*
+ * SCSI Sequence Control 1
+ */
+register SCSISEQ1 {
+	address			0x03B
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	MANUALCTL	0x40
+	field	ENSELI		0x20
+	field	ENRSELI		0x10
+	field	MANUALP		0x0C
+	field	ENAUTOATNP	0x02
+	field	ALTSTIM		0x01
+}
+
+/*
+ * SCSI Transfer Control 0
+ */
+register SXFRCTL0 {
+	address			0x03C
+	access_mode	RW
+	modes		M_SCSI
+	field	DFON		0x80
+	field	DFPEXP		0x40
+	field	BIOSCANCELEN	0x10
+	field	SPIOEN		0x08
+}
+
+/*
+ * SCSI Transfer Control 1
+ */
+register SXFRCTL1 {
+	address			0x03D
+	access_mode	RW
+	modes		M_SCSI
+	field	BITBUCKET	0x80
+	field	ENSACHK		0x40
+	field	ENSPCHK		0x20
+	field	STIMESEL	0x18
+	field	ENSTIMER	0x04
+	field	ACTNEGEN	0x02
+	field	STPWEN		0x01
+}
+
+/*
+ * SCSI Transfer Control 2
+ */
+register SXFRCTL2 {
+	address			0x03E
+	access_mode	RW
+	modes		M_SCSI
+	field	AUTORSTDIS	0x10
+	field	CMDDMAEN	0x08
+	field	ASU		0x07
+}
+
+/*
+ * SCSI Bus Initiator IDs
+ * Bitmask of observed initiators on the bus.
+ */
+register BUSINITID {
+	address			0x03C
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * Data Length Counters
+ * Packet byte counter.
+ */
+register DLCOUNT {
+	address			0x03C
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	size		3
+}
+
+/*
+ * Data FIFO Status
+ */
+register DFFSTAT {
+	address			0x03F
+	access_mode	RW
+	modes		M_SCSI
+	field	FIFO1FREE	0x20
+	field	FIFO0FREE	0x10
+	field	CURRFIFO	0x01
+}
+
+/*
+ * SCSI Bus Target IDs
+ * Bitmask of observed targets on the bus.
+ */
+register BUSTARGID {
+	address			0x03E
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * SCSI Control Signal Out
+ */
+register SCSISIGO {
+	address			0x040
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CDO		0x80
+	field	IOO		0x40
+	field	MSGO		0x20
+	field	ATNO		0x10
+	field	SELO		0x08
+	field	BSYO		0x04
+	field	REQO		0x02
+	field	ACKO		0x01
+/*
+ * Possible phases to write into SCSISIG0
+ */
+	enum	PHASE_MASK  CDO|IOO|MSGO {
+		P_DATAOUT	0x0,
+		P_DATAIN	IOO,
+		P_DATAOUT_DT	P_DATAOUT|MSGO,
+		P_DATAIN_DT	P_DATAIN|MSGO,
+		P_COMMAND	CDO,
+		P_MESGOUT	CDO|MSGO,
+		P_STATUS	CDO|IOO,
+		P_MESGIN	CDO|IOO|MSGO
+	}
+}
+
+register SCSISIGI {
+	address			0x041
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CDI		0x80
+	field	IOI		0x40
+	field	MSGI		0x20
+	field	ATNI		0x10
+	field	SELI		0x08
+	field	BSYI		0x04
+	field	REQI		0x02
+	field	ACKI		0x01
+/*
+ * Possible phases in SCSISIGI
+ */
+	enum	PHASE_MASK  CDO|IOO|MSGO {
+		P_DATAOUT	0x0,
+		P_DATAIN	IOO,
+		P_DATAOUT_DT	P_DATAOUT|MSGO,
+		P_DATAIN_DT	P_DATAIN|MSGO,
+		P_COMMAND	CDO,
+		P_MESGOUT	CDO|MSGO,
+		P_STATUS	CDO|IOO,
+		P_MESGIN	CDO|IOO|MSGO
+	}
+}
+
+/*
+ * Multiple Target IDs
+ * Bitmask of ids to respond as a target.
+ */
+register MULTARGID {
+	address			0x040
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * SCSI Phase
+ */
+register SCSIPHASE {
+	address			0x042
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	STATUS_PHASE	0x20
+	field	COMMAND_PHASE	0x10
+	field	MSG_IN_PHASE	0x08
+	field	MSG_OUT_PHASE	0x04
+	field	DATA_PHASE_MASK	0x03 {
+		DATA_OUT_PHASE	0x01,
+		DATA_IN_PHASE	0x02
+	}
+}
+
+/*
+ * SCSI Data 0 Image
+ */
+register SCSIDAT0_IMG {
+	address			0x043
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * SCSI Latched Data
+ */
+register SCSIDAT {
+	address			0x044
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	size		2
+}
+
+/*
+ * SCSI Data Bus
+ */
+register SCSIBUS {
+	address			0x046
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	size		2
+}
+
+/*
+ * Target ID In
+ */
+register TARGIDIN {
+	address			0x048
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLKOUT		0x80
+	field	TARGID		0x0F
+}
+
+/*
+ * Selection/Reselection ID
+ * Upper four bits are the device id.  The ONEBIT is set when the re/selecting
+ * device did not set its own ID.
+ */
+register SELID {
+	address			0x049
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	SELID_MASK	0xf0
+	field	ONEBIT		0x08
+}
+
+/*
+ * SCSI Block Control
+ * Controls Bus type and channel selection.  SELWIDE allows for the
+ * coexistence of 8bit and 16bit devices on a wide bus.
+ */
+register SBLKCTL {
+	address			0x04A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	DIAGLEDEN	0x80
+	field	DIAGLEDON	0x40
+	field	ENAB40		0x08	/* LVD transceiver active */
+	field	ENAB20		0x04	/* SE/HVD transceiver active */
+	field	SELWIDE		0x02
+}
+
+/*
+ * Option Mode
+ */
+register OPTIONMODE {
+	address			0x04A
+	access_mode	RW
+	modes		M_CFG
+	field	BIOSCANCTL		0x80
+	field	AUTOACKEN		0x40
+	field	BIASCANCTL		0x20
+	field	BUSFREEREV		0x10
+	field	ENDGFORMCHK		0x04
+	field	AUTO_MSGOUT_DE		0x02
+	mask	OPTIONMODE_DEFAULTS	AUTO_MSGOUT_DE
+}
+
+/*
+ * SCSI Status 0
+ */
+register SSTAT0	{
+	address			0x04B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	TARGET		0x80	/* Board acting as target */
+	field	SELDO		0x40	/* Selection Done */
+	field	SELDI		0x20	/* Board has been selected */
+	field	SELINGO		0x10	/* Selection In Progress */
+	field	IOERR		0x08	/* LVD Tranceiver mode changed */
+	field	OVERRUN		0x04	/* SCSI Offset overrun detected */
+	field	SPIORDY		0x02	/* SCSI PIO Ready */
+	field	ARBDO		0x01	/* Arbitration Done Out */
+}
+
+/*
+ * Clear SCSI Interrupt 0
+ * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.
+ */
+register CLRSINT0 {
+	address			0x04B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRSELDO	0x40
+	field	CLRSELDI	0x20
+	field	CLRSELINGO	0x10
+	field	CLRIOERR	0x08
+	field	CLROVERRUN	0x04
+	field	CLRSPIORDY	0x02
+	field	CLRARBDO	0x01
+}
+
+/*
+ * SCSI Interrupt Mode 0
+ * Setting any bit will enable the corresponding function
+ * in SIMODE0 to interrupt via the IRQ pin.
+ */
+register SIMODE0 {
+	address			0x04B
+	access_mode	RW
+	modes		M_CFG
+	field	ENSELDO		0x40
+	field	ENSELDI		0x20
+	field	ENSELINGO	0x10
+	field	ENIOERR		0x08
+	field	ENOVERRUN	0x04
+	field	ENSPIORDY	0x02
+	field	ENARBDO		0x01
+}
+
+/*
+ * SCSI Status 1
+ */
+register SSTAT1 {
+	address			0x04C
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	SELTO		0x80
+	field	ATNTARG 	0x40
+	field	SCSIRSTI	0x20
+	field	PHASEMIS	0x10
+	field	BUSFREE		0x08
+	field	SCSIPERR	0x04
+	field	STRB2FAST	0x02
+	field	REQINIT		0x01
+}
+
+/*
+ * Clear SCSI Interrupt 1
+ * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.
+ */
+register CLRSINT1 {
+	address			0x04C
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRSELTIMEO	0x80
+	field	CLRATNO		0x40
+	field	CLRSCSIRSTI	0x20
+	field	CLRBUSFREE	0x08
+	field	CLRSCSIPERR	0x04
+	field	CLRSTRB2FAST	0x02
+	field	CLRREQINIT	0x01
+}
+
+/*
+ * SCSI Status 2
+ */
+register SSTAT2 {
+	address			0x04d
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	BUSFREETIME	0xc0 {
+		BUSFREE_LQO	0x40,
+		BUSFREE_DFF0	0x80,
+		BUSFREE_DFF1	0xC0
+	}
+	field	NONPACKREQ	0x20
+	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
+	field	BSYX		0x08	/* Busy Expander */
+	field	WIDE_RES	0x04	/* Modes 0 and 1 only */
+	field	SDONE		0x02	/* Modes 0 and 1 only */
+	field	DMADONE		0x01	/* Modes 0 and 1 only */
+}
+
+/*
+ * Clear SCSI Interrupt 2
+ */
+register CLRSINT2 {
+	address			0x04D
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRNONPACKREQ	0x20
+	field	CLRWIDE_RES	0x04	/* Modes 0 and 1 only */
+	field	CLRSDONE	0x02	/* Modes 0 and 1 only */
+	field	CLRDMADONE	0x01	/* Modes 0 and 1 only */
+}
+
+/*
+ * SCSI Interrupt Mode 2
+ */
+register SIMODE2 {
+	address			0x04D
+	access_mode	RW
+	modes		M_CFG
+	field	ENWIDE_RES	0x04
+	field	ENSDONE		0x02
+	field	ENDMADONE	0x01
+}
+
+/*
+ * Physical Error Diagnosis
+ */
+register PERRDIAG {
+	address			0x04E
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	HIZERO		0x80
+	field	HIPERR		0x40
+	field	PREVPHASE	0x20
+	field	PARITYERR	0x10
+	field	AIPERR		0x08
+	field	CRCERR		0x04
+	field	DGFORMERR	0x02
+	field	DTERR		0x01
+}
+
+/*
+ * LQI Manager Current State
+ */
+register LQISTATE {
+	address			0x04E
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * SCSI Offset Count
+ */
+register SOFFCNT {
+	address			0x04F
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * LQO Manager Current State
+ */
+register LQOSTATE {
+	address			0x04F
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * LQI Manager Status
+ */
+register LQISTAT0 {
+	address			0x050
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIATNQAS	0x20
+	field	LQICRCT1	0x10
+	field	LQICRCT2	0x08
+	field	LQIBADLQT	0x04
+	field	LQIATNLQ	0x02
+	field	LQIATNCMD	0x01
+}
+
+/*
+ * Clear LQI Interrupts 0
+ */
+register CLRLQIINT0 {
+	address			0x050
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQIATNQAS	0x20
+	field	CLRLQICRCT1	0x10
+	field	CLRLQICRCT2	0x08
+	field	CLRLQIBADLQT	0x04
+	field	CLRLQIATNLQ	0x02
+	field	CLRLQIATNCMD	0x01
+}
+
+/*
+ * LQI Manager Interrupt Mode 0
+ */
+register LQIMODE0 {
+	address			0x050
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQIATNQASK	0x20
+	field	ENLQICRCT1	0x10
+	field	ENLQICRCT2	0x08
+	field	ENLQIBADLQT	0x04
+	field	ENLQIATNLQ	0x02
+	field	ENLQIATNCMD	0x01
+}
+
+/*
+ * LQI Manager Status 1
+ */
+register LQISTAT1 {
+	address			0x051
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIPHASE_LQ	0x80
+	field	LQIPHASE_NLQ	0x40
+	field	LQIABORT	0x20
+	field	LQICRCI_LQ	0x10
+	field	LQICRCI_NLQ	0x08
+	field	LQIBADLQI	0x04
+	field	LQIOVERI_LQ	0x02
+	field	LQIOVERI_NLQ	0x01
+}
+
+/*
+ * Clear LQI Manager Interrupts1
+ */
+register CLRLQIINT1 {
+	address			0x051
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQIPHASE_LQ	0x80
+	field	CLRLQIPHASE_NLQ	0x40
+	field	CLRLIQABORT	0x20
+	field	CLRLQICRCI_LQ	0x10
+	field	CLRLQICRCI_NLQ	0x08
+	field	CLRLQIBADLQI	0x04
+	field	CLRLQIOVERI_LQ	0x02
+	field	CLRLQIOVERI_NLQ	0x01
+}
+
+/*
+ * LQI Manager Interrupt Mode 1
+ */
+register LQIMODE1 {
+	address			0x051
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQIPHASE_LQ	0x80
+	field	ENLQIPHASE_NLQ	0x40
+	field	ENLIQABORT	0x20
+	field	ENLQICRCI_LQ	0x10
+	field	ENLQICRCI_NLQ	0x08
+	field	ENLQIBADLQI	0x04
+	field	ENLQIOVERI_LQ	0x02
+	field	ENLQIOVERI_NLQ	0x01
+}
+
+/*
+ * LQI Manager Status 2
+ */
+register LQISTAT2 {
+	address			0x052
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	PACKETIZED	0x80
+	field	LQIPHASE_OUTPKT	0x40
+	field	LQIWORKONLQ	0x20
+	field	LQIWAITFIFO	0x10
+	field	LQISTOPPKT	0x08
+	field	LQISTOPLQ	0x04
+	field	LQISTOPCMD	0x02
+	field	LQIGSAVAIL	0x01
+}
+
+/*
+ * SCSI Status 3
+ */
+register SSTAT3 {
+	address			0x053
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	NTRAMPERR	0x02
+	field	OSRAMPERR	0x01
+}
+
+/*
+ * Clear SCSI Status 3
+ */
+register CLRSINT3 {
+	address			0x053
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRNTRAMPERR	0x02
+	field	CLROSRAMPERR	0x01
+}
+
+/*
+ * SCSI Interrupt Mode 3
+ */
+register SIMODE3 {
+	address			0x053
+	access_mode	RW
+	modes		M_CFG
+	field	ENNTRAMPERR	0x02
+	field	ENOSRAMPERR	0x01
+}
+
+/*
+ * LQO Manager Status 0
+ */
+register LQOSTAT0 {
+	address			0x054
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOTARGSCBPERR	0x10
+	field	LQOSTOPT2	0x08
+	field	LQOATNLQ	0x04
+	field	LQOATNPKT	0x02
+	field	LQOTCRC		0x01
+}
+
+/*
+ * Clear LQO Manager interrupt 0
+ */
+register CLRLQOINT0 {
+	address			0x054
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQOTARGSCBPERR	0x10
+	field	CLRLQOSTOPT2		0x08
+	field	CLRLQOATNLQ		0x04
+	field	CLRLQOATNPKT		0x02
+	field	CLRLQOTCRC		0x01
+}
+
+/*
+ * LQO Manager Interrupt Mode 0
+ */
+register LQOMODE0 {
+	address			0x054
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQOTARGSCBPERR	0x10
+	field	ENLQOSTOPT2		0x08
+	field	ENLQOATNLQ		0x04
+	field	ENLQOATNPKT		0x02
+	field	ENLQOTCRC		0x01
+}
+
+/*
+ * LQO Manager Status 1
+ */
+register LQOSTAT1 {
+	address			0x055
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOINITSCBPERR	0x10
+	field	LQOSTOPI2	0x08
+	field	LQOBADQAS	0x04
+	field	LQOBUSFREE	0x02
+	field	LQOPHACHGINPKT	0x01
+}
+
+/*
+ * Clear LOQ Interrupt 1
+ */
+register CLRLQOINT1 {
+	address			0x055
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQOINITSCBPERR	0x10
+	field	CLRLQOSTOPI2		0x08
+	field	CLRLQOBADQAS		0x04
+	field	CLRLQOBUSFREE		0x02
+	field	CLRLQOPHACHGINPKT	0x01
+}
+
+/*
+ * LQO Manager Interrupt Mode 1
+ */
+register LQOMODE1 {
+	address			0x055
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQOINITSCBPERR	0x10
+	field	ENLQOSTOPI2		0x08
+	field	ENLQOBADQAS		0x04
+	field	ENLQOBUSFREE		0x02
+	field	ENLQOPHACHGINPKT	0x01
+}
+
+/*
+ * LQO Manager Status 2
+ */
+register LQOSTAT2 {
+	address			0x056
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOPKT		0xE0
+	field	LQOWAITFIFO	0x10
+	field	LQOPHACHGOUTPKT	0x02	/* outside of packet boundaries. */
+	field	LQOSTOP0	0x01	/* Stopped after sending all packets */
+}
+
+/*
+ * Output Synchronizer Space Count
+ */
+register OS_SPACE_CNT {
+	address			0x056
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * SCSI Interrupt Mode 1
+ * Setting any bit will enable the corresponding function
+ * in SIMODE1 to interrupt via the IRQ pin.
+ */
+register SIMODE1 {
+	address			0x057
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	ENSELTIMO	0x80
+	field	ENATNTARG	0x40
+	field	ENSCSIRST	0x20
+	field	ENPHASEMIS	0x10
+	field	ENBUSFREE	0x08
+	field	ENSCSIPERR	0x04
+	field	ENSTRB2FAST	0x02
+	field	ENREQINIT	0x01
+}
+
+/*
+ * Good Status FIFO
+ */
+register GSFIFO {
+	address			0x058
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * Data FIFO SCSI Transfer Control
+ */
+register DFFSXFRCTL {
+	address			0x05A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	CLRSHCNT	0x04
+	field	CLRCHN		0x02
+	field	RSTCHN		0x01
+}
+
+/*
+ * Next SCSI Control Block
+ */
+register NEXTSCB {
+	address			0x05A
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+	
+/*
+ * SEQ Interrupts
+ */
+register SEQINTSRC {
+	address			0x05B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CTXTDONE	0x40
+	field	SAVEPTRS	0x20
+	field	CFG4DATA	0x10
+	field	CFG4ISTAT	0x08
+	field	CFG4TSTAT	0x04
+	field	CFG4ICMD	0x02
+	field	CFG4TCMD	0x01
+}
+
+/*
+ * Clear Arp Interrupts
+ */
+register CLRSEQINTSRC {
+	address			0x05B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1
+	field	CLRCTXTDONE	0x40
+	field	CLRSAVEPTRS	0x20
+	field	CLRCFG4DATA	0x10
+	field	CLRCFG4ISTAT	0x08
+	field	CLRCFG4TSTAT	0x04
+	field	CLRCFG4ICMD	0x02
+	field	CLRCFG4TCMD	0x01
+}
+
+/*
+ * SEQ Interrupt Enabled (Shared)
+ */
+register SEQIMODE {
+	address			0x05C
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	ENCTXTDONE	0x40
+	field	ENSAVEPTRS	0x20
+	field	ENCFG4DATA	0x10
+	field	ENCFG4ISTAT	0x08
+	field	ENCFG4TSTAT	0x04
+	field	ENCFG4ICMD	0x02
+	field	ENCFG4TCMD	0x01
+}
+
+/*
+ * Current SCSI Control Block
+ */
+register CURRSCB {
+	address			0x05C
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Data FIFO Status
+ */
+register MDFFSTAT {
+	address			0x05D
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	SHCNTNEGATIVE	0x40 /* Rev B or higher */
+	field	SHCNTMINUS1	0x20 /* Rev B or higher */
+	field	LASTSDONE	0x10
+	field	SHVALID		0x08
+	field	DLZERO		0x04 /* FIFO data ends on packet boundary. */
+	field	DATAINFIFO	0x02
+	field	FIFOFREE	0x01
+}
+
+/*
+ * CRC Control
+ */
+register CRCCONTROL {
+	address			0x05d
+	access_mode	RW
+	modes		M_CFG
+	field	CRCVALCHKEN		0x40
+}
+
+/*
+ * SCSI Test Control
+ */
+register SCSITEST {
+	address			0x05E
+	access_mode	RW
+	modes		M_CFG
+	field	CNTRTEST	0x08
+	field	SEL_TXPLL_DEBUG	0x04
+}
+
+/*
+ * Data FIFO Queue Tag
+ */
+register DFFTAG {
+	address			0x05E
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Last SCSI Control Block
+ */
+register LASTSCB {
+	address			0x05E
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * SCSI I/O Cell Power-down Control
+ */
+register IOPDNCTL {
+	address			0x05F
+	access_mode	RW
+	modes		M_CFG
+	field	DISABLE_OE	0x80
+	field	PDN_IDIST	0x04
+	field	PDN_DIFFSENSE	0x01
+}
+
+/*
+ * Shaddow Host Address.
+ */
+register SHADDR {
+	address			0x060
+	access_mode	RO
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data Group CRC Interval.
+ */
+register DGRPCRCI {
+	address			0x060
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Data Transfer Negotiation Address
+ */
+register NEGOADDR {
+	address			0x060
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data Transfer Negotiation Data - Period Byte
+ */
+register NEGPERIOD {
+	address			0x061
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Packetized CRC Interval
+ */
+register PACKCRCI {
+	address			0x062
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Data Transfer Negotiation Data - Offset Byte
+ */
+register NEGOFFSET {
+	address			0x062
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data Transfer Negotiation Data - PPR Options
+ */
+register NEGPPROPTS {
+	address			0x063
+	access_mode	RW
+	modes		M_SCSI
+	field	PPROPT_PACE	0x08
+	field	PPROPT_QAS	0x04
+	field	PPROPT_DT	0x02
+	field	PPROPT_IUT	0x01
+}
+
+/*
+ * Data Transfer Negotiation Data -  Connection Options
+ */
+register NEGCONOPTS {
+	address			0x064
+	access_mode	RW
+	modes		M_SCSI
+	field	ENAIP		0x08
+	field	ENAUTOATNI	0x04
+	field	ENAUTOATNO	0x02
+	field	WIDEXFER	0x01
+}
+
+/*
+ * Negotiation Table Annex Column Index.
+ */
+register ANNEXCOL {
+	address			0x065
+	access_mode	RW
+	modes		M_SCSI
+}
+
+register SCSCHKN {
+	address			0x066
+	access_mode	RW
+	modes		M_CFG
+	field	STSELSKIDDIS	0x40
+	field	CURFIFODEF	0x20
+	field	WIDERESEN	0x10
+	field	SDONEMSKDIS	0x08
+	field	DFFACTCLR	0x04
+	field	SHVALIDSTDIS	0x02
+	field	LSTSGCLRDIS	0x01
+}
+
+const AHD_ANNEXCOL_PRECOMP	4
+const	AHD_PRECOMP_MASK	0x07
+const	AHD_PRECOMP_CUTBACK_17	0x04
+const	AHD_PRECOMP_CUTBACK_29	0x06
+const	AHD_PRECOMP_CUTBACK_37	0x07
+const	AHD_PRECOMP_FASTSLEW	0x40
+const AHD_NUM_ANNEXCOLS		4
+
+/*
+ * Negotiation Table Annex Data Port.
+ */
+register ANNEXDAT {
+	address			0x066
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Initiator's Own Id.
+ * The SCSI ID to use for Selection Out and seen during a reselection..
+ */
+register IOWNID {
+	address			0x067
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960MHz Phase-Locked Loop Control 0
+ */
+register PLL960CTL0 {
+	address			0x068
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_VCOSEL	0x80
+	field	PLL_PWDN	0x40
+	field	PLL_NS		0x30
+	field	PLL_ENLUD	0x08
+	field	PLL_ENLPF	0x04
+	field	PLL_DLPF	0x02
+	field	PLL_ENFBM	0x01
+}
+
+/*
+ * Target Own Id
+ */
+register TOWNID {
+	address			0x069
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960MHz Phase-Locked Loop Control 1
+ */
+register PLL960CTL1 {
+	address			0x069
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_CNTEN	0x80
+	field	PLL_CNTCLR	0x40
+	field	PLL_RST		0x01
+}
+
+/*
+ * Expander Signature
+ */
+register XSIG {
+	address			0x06A
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Shadow Byte Count
+ */
+register SHCNT {
+	address			0x068
+	access_mode	RW
+	size		3
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Selection Out ID
+ */
+register SELOID {
+	address			0x06B
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960-MHz Phase-Locked Loop Test Count
+ */
+register PLL960CNT0 {
+	address			0x06A
+	access_mode	RO
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Control 0
+ */
+register PLL400CTL0 {
+	address			0x06C
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_VCOSEL	0x80
+	field	PLL_PWDN	0x40
+	field	PLL_NS		0x30
+	field	PLL_ENLUD	0x08
+	field	PLL_ENLPF	0x04
+	field	PLL_DLPF	0x02
+	field	PLL_ENFBM	0x01
+}
+
+/*
+ * Arbitration Fairness
+ */
+register FAIRNESS {
+	address			0x06C
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Control 1
+ */
+register PLL400CTL1 {
+	address			0x06D
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_CNTEN	0x80
+	field	PLL_CNTCLR	0x40
+	field	PLL_RST		0x01
+}
+
+/*
+ * Arbitration Unfairness
+ */
+register UNFAIRNESS {
+	address			0x06E
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Test Count
+ */
+register PLL400CNT0 {
+	address			0x06E
+	access_mode	RO
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * SCB Page Pointer
+ */
+register SCBPTR {
+	address			0x0A8
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1, M_CCHAN, M_SCSI
+}
+
+/*
+ * CMC SCB Array Count
+ * Number of bytes to transfer between CMC SCB memory and SCBRAM.
+ * Transfers must be 8byte aligned and sized.
+ */
+register CCSCBACNT {
+	address			0x0AB
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * SCB Autopointer
+ * SCB-Next Address Snooping logic.  When an SCB is transferred to
+ * the card, the next SCB address to be used by the CMC array can
+ * be autoloaded from that transfer.
+ */
+register SCBAUTOPTR {
+	address			0x0AB
+	access_mode	RW
+	modes		M_CFG
+	field	AUSCBPTR_EN	0x80
+	field	SCBPTR_ADDR	0x38
+	field	SCBPTR_OFF	0x07
+}
+
+/*
+ * CMC SG Ram Address Pointer
+ */
+register CCSGADDR {
+	address			0x0AC
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * CMC SCB RAM Address Pointer
+ */
+register CCSCBADDR {
+	address			0x0AC
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * CMC SCB Ram Back-up Address Pointer
+ * Indicates the true stop location of transfers halted prior
+ * to SCBHCNT going to 0.
+ */
+register CCSCBADR_BK {
+	address			0x0AC
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * CMC SG Control
+ */
+register CCSGCTL {
+	address			0x0AD
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	CCSGDONE	0x80
+	field	SG_CACHE_AVAIL	0x10
+	field	CCSGEN		0x08
+	field	SG_FETCH_REQ	0x02
+	field	CCSGRESET	0x01
+}
+
+/*
+ * CMD SCB Control
+ */
+register CCSCBCTL {
+	address			0x0AD
+	access_mode	RW
+	modes		M_CCHAN
+	field	CCSCBDONE	0x80
+	field	ARRDONE		0x40
+	field	CCARREN		0x10
+	field	CCSCBEN		0x08
+	field	CCSCBDIR	0x04
+	field	CCSCBRESET	0x01
+}
+
+/*
+ * CMC Ram BIST
+ */
+register CMC_RAMBIST {
+	address			0x0AD
+	access_mode	RW
+	modes		M_CFG
+	field	SG_ELEMENT_SIZE		0x80
+	field	SCBRAMBIST_FAIL		0x40
+	field	SG_BIST_FAIL		0x20
+	field	SG_BIST_EN		0x10
+	field	CMC_BUFFER_BIST_FAIL	0x02
+	field	CMC_BUFFER_BIST_EN	0x01
+}
+
+/*
+ * CMC SG RAM Data Port
+ */
+register CCSGRAM {
+	address			0x0B0
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * CMC SCB RAM Data Port
+ */
+register CCSCBRAM {
+	address			0x0B0
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * Flex DMA Address.
+ */
+register FLEXADR {
+	address			0x0B0
+	access_mode	RW
+	size		3
+	modes		M_SCSI
+}
+
+/*
+ * Flex DMA Byte Count
+ */
+register FLEXCNT {
+	address			0x0B3
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Flex DMA Status
+ */
+register FLEXDMASTAT {
+	address			0x0B5
+	access_mode	RW
+	modes		M_SCSI
+	field	FLEXDMAERR	0x02
+	field	FLEXDMADONE	0x01
+}
+
+/*
+ * Flex DMA Data Port
+ */
+register FLEXDATA {
+	address			0x0B6
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Board Data
+ */
+register BRDDAT {
+	address			0x0B8
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Board Control
+ */
+register BRDCTL {
+	address			0x0B9
+	access_mode	RW
+	modes		M_SCSI
+	field	FLXARBACK	0x80
+	field	FLXARBREQ	0x40
+	field	BRDADDR		0x38
+	field	BRDEN		0x04
+	field	BRDRW		0x02
+	field	BRDSTB		0x01
+}
+
+/*
+ * Serial EEPROM Address
+ */
+register SEEADR {
+	address			0x0BA
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Serial EEPROM Data
+ */
+register SEEDAT {
+	address			0x0BC
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Serial EEPROM Status
+ */
+register SEESTAT {
+	address			0x0BE
+	access_mode	RO
+	modes		M_SCSI
+	field	INIT_DONE	0x80
+	field	SEEOPCODE	0x70
+	field	LDALTID_L	0x08
+	field	SEEARBACK	0x04
+	field	SEEBUSY		0x02
+	field	SEESTART	0x01
+}
+
+/*
+ * Serial EEPROM Control
+ */
+register SEECTL {
+	address			0x0BE
+	access_mode	RW
+	modes		M_SCSI
+	field	SEEOPCODE	0x70 {
+		SEEOP_ERASE	0x70,
+		SEEOP_READ	0x60,
+		SEEOP_WRITE	0x50,
+	/*
+	 * The following four commands use special
+	 * addresses for differentiation.
+	 */
+		SEEOP_ERAL	0x40
+	}
+	mask	SEEOP_EWEN	0x40
+	mask	SEEOP_WALL	0x40
+	mask	SEEOP_EWDS	0x40
+	field	SEERST		0x02
+	field	SEESTART	0x01
+}
+
+const SEEOP_ERAL_ADDR	0x80
+const SEEOP_EWEN_ADDR	0xC0
+const SEEOP_WRAL_ADDR	0x40
+const SEEOP_EWDS_ADDR	0x00
+
+/*
+ * SCB Counter
+ */
+register SCBCNT {
+	address			0x0BF
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data FIFO Write Address
+ * Pointer to the next QWD location to be written to the data FIFO.
+ */
+register DFWADDR {
+	address			0x0C0
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP Filter Control
+ */
+register DSPFLTRCTL {
+	address			0x0C0
+	access_mode	RW
+	modes		M_CFG
+	field	FLTRDISABLE	0x20
+	field	EDGESENSE	0x10
+	field	DSPFCNTSEL	0x0F
+}
+
+/*
+ * DSP Data Channel Control
+ */
+register DSPDATACTL {
+	address			0x0C1
+	access_mode	RW
+	modes		M_CFG
+	field	BYPASSENAB	0x80
+	field	DESQDIS		0x10
+	field	RCVROFFSTDIS	0x04
+	field	XMITOFFSTDIS	0x02
+}
+
+/*
+ * Data FIFO Read Address
+ * Pointer to the next QWD location to be read from the data FIFO.
+ */
+register DFRADDR {
+	address			0x0C2
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP REQ Control
+ */
+register DSPREQCTL {
+	address			0x0C2
+	access_mode	RW
+	modes		M_CFG
+	field	MANREQCTL	0xC0
+	field	MANREQDLY	0x3F
+}
+
+/*
+ * DSP ACK Control
+ */
+register DSPACKCTL {
+	address			0x0C3
+	access_mode	RW
+	modes		M_CFG
+	field	MANACKCTL	0xC0
+	field	MANACKDLY	0x3F
+}
+
+/*
+ * Data FIFO Data
+ * Read/Write byte port into the data FIFO.  The read and write
+ * FIFO pointers increment with each read and write respectively
+ * to this port.
+ */
+register DFDAT {
+	address			0x0C4
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP Channel Select
+ */
+register DSPSELECT {
+	address			0x0C4
+	access_mode	RW
+	modes		M_CFG
+	field	AUTOINCEN	0x80
+	field	DSPSEL		0x1F
+}
+
+const NUMDSPS 0x14
+
+/*
+ * Write Bias Control
+ */
+register WRTBIASCTL {
+	address			0x0C5
+	access_mode	WO
+	modes		M_CFG
+	field	AUTOXBCDIS	0x80
+	field	XMITMANVAL	0x3F
+}
+
+const WRTBIASCTL_CPQ_DEFAULT 0x97
+
+/*
+ * Receiver Bias Control
+ */
+register RCVRBIOSCTL {
+	address			0x0C6
+	access_mode	WO
+	modes		M_CFG
+	field	AUTORBCDIS	0x80
+	field	RCVRMANVAL	0x3F
+}
+
+/*
+ * Write Bias Calculator
+ */
+register WRTBIASCALC {
+	address			0x0C7
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Pointers
+ * Contains the byte offset from DFWADDR and DWRADDR to the current
+ * FIFO write/read locations.
+ */
+register DFPTRS {
+	address			0x0C8
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Receiver Bias Calculator
+ */
+register RCVRBIASCALC {
+	address			0x0C8
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Debug Control
+ */
+register DFDBCTL {
+	address				0x0C8
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	DFF_CIO_WR_RDY		0x20
+	field	DFF_CIO_RD_RDY		0x10
+	field	DFF_DIR_ERR		0x08
+	field	DFF_RAMBIST_FAIL	0x04
+	field	DFF_RAMBIST_DONE	0x02
+	field	DFF_RAMBIST_EN		0x01
+}
+
+/*
+ * Data FIFO Backup Read Pointer
+ * Contains the data FIFO address to be restored if the last
+ * data accessed from the data FIFO was not transferred successfully.
+ */
+register DFBKPTR {
+	address			0x0C9
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Skew Calculator
+ */
+register SKEWCALC {
+	address			0x0C9
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Space Count
+ * Number of FIFO locations that are free.
+ */
+register DFSCNT {
+	address			0x0CC
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data FIFO Byte Count
+ * Number of filled FIFO locations.
+ */
+register DFBCNT {
+	address			0x0CE
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Sequencer Program Overlay Address.
+ * Low address must be written prior to high address.
+ */
+register OVLYADDR {
+	address			0x0D4
+	modes		M_SCSI
+	size		2
+	access_mode	RW
+}
+
+/*
+ * Sequencer Control 0
+ * Error detection mode, speed configuration,
+ * single step, breakpoints and program load.
+ */
+register SEQCTL0 {
+	address			0x0D6
+	access_mode RW
+	field	PERRORDIS	0x80
+	field	PAUSEDIS	0x40
+	field	FAILDIS		0x20
+	field	FASTMODE	0x10
+	field	BRKADRINTEN	0x08
+	field	STEP		0x04
+	field	SEQRESET	0x02
+	field	LOADRAM		0x01
+}
+
+/*
+ * Sequencer Control 1
+ * Instruction RAM Diagnostics
+ */
+register SEQCTL1 {
+	address			0x0D7
+	access_mode RW
+	field	OVRLAY_DATA_CHK	0x08
+	field	RAMBIST_DONE	0x04
+	field	RAMBIST_FAIL	0x02
+	field	RAMBIST_EN	0x01
+}
+
+/*
+ * Sequencer Flags
+ * Zero and Carry state of the ALU.
+ */
+register FLAGS {
+	address			0x0D8
+	access_mode RO
+	field	ZERO		0x02
+	field	CARRY		0x01
+}
+
+/*
+ * Sequencer Interrupt Control
+ */ 
+register SEQINTCTL {
+	address			0x0D9
+	access_mode RW
+	field	INTVEC1DSL	0x80
+	field	INT1_CONTEXT	0x20
+	field	SCS_SEQ_INT1M1	0x10
+	field	SCS_SEQ_INT1M0	0x08
+	field	INTMASK		0x06
+	field	IRET		0x01
+}
+
+/*
+ * Sequencer RAM Data Port
+ * Single byte window into the Sequencer Instruction Ram area starting
+ * at the address specified by OVLYADDR.  To write a full instruction word,
+ * simply write four bytes in succession.  OVLYADDR will increment after the
+ * most significant instrution byte (the byte with the parity bit) is written.
+ */
+register SEQRAM {
+	address			0x0DA
+	access_mode RW
+}
+
+/*
+ * Sequencer Program Counter
+ * Low byte must be written prior to high byte.
+ */
+register PRGMCNT {
+	address			0x0DE
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Accumulator
+ */
+register ACCUM {
+	address			0x0E0
+	access_mode RW
+	accumulator
+}
+
+/*
+ * Source Index Register
+ * Incrementing index for reads of SINDIR and the destination (low byte only)
+ * for any immediate operands passed in jmp, jc, jnc, call instructions.
+ * Example:
+ *		mvi	0xFF	call some_routine;
+ *
+ *  Will set SINDEX[0] to 0xFF and call the routine "some_routine.
+ */
+register SINDEX	{
+	address			0x0E2
+	access_mode	RW
+	size		2
+	sindex
+}
+
+/*
+ * Destination Index Register
+ * Incrementing index for writes to DINDIR.  Can be used as a scratch register.
+ */
+register DINDEX {
+	address			0x0E4
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Break Address
+ * Sequencer instruction breakpoint address address.
+ */
+register BRKADDR0 {
+	address			0x0E6
+	access_mode	RW
+}
+
+register BRKADDR1 {
+	address			0x0E6
+	access_mode	RW
+	field	BRKDIS		0x80	/* Disable Breakpoint */
+}
+
+/*
+ * All Ones
+ * All reads to this register return the value 0xFF.
+ */
+register ALLONES {
+	address			0x0E8
+	access_mode RO
+	allones
+}
+
+/*
+ * All Zeros
+ * All reads to this register return the value 0.
+ */
+register ALLZEROS {
+	address			0x0EA
+	access_mode RO
+	allzeros
+}
+
+/*
+ * No Destination
+ * Writes to this register have no effect.
+ */
+register NONE {
+	address			0x0EA
+	access_mode WO
+	none
+}
+
+/*
+ * Source Index Indirect
+ * Reading this register is equivalent to reading (register_base + SINDEX) and
+ * incrementing SINDEX by 1.
+ */
+register SINDIR	{
+	address			0x0EC
+	access_mode RO
+}
+
+/*
+ * Destination Index Indirect
+ * Writing this register is equivalent to writing to (register_base + DINDEX)
+ * and incrementing DINDEX by 1.
+ */
+register DINDIR	 {
+	address			0x0ED
+	access_mode WO
+}
+
+/*
+ * Function One
+ * 2's complement to bit value conversion.  Write the 2's complement value
+ * (0-7 only) to the top nibble and retrieve the bit indexed by that value
+ * on the next read of this register. 
+ * Example:
+ *	Write	0x60
+ *	Read	0x40
+ */
+register FUNCTION1 {
+	address			0x0F0
+	access_mode RW
+}
+
+/*
+ * Stack
+ * Window into the stack.  Each stack location is 10 bits wide reported
+ * low byte followed by high byte.  There are 8 stack locations.
+ */
+register STACK {
+	address			0x0F2
+	access_mode RW
+}
+
+/*
+ * Interrupt Vector 1 Address
+ * Interrupt branch address for SCS SEQ_INT1 mode 0 and 1 interrupts.
+ */
+register INTVEC1_ADDR {
+	address			0x0F4
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Current Address
+ * Address of the SEQRAM instruction currently executing instruction.
+ */
+register CURADDR {
+	address			0x0F4
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Interrupt Vector 2 Address
+ * Interrupt branch address for HST_SEQ_INT2 interrupts.
+ */
+register INTVEC2_ADDR {
+	address			0x0F6
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Last Address
+ * Address of the SEQRAM instruction executed prior to the current instruction.
+ */
+register LASTADDR {
+	address			0x0F6
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+register AHD_PCI_CONFIG_BASE {
+	address			0x100
+	access_mode	RW
+	size		256
+	modes		M_CFG
+}
+
+/* ---------------------- Scratch RAM Offsets ------------------------- */
+scratch_ram {
+	/* Mode Specific */
+	address			0x0A0
+	size	8
+	modes	0, 1, 2, 3
+	REG0 {
+		size		2
+	}
+	REG1 {
+		size		2
+	}
+	REG_ISR {
+		size		2
+	}
+	SG_STATE {
+		size		1
+		field	SEGS_AVAIL	0x01
+		field	LOADING_NEEDED	0x02
+		field	FETCH_INPROG	0x04
+	}
+	/*
+	 * Track whether the transfer byte count for
+	 * the current data phase is odd.
+	 */
+	DATA_COUNT_ODD {
+		size		1
+	}
+}
+
+scratch_ram {
+	/* Mode Specific */
+	address			0x0F8
+	size	8
+	modes	0, 1, 2, 3
+	LONGJMP_ADDR {
+		size		2
+	}
+	LONGJMP_SCB {
+		size		2
+	}
+	ACCUM_SAVE {
+		size		1
+	}
+}
+
+
+scratch_ram {
+	address			0x100
+	size	128
+	modes	0, 1, 2, 3
+	/*
+	 * Per "other-id" execution queues.  We use an array of
+	 * tail pointers into lists of SCBs sorted by "other-id".
+	 * The execution head pointer threads the head SCBs for
+	 * each list.
+	 */
+	WAITING_SCB_TAILS {
+		size		32
+	}
+	WAITING_TID_HEAD {
+		size		2
+	}
+	WAITING_TID_TAIL {
+		size		2
+	}
+	/*
+	 * SCBID of the next SCB in the new SCB queue.
+	 */
+	NEXT_QUEUED_SCB_ADDR {
+		size		4
+	}
+	/*
+	 * head of list of SCBs that have
+	 * completed but have not been
+	 * put into the qoutfifo.
+	 */
+	COMPLETE_SCB_HEAD {
+		size		2
+	}
+	/*
+	 * The list of completed SCBs in
+	 * the active DMA.
+	 */
+	COMPLETE_SCB_DMAINPROG_HEAD {
+		size		2
+	}
+	/*
+	 * head of list of SCBs that have
+	 * completed but need to be uploaded
+	 * to the host prior to being completed.
+	 */
+	COMPLETE_DMA_SCB_HEAD {
+		size		2
+	}
+	/* Counting semaphore to prevent new select-outs */
+	QFREEZE_COUNT {
+		size		2
+	}
+	/*
+	 * Mode to restore on idle_loop exit.
+	 */
+	SAVED_MODE {
+		size		1
+	}
+	/*
+	 * Single byte buffer used to designate the type or message
+	 * to send to a target.
+	 */
+	MSG_OUT {
+		size		1
+	}
+	/* Parameters for DMA Logic */
+	DMAPARAMS {
+		size		1
+		field	PRELOADEN	0x80
+		field	WIDEODD		0x40
+		field	SCSIEN		0x20
+		field	SDMAEN		0x10
+		field	SDMAENACK	0x10
+		field	HDMAEN		0x08
+		field	HDMAENACK	0x08
+		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
+		field	FIFOFLUSH	0x02
+		field	FIFORESET	0x01
+	}
+	SEQ_FLAGS {
+		size		1
+		field	NOT_IDENTIFIED		0x80
+		field	NO_CDB_SENT		0x40
+		field	TARGET_CMD_IS_TAGGED	0x40
+		field	DPHASE			0x20
+		/* Target flags */
+		field	TARG_CMD_PENDING	0x10
+		field	CMDPHASE_PENDING	0x08
+		field	DPHASE_PENDING		0x04
+		field	SPHASE_PENDING		0x02
+		field	NO_DISCONNECT		0x01
+	}
+	/*
+	 * Temporary storage for the
+	 * target/channel/lun of a
+	 * reconnecting target
+	 */
+	SAVED_SCSIID {
+		size		1
+	}
+	SAVED_LUN {
+		size		1
+	}
+	/*
+	 * The last bus phase as seen by the sequencer. 
+	 */
+	LASTPHASE {
+		size		1
+		field	CDI		0x80
+		field	IOI		0x40
+		field	MSGI		0x20
+		field	P_BUSFREE	0x01
+		enum	PHASE_MASK  CDO|IOO|MSGO {
+			P_DATAOUT	0x0,
+			P_DATAIN	IOO,
+			P_DATAOUT_DT	P_DATAOUT|MSGO,
+			P_DATAIN_DT	P_DATAIN|MSGO,
+			P_COMMAND	CDO,
+			P_MESGOUT	CDO|MSGO,
+			P_STATUS	CDO|IOO,
+			P_MESGIN	CDO|IOO|MSGO
+		}
+	}
+	/*
+	 * Base address of our shared data with the kernel driver in host
+	 * memory.  This includes the qoutfifo and target mode
+	 * incoming command queue.
+	 */
+	SHARED_DATA_ADDR {
+		size		4
+	}
+	/*
+	 * Pointer to location in host memory for next
+	 * position in the qoutfifo.
+	 */
+	QOUTFIFO_NEXT_ADDR {
+		size		4
+	}
+	/*
+	 * Value to "or" into the SCBPTR[1] value to
+	 * indicate that an entry in the QINFIFO is valid.
+	 */
+	QOUTFIFO_ENTRY_VALID_TAG {
+		size		1
+	}
+	/*
+	 * Kernel and sequencer offsets into the queue of
+	 * incoming target mode command descriptors.  The
+	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
+	 */
+	KERNEL_TQINPOS {
+		size		1
+	}
+	TQINPOS {                
+		size		1
+	}
+	ARG_1 {
+		size		1
+		mask	SEND_MSG		0x80
+		mask	SEND_SENSE		0x40
+		mask	SEND_REJ		0x20
+		mask	MSGOUT_PHASEMIS		0x10
+		mask	EXIT_MSG_LOOP		0x08
+		mask	CONT_MSG_LOOP_WRITE	0x04
+		mask	CONT_MSG_LOOP_READ	0x03
+		mask	CONT_MSG_LOOP_TARG	0x02
+		alias	RETURN_1
+	}
+	ARG_2 {
+		size		1
+		alias	RETURN_2
+	}
+
+	/*
+	 * Snapshot of MSG_OUT taken after each message is sent.
+	 */
+	LAST_MSG {
+		size		1
+	}
+
+	/*
+	 * Sequences the kernel driver has okayed for us.  This allows
+	 * the driver to do things like prevent initiator or target
+	 * operations.
+	 */
+	SCSISEQ_TEMPLATE {
+		size		1
+		field	MANUALCTL	0x40
+		field	ENSELI		0x20
+		field	ENRSELI		0x10
+		field	MANUALP		0x0C
+		field	ENAUTOATNP	0x02
+		field	ALTSTIM		0x01
+	}
+
+	/*
+	 * The initiator specified tag for this target mode transaction.
+	 */
+	INITIATOR_TAG {
+		size		1
+	}
+
+	SEQ_FLAGS2 {
+		size		1
+		field	TARGET_MSG_PENDING	  0x02
+		field	SELECTOUT_QFROZEN	  0x04
+	}
+
+	ALLOCFIFO_SCBPTR {
+		size		2
+	}
+
+	/*
+	 * Target-mode CDB type to CDB length table used
+	 * in non-packetized operation.
+	 */
+	CMDSIZE_TABLE {
+		size		8
+	}
+}
+
+/************************* Hardware SCB Definition ****************************/
+scb {
+	address			0x180
+	size	64
+	modes	0, 1, 2, 3
+	SCB_RESIDUAL_DATACNT {
+		size	4
+		alias	SCB_CDB_STORE
+	}
+	SCB_RESIDUAL_SGPTR {
+		size	4
+		alias	SCB_CDB_PTR
+		field	SG_ADDR_MASK		0xf8	/* In the last byte */
+		field	SG_OVERRUN_RESID	0x02	/* In the first byte */
+		field	SG_LIST_NULL		0x01	/* In the first byte */
+	}
+	SCB_SCSI_STATUS {
+		size	1
+	}
+	SCB_TARGET_PHASES {
+		size	1
+	}
+	SCB_TARGET_DATA_DIR {
+		size	1
+	}
+	SCB_TARGET_ITAG {
+		size	1
+	}
+	SCB_SENSE_BUSADDR {
+		/*
+		 * Only valid if CDB length is less than 13 bytes or
+		 * we are using a CDB pointer.  Otherwise contains
+		 * the last 4 bytes of embedded cdb information.
+		 */
+		size	4
+		alias	SCB_NEXT_COMPLETE
+	}
+	SCB_TAG {
+		size	2
+	}
+	SCB_CDB_LEN {
+		size	1
+		field	SCB_CDB_LEN_PTR	0x80	/* CDB in host memory */
+	}
+	SCB_TASK_MANAGEMENT {
+		size	1
+	}
+	SCB_NEXT {
+		alias	SCB_NEXT_SCB_BUSADDR
+		size	2
+	}
+	SCB_NEXT2 {
+		size	2
+	}
+	SCB_DATAPTR {
+		size	8
+	}
+	SCB_DATACNT {
+		/*
+		 * The last byte is really the high address bits for
+		 * the data address.
+		 */
+		size	4
+		field	SG_LAST_SEG		0x80	/* In the fourth byte */
+		field	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
+	}
+	SCB_SGPTR {
+		size	4
+		field	SG_STATUS_VALID	0x04	/* In the first byte */
+		field	SG_FULL_RESID	0x02	/* In the first byte */
+		field	SG_LIST_NULL	0x01	/* In the first byte */
+	}
+	SCB_CONTROL {
+		size	1
+		field	TARGET_SCB	0x80
+		field	DISCENB		0x40
+		field	TAG_ENB		0x20
+		field	MK_MESSAGE	0x10
+		field	STATUS_RCVD	0x08
+		field	DISCONNECTED	0x04
+		field	SCB_TAG_TYPE	0x03
+	}
+	SCB_SCSIID {
+		size	1
+		field	TID	0xF0
+		field	OID	0x0F
+	}
+	SCB_LUN {
+		size	1
+		field	LID				0xff
+	}
+	SCB_TASK_ATTRIBUTE {
+		size	1
+	}
+	SCB_BUSADDR {
+		size	4
+	}
+	SCB_SPARE {
+		size	8
+		alias	SCB_PKT_LUN
+	}
+	SCB_DISCONNECTED_LISTS {
+		size	8
+	}
+}
+
+/*********************************** Constants ********************************/
+const SEQ_STACK_SIZE	8
+const MK_MESSAGE_BIT_OFFSET	4
+const TID_SHIFT		4
+const TARGET_CMD_CMPLT	0xfe
+const INVALID_ADDR	0x80
+#define SCB_LIST_NULL	0xff
+#define QOUTFIFO_ENTRY_VALID_TOGGLE	0x80
+
+const CCSGADDR_MAX	0x80
+const CCSCBADDR_MAX	0x80
+const CCSGRAM_MAXSEGS	16
+
+/* Selection Timeout Timer Constants */
+const STIMESEL_SHIFT	3
+const STIMESEL_MIN	0x18
+const STIMESEL_BUG_ADJ	0x8
+
+/* WDTR Message values */
+const BUS_8_BIT			0x00
+const BUS_16_BIT		0x01
+const BUS_32_BIT		0x02
+
+/* Offset maximums */
+const MAX_OFFSET		0xfe
+const MAX_OFFSET_PACED		0x7f
+const HOST_MSG			0xff
+
+/*
+ * The size of our sense buffers.
+ * Sense buffer mapping can be handled in either of two ways.
+ * The first is to allocate a dmamap for each transaction.
+ * Depending on the architecture, dmamaps can be costly. The
+ * alternative is to statically map the buffers in much the same
+ * way we handle our scatter gather lists.  The driver implements
+ * the later.
+ */
+const AHD_SENSE_BUFSIZE		256
+
+/* Target mode command processing constants */
+const CMD_GROUP_CODE_SHIFT	0x05
+
+const STATUS_BUSY		0x08
+const STATUS_QUEUE_FULL		0x28
+const STATUS_PKT_SENSE		0xFF
+const TARGET_DATA_IN		1
+
+const SCB_TRANSFER_SIZE_FULL_LUN	56
+const SCB_TRANSFER_SIZE_1BYTE_LUN	48
+/* PKT_OVERRUN_BUFSIZE must be a multiple of 256 less than 64K */
+const PKT_OVERRUN_BUFSIZE	512
+
+/*
+ * Downloaded (kernel inserted) constants
+ */
+const SG_PREFETCH_CNT download
+const SG_PREFETCH_CNT_LIMIT download
+const SG_PREFETCH_ALIGN_MASK download
+const SG_PREFETCH_ADDR_MASK download
+const SG_SIZEOF download
+const PKT_OVERRUN_BUFOFFSET download
+const SCB_TRANSFER_SIZE	download
+
+/*
+ * BIOS SCB offsets
+ */
+const NVRAM_SCB_OFFSET	0x2C
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_reg.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_reg.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_reg.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_reg.h	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,3668 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#60 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#45 $
+ */
+typedef int (ahd_reg_print_t)(u_int, u_int *, u_int);
+typedef struct ahd_reg_parse_entry {
+	char	*name;
+	uint8_t	 value;
+	uint8_t	 mask;
+} ahd_reg_parse_entry_t;
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_mode_ptr_print;
+#else
+#define ahd_mode_ptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MODE_PTR", 0x00, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intstat_print;
+#else
+#define ahd_intstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTSTAT", 0x01, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintcode_print;
+#else
+#define ahd_seqintcode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTCODE", 0x02, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrint_print;
+#else
+#define ahd_clrint_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRINT", 0x03, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_error_print;
+#else
+#define ahd_error_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ERROR", 0x04, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrerr_print;
+#else
+#define ahd_clrerr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRERR", 0x04, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hcntrl_print;
+#else
+#define ahd_hcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HCNTRL", 0x05, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hnscb_qoff_print;
+#else
+#define ahd_hnscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HNSCB_QOFF", 0x06, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hescb_qoff_print;
+#else
+#define ahd_hescb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HESCB_QOFF", 0x08, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hs_mailbox_print;
+#else
+#define ahd_hs_mailbox_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HS_MAILBOX", 0x0b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintstat_print;
+#else
+#define ahd_seqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_snscb_qoff_print;
+#else
+#define ahd_snscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SNSCB_QOFF", 0x10, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sescb_qoff_print;
+#else
+#define ahd_sescb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SESCB_QOFF", 0x12, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sdscb_qoff_print;
+#else
+#define ahd_sdscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SDSCB_QOFF", 0x14, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoff_ctlsta_print;
+#else
+#define ahd_qoff_ctlsta_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOFF_CTLSTA", 0x16, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intctl_print;
+#else
+#define ahd_intctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTCTL", 0x18, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfcntrl_print;
+#else
+#define ahd_dfcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFCNTRL", 0x19, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dscommand0_print;
+#else
+#define ahd_dscommand0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSCOMMAND0", 0x19, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfstatus_print;
+#else
+#define ahd_dfstatus_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFSTATUS", 0x1a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_cache_shadow_print;
+#else
+#define ahd_sg_cache_shadow_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_CACHE_SHADOW", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arbctl_print;
+#else
+#define ahd_arbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARBCTL", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_cache_pre_print;
+#else
+#define ahd_sg_cache_pre_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_CACHE_PRE", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqin_print;
+#else
+#define ahd_lqin_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIN", 0x20, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_typeptr_print;
+#else
+#define ahd_typeptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TYPEPTR", 0x20, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_tagptr_print;
+#else
+#define ahd_tagptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TAGPTR", 0x21, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lunptr_print;
+#else
+#define ahd_lunptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LUNPTR", 0x22, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_datalenptr_print;
+#else
+#define ahd_datalenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DATALENPTR", 0x23, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_statlenptr_print;
+#else
+#define ahd_statlenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "STATLENPTR", 0x24, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdlenptr_print;
+#else
+#define ahd_cmdlenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDLENPTR", 0x25, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_attrptr_print;
+#else
+#define ahd_attrptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ATTRPTR", 0x26, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flagptr_print;
+#else
+#define ahd_flagptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLAGPTR", 0x27, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdptr_print;
+#else
+#define ahd_cmdptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDPTR", 0x28, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qnextptr_print;
+#else
+#define ahd_qnextptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QNEXTPTR", 0x29, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_idptr_print;
+#else
+#define ahd_idptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IDPTR", 0x2a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_abrtbyteptr_print;
+#else
+#define ahd_abrtbyteptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ABRTBYTEPTR", 0x2b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_abrtbitptr_print;
+#else
+#define ahd_abrtbitptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ABRTBITPTR", 0x2c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmdbytes_print;
+#else
+#define ahd_maxcmdbytes_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMDBYTES", 0x2d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmd2rcv_print;
+#else
+#define ahd_maxcmd2rcv_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMD2RCV", 0x2e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shortthresh_print;
+#else
+#define ahd_shortthresh_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHORTTHRESH", 0x2f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lunlen_print;
+#else
+#define ahd_lunlen_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LUNLEN", 0x30, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cdblimit_print;
+#else
+#define ahd_cdblimit_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CDBLIMIT", 0x31, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmd_print;
+#else
+#define ahd_maxcmd_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMD", 0x32, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmdcnt_print;
+#else
+#define ahd_maxcmdcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMDCNT", 0x33, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd01_print;
+#else
+#define ahd_lqrsvd01_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD01", 0x34, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd16_print;
+#else
+#define ahd_lqrsvd16_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD16", 0x35, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd17_print;
+#else
+#define ahd_lqrsvd17_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD17", 0x36, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdrsvd0_print;
+#else
+#define ahd_cmdrsvd0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDRSVD0", 0x37, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl0_print;
+#else
+#define ahd_lqctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL0", 0x38, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl1_print;
+#else
+#define ahd_lqctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL1", 0x38, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsbist0_print;
+#else
+#define ahd_scsbist0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSBIST0", 0x39, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl2_print;
+#else
+#define ahd_lqctl2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL2", 0x39, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsbist1_print;
+#else
+#define ahd_scsbist1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSBIST1", 0x3a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq0_print;
+#else
+#define ahd_scsiseq0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ0", 0x3a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq1_print;
+#else
+#define ahd_scsiseq1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ1", 0x3b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl0_print;
+#else
+#define ahd_sxfrctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL0", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_businitid_print;
+#else
+#define ahd_businitid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BUSINITID", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dlcount_print;
+#else
+#define ahd_dlcount_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DLCOUNT", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl1_print;
+#else
+#define ahd_sxfrctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL1", 0x3d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_bustargid_print;
+#else
+#define ahd_bustargid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BUSTARGID", 0x3e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl2_print;
+#else
+#define ahd_sxfrctl2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL2", 0x3e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dffstat_print;
+#else
+#define ahd_dffstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFSTAT", 0x3f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsisigo_print;
+#else
+#define ahd_scsisigo_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISIGO", 0x40, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_multargid_print;
+#else
+#define ahd_multargid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MULTARGID", 0x40, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsisigi_print;
+#else
+#define ahd_scsisigi_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISIGI", 0x41, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiphase_print;
+#else
+#define ahd_scsiphase_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIPHASE", 0x42, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsidat0_img_print;
+#else
+#define ahd_scsidat0_img_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIDAT0_IMG", 0x43, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsidat_print;
+#else
+#define ahd_scsidat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIDAT", 0x44, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsibus_print;
+#else
+#define ahd_scsibus_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIBUS", 0x46, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_targidin_print;
+#else
+#define ahd_targidin_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TARGIDIN", 0x48, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_selid_print;
+#else
+#define ahd_selid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SELID", 0x49, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sblkctl_print;
+#else
+#define ahd_sblkctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SBLKCTL", 0x4a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_optionmode_print;
+#else
+#define ahd_optionmode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OPTIONMODE", 0x4a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat0_print;
+#else
+#define ahd_sstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint0_print;
+#else
+#define ahd_clrsint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode0_print;
+#else
+#define ahd_simode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint1_print;
+#else
+#define ahd_clrsint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT1", 0x4c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat1_print;
+#else
+#define ahd_sstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT1", 0x4c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat2_print;
+#else
+#define ahd_sstat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint2_print;
+#else
+#define ahd_clrsint2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode2_print;
+#else
+#define ahd_simode2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_perrdiag_print;
+#else
+#define ahd_perrdiag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PERRDIAG", 0x4e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistate_print;
+#else
+#define ahd_lqistate_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTATE", 0x4e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_soffcnt_print;
+#else
+#define ahd_soffcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SOFFCNT", 0x4f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostate_print;
+#else
+#define ahd_lqostate_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTATE", 0x4f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat0_print;
+#else
+#define ahd_lqistat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqiint0_print;
+#else
+#define ahd_clrlqiint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQIINT0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqimode0_print;
+#else
+#define ahd_lqimode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIMODE0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqimode1_print;
+#else
+#define ahd_lqimode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIMODE1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat1_print;
+#else
+#define ahd_lqistat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqiint1_print;
+#else
+#define ahd_clrlqiint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQIINT1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat2_print;
+#else
+#define ahd_lqistat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT2", 0x52, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat3_print;
+#else
+#define ahd_sstat3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode3_print;
+#else
+#define ahd_simode3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint3_print;
+#else
+#define ahd_clrsint3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode0_print;
+#else
+#define ahd_lqomode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat0_print;
+#else
+#define ahd_lqostat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqoint0_print;
+#else
+#define ahd_clrlqoint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQOINT0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat1_print;
+#else
+#define ahd_lqostat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqoint1_print;
+#else
+#define ahd_clrlqoint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQOINT1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode1_print;
+#else
+#define ahd_lqomode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat2_print;
+#else
+#define ahd_lqostat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT2", 0x56, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_os_space_cnt_print;
+#else
+#define ahd_os_space_cnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OS_SPACE_CNT", 0x56, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode1_print;
+#else
+#define ahd_simode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE1", 0x57, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_gsfifo_print;
+#else
+#define ahd_gsfifo_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "GSFIFO", 0x58, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dffsxfrctl_print;
+#else
+#define ahd_dffsxfrctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFSXFRCTL", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_nextscb_print;
+#else
+#define ahd_nextscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEXTSCB", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrseqintsrc_print;
+#else
+#define ahd_clrseqintsrc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSEQINTSRC", 0x5b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintsrc_print;
+#else
+#define ahd_seqintsrc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTSRC", 0x5b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_currscb_print;
+#else
+#define ahd_currscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CURRSCB", 0x5c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqimode_print;
+#else
+#define ahd_seqimode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQIMODE", 0x5c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_mdffstat_print;
+#else
+#define ahd_mdffstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MDFFSTAT", 0x5d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_crccontrol_print;
+#else
+#define ahd_crccontrol_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CRCCONTROL", 0x5d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfftag_print;
+#else
+#define ahd_dfftag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFTAG", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastscb_print;
+#else
+#define ahd_lastscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTSCB", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsitest_print;
+#else
+#define ahd_scsitest_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSITEST", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_iopdnctl_print;
+#else
+#define ahd_iopdnctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IOPDNCTL", 0x5f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shaddr_print;
+#else
+#define ahd_shaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHADDR", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negoaddr_print;
+#else
+#define ahd_negoaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGOADDR", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dgrpcrci_print;
+#else
+#define ahd_dgrpcrci_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DGRPCRCI", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negperiod_print;
+#else
+#define ahd_negperiod_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGPERIOD", 0x61, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_packcrci_print;
+#else
+#define ahd_packcrci_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PACKCRCI", 0x62, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negoffset_print;
+#else
+#define ahd_negoffset_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGOFFSET", 0x62, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negppropts_print;
+#else
+#define ahd_negppropts_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGPPROPTS", 0x63, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negconopts_print;
+#else
+#define ahd_negconopts_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGCONOPTS", 0x64, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_annexcol_print;
+#else
+#define ahd_annexcol_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ANNEXCOL", 0x65, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scschkn_print;
+#else
+#define ahd_scschkn_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSCHKN", 0x66, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_annexdat_print;
+#else
+#define ahd_annexdat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ANNEXDAT", 0x66, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_iownid_print;
+#else
+#define ahd_iownid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IOWNID", 0x67, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960ctl0_print;
+#else
+#define ahd_pll960ctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CTL0", 0x68, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shcnt_print;
+#else
+#define ahd_shcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHCNT", 0x68, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_townid_print;
+#else
+#define ahd_townid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TOWNID", 0x69, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960ctl1_print;
+#else
+#define ahd_pll960ctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CTL1", 0x69, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960cnt0_print;
+#else
+#define ahd_pll960cnt0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CNT0", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_xsig_print;
+#else
+#define ahd_xsig_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "XSIG", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seloid_print;
+#else
+#define ahd_seloid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SELOID", 0x6b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400ctl0_print;
+#else
+#define ahd_pll400ctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CTL0", 0x6c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_fairness_print;
+#else
+#define ahd_fairness_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FAIRNESS", 0x6c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400ctl1_print;
+#else
+#define ahd_pll400ctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CTL1", 0x6d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400cnt0_print;
+#else
+#define ahd_pll400cnt0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CNT0", 0x6e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_unfairness_print;
+#else
+#define ahd_unfairness_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "UNFAIRNESS", 0x6e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_haddr_print;
+#else
+#define ahd_haddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HADDR", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmaadr_print;
+#else
+#define ahd_hodmaadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMAADR", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmacnt_print;
+#else
+#define ahd_hodmacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMACNT", 0x78, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hcnt_print;
+#else
+#define ahd_hcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HCNT", 0x78, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmaen_print;
+#else
+#define ahd_hodmaen_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMAEN", 0x7a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sghaddr_print;
+#else
+#define ahd_sghaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHADDR", 0x7c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbhaddr_print;
+#else
+#define ahd_scbhaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBHADDR", 0x7c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sghcnt_print;
+#else
+#define ahd_sghcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHCNT", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbhcnt_print;
+#else
+#define ahd_scbhcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBHCNT", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dff_thrsh_print;
+#else
+#define ahd_dff_thrsh_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFF_THRSH", 0x88, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romaddr_print;
+#else
+#define ahd_romaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMADDR", 0x8a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romcntrl_print;
+#else
+#define ahd_romcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMCNTRL", 0x8d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romdata_print;
+#else
+#define ahd_romdata_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMDATA", 0x8e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg0_print;
+#else
+#define ahd_cmcrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_roenable_print;
+#else
+#define ahd_roenable_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROENABLE", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg0_print;
+#else
+#define ahd_ovlyrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg0_print;
+#else
+#define ahd_dchrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg1_print;
+#else
+#define ahd_ovlyrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_nsenable_print;
+#else
+#define ahd_nsenable_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NSENABLE", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg1_print;
+#else
+#define ahd_dchrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg1_print;
+#else
+#define ahd_cmcrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg2_print;
+#else
+#define ahd_dchrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg2_print;
+#else
+#define ahd_ovlyrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg2_print;
+#else
+#define ahd_cmcrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ost_print;
+#else
+#define ahd_ost_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OST", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg3_print;
+#else
+#define ahd_dchrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg3_print;
+#else
+#define ahd_cmcrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pcixctl_print;
+#else
+#define ahd_pcixctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PCIXCTL", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg3_print;
+#else
+#define ahd_ovlyrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyseqbcnt_print;
+#else
+#define ahd_ovlyseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcseqbcnt_print;
+#else
+#define ahd_cmcseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchseqbcnt_print;
+#else
+#define ahd_dchseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcspltstat0_print;
+#else
+#define ahd_cmcspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyspltstat0_print;
+#else
+#define ahd_ovlyspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchspltstat0_print;
+#else
+#define ahd_dchspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchspltstat1_print;
+#else
+#define ahd_dchspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcspltstat1_print;
+#else
+#define ahd_cmcspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyspltstat1_print;
+#else
+#define ahd_ovlyspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg0_print;
+#else
+#define ahd_sgrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG0", 0x98, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr0_print;
+#else
+#define ahd_slvspltoutadr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR0", 0x98, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg1_print;
+#else
+#define ahd_sgrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG1", 0x99, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr1_print;
+#else
+#define ahd_slvspltoutadr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR1", 0x99, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg2_print;
+#else
+#define ahd_sgrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG2", 0x9a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr2_print;
+#else
+#define ahd_slvspltoutadr2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR2", 0x9a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg3_print;
+#else
+#define ahd_sgrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG3", 0x9b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr3_print;
+#else
+#define ahd_slvspltoutadr3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR3", 0x9b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgseqbcnt_print;
+#else
+#define ahd_sgseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSEQBCNT", 0x9c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr0_print;
+#else
+#define ahd_slvspltoutattr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR0", 0x9c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr1_print;
+#else
+#define ahd_slvspltoutattr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR1", 0x9d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr2_print;
+#else
+#define ahd_slvspltoutattr2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR2", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgspltstat0_print;
+#else
+#define ahd_sgspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSPLTSTAT0", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sfunct_print;
+#else
+#define ahd_sfunct_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgspltstat1_print;
+#else
+#define ahd_sgspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSPLTSTAT1", 0x9f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_df0pcistat_print;
+#else
+#define ahd_df0pcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DF0PCISTAT", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg0_print;
+#else
+#define ahd_reg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG0", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_df1pcistat_print;
+#else
+#define ahd_df1pcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DF1PCISTAT", 0xa1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgpcistat_print;
+#else
+#define ahd_sgpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGPCISTAT", 0xa2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg1_print;
+#else
+#define ahd_reg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG1", 0xa2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcpcistat_print;
+#else
+#define ahd_cmcpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCPCISTAT", 0xa3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlypcistat_print;
+#else
+#define ahd_ovlypcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYPCISTAT", 0xa4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg_isr_print;
+#else
+#define ahd_reg_isr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG_ISR", 0xa4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_state_print;
+#else
+#define ahd_sg_state_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_STATE", 0xa6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_msipcistat_print;
+#else
+#define ahd_msipcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MSIPCISTAT", 0xa6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_targpcistat_print;
+#else
+#define ahd_targpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TARGPCISTAT", 0xa6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_data_count_odd_print;
+#else
+#define ahd_data_count_odd_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DATA_COUNT_ODD", 0xa7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbptr_print;
+#else
+#define ahd_scbptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBPTR", 0xa8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbacnt_print;
+#else
+#define ahd_ccscbacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBACNT", 0xab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbautoptr_print;
+#else
+#define ahd_scbautoptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBAUTOPTR", 0xab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgaddr_print;
+#else
+#define ahd_ccsgaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGADDR", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbaddr_print;
+#else
+#define ahd_ccscbaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADDR", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbadr_bk_print;
+#else
+#define ahd_ccscbadr_bk_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADR_BK", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmc_rambist_print;
+#else
+#define ahd_cmc_rambist_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMC_RAMBIST", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgctl_print;
+#else
+#define ahd_ccsgctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGCTL", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbctl_print;
+#else
+#define ahd_ccscbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBCTL", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgram_print;
+#else
+#define ahd_ccsgram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGRAM", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexadr_print;
+#else
+#define ahd_flexadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXADR", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbram_print;
+#else
+#define ahd_ccscbram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBRAM", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexcnt_print;
+#else
+#define ahd_flexcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXCNT", 0xb3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexdmastat_print;
+#else
+#define ahd_flexdmastat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXDMASTAT", 0xb5, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexdata_print;
+#else
+#define ahd_flexdata_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXDATA", 0xb6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brddat_print;
+#else
+#define ahd_brddat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRDDAT", 0xb8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brdctl_print;
+#else
+#define ahd_brdctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRDCTL", 0xb9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seeadr_print;
+#else
+#define ahd_seeadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEEADR", 0xba, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seedat_print;
+#else
+#define ahd_seedat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEEDAT", 0xbc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seectl_print;
+#else
+#define ahd_seectl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEECTL", 0xbe, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seestat_print;
+#else
+#define ahd_seestat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEESTAT", 0xbe, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbcnt_print;
+#else
+#define ahd_scbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBCNT", 0xbf, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfwaddr_print;
+#else
+#define ahd_dfwaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFWADDR", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspfltrctl_print;
+#else
+#define ahd_dspfltrctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPFLTRCTL", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrseqintstat_print;
+#else
+#define ahd_clrseqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSEQINTSTAT", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspdatactl_print;
+#else
+#define ahd_dspdatactl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPDATACTL", 0xc1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfraddr_print;
+#else
+#define ahd_dfraddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFRADDR", 0xc2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspreqctl_print;
+#else
+#define ahd_dspreqctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPREQCTL", 0xc2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspackctl_print;
+#else
+#define ahd_dspackctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPACKCTL", 0xc3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfdat_print;
+#else
+#define ahd_dfdat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFDAT", 0xc4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspselect_print;
+#else
+#define ahd_dspselect_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPSELECT", 0xc4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_wrtbiasctl_print;
+#else
+#define ahd_wrtbiasctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WRTBIASCTL", 0xc5, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_rcvrbiosctl_print;
+#else
+#define ahd_rcvrbiosctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "RCVRBIOSCTL", 0xc6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_wrtbiascalc_print;
+#else
+#define ahd_wrtbiascalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WRTBIASCALC", 0xc7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfptrs_print;
+#else
+#define ahd_dfptrs_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFPTRS", 0xc8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_rcvrbiascalc_print;
+#else
+#define ahd_rcvrbiascalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "RCVRBIASCALC", 0xc8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfdbctl_print;
+#else
+#define ahd_dfdbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFDBCTL", 0xc8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfbkptr_print;
+#else
+#define ahd_dfbkptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFBKPTR", 0xc9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_skewcalc_print;
+#else
+#define ahd_skewcalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SKEWCALC", 0xc9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfscnt_print;
+#else
+#define ahd_dfscnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFSCNT", 0xcc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfbcnt_print;
+#else
+#define ahd_dfbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFBCNT", 0xce, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyaddr_print;
+#else
+#define ahd_ovlyaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYADDR", 0xd4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqctl0_print;
+#else
+#define ahd_seqctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQCTL0", 0xd6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqctl1_print;
+#else
+#define ahd_seqctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQCTL1", 0xd7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flags_print;
+#else
+#define ahd_flags_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLAGS", 0xd8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintctl_print;
+#else
+#define ahd_seqintctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTCTL", 0xd9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqram_print;
+#else
+#define ahd_seqram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQRAM", 0xda, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_prgmcnt_print;
+#else
+#define ahd_prgmcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PRGMCNT", 0xde, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_swtimer_print;
+#else
+#define ahd_swtimer_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SWTIMER", 0xe0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_accum_print;
+#else
+#define ahd_accum_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ACCUM", 0xe0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sindex_print;
+#else
+#define ahd_sindex_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SINDEX", 0xe2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dindex_print;
+#else
+#define ahd_dindex_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DINDEX", 0xe4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brkaddr1_print;
+#else
+#define ahd_brkaddr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR1", 0xe6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brkaddr0_print;
+#else
+#define ahd_brkaddr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR0", 0xe6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allones_print;
+#else
+#define ahd_allones_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLONES", 0xe8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allzeros_print;
+#else
+#define ahd_allzeros_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLZEROS", 0xea, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_none_print;
+#else
+#define ahd_none_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NONE", 0xea, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sindir_print;
+#else
+#define ahd_sindir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SINDIR", 0xec, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dindir_print;
+#else
+#define ahd_dindir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DINDIR", 0xed, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_function1_print;
+#else
+#define ahd_function1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FUNCTION1", 0xf0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_stack_print;
+#else
+#define ahd_stack_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "STACK", 0xf2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_curaddr_print;
+#else
+#define ahd_curaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CURADDR", 0xf4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intvec1_addr_print;
+#else
+#define ahd_intvec1_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTVEC1_ADDR", 0xf4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intvec2_addr_print;
+#else
+#define ahd_intvec2_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTVEC2_ADDR", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastaddr_print;
+#else
+#define ahd_lastaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTADDR", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_longjmp_addr_print;
+#else
+#define ahd_longjmp_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LONGJMP_ADDR", 0xf8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_longjmp_scb_print;
+#else
+#define ahd_longjmp_scb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LONGJMP_SCB", 0xfa, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_accum_save_print;
+#else
+#define ahd_accum_save_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ACCUM_SAVE", 0xfc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_scb_tails_print;
+#else
+#define ahd_waiting_scb_tails_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_SCB_TAILS", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ahd_pci_config_base_print;
+#else
+#define ahd_ahd_pci_config_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sram_base_print;
+#else
+#define ahd_sram_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SRAM_BASE", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_tid_head_print;
+#else
+#define ahd_waiting_tid_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_TID_HEAD", 0x120, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_tid_tail_print;
+#else
+#define ahd_waiting_tid_tail_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_TID_TAIL", 0x122, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_next_queued_scb_addr_print;
+#else
+#define ahd_next_queued_scb_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR", 0x124, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_scb_head_print;
+#else
+#define ahd_complete_scb_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD", 0x128, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_scb_dmainprog_head_print;
+#else
+#define ahd_complete_scb_dmainprog_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD", 0x12a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_dma_scb_head_print;
+#else
+#define ahd_complete_dma_scb_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD", 0x12c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qfreeze_count_print;
+#else
+#define ahd_qfreeze_count_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QFREEZE_COUNT", 0x12e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_mode_print;
+#else
+#define ahd_saved_mode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_MODE", 0x130, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_msg_out_print;
+#else
+#define ahd_msg_out_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MSG_OUT", 0x131, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dmaparams_print;
+#else
+#define ahd_dmaparams_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DMAPARAMS", 0x132, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seq_flags_print;
+#else
+#define ahd_seq_flags_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQ_FLAGS", 0x133, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_scsiid_print;
+#else
+#define ahd_saved_scsiid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_SCSIID", 0x134, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_lun_print;
+#else
+#define ahd_saved_lun_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_LUN", 0x135, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastphase_print;
+#else
+#define ahd_lastphase_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTPHASE", 0x136, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shared_data_addr_print;
+#else
+#define ahd_shared_data_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x137, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoutfifo_next_addr_print;
+#else
+#define ahd_qoutfifo_next_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR", 0x13b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoutfifo_entry_valid_tag_print;
+#else
+#define ahd_qoutfifo_entry_valid_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG", 0x13f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_kernel_tqinpos_print;
+#else
+#define ahd_kernel_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "KERNEL_TQINPOS", 0x140, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_tqinpos_print;
+#else
+#define ahd_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TQINPOS", 0x141, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arg_1_print;
+#else
+#define ahd_arg_1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARG_1", 0x142, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arg_2_print;
+#else
+#define ahd_arg_2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARG_2", 0x143, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_last_msg_print;
+#else
+#define ahd_last_msg_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LAST_MSG", 0x144, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq_template_print;
+#else
+#define ahd_scsiseq_template_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x145, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_initiator_tag_print;
+#else
+#define ahd_initiator_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INITIATOR_TAG", 0x146, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seq_flags2_print;
+#else
+#define ahd_seq_flags2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQ_FLAGS2", 0x147, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allocfifo_scbptr_print;
+#else
+#define ahd_allocfifo_scbptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR", 0x148, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdsize_table_print;
+#else
+#define ahd_cmdsize_table_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDSIZE_TABLE", 0x14a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_base_print;
+#else
+#define ahd_scb_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_BASE", 0x180, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_residual_datacnt_print;
+#else
+#define ahd_scb_residual_datacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT", 0x180, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_residual_sgptr_print;
+#else
+#define ahd_scb_residual_sgptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_RESIDUAL_SGPTR", 0x184, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_scsi_status_print;
+#else
+#define ahd_scb_scsi_status_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SCSI_STATUS", 0x188, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_phases_print;
+#else
+#define ahd_scb_target_phases_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_PHASES", 0x189, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_data_dir_print;
+#else
+#define ahd_scb_target_data_dir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR", 0x18a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_itag_print;
+#else
+#define ahd_scb_target_itag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_ITAG", 0x18b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_sense_busaddr_print;
+#else
+#define ahd_scb_sense_busaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR", 0x18c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_tag_print;
+#else
+#define ahd_scb_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TAG", 0x190, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_cdb_len_print;
+#else
+#define ahd_scb_cdb_len_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_CDB_LEN", 0x192, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_task_management_print;
+#else
+#define ahd_scb_task_management_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT", 0x193, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_next_print;
+#else
+#define ahd_scb_next_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_NEXT", 0x194, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_next2_print;
+#else
+#define ahd_scb_next2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_NEXT2", 0x196, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_dataptr_print;
+#else
+#define ahd_scb_dataptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DATAPTR", 0x198, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_datacnt_print;
+#else
+#define ahd_scb_datacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DATACNT", 0x1a0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_sgptr_print;
+#else
+#define ahd_scb_sgptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SGPTR", 0x1a4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_control_print;
+#else
+#define ahd_scb_control_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_CONTROL", 0x1a8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_scsiid_print;
+#else
+#define ahd_scb_scsiid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SCSIID", 0x1a9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_lun_print;
+#else
+#define ahd_scb_lun_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_LUN", 0x1aa, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_task_attribute_print;
+#else
+#define ahd_scb_task_attribute_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TASK_ATTRIBUTE", 0x1ab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_busaddr_print;
+#else
+#define ahd_scb_busaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_BUSADDR", 0x1ac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_spare_print;
+#else
+#define ahd_scb_spare_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SPARE", 0x1b0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_disconnected_lists_print;
+#else
+#define ahd_scb_disconnected_lists_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS", 0x1b8, regvalue, cur_col, wrap)
+#endif
+
+
+#define	MODE_PTR        		0x00
+#define		DST_MODE        	0x70
+#define		SRC_MODE        	0x07
+
+#define	INTSTAT         		0x01
+#define		INT_PEND        	0xff
+#define		HWERRINT        	0x80
+#define		BRKADRINT       	0x40
+#define		SWTMINT         	0x20
+#define		PCIINT          	0x10
+#define		SCSIINT         	0x08
+#define		SEQINT          	0x04
+#define		CMDCMPLT        	0x02
+#define		SPLTINT         	0x01
+
+#define	SEQINTCODE      		0x02
+#define		ENTERING_NONPACK	0x12
+#define		CFG4OVERRUN     	0x11
+#define		STATUS_OVERRUN  	0x10
+#define		CFG4ISTAT_INTR  	0x0f
+#define		INVALID_SEQINT  	0x0e
+#define		ILLEGAL_PHASE   	0x0d
+#define		DUMP_CARD_STATE 	0x0c
+#define		MISSED_BUSFREE  	0x0b
+#define		MKMSG_FAILED    	0x0a
+#define		DATA_OVERRUN    	0x09
+#define		BAD_STATUS      	0x08
+#define		HOST_MSG_LOOP   	0x07
+#define		PDATA_REINIT    	0x06
+#define		IGN_WIDE_RES    	0x05
+#define		NO_MATCH        	0x04
+#define		PROTO_VIOLATION 	0x03
+#define		SEND_REJECT     	0x02
+#define		BAD_PHASE       	0x01
+
+#define	CLRINT          		0x03
+#define		CLRHWERRINT     	0x80
+#define		CLRBRKADRINT    	0x40
+#define		CLRSWTMINT      	0x20
+#define		CLRSCSIINT      	0x08
+#define		CLRSEQINT       	0x04
+#define		CLRCMDINT       	0x02
+#define		CLRSPLTINT      	0x01
+
+#define	ERROR           		0x04
+#define		CIOPARERR       	0x80
+#define		CIOACCESFAIL    	0x40
+#define		MPARERR         	0x20
+#define		DPARERR         	0x10
+#define		SQPARERR        	0x08
+#define		ILLOPCODE       	0x04
+#define		DSCTMOUT        	0x02
+
+#define	CLRERR          		0x04
+#define		CLRCIOPARERR    	0x80
+#define		CLRCIOACCESFAIL 	0x40
+#define		CLRMPARERR      	0x20
+#define		CLRDPARERR      	0x10
+#define		CLRSQPARERR     	0x08
+#define		CLRILLOPCODE    	0x04
+#define		CLRDSCTMOUT     	0x02
+
+#define	HCNTRL          		0x05
+#define		SEQ_RESET       	0x80
+#define		POWRDN          	0x40
+#define		SWINT           	0x10
+#define		SWTIMER_START_B 	0x08
+#define		PAUSE           	0x04
+#define		INTEN           	0x02
+#define		CHIPRST         	0x01
+#define		CHIPRSTACK      	0x01
+
+#define	HNSCB_QOFF      		0x06
+
+#define	HESCB_QOFF      		0x08
+
+#define	HS_MAILBOX      		0x0b
+#define		HOST_TQINPOS    	0x80
+
+#define	SEQINTSTAT      		0x0c
+#define		SEQ_SWTMRTO     	0x10
+#define		SEQ_SEQINT      	0x08
+#define		SEQ_SCSIINT     	0x04
+#define		SEQ_PCIINT      	0x02
+#define		SEQ_SPLTINT     	0x01
+
+#define	SNSCB_QOFF      		0x10
+
+#define	SESCB_QOFF      		0x12
+
+#define	SDSCB_QOFF      		0x14
+
+#define	QOFF_CTLSTA     		0x16
+#define		EMPTY_SCB_AVAIL 	0x80
+#define		NEW_SCB_AVAIL   	0x40
+#define		SDSCB_ROLLOVR   	0x20
+#define		HS_MAILBOX_ACT  	0x10
+#define		SCB_QSIZE       	0x0f
+#define		SCB_QSIZE_16384 	0x0c
+#define		SCB_QSIZE_8192  	0x0b
+#define		SCB_QSIZE_4096  	0x0a
+#define		SCB_QSIZE_2048  	0x09
+#define		SCB_QSIZE_1024  	0x08
+#define		SCB_QSIZE_512   	0x07
+#define		SCB_QSIZE_256   	0x06
+#define		SCB_QSIZE_128   	0x05
+#define		SCB_QSIZE_64    	0x04
+#define		SCB_QSIZE_32    	0x03
+#define		SCB_QSIZE_16    	0x02
+#define		SCB_QSIZE_8     	0x01
+#define		SCB_QSIZE_4     	0x00
+
+#define	INTCTL          		0x18
+#define		SWTMINTMASK     	0x80
+#define		SWTMINTEN       	0x40
+#define		SWTIMER_START   	0x20
+#define		AUTOCLRCMDINT   	0x10
+#define		PCIINTEN        	0x08
+#define		SCSIINTEN       	0x04
+#define		SEQINTEN        	0x02
+#define		SPLTINTEN       	0x01
+
+#define	DFCNTRL         		0x19
+#define		SCSIENACK       	0x20
+#define		DIRECTIONACK    	0x04
+#define		FIFOFLUSHACK    	0x02
+#define		DIRECTIONEN     	0x01
+
+#define	DSCOMMAND0      		0x19
+#define		CACHETHEN       	0x80
+#define		DPARCKEN        	0x40
+#define		MPARCKEN        	0x20
+#define		EXTREQLCK       	0x10
+#define		DISABLE_TWATE   	0x02
+#define		CIOPARCKEN      	0x01
+
+#define	DFSTATUS        		0x1a
+#define		PRELOAD_AVAIL   	0x80
+#define		PKT_PRELOAD_AVAIL	0x40
+#define		MREQPEND        	0x10
+#define		HDONE           	0x08
+#define		DFTHRESH        	0x04
+#define		FIFOFULL        	0x02
+#define		FIFOEMP         	0x01
+
+#define	SG_CACHE_SHADOW 		0x1b
+#define		ODD_SEG         	0x04
+#define		LAST_SEG        	0x02
+#define		LAST_SEG_DONE   	0x01
+
+#define	ARBCTL          		0x1b
+#define		RESET_HARB      	0x80
+#define		RETRY_SWEN      	0x08
+#define		USE_TIME        	0x07
+
+#define	SG_CACHE_PRE    		0x1b
+
+#define	LQIN            		0x20
+
+#define	TYPEPTR         		0x20
+
+#define	TAGPTR          		0x21
+
+#define	LUNPTR          		0x22
+
+#define	DATALENPTR      		0x23
+
+#define	STATLENPTR      		0x24
+
+#define	CMDLENPTR       		0x25
+
+#define	ATTRPTR         		0x26
+
+#define	FLAGPTR         		0x27
+
+#define	CMDPTR          		0x28
+
+#define	QNEXTPTR        		0x29
+
+#define	IDPTR           		0x2a
+
+#define	ABRTBYTEPTR     		0x2b
+
+#define	ABRTBITPTR      		0x2c
+
+#define	MAXCMDBYTES     		0x2d
+
+#define	MAXCMD2RCV      		0x2e
+
+#define	SHORTTHRESH     		0x2f
+
+#define	LUNLEN          		0x30
+
+#define	CDBLIMIT        		0x31
+
+#define	MAXCMD          		0x32
+
+#define	MAXCMDCNT       		0x33
+
+#define	LQRSVD01        		0x34
+
+#define	LQRSVD16        		0x35
+
+#define	LQRSVD17        		0x36
+
+#define	CMDRSVD0        		0x37
+
+#define	LQCTL0          		0x38
+#define		LQITARGCLT      	0xc0
+#define		LQIINITGCLT     	0x30
+#define		LQ0TARGCLT      	0x0c
+#define		LQ0INITGCLT     	0x03
+
+#define	LQCTL1          		0x38
+#define		PCI2PCI         	0x04
+#define		SINGLECMD       	0x02
+#define		ABORTPENDING    	0x01
+
+#define	SCSBIST0        		0x39
+#define		GSBISTERR       	0x40
+#define		GSBISTDONE      	0x20
+#define		GSBISTRUN       	0x10
+#define		OSBISTERR       	0x04
+#define		OSBISTDONE      	0x02
+#define		OSBISTRUN       	0x01
+
+#define	LQCTL2          		0x39
+#define		LQIRETRY        	0x80
+#define		LQICONTINUE     	0x40
+#define		LQITOIDLE       	0x20
+#define		LQIPAUSE        	0x10
+#define		LQORETRY        	0x08
+#define		LQOCONTINUE     	0x04
+#define		LQOTOIDLE       	0x02
+#define		LQOPAUSE        	0x01
+
+#define	SCSBIST1        		0x3a
+#define		NTBISTERR       	0x04
+#define		NTBISTDONE      	0x02
+#define		NTBISTRUN       	0x01
+
+#define	SCSISEQ0        		0x3a
+#define		TEMODEO         	0x80
+#define		ENSELO          	0x40
+#define		ENARBO          	0x20
+#define		FORCEBUSFREE    	0x10
+#define		SCSIRSTO        	0x01
+
+#define	SCSISEQ1        		0x3b
+
+#define	SXFRCTL0        		0x3c
+#define		DFON            	0x80
+#define		DFPEXP          	0x40
+#define		BIOSCANCELEN    	0x10
+#define		SPIOEN          	0x08
+
+#define	BUSINITID       		0x3c
+
+#define	DLCOUNT         		0x3c
+
+#define	SXFRCTL1        		0x3d
+#define		BITBUCKET       	0x80
+#define		ENSACHK         	0x40
+#define		ENSPCHK         	0x20
+#define		STIMESEL        	0x18
+#define		ENSTIMER        	0x04
+#define		ACTNEGEN        	0x02
+#define		STPWEN          	0x01
+
+#define	BUSTARGID       		0x3e
+
+#define	SXFRCTL2        		0x3e
+#define		AUTORSTDIS      	0x10
+#define		CMDDMAEN        	0x08
+#define		ASU             	0x07
+
+#define	DFFSTAT         		0x3f
+#define		FIFO1FREE       	0x20
+#define		FIFO0FREE       	0x10
+#define		CURRFIFO        	0x01
+
+#define	SCSISIGO        		0x40
+#define		CDO             	0x80
+#define		IOO             	0x40
+#define		MSGO            	0x20
+#define		ATNO            	0x10
+#define		SELO            	0x08
+#define		BSYO            	0x04
+#define		REQO            	0x02
+#define		ACKO            	0x01
+
+#define	MULTARGID       		0x40
+
+#define	SCSISIGI        		0x41
+#define		ATNI            	0x10
+#define		SELI            	0x08
+#define		BSYI            	0x04
+#define		REQI            	0x02
+#define		ACKI            	0x01
+
+#define	SCSIPHASE       		0x42
+#define		STATUS_PHASE    	0x20
+#define		COMMAND_PHASE   	0x10
+#define		MSG_IN_PHASE    	0x08
+#define		MSG_OUT_PHASE   	0x04
+#define		DATA_PHASE_MASK 	0x03
+#define		DATA_IN_PHASE   	0x02
+#define		DATA_OUT_PHASE  	0x01
+
+#define	SCSIDAT0_IMG    		0x43
+
+#define	SCSIDAT         		0x44
+
+#define	SCSIBUS         		0x46
+
+#define	TARGIDIN        		0x48
+#define		CLKOUT          	0x80
+#define		TARGID          	0x0f
+
+#define	SELID           		0x49
+#define		SELID_MASK      	0xf0
+#define		ONEBIT          	0x08
+
+#define	SBLKCTL         		0x4a
+#define		DIAGLEDEN       	0x80
+#define		DIAGLEDON       	0x40
+#define		ENAB40          	0x08
+#define		ENAB20          	0x04
+#define		SELWIDE         	0x02
+
+#define	OPTIONMODE      		0x4a
+#define		OPTIONMODE_DEFAULTS	0x02
+#define		BIOSCANCTL      	0x80
+#define		AUTOACKEN       	0x40
+#define		BIASCANCTL      	0x20
+#define		BUSFREEREV      	0x10
+#define		ENDGFORMCHK     	0x04
+#define		AUTO_MSGOUT_DE  	0x02
+
+#define	SSTAT0          		0x4b
+#define		TARGET          	0x80
+#define		SELDO           	0x40
+#define		SELDI           	0x20
+#define		SELINGO         	0x10
+#define		IOERR           	0x08
+#define		OVERRUN         	0x04
+#define		SPIORDY         	0x02
+#define		ARBDO           	0x01
+
+#define	CLRSINT0        		0x4b
+#define		CLRSELDO        	0x40
+#define		CLRSELDI        	0x20
+#define		CLRSELINGO      	0x10
+#define		CLRIOERR        	0x08
+#define		CLROVERRUN      	0x04
+#define		CLRSPIORDY      	0x02
+#define		CLRARBDO        	0x01
+
+#define	SIMODE0         		0x4b
+#define		ENSELDO         	0x40
+#define		ENSELDI         	0x20
+#define		ENSELINGO       	0x10
+#define		ENIOERR         	0x08
+#define		ENOVERRUN       	0x04
+#define		ENSPIORDY       	0x02
+#define		ENARBDO         	0x01
+
+#define	CLRSINT1        		0x4c
+#define		CLRSELTIMEO     	0x80
+#define		CLRATNO         	0x40
+#define		CLRSCSIRSTI     	0x20
+#define		CLRBUSFREE      	0x08
+#define		CLRSCSIPERR     	0x04
+#define		CLRSTRB2FAST    	0x02
+#define		CLRREQINIT      	0x01
+
+#define	SSTAT1          		0x4c
+#define		SELTO           	0x80
+#define		ATNTARG         	0x40
+#define		SCSIRSTI        	0x20
+#define		PHASEMIS        	0x10
+#define		BUSFREE         	0x08
+#define		SCSIPERR        	0x04
+#define		STRB2FAST       	0x02
+#define		REQINIT         	0x01
+
+#define	SSTAT2          		0x4d
+#define		BUSFREETIME     	0xc0
+#define		NONPACKREQ      	0x20
+#define		EXP_ACTIVE      	0x10
+#define		BSYX            	0x08
+#define		WIDE_RES        	0x04
+#define		SDONE           	0x02
+#define		DMADONE         	0x01
+#define		BUSFREE_DFF1    	0xc0
+#define		BUSFREE_DFF0    	0x80
+#define		BUSFREE_LQO     	0x40
+
+#define	CLRSINT2        		0x4d
+#define		CLRNONPACKREQ   	0x20
+#define		CLRWIDE_RES     	0x04
+#define		CLRSDONE        	0x02
+#define		CLRDMADONE      	0x01
+
+#define	SIMODE2         		0x4d
+#define		ENWIDE_RES      	0x04
+#define		ENSDONE         	0x02
+#define		ENDMADONE       	0x01
+
+#define	PERRDIAG        		0x4e
+#define		HIZERO          	0x80
+#define		HIPERR          	0x40
+#define		PREVPHASE       	0x20
+#define		PARITYERR       	0x10
+#define		AIPERR          	0x08
+#define		CRCERR          	0x04
+#define		DGFORMERR       	0x02
+#define		DTERR           	0x01
+
+#define	LQISTATE        		0x4e
+
+#define	SOFFCNT         		0x4f
+
+#define	LQOSTATE        		0x4f
+
+#define	LQISTAT0        		0x50
+#define		LQIATNQAS       	0x20
+#define		LQICRCT1        	0x10
+#define		LQICRCT2        	0x08
+#define		LQIBADLQT       	0x04
+#define		LQIATNLQ        	0x02
+#define		LQIATNCMD       	0x01
+
+#define	CLRLQIINT0      		0x50
+#define		CLRLQIATNQAS    	0x20
+#define		CLRLQICRCT1     	0x10
+#define		CLRLQICRCT2     	0x08
+#define		CLRLQIBADLQT    	0x04
+#define		CLRLQIATNLQ     	0x02
+#define		CLRLQIATNCMD    	0x01
+
+#define	LQIMODE0        		0x50
+#define		ENLQIATNQASK    	0x20
+#define		ENLQICRCT1      	0x10
+#define		ENLQICRCT2      	0x08
+#define		ENLQIBADLQT     	0x04
+#define		ENLQIATNLQ      	0x02
+#define		ENLQIATNCMD     	0x01
+
+#define	LQIMODE1        		0x51
+#define		ENLQIPHASE_LQ   	0x80
+#define		ENLQIPHASE_NLQ  	0x40
+#define		ENLIQABORT      	0x20
+#define		ENLQICRCI_LQ    	0x10
+#define		ENLQICRCI_NLQ   	0x08
+#define		ENLQIBADLQI     	0x04
+#define		ENLQIOVERI_LQ   	0x02
+#define		ENLQIOVERI_NLQ  	0x01
+
+#define	LQISTAT1        		0x51
+#define		LQIPHASE_LQ     	0x80
+#define		LQIPHASE_NLQ    	0x40
+#define		LQIABORT        	0x20
+#define		LQICRCI_LQ      	0x10
+#define		LQICRCI_NLQ     	0x08
+#define		LQIBADLQI       	0x04
+#define		LQIOVERI_LQ     	0x02
+#define		LQIOVERI_NLQ    	0x01
+
+#define	CLRLQIINT1      		0x51
+#define		CLRLQIPHASE_LQ  	0x80
+#define		CLRLQIPHASE_NLQ 	0x40
+#define		CLRLIQABORT     	0x20
+#define		CLRLQICRCI_LQ   	0x10
+#define		CLRLQICRCI_NLQ  	0x08
+#define		CLRLQIBADLQI    	0x04
+#define		CLRLQIOVERI_LQ  	0x02
+#define		CLRLQIOVERI_NLQ 	0x01
+
+#define	LQISTAT2        		0x52
+#define		PACKETIZED      	0x80
+#define		LQIPHASE_OUTPKT 	0x40
+#define		LQIWORKONLQ     	0x20
+#define		LQIWAITFIFO     	0x10
+#define		LQISTOPPKT      	0x08
+#define		LQISTOPLQ       	0x04
+#define		LQISTOPCMD      	0x02
+#define		LQIGSAVAIL      	0x01
+
+#define	SSTAT3          		0x53
+#define		NTRAMPERR       	0x02
+#define		OSRAMPERR       	0x01
+
+#define	SIMODE3         		0x53
+#define		ENNTRAMPERR     	0x02
+#define		ENOSRAMPERR     	0x01
+
+#define	CLRSINT3        		0x53
+#define		CLRNTRAMPERR    	0x02
+#define		CLROSRAMPERR    	0x01
+
+#define	LQOMODE0        		0x54
+#define		ENLQOTARGSCBPERR	0x10
+#define		ENLQOSTOPT2     	0x08
+#define		ENLQOATNLQ      	0x04
+#define		ENLQOATNPKT     	0x02
+#define		ENLQOTCRC       	0x01
+
+#define	LQOSTAT0        		0x54
+#define		LQOTARGSCBPERR  	0x10
+#define		LQOSTOPT2       	0x08
+#define		LQOATNLQ        	0x04
+#define		LQOATNPKT       	0x02
+#define		LQOTCRC         	0x01
+
+#define	CLRLQOINT0      		0x54
+#define		CLRLQOTARGSCBPERR	0x10
+#define		CLRLQOSTOPT2    	0x08
+#define		CLRLQOATNLQ     	0x04
+#define		CLRLQOATNPKT    	0x02
+#define		CLRLQOTCRC      	0x01
+
+#define	LQOSTAT1        		0x55
+#define		LQOINITSCBPERR  	0x10
+#define		LQOSTOPI2       	0x08
+#define		LQOBADQAS       	0x04
+#define		LQOBUSFREE      	0x02
+#define		LQOPHACHGINPKT  	0x01
+
+#define	CLRLQOINT1      		0x55
+#define		CLRLQOINITSCBPERR	0x10
+#define		CLRLQOSTOPI2    	0x08
+#define		CLRLQOBADQAS    	0x04
+#define		CLRLQOBUSFREE   	0x02
+#define		CLRLQOPHACHGINPKT	0x01
+
+#define	LQOMODE1        		0x55
+#define		ENLQOINITSCBPERR	0x10
+#define		ENLQOSTOPI2     	0x08
+#define		ENLQOBADQAS     	0x04
+#define		ENLQOBUSFREE    	0x02
+#define		ENLQOPHACHGINPKT	0x01
+
+#define	LQOSTAT2        		0x56
+#define		LQOPKT          	0xe0
+#define		LQOWAITFIFO     	0x10
+#define		LQOPHACHGOUTPKT 	0x02
+#define		LQOSTOP0        	0x01
+
+#define	OS_SPACE_CNT    		0x56
+
+#define	SIMODE1         		0x57
+#define		ENSELTIMO       	0x80
+#define		ENATNTARG       	0x40
+#define		ENSCSIRST       	0x20
+#define		ENPHASEMIS      	0x10
+#define		ENBUSFREE       	0x08
+#define		ENSCSIPERR      	0x04
+#define		ENSTRB2FAST     	0x02
+#define		ENREQINIT       	0x01
+
+#define	GSFIFO          		0x58
+
+#define	DFFSXFRCTL      		0x5a
+#define		CLRSHCNT        	0x04
+#define		CLRCHN          	0x02
+#define		RSTCHN          	0x01
+
+#define	NEXTSCB         		0x5a
+
+#define	CLRSEQINTSRC    		0x5b
+#define		CLRCTXTDONE     	0x40
+#define		CLRSAVEPTRS     	0x20
+#define		CLRCFG4DATA     	0x10
+#define		CLRCFG4ISTAT    	0x08
+#define		CLRCFG4TSTAT    	0x04
+#define		CLRCFG4ICMD     	0x02
+#define		CLRCFG4TCMD     	0x01
+
+#define	SEQINTSRC       		0x5b
+#define		CTXTDONE        	0x40
+#define		SAVEPTRS        	0x20
+#define		CFG4DATA        	0x10
+#define		CFG4ISTAT       	0x08
+#define		CFG4TSTAT       	0x04
+#define		CFG4ICMD        	0x02
+#define		CFG4TCMD        	0x01
+
+#define	CURRSCB         		0x5c
+
+#define	SEQIMODE        		0x5c
+#define		ENCTXTDONE      	0x40
+#define		ENSAVEPTRS      	0x20
+#define		ENCFG4DATA      	0x10
+#define		ENCFG4ISTAT     	0x08
+#define		ENCFG4TSTAT     	0x04
+#define		ENCFG4ICMD      	0x02
+#define		ENCFG4TCMD      	0x01
+
+#define	MDFFSTAT        		0x5d
+#define		SHCNTNEGATIVE   	0x40
+#define		SHCNTMINUS1     	0x20
+#define		LASTSDONE       	0x10
+#define		SHVALID         	0x08
+#define		DLZERO          	0x04
+#define		DATAINFIFO      	0x02
+#define		FIFOFREE        	0x01
+
+#define	CRCCONTROL      		0x5d
+#define		CRCVALCHKEN     	0x40
+
+#define	DFFTAG          		0x5e
+
+#define	LASTSCB         		0x5e
+
+#define	SCSITEST        		0x5e
+#define		CNTRTEST        	0x08
+#define		SEL_TXPLL_DEBUG 	0x04
+
+#define	IOPDNCTL        		0x5f
+#define		DISABLE_OE      	0x80
+#define		PDN_IDIST       	0x04
+#define		PDN_DIFFSENSE   	0x01
+
+#define	SHADDR          		0x60
+
+#define	NEGOADDR        		0x60
+
+#define	DGRPCRCI        		0x60
+
+#define	NEGPERIOD       		0x61
+
+#define	PACKCRCI        		0x62
+
+#define	NEGOFFSET       		0x62
+
+#define	NEGPPROPTS      		0x63
+#define		PPROPT_PACE     	0x08
+#define		PPROPT_QAS      	0x04
+#define		PPROPT_DT       	0x02
+#define		PPROPT_IUT      	0x01
+
+#define	NEGCONOPTS      		0x64
+#define		ENAIP           	0x08
+#define		ENAUTOATNI      	0x04
+#define		ENAUTOATNO      	0x02
+#define		WIDEXFER        	0x01
+
+#define	ANNEXCOL        		0x65
+
+#define	SCSCHKN         		0x66
+#define		STSELSKIDDIS    	0x40
+#define		CURFIFODEF      	0x20
+#define		WIDERESEN       	0x10
+#define		SDONEMSKDIS     	0x08
+#define		DFFACTCLR       	0x04
+#define		SHVALIDSTDIS    	0x02
+#define		LSTSGCLRDIS     	0x01
+
+#define	ANNEXDAT        		0x66
+
+#define	IOWNID          		0x67
+
+#define	PLL960CTL0      		0x68
+
+#define	SHCNT           		0x68
+
+#define	TOWNID          		0x69
+
+#define	PLL960CTL1      		0x69
+
+#define	PLL960CNT0      		0x6a
+
+#define	XSIG            		0x6a
+
+#define	SELOID          		0x6b
+
+#define	PLL400CTL0      		0x6c
+#define		PLL_VCOSEL      	0x80
+#define		PLL_PWDN        	0x40
+#define		PLL_NS          	0x30
+#define		PLL_ENLUD       	0x08
+#define		PLL_ENLPF       	0x04
+#define		PLL_DLPF        	0x02
+#define		PLL_ENFBM       	0x01
+
+#define	FAIRNESS        		0x6c
+
+#define	PLL400CTL1      		0x6d
+#define		PLL_CNTEN       	0x80
+#define		PLL_CNTCLR      	0x40
+#define		PLL_RST         	0x01
+
+#define	PLL400CNT0      		0x6e
+
+#define	UNFAIRNESS      		0x6e
+
+#define	HADDR           		0x70
+
+#define	HODMAADR        		0x70
+
+#define	HODMACNT        		0x78
+
+#define	HCNT            		0x78
+
+#define	HODMAEN         		0x7a
+
+#define	SGHADDR         		0x7c
+
+#define	SCBHADDR        		0x7c
+
+#define	SGHCNT          		0x84
+
+#define	SCBHCNT         		0x84
+
+#define	DFF_THRSH       		0x88
+#define		WR_DFTHRSH      	0x70
+#define		RD_DFTHRSH      	0x07
+#define		WR_DFTHRSH_MAX  	0x70
+#define		WR_DFTHRSH_90   	0x60
+#define		WR_DFTHRSH_85   	0x50
+#define		WR_DFTHRSH_75   	0x40
+#define		WR_DFTHRSH_63   	0x30
+#define		WR_DFTHRSH_50   	0x20
+#define		WR_DFTHRSH_25   	0x10
+#define		RD_DFTHRSH_MAX  	0x07
+#define		RD_DFTHRSH_90   	0x06
+#define		RD_DFTHRSH_85   	0x05
+#define		RD_DFTHRSH_75   	0x04
+#define		RD_DFTHRSH_63   	0x03
+#define		RD_DFTHRSH_50   	0x02
+#define		RD_DFTHRSH_25   	0x01
+#define		WR_DFTHRSH_MIN  	0x00
+#define		RD_DFTHRSH_MIN  	0x00
+
+#define	ROMADDR         		0x8a
+
+#define	ROMCNTRL        		0x8d
+#define		ROMOP           	0xe0
+#define		ROMSPD          	0x18
+#define		REPEAT          	0x02
+#define		RDY             	0x01
+
+#define	ROMDATA         		0x8e
+
+#define	CMCRXMSG0       		0x90
+
+#define	ROENABLE        		0x90
+#define		MSIROEN         	0x20
+#define		OVLYROEN        	0x10
+#define		CMCROEN         	0x08
+#define		SGROEN          	0x04
+#define		DCH1ROEN        	0x02
+#define		DCH0ROEN        	0x01
+
+#define	OVLYRXMSG0      		0x90
+
+#define	DCHRXMSG0       		0x90
+
+#define	OVLYRXMSG1      		0x91
+
+#define	NSENABLE        		0x91
+#define		MSINSEN         	0x20
+#define		OVLYNSEN        	0x10
+#define		CMCNSEN         	0x08
+#define		SGNSEN          	0x04
+#define		DCH1NSEN        	0x02
+#define		DCH0NSEN        	0x01
+
+#define	DCHRXMSG1       		0x91
+
+#define	CMCRXMSG1       		0x91
+
+#define	DCHRXMSG2       		0x92
+
+#define	OVLYRXMSG2      		0x92
+
+#define	CMCRXMSG2       		0x92
+
+#define	OST             		0x92
+
+#define	DCHRXMSG3       		0x93
+
+#define	CMCRXMSG3       		0x93
+
+#define	PCIXCTL         		0x93
+#define		SERRPULSE       	0x80
+#define		UNEXPSCIEN      	0x20
+#define		SPLTSMADIS      	0x10
+#define		SPLTSTADIS      	0x08
+#define		SRSPDPEEN       	0x04
+#define		TSCSERREN       	0x02
+#define		CMPABCDIS       	0x01
+
+#define	OVLYRXMSG3      		0x93
+
+#define	OVLYSEQBCNT     		0x94
+
+#define	CMCSEQBCNT      		0x94
+
+#define	DCHSEQBCNT      		0x94
+
+#define	CMCSPLTSTAT0    		0x96
+
+#define	OVLYSPLTSTAT0   		0x96
+
+#define	DCHSPLTSTAT0    		0x96
+
+#define	DCHSPLTSTAT1    		0x97
+
+#define	CMCSPLTSTAT1    		0x97
+
+#define	OVLYSPLTSTAT1   		0x97
+
+#define	SGRXMSG0        		0x98
+#define		CDNUM           	0xf8
+#define		CFNUM           	0x07
+
+#define	SLVSPLTOUTADR0  		0x98
+#define		LOWER_ADDR      	0x7f
+
+#define	SGRXMSG1        		0x99
+#define		CBNUM           	0xff
+
+#define	SLVSPLTOUTADR1  		0x99
+#define		REQ_DNUM        	0xf8
+#define		REQ_FNUM        	0x07
+
+#define	SGRXMSG2        		0x9a
+#define		MINDEX          	0xff
+
+#define	SLVSPLTOUTADR2  		0x9a
+#define		REQ_BNUM        	0xff
+
+#define	SGRXMSG3        		0x9b
+#define		MCLASS          	0x0f
+
+#define	SLVSPLTOUTADR3  		0x9b
+#define		TAG_NUM         	0x1f
+#define		RLXORD          	0x10
+
+#define	SGSEQBCNT       		0x9c
+
+#define	SLVSPLTOUTATTR0 		0x9c
+#define		LOWER_BCNT      	0xff
+
+#define	SLVSPLTOUTATTR1 		0x9d
+#define		CMPLT_DNUM      	0xf8
+#define		CMPLT_FNUM      	0x07
+
+#define	SLVSPLTOUTATTR2 		0x9e
+#define		CMPLT_BNUM      	0xff
+
+#define	SGSPLTSTAT0     		0x9e
+#define		STAETERM        	0x80
+#define		SCBCERR         	0x40
+#define		SCADERR         	0x20
+#define		SCDATBUCKET     	0x10
+#define		CNTNOTCMPLT     	0x08
+#define		RXOVRUN         	0x04
+#define		RXSCEMSG        	0x02
+#define		RXSPLTRSP       	0x01
+
+#define	SFUNCT          		0x9f
+#define		TEST_GROUP      	0xf0
+#define		TEST_NUM        	0x0f
+
+#define	SGSPLTSTAT1     		0x9f
+#define		RXDATABUCKET    	0x01
+
+#define	DF0PCISTAT      		0xa0
+
+#define	REG0            		0xa0
+
+#define	DF1PCISTAT      		0xa1
+
+#define	SGPCISTAT       		0xa2
+
+#define	REG1            		0xa2
+
+#define	CMCPCISTAT      		0xa3
+
+#define	OVLYPCISTAT     		0xa4
+#define		SCAAPERR        	0x08
+#define		RDPERR          	0x04
+
+#define	REG_ISR         		0xa4
+
+#define	SG_STATE        		0xa6
+#define		FETCH_INPROG    	0x04
+#define		LOADING_NEEDED  	0x02
+#define		SEGS_AVAIL      	0x01
+
+#define	MSIPCISTAT      		0xa6
+#define		RMA             	0x20
+#define		RTA             	0x10
+#define		CLRPENDMSI      	0x08
+#define		DPR             	0x01
+
+#define	TARGPCISTAT     		0xa6
+#define		DPE             	0x80
+#define		SSE             	0x40
+#define		STA             	0x08
+#define		TWATERR         	0x02
+
+#define	DATA_COUNT_ODD  		0xa7
+
+#define	SCBPTR          		0xa8
+
+#define	CCSCBACNT       		0xab
+
+#define	SCBAUTOPTR      		0xab
+#define		AUSCBPTR_EN     	0x80
+#define		SCBPTR_ADDR     	0x38
+#define		SCBPTR_OFF      	0x07
+
+#define	CCSGADDR        		0xac
+
+#define	CCSCBADDR       		0xac
+
+#define	CCSCBADR_BK     		0xac
+
+#define	CMC_RAMBIST     		0xad
+#define		SG_ELEMENT_SIZE 	0x80
+#define		SCBRAMBIST_FAIL 	0x40
+#define		SG_BIST_FAIL    	0x20
+#define		SG_BIST_EN      	0x10
+#define		CMC_BUFFER_BIST_FAIL	0x02
+#define		CMC_BUFFER_BIST_EN	0x01
+
+#define	CCSGCTL         		0xad
+#define		CCSGDONE        	0x80
+#define		SG_CACHE_AVAIL  	0x10
+#define		CCSGEN          	0x08
+#define		SG_FETCH_REQ    	0x02
+#define		CCSGRESET       	0x01
+
+#define	CCSCBCTL        		0xad
+#define		CCSCBDONE       	0x80
+#define		ARRDONE         	0x40
+#define		CCARREN         	0x10
+#define		CCSCBEN         	0x08
+#define		CCSCBDIR        	0x04
+#define		CCSCBRESET      	0x01
+
+#define	CCSGRAM         		0xb0
+
+#define	FLEXADR         		0xb0
+
+#define	CCSCBRAM        		0xb0
+
+#define	FLEXCNT         		0xb3
+
+#define	FLEXDMASTAT     		0xb5
+#define		FLEXDMAERR      	0x02
+#define		FLEXDMADONE     	0x01
+
+#define	FLEXDATA        		0xb6
+
+#define	BRDDAT          		0xb8
+
+#define	BRDCTL          		0xb9
+#define		FLXARBACK       	0x80
+#define		FLXARBREQ       	0x40
+#define		BRDADDR         	0x38
+#define		BRDEN           	0x04
+#define		BRDRW           	0x02
+#define		BRDSTB          	0x01
+
+#define	SEEADR          		0xba
+
+#define	SEEDAT          		0xbc
+
+#define	SEECTL          		0xbe
+#define		SEEOP_EWEN      	0x40
+#define		SEEOP_WALL      	0x40
+#define		SEEOP_EWDS      	0x40
+#define		SEEOPCODE       	0x70
+#define		SEERST          	0x02
+#define		SEESTART        	0x01
+#define		SEEOP_ERASE     	0x70
+#define		SEEOP_READ      	0x60
+#define		SEEOP_WRITE     	0x50
+#define		SEEOP_ERAL      	0x40
+
+#define	SEESTAT         		0xbe
+#define		INIT_DONE       	0x80
+#define		LDALTID_L       	0x08
+#define		SEEARBACK       	0x04
+#define		SEEBUSY         	0x02
+
+#define	SCBCNT          		0xbf
+
+#define	DFWADDR         		0xc0
+
+#define	DSPFLTRCTL      		0xc0
+#define		FLTRDISABLE     	0x20
+#define		EDGESENSE       	0x10
+#define		DSPFCNTSEL      	0x0f
+
+#define	CLRSEQINTSTAT   		0xc0
+#define		CLRSEQ_SWTMRTO  	0x10
+#define		CLRSEQ_SEQINT   	0x08
+#define		CLRSEQ_SCSIINT  	0x04
+#define		CLRSEQ_PCIINT   	0x02
+#define		CLRSEQ_SPLTINT  	0x01
+
+#define	DSPDATACTL      		0xc1
+#define		BYPASSENAB      	0x80
+#define		DESQDIS         	0x10
+#define		RCVROFFSTDIS    	0x04
+#define		XMITOFFSTDIS    	0x02
+
+#define	DFRADDR         		0xc2
+
+#define	DSPREQCTL       		0xc2
+#define		MANREQCTL       	0xc0
+#define		MANREQDLY       	0x3f
+
+#define	DSPACKCTL       		0xc3
+#define		MANACKCTL       	0xc0
+#define		MANACKDLY       	0x3f
+
+#define	DFDAT           		0xc4
+
+#define	DSPSELECT       		0xc4
+#define		AUTOINCEN       	0x80
+#define		DSPSEL          	0x1f
+
+#define	WRTBIASCTL      		0xc5
+#define		AUTOXBCDIS      	0x80
+#define		XMITMANVAL      	0x3f
+
+#define	RCVRBIOSCTL     		0xc6
+#define		AUTORBCDIS      	0x80
+#define		RCVRMANVAL      	0x3f
+
+#define	WRTBIASCALC     		0xc7
+
+#define	DFPTRS          		0xc8
+
+#define	RCVRBIASCALC    		0xc8
+
+#define	DFDBCTL         		0xc8
+#define		DFF_CIO_WR_RDY  	0x20
+#define		DFF_CIO_RD_RDY  	0x10
+#define		DFF_DIR_ERR     	0x08
+#define		DFF_RAMBIST_FAIL	0x04
+#define		DFF_RAMBIST_DONE	0x02
+#define		DFF_RAMBIST_EN  	0x01
+
+#define	DFBKPTR         		0xc9
+
+#define	SKEWCALC        		0xc9
+
+#define	DFSCNT          		0xcc
+
+#define	DFBCNT          		0xce
+
+#define	OVLYADDR        		0xd4
+
+#define	SEQCTL0         		0xd6
+#define		PERRORDIS       	0x80
+#define		PAUSEDIS        	0x40
+#define		FAILDIS         	0x20
+#define		FASTMODE        	0x10
+#define		BRKADRINTEN     	0x08
+#define		STEP            	0x04
+#define		SEQRESET        	0x02
+#define		LOADRAM         	0x01
+
+#define	SEQCTL1         		0xd7
+#define		OVRLAY_DATA_CHK 	0x08
+#define		RAMBIST_DONE    	0x04
+#define		RAMBIST_FAIL    	0x02
+#define		RAMBIST_EN      	0x01
+
+#define	FLAGS           		0xd8
+#define		ZERO            	0x02
+#define		CARRY           	0x01
+
+#define	SEQINTCTL       		0xd9
+#define		INTVEC1DSL      	0x80
+#define		INT1_CONTEXT    	0x20
+#define		SCS_SEQ_INT1M1  	0x10
+#define		SCS_SEQ_INT1M0  	0x08
+#define		INTMASK         	0x06
+#define		IRET            	0x01
+
+#define	SEQRAM          		0xda
+
+#define	PRGMCNT         		0xde
+
+#define	SWTIMER         		0xe0
+
+#define	ACCUM           		0xe0
+
+#define	SINDEX          		0xe2
+
+#define	DINDEX          		0xe4
+
+#define	BRKADDR1        		0xe6
+#define		BRKDIS          	0x80
+
+#define	BRKADDR0        		0xe6
+
+#define	ALLONES         		0xe8
+
+#define	ALLZEROS        		0xea
+
+#define	NONE            		0xea
+
+#define	SINDIR          		0xec
+
+#define	DINDIR          		0xed
+
+#define	FUNCTION1       		0xf0
+
+#define	STACK           		0xf2
+
+#define	CURADDR         		0xf4
+
+#define	INTVEC1_ADDR    		0xf4
+
+#define	INTVEC2_ADDR    		0xf6
+
+#define	LASTADDR        		0xf6
+
+#define	LONGJMP_ADDR    		0xf8
+
+#define	LONGJMP_SCB     		0xfa
+
+#define	ACCUM_SAVE      		0xfc
+
+#define	WAITING_SCB_TAILS		0x100
+
+#define	AHD_PCI_CONFIG_BASE		0x100
+
+#define	SRAM_BASE       		0x100
+
+#define	WAITING_TID_HEAD		0x120
+
+#define	WAITING_TID_TAIL		0x122
+
+#define	NEXT_QUEUED_SCB_ADDR		0x124
+
+#define	COMPLETE_SCB_HEAD		0x128
+
+#define	COMPLETE_SCB_DMAINPROG_HEAD		0x12a
+
+#define	COMPLETE_DMA_SCB_HEAD		0x12c
+
+#define	QFREEZE_COUNT   		0x12e
+
+#define	SAVED_MODE      		0x130
+
+#define	MSG_OUT         		0x131
+
+#define	DMAPARAMS       		0x132
+#define		PRELOADEN       	0x80
+#define		WIDEODD         	0x40
+#define		SCSIEN          	0x20
+#define		SDMAEN          	0x10
+#define		SDMAENACK       	0x10
+#define		HDMAENACK       	0x08
+#define		HDMAEN          	0x08
+#define		DIRECTION       	0x04
+#define		FIFOFLUSH       	0x02
+#define		FIFORESET       	0x01
+
+#define	SEQ_FLAGS       		0x133
+#define		NOT_IDENTIFIED  	0x80
+#define		NO_CDB_SENT     	0x40
+#define		TARGET_CMD_IS_TAGGED	0x40
+#define		DPHASE          	0x20
+#define		TARG_CMD_PENDING	0x10
+#define		CMDPHASE_PENDING	0x08
+#define		DPHASE_PENDING  	0x04
+#define		SPHASE_PENDING  	0x02
+#define		NO_DISCONNECT   	0x01
+
+#define	SAVED_SCSIID    		0x134
+
+#define	SAVED_LUN       		0x135
+
+#define	LASTPHASE       		0x136
+#define		PHASE_MASK      	0xe0
+#define		CDI             	0x80
+#define		IOI             	0x40
+#define		MSGI            	0x20
+#define		P_BUSFREE       	0x01
+#define		P_MESGIN        	0xe0
+#define		P_STATUS        	0xc0
+#define		P_MESGOUT       	0xa0
+#define		P_COMMAND       	0x80
+#define		P_DATAIN_DT     	0x60
+#define		P_DATAIN        	0x40
+#define		P_DATAOUT_DT    	0x20
+#define		P_DATAOUT       	0x00
+
+#define	SHARED_DATA_ADDR		0x137
+
+#define	QOUTFIFO_NEXT_ADDR		0x13b
+
+#define	QOUTFIFO_ENTRY_VALID_TAG		0x13f
+
+#define	KERNEL_TQINPOS  		0x140
+
+#define	TQINPOS         		0x141
+
+#define	ARG_1           		0x142
+#define	RETURN_1        		0x142
+#define		SEND_MSG        	0x80
+#define		SEND_SENSE      	0x40
+#define		SEND_REJ        	0x20
+#define		MSGOUT_PHASEMIS 	0x10
+#define		EXIT_MSG_LOOP   	0x08
+#define		CONT_MSG_LOOP_WRITE	0x04
+#define		CONT_MSG_LOOP_READ	0x03
+#define		CONT_MSG_LOOP_TARG	0x02
+
+#define	ARG_2           		0x143
+#define	RETURN_2        		0x143
+
+#define	LAST_MSG        		0x144
+
+#define	SCSISEQ_TEMPLATE		0x145
+#define		MANUALCTL       	0x40
+#define		ENSELI          	0x20
+#define		ENRSELI         	0x10
+#define		MANUALP         	0x0c
+#define		ENAUTOATNP      	0x02
+#define		ALTSTIM         	0x01
+
+#define	INITIATOR_TAG   		0x146
+
+#define	SEQ_FLAGS2      		0x147
+#define		SELECTOUT_QFROZEN	0x04
+#define		TARGET_MSG_PENDING	0x02
+
+#define	ALLOCFIFO_SCBPTR		0x148
+
+#define	CMDSIZE_TABLE   		0x14a
+
+#define	SCB_BASE        		0x180
+
+#define	SCB_RESIDUAL_DATACNT		0x180
+#define	SCB_CDB_STORE   		0x180
+
+#define	SCB_RESIDUAL_SGPTR		0x184
+#define	SCB_CDB_PTR     		0x184
+#define		SG_ADDR_MASK    	0xf8
+#define		SG_OVERRUN_RESID	0x02
+
+#define	SCB_SCSI_STATUS 		0x188
+
+#define	SCB_TARGET_PHASES		0x189
+
+#define	SCB_TARGET_DATA_DIR		0x18a
+
+#define	SCB_TARGET_ITAG 		0x18b
+
+#define	SCB_SENSE_BUSADDR		0x18c
+#define	SCB_NEXT_COMPLETE		0x18c
+
+#define	SCB_TAG         		0x190
+
+#define	SCB_CDB_LEN     		0x192
+#define		SCB_CDB_LEN_PTR 	0x80
+
+#define	SCB_TASK_MANAGEMENT		0x193
+
+#define	SCB_NEXT        		0x194
+#define	SCB_NEXT_SCB_BUSADDR		0x194
+
+#define	SCB_NEXT2       		0x196
+
+#define	SCB_DATAPTR     		0x198
+
+#define	SCB_DATACNT     		0x1a0
+#define		SG_LAST_SEG     	0x80
+#define		SG_HIGH_ADDR_BITS	0x7f
+
+#define	SCB_SGPTR       		0x1a4
+#define		SG_STATUS_VALID 	0x04
+#define		SG_FULL_RESID   	0x02
+#define		SG_LIST_NULL    	0x01
+
+#define	SCB_CONTROL     		0x1a8
+#define		TARGET_SCB      	0x80
+#define		DISCENB         	0x40
+#define		TAG_ENB         	0x20
+#define		MK_MESSAGE      	0x10
+#define		STATUS_RCVD     	0x08
+#define		DISCONNECTED    	0x04
+#define		SCB_TAG_TYPE    	0x03
+
+#define	SCB_SCSIID      		0x1a9
+#define		TID             	0xf0
+#define		OID             	0x0f
+
+#define	SCB_LUN         		0x1aa
+#define		LID             	0xff
+
+#define	SCB_TASK_ATTRIBUTE		0x1ab
+
+#define	SCB_BUSADDR     		0x1ac
+
+#define	SCB_SPARE       		0x1b0
+#define	SCB_PKT_LUN     		0x1b0
+
+#define	SCB_DISCONNECTED_LISTS		0x1b8
+
+
+#define	SCB_TRANSFER_SIZE_FULL_LUN	0x38
+#define	STATUS_QUEUE_FULL	0x28
+#define	STATUS_BUSY	0x08
+#define	MAX_OFFSET_PACED	0x7f
+#define	BUS_32_BIT	0x02
+#define	CCSGADDR_MAX	0x80
+#define	TID_SHIFT	0x04
+#define	MK_MESSAGE_BIT_OFFSET	0x04
+#define	SEEOP_EWDS_ADDR	0x00
+#define	AHD_NUM_ANNEXCOLS	0x04
+#define	AHD_PRECOMP_FASTSLEW	0x40
+#define	AHD_PRECOMP_CUTBACK_29	0x06
+#define	NVRAM_SCB_OFFSET	0x2c
+#define	STATUS_PKT_SENSE	0xff
+#define	CMD_GROUP_CODE_SHIFT	0x05
+#define	AHD_SENSE_BUFSIZE	0x100
+#define	BUS_8_BIT	0x00
+#define	STIMESEL_BUG_ADJ	0x08
+#define	STIMESEL_MIN	0x18
+#define	STIMESEL_SHIFT	0x03
+#define	CCSGRAM_MAXSEGS	0x10
+#define	INVALID_ADDR	0x80
+#define	TARGET_CMD_CMPLT	0xfe
+#define	SEEOP_WRAL_ADDR	0x40
+#define	SEEOP_ERAL_ADDR	0x80
+#define	AHD_PRECOMP_CUTBACK_37	0x07
+#define	AHD_PRECOMP_CUTBACK_17	0x04
+#define	AHD_PRECOMP_MASK	0x07
+#define	AHD_ANNEXCOL_PRECOMP	0x04
+#define	SRC_MODE_SHIFT	0x00
+#define	PKT_OVERRUN_BUFSIZE	0x200
+#define	SCB_TRANSFER_SIZE_1BYTE_LUN	0x30
+#define	TARGET_DATA_IN	0x01
+#define	HOST_MSG	0xff
+#define	MAX_OFFSET	0xfe
+#define	BUS_16_BIT	0x01
+#define	CCSCBADDR_MAX	0x80
+#define	SEQ_STACK_SIZE	0x08
+#define	WRTBIASCTL_CPQ_DEFAULT	0x97
+#define	NUMDSPS 	0x14
+#define	SEEOP_EWEN_ADDR	0xc0
+#define	DST_MODE_SHIFT	0x04
+
+
+/* Downloaded Constant Definitions */
+#define	SCB_TRANSFER_SIZE	0x06
+#define	PKT_OVERRUN_BUFOFFSET	0x05
+#define	SG_SIZEOF	0x04
+#define	SG_PREFETCH_ADDR_MASK	0x03
+#define	SG_PREFETCH_ALIGN_MASK	0x02
+#define	SG_PREFETCH_CNT_LIMIT	0x01
+#define	SG_PREFETCH_CNT	0x00
+#define	DOWNLOAD_CONST_COUNT	0x07
+
+
+/* Exported Labels */
+#define	LABEL_seq_isr 	0x21c
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_reg_print.c linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_reg_print.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_reg_print.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_reg_print.c	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,3547 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#60 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#45 $
+ */
+
+#include "aic79xx_osm.h"
+
+static ahd_reg_parse_entry_t MODE_PTR_parse_table[] = {
+	{ "SRC_MODE",		0x07, 0x07 },
+	{ "DST_MODE",		0x70, 0x70 }
+};
+
+int
+ahd_mode_ptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MODE_PTR_parse_table, 2, "MODE_PTR",
+	    0x00, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t INTSTAT_parse_table[] = {
+	{ "SPLTINT",		0x01, 0x01 },
+	{ "CMDCMPLT",		0x02, 0x02 },
+	{ "SEQINT",		0x04, 0x04 },
+	{ "SCSIINT",		0x08, 0x08 },
+	{ "PCIINT",		0x10, 0x10 },
+	{ "SWTMINT",		0x20, 0x20 },
+	{ "BRKADRINT",		0x40, 0x40 },
+	{ "HWERRINT",		0x80, 0x80 },
+	{ "INT_PEND",		0xff, 0xff }
+};
+
+int
+ahd_intstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(INTSTAT_parse_table, 9, "INTSTAT",
+	    0x01, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTCODE_parse_table[] = {
+	{ "BAD_PHASE",		0x01, 0xff },
+	{ "SEND_REJECT",	0x02, 0xff },
+	{ "PROTO_VIOLATION",	0x03, 0xff },
+	{ "NO_MATCH",		0x04, 0xff },
+	{ "IGN_WIDE_RES",	0x05, 0xff },
+	{ "PDATA_REINIT",	0x06, 0xff },
+	{ "HOST_MSG_LOOP",	0x07, 0xff },
+	{ "BAD_STATUS",		0x08, 0xff },
+	{ "DATA_OVERRUN",	0x09, 0xff },
+	{ "MKMSG_FAILED",	0x0a, 0xff },
+	{ "MISSED_BUSFREE",	0x0b, 0xff },
+	{ "DUMP_CARD_STATE",	0x0c, 0xff },
+	{ "ILLEGAL_PHASE",	0x0d, 0xff },
+	{ "INVALID_SEQINT",	0x0e, 0xff },
+	{ "CFG4ISTAT_INTR",	0x0f, 0xff },
+	{ "STATUS_OVERRUN",	0x10, 0xff },
+	{ "CFG4OVERRUN",	0x11, 0xff },
+	{ "ENTERING_NONPACK",	0x12, 0xff }
+};
+
+int
+ahd_seqintcode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTCODE_parse_table, 18, "SEQINTCODE",
+	    0x02, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRINT_parse_table[] = {
+	{ "CLRSPLTINT",		0x01, 0x01 },
+	{ "CLRCMDINT",		0x02, 0x02 },
+	{ "CLRSEQINT",		0x04, 0x04 },
+	{ "CLRSCSIINT",		0x08, 0x08 },
+	{ "CLRSWTMINT",		0x20, 0x20 },
+	{ "CLRBRKADRINT",	0x40, 0x40 },
+	{ "CLRHWERRINT",	0x80, 0x80 }
+};
+
+int
+ahd_clrint_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRINT_parse_table, 7, "CLRINT",
+	    0x03, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ERROR_parse_table[] = {
+	{ "DSCTMOUT",		0x02, 0x02 },
+	{ "ILLOPCODE",		0x04, 0x04 },
+	{ "SQPARERR",		0x08, 0x08 },
+	{ "DPARERR",		0x10, 0x10 },
+	{ "MPARERR",		0x20, 0x20 },
+	{ "CIOACCESFAIL",	0x40, 0x40 },
+	{ "CIOPARERR",		0x80, 0x80 }
+};
+
+int
+ahd_error_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ERROR_parse_table, 7, "ERROR",
+	    0x04, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRERR_parse_table[] = {
+	{ "CLRDSCTMOUT",	0x02, 0x02 },
+	{ "CLRILLOPCODE",	0x04, 0x04 },
+	{ "CLRSQPARERR",	0x08, 0x08 },
+	{ "CLRDPARERR",		0x10, 0x10 },
+	{ "CLRMPARERR",		0x20, 0x20 },
+	{ "CLRCIOACCESFAIL",	0x40, 0x40 },
+	{ "CLRCIOPARERR",	0x80, 0x80 }
+};
+
+int
+ahd_clrerr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRERR_parse_table, 7, "CLRERR",
+	    0x04, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t HCNTRL_parse_table[] = {
+	{ "CHIPRST",		0x01, 0x01 },
+	{ "CHIPRSTACK",		0x01, 0x01 },
+	{ "INTEN",		0x02, 0x02 },
+	{ "PAUSE",		0x04, 0x04 },
+	{ "SWTIMER_START_B",	0x08, 0x08 },
+	{ "SWINT",		0x10, 0x10 },
+	{ "POWRDN",		0x40, 0x40 },
+	{ "SEQ_RESET",		0x80, 0x80 }
+};
+
+int
+ahd_hcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(HCNTRL_parse_table, 8, "HCNTRL",
+	    0x05, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hnscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HNSCB_QOFF",
+	    0x06, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HESCB_QOFF",
+	    0x08, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t HS_MAILBOX_parse_table[] = {
+	{ "HOST_TQINPOS",	0x80, 0x80 }
+};
+
+int
+ahd_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(HS_MAILBOX_parse_table, 1, "HS_MAILBOX",
+	    0x0b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTSTAT_parse_table[] = {
+	{ "SEQ_SPLTINT",	0x01, 0x01 },
+	{ "SEQ_PCIINT",		0x02, 0x02 },
+	{ "SEQ_SCSIINT",	0x04, 0x04 },
+	{ "SEQ_SEQINT",		0x08, 0x08 },
+	{ "SEQ_SWTMRTO",	0x10, 0x10 }
+};
+
+int
+ahd_seqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTSTAT_parse_table, 5, "SEQINTSTAT",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_snscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SNSCB_QOFF",
+	    0x10, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SESCB_QOFF",
+	    0x12, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sdscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SDSCB_QOFF",
+	    0x14, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t QOFF_CTLSTA_parse_table[] = {
+	{ "SCB_QSIZE_4",	0x00, 0x0f },
+	{ "SCB_QSIZE_8",	0x01, 0x0f },
+	{ "SCB_QSIZE_16",	0x02, 0x0f },
+	{ "SCB_QSIZE_32",	0x03, 0x0f },
+	{ "SCB_QSIZE_64",	0x04, 0x0f },
+	{ "SCB_QSIZE_128",	0x05, 0x0f },
+	{ "SCB_QSIZE_256",	0x06, 0x0f },
+	{ "SCB_QSIZE_512",	0x07, 0x0f },
+	{ "SCB_QSIZE_1024",	0x08, 0x0f },
+	{ "SCB_QSIZE_2048",	0x09, 0x0f },
+	{ "SCB_QSIZE_4096",	0x0a, 0x0f },
+	{ "SCB_QSIZE_8192",	0x0b, 0x0f },
+	{ "SCB_QSIZE_16384",	0x0c, 0x0f },
+	{ "SCB_QSIZE",		0x0f, 0x0f },
+	{ "HS_MAILBOX_ACT",	0x10, 0x10 },
+	{ "SDSCB_ROLLOVR",	0x20, 0x20 },
+	{ "NEW_SCB_AVAIL",	0x40, 0x40 },
+	{ "EMPTY_SCB_AVAIL",	0x80, 0x80 }
+};
+
+int
+ahd_qoff_ctlsta_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(QOFF_CTLSTA_parse_table, 18, "QOFF_CTLSTA",
+	    0x16, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t INTCTL_parse_table[] = {
+	{ "SPLTINTEN",		0x01, 0x01 },
+	{ "SEQINTEN",		0x02, 0x02 },
+	{ "SCSIINTEN",		0x04, 0x04 },
+	{ "PCIINTEN",		0x08, 0x08 },
+	{ "AUTOCLRCMDINT",	0x10, 0x10 },
+	{ "SWTIMER_START",	0x20, 0x20 },
+	{ "SWTMINTEN",		0x40, 0x40 },
+	{ "SWTMINTMASK",	0x80, 0x80 }
+};
+
+int
+ahd_intctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(INTCTL_parse_table, 8, "INTCTL",
+	    0x18, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFCNTRL_parse_table[] = {
+	{ "DIRECTIONEN",	0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "FIFOFLUSHACK",	0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "DIRECTIONACK",	0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "SCSIENACK",		0x20, 0x20 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahd_dfcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFCNTRL_parse_table, 10, "DFCNTRL",
+	    0x19, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSCOMMAND0_parse_table[] = {
+	{ "CIOPARCKEN",		0x01, 0x01 },
+	{ "DISABLE_TWATE",	0x02, 0x02 },
+	{ "EXTREQLCK",		0x10, 0x10 },
+	{ "MPARCKEN",		0x20, 0x20 },
+	{ "DPARCKEN",		0x40, 0x40 },
+	{ "CACHETHEN",		0x80, 0x80 }
+};
+
+int
+ahd_dscommand0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSCOMMAND0_parse_table, 6, "DSCOMMAND0",
+	    0x19, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFSTATUS_parse_table[] = {
+	{ "FIFOEMP",		0x01, 0x01 },
+	{ "FIFOFULL",		0x02, 0x02 },
+	{ "DFTHRESH",		0x04, 0x04 },
+	{ "HDONE",		0x08, 0x08 },
+	{ "MREQPEND",		0x10, 0x10 },
+	{ "PKT_PRELOAD_AVAIL",	0x40, 0x40 },
+	{ "PRELOAD_AVAIL",	0x80, 0x80 }
+};
+
+int
+ahd_dfstatus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFSTATUS_parse_table, 7, "DFSTATUS",
+	    0x1a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_CACHE_SHADOW_parse_table[] = {
+	{ "LAST_SEG_DONE",	0x01, 0x01 },
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "ODD_SEG",		0x04, 0x04 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_sg_cache_shadow_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_CACHE_SHADOW_parse_table, 4, "SG_CACHE_SHADOW",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ARBCTL_parse_table[] = {
+	{ "USE_TIME",		0x07, 0x07 },
+	{ "RETRY_SWEN",		0x08, 0x08 },
+	{ "RESET_HARB",		0x80, 0x80 }
+};
+
+int
+ahd_arbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ARBCTL_parse_table, 3, "ARBCTL",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_CACHE_PRE_parse_table[] = {
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "ODD_SEG",		0x04, 0x04 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_sg_cache_pre_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_CACHE_PRE_parse_table, 3, "SG_CACHE_PRE",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqin_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQIN",
+	    0x20, regvalue, cur_col, wrap));
+}
+
+int
+ahd_typeptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TYPEPTR",
+	    0x20, regvalue, cur_col, wrap));
+}
+
+int
+ahd_tagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TAGPTR",
+	    0x21, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lunptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LUNPTR",
+	    0x22, regvalue, cur_col, wrap));
+}
+
+int
+ahd_datalenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DATALENPTR",
+	    0x23, regvalue, cur_col, wrap));
+}
+
+int
+ahd_statlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "STATLENPTR",
+	    0x24, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDLENPTR",
+	    0x25, regvalue, cur_col, wrap));
+}
+
+int
+ahd_attrptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ATTRPTR",
+	    0x26, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLAGPTR",
+	    0x27, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDPTR",
+	    0x28, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qnextptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QNEXTPTR",
+	    0x29, regvalue, cur_col, wrap));
+}
+
+int
+ahd_idptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "IDPTR",
+	    0x2a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_abrtbyteptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ABRTBYTEPTR",
+	    0x2b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_abrtbitptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ABRTBITPTR",
+	    0x2c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmdbytes_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMDBYTES",
+	    0x2d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmd2rcv_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMD2RCV",
+	    0x2e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shortthresh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHORTTHRESH",
+	    0x2f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lunlen_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LUNLEN",
+	    0x30, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cdblimit_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CDBLIMIT",
+	    0x31, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmd_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMD",
+	    0x32, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmdcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMDCNT",
+	    0x33, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd01_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD01",
+	    0x34, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd16_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD16",
+	    0x35, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd17_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD17",
+	    0x36, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdrsvd0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDRSVD0",
+	    0x37, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL0_parse_table[] = {
+	{ "LQ0INITGCLT",	0x03, 0x03 },
+	{ "LQ0TARGCLT",		0x0c, 0x0c },
+	{ "LQIINITGCLT",	0x30, 0x30 },
+	{ "LQITARGCLT",		0xc0, 0xc0 }
+};
+
+int
+ahd_lqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL0_parse_table, 4, "LQCTL0",
+	    0x38, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL1_parse_table[] = {
+	{ "ABORTPENDING",	0x01, 0x01 },
+	{ "SINGLECMD",		0x02, 0x02 },
+	{ "PCI2PCI",		0x04, 0x04 }
+};
+
+int
+ahd_lqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL1_parse_table, 3, "LQCTL1",
+	    0x38, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSBIST0_parse_table[] = {
+	{ "OSBISTRUN",		0x01, 0x01 },
+	{ "OSBISTDONE",		0x02, 0x02 },
+	{ "OSBISTERR",		0x04, 0x04 },
+	{ "GSBISTRUN",		0x10, 0x10 },
+	{ "GSBISTDONE",		0x20, 0x20 },
+	{ "GSBISTERR",		0x40, 0x40 }
+};
+
+int
+ahd_scsbist0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSBIST0_parse_table, 6, "SCSBIST0",
+	    0x39, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL2_parse_table[] = {
+	{ "LQOPAUSE",		0x01, 0x01 },
+	{ "LQOTOIDLE",		0x02, 0x02 },
+	{ "LQOCONTINUE",	0x04, 0x04 },
+	{ "LQORETRY",		0x08, 0x08 },
+	{ "LQIPAUSE",		0x10, 0x10 },
+	{ "LQITOIDLE",		0x20, 0x20 },
+	{ "LQICONTINUE",	0x40, 0x40 },
+	{ "LQIRETRY",		0x80, 0x80 }
+};
+
+int
+ahd_lqctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL2_parse_table, 8, "LQCTL2",
+	    0x39, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSBIST1_parse_table[] = {
+	{ "NTBISTRUN",		0x01, 0x01 },
+	{ "NTBISTDONE",		0x02, 0x02 },
+	{ "NTBISTERR",		0x04, 0x04 }
+};
+
+int
+ahd_scsbist1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSBIST1_parse_table, 3, "SCSBIST1",
+	    0x3a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ0_parse_table[] = {
+	{ "SCSIRSTO",		0x01, 0x01 },
+	{ "FORCEBUSFREE",	0x10, 0x10 },
+	{ "ENARBO",		0x20, 0x20 },
+	{ "ENSELO",		0x40, 0x40 },
+	{ "TEMODEO",		0x80, 0x80 }
+};
+
+int
+ahd_scsiseq0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ0_parse_table, 5, "SCSISEQ0",
+	    0x3a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ1_parse_table[] = {
+	{ "ALTSTIM",		0x01, 0x01 },
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "MANUALP",		0x0c, 0x0c },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "MANUALCTL",		0x40, 0x40 }
+};
+
+int
+ahd_scsiseq1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ1_parse_table, 6, "SCSISEQ1",
+	    0x3b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL0_parse_table[] = {
+	{ "SPIOEN",		0x08, 0x08 },
+	{ "BIOSCANCELEN",	0x10, 0x10 },
+	{ "DFPEXP",		0x40, 0x40 },
+	{ "DFON",		0x80, 0x80 }
+};
+
+int
+ahd_sxfrctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL0_parse_table, 4, "SXFRCTL0",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_businitid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BUSINITID",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dlcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DLCOUNT",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL1_parse_table[] = {
+	{ "STPWEN",		0x01, 0x01 },
+	{ "ACTNEGEN",		0x02, 0x02 },
+	{ "ENSTIMER",		0x04, 0x04 },
+	{ "STIMESEL",		0x18, 0x18 },
+	{ "ENSPCHK",		0x20, 0x20 },
+	{ "ENSACHK",		0x40, 0x40 },
+	{ "BITBUCKET",		0x80, 0x80 }
+};
+
+int
+ahd_sxfrctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL1_parse_table, 7, "SXFRCTL1",
+	    0x3d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_bustargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BUSTARGID",
+	    0x3e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL2_parse_table[] = {
+	{ "ASU",		0x07, 0x07 },
+	{ "CMDDMAEN",		0x08, 0x08 },
+	{ "AUTORSTDIS",		0x10, 0x10 }
+};
+
+int
+ahd_sxfrctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL2_parse_table, 3, "SXFRCTL2",
+	    0x3e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFFSTAT_parse_table[] = {
+	{ "CURRFIFO",		0x01, 0x01 },
+	{ "FIFO0FREE",		0x10, 0x10 },
+	{ "FIFO1FREE",		0x20, 0x20 }
+};
+
+int
+ahd_dffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFFSTAT_parse_table, 3, "DFFSTAT",
+	    0x3f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISIGO_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "ACKO",		0x01, 0x01 },
+	{ "REQO",		0x02, 0x02 },
+	{ "BSYO",		0x04, 0x04 },
+	{ "SELO",		0x08, 0x08 },
+	{ "ATNO",		0x10, 0x10 },
+	{ "MSGO",		0x20, 0x20 },
+	{ "IOO",		0x40, 0x40 },
+	{ "CDO",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_scsisigo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISIGO_parse_table, 17, "SCSISIGO",
+	    0x40, regvalue, cur_col, wrap));
+}
+
+int
+ahd_multargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MULTARGID",
+	    0x40, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISIGI_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "ACKI",		0x01, 0x01 },
+	{ "REQI",		0x02, 0x02 },
+	{ "BSYI",		0x04, 0x04 },
+	{ "SELI",		0x08, 0x08 },
+	{ "ATNI",		0x10, 0x10 },
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_scsisigi_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISIGI_parse_table, 17, "SCSISIGI",
+	    0x41, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSIPHASE_parse_table[] = {
+	{ "DATA_OUT_PHASE",	0x01, 0x03 },
+	{ "DATA_IN_PHASE",	0x02, 0x03 },
+	{ "DATA_PHASE_MASK",	0x03, 0x03 },
+	{ "MSG_OUT_PHASE",	0x04, 0x04 },
+	{ "MSG_IN_PHASE",	0x08, 0x08 },
+	{ "COMMAND_PHASE",	0x10, 0x10 },
+	{ "STATUS_PHASE",	0x20, 0x20 }
+};
+
+int
+ahd_scsiphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSIPHASE_parse_table, 7, "SCSIPHASE",
+	    0x42, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsidat0_img_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIDAT0_IMG",
+	    0x43, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsidat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIDAT",
+	    0x44, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsibus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIBUS",
+	    0x46, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t TARGIDIN_parse_table[] = {
+	{ "TARGID",		0x0f, 0x0f },
+	{ "CLKOUT",		0x80, 0x80 }
+};
+
+int
+ahd_targidin_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(TARGIDIN_parse_table, 2, "TARGIDIN",
+	    0x48, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SELID_parse_table[] = {
+	{ "ONEBIT",		0x08, 0x08 },
+	{ "SELID_MASK",		0xf0, 0xf0 }
+};
+
+int
+ahd_selid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SELID_parse_table, 2, "SELID",
+	    0x49, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SBLKCTL_parse_table[] = {
+	{ "SELWIDE",		0x02, 0x02 },
+	{ "ENAB20",		0x04, 0x04 },
+	{ "ENAB40",		0x08, 0x08 },
+	{ "DIAGLEDON",		0x40, 0x40 },
+	{ "DIAGLEDEN",		0x80, 0x80 }
+};
+
+int
+ahd_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SBLKCTL_parse_table, 5, "SBLKCTL",
+	    0x4a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OPTIONMODE_parse_table[] = {
+	{ "AUTO_MSGOUT_DE",	0x02, 0x02 },
+	{ "ENDGFORMCHK",	0x04, 0x04 },
+	{ "BUSFREEREV",		0x10, 0x10 },
+	{ "BIASCANCTL",		0x20, 0x20 },
+	{ "AUTOACKEN",		0x40, 0x40 },
+	{ "BIOSCANCTL",		0x80, 0x80 },
+	{ "OPTIONMODE_DEFAULTS",0x02, 0x02 }
+};
+
+int
+ahd_optionmode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OPTIONMODE_parse_table, 7, "OPTIONMODE",
+	    0x4a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT0_parse_table[] = {
+	{ "ARBDO",		0x01, 0x01 },
+	{ "SPIORDY",		0x02, 0x02 },
+	{ "OVERRUN",		0x04, 0x04 },
+	{ "IOERR",		0x08, 0x08 },
+	{ "SELINGO",		0x10, 0x10 },
+	{ "SELDI",		0x20, 0x20 },
+	{ "SELDO",		0x40, 0x40 },
+	{ "TARGET",		0x80, 0x80 }
+};
+
+int
+ahd_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT0_parse_table, 8, "SSTAT0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT0_parse_table[] = {
+	{ "CLRARBDO",		0x01, 0x01 },
+	{ "CLRSPIORDY",		0x02, 0x02 },
+	{ "CLROVERRUN",		0x04, 0x04 },
+	{ "CLRIOERR",		0x08, 0x08 },
+	{ "CLRSELINGO",		0x10, 0x10 },
+	{ "CLRSELDI",		0x20, 0x20 },
+	{ "CLRSELDO",		0x40, 0x40 }
+};
+
+int
+ahd_clrsint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT0_parse_table, 7, "CLRSINT0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE0_parse_table[] = {
+	{ "ENARBDO",		0x01, 0x01 },
+	{ "ENSPIORDY",		0x02, 0x02 },
+	{ "ENOVERRUN",		0x04, 0x04 },
+	{ "ENIOERR",		0x08, 0x08 },
+	{ "ENSELINGO",		0x10, 0x10 },
+	{ "ENSELDI",		0x20, 0x20 },
+	{ "ENSELDO",		0x40, 0x40 }
+};
+
+int
+ahd_simode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE0_parse_table, 7, "SIMODE0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT1_parse_table[] = {
+	{ "CLRREQINIT",		0x01, 0x01 },
+	{ "CLRSTRB2FAST",	0x02, 0x02 },
+	{ "CLRSCSIPERR",	0x04, 0x04 },
+	{ "CLRBUSFREE",		0x08, 0x08 },
+	{ "CLRSCSIRSTI",	0x20, 0x20 },
+	{ "CLRATNO",		0x40, 0x40 },
+	{ "CLRSELTIMEO",	0x80, 0x80 }
+};
+
+int
+ahd_clrsint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT1_parse_table, 7, "CLRSINT1",
+	    0x4c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT1_parse_table[] = {
+	{ "REQINIT",		0x01, 0x01 },
+	{ "STRB2FAST",		0x02, 0x02 },
+	{ "SCSIPERR",		0x04, 0x04 },
+	{ "BUSFREE",		0x08, 0x08 },
+	{ "PHASEMIS",		0x10, 0x10 },
+	{ "SCSIRSTI",		0x20, 0x20 },
+	{ "ATNTARG",		0x40, 0x40 },
+	{ "SELTO",		0x80, 0x80 }
+};
+
+int
+ahd_sstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT1_parse_table, 8, "SSTAT1",
+	    0x4c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT2_parse_table[] = {
+	{ "BUSFREE_LQO",	0x40, 0xc0 },
+	{ "BUSFREE_DFF0",	0x80, 0xc0 },
+	{ "BUSFREE_DFF1",	0xc0, 0xc0 },
+	{ "DMADONE",		0x01, 0x01 },
+	{ "SDONE",		0x02, 0x02 },
+	{ "WIDE_RES",		0x04, 0x04 },
+	{ "BSYX",		0x08, 0x08 },
+	{ "EXP_ACTIVE",		0x10, 0x10 },
+	{ "NONPACKREQ",		0x20, 0x20 },
+	{ "BUSFREETIME",	0xc0, 0xc0 }
+};
+
+int
+ahd_sstat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT2_parse_table, 10, "SSTAT2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT2_parse_table[] = {
+	{ "CLRDMADONE",		0x01, 0x01 },
+	{ "CLRSDONE",		0x02, 0x02 },
+	{ "CLRWIDE_RES",	0x04, 0x04 },
+	{ "CLRNONPACKREQ",	0x20, 0x20 }
+};
+
+int
+ahd_clrsint2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT2_parse_table, 4, "CLRSINT2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE2_parse_table[] = {
+	{ "ENDMADONE",		0x01, 0x01 },
+	{ "ENSDONE",		0x02, 0x02 },
+	{ "ENWIDE_RES",		0x04, 0x04 }
+};
+
+int
+ahd_simode2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE2_parse_table, 3, "SIMODE2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PERRDIAG_parse_table[] = {
+	{ "DTERR",		0x01, 0x01 },
+	{ "DGFORMERR",		0x02, 0x02 },
+	{ "CRCERR",		0x04, 0x04 },
+	{ "AIPERR",		0x08, 0x08 },
+	{ "PARITYERR",		0x10, 0x10 },
+	{ "PREVPHASE",		0x20, 0x20 },
+	{ "HIPERR",		0x40, 0x40 },
+	{ "HIZERO",		0x80, 0x80 }
+};
+
+int
+ahd_perrdiag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PERRDIAG_parse_table, 8, "PERRDIAG",
+	    0x4e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqistate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQISTATE",
+	    0x4e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_soffcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SOFFCNT",
+	    0x4f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqostate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQOSTATE",
+	    0x4f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT0_parse_table[] = {
+	{ "LQIATNCMD",		0x01, 0x01 },
+	{ "LQIATNLQ",		0x02, 0x02 },
+	{ "LQIBADLQT",		0x04, 0x04 },
+	{ "LQICRCT2",		0x08, 0x08 },
+	{ "LQICRCT1",		0x10, 0x10 },
+	{ "LQIATNQAS",		0x20, 0x20 }
+};
+
+int
+ahd_lqistat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT0_parse_table, 6, "LQISTAT0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQIINT0_parse_table[] = {
+	{ "CLRLQIATNCMD",	0x01, 0x01 },
+	{ "CLRLQIATNLQ",	0x02, 0x02 },
+	{ "CLRLQIBADLQT",	0x04, 0x04 },
+	{ "CLRLQICRCT2",	0x08, 0x08 },
+	{ "CLRLQICRCT1",	0x10, 0x10 },
+	{ "CLRLQIATNQAS",	0x20, 0x20 }
+};
+
+int
+ahd_clrlqiint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQIINT0_parse_table, 6, "CLRLQIINT0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQIMODE0_parse_table[] = {
+	{ "ENLQIATNCMD",	0x01, 0x01 },
+	{ "ENLQIATNLQ",		0x02, 0x02 },
+	{ "ENLQIBADLQT",	0x04, 0x04 },
+	{ "ENLQICRCT2",		0x08, 0x08 },
+	{ "ENLQICRCT1",		0x10, 0x10 },
+	{ "ENLQIATNQASK",	0x20, 0x20 }
+};
+
+int
+ahd_lqimode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQIMODE0_parse_table, 6, "LQIMODE0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQIMODE1_parse_table[] = {
+	{ "ENLQIOVERI_NLQ",	0x01, 0x01 },
+	{ "ENLQIOVERI_LQ",	0x02, 0x02 },
+	{ "ENLQIBADLQI",	0x04, 0x04 },
+	{ "ENLQICRCI_NLQ",	0x08, 0x08 },
+	{ "ENLQICRCI_LQ",	0x10, 0x10 },
+	{ "ENLIQABORT",		0x20, 0x20 },
+	{ "ENLQIPHASE_NLQ",	0x40, 0x40 },
+	{ "ENLQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_lqimode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQIMODE1_parse_table, 8, "LQIMODE1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT1_parse_table[] = {
+	{ "LQIOVERI_NLQ",	0x01, 0x01 },
+	{ "LQIOVERI_LQ",	0x02, 0x02 },
+	{ "LQIBADLQI",		0x04, 0x04 },
+	{ "LQICRCI_NLQ",	0x08, 0x08 },
+	{ "LQICRCI_LQ",		0x10, 0x10 },
+	{ "LQIABORT",		0x20, 0x20 },
+	{ "LQIPHASE_NLQ",	0x40, 0x40 },
+	{ "LQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_lqistat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT1_parse_table, 8, "LQISTAT1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQIINT1_parse_table[] = {
+	{ "CLRLQIOVERI_NLQ",	0x01, 0x01 },
+	{ "CLRLQIOVERI_LQ",	0x02, 0x02 },
+	{ "CLRLQIBADLQI",	0x04, 0x04 },
+	{ "CLRLQICRCI_NLQ",	0x08, 0x08 },
+	{ "CLRLQICRCI_LQ",	0x10, 0x10 },
+	{ "CLRLIQABORT",	0x20, 0x20 },
+	{ "CLRLQIPHASE_NLQ",	0x40, 0x40 },
+	{ "CLRLQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_clrlqiint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQIINT1_parse_table, 8, "CLRLQIINT1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT2_parse_table[] = {
+	{ "LQIGSAVAIL",		0x01, 0x01 },
+	{ "LQISTOPCMD",		0x02, 0x02 },
+	{ "LQISTOPLQ",		0x04, 0x04 },
+	{ "LQISTOPPKT",		0x08, 0x08 },
+	{ "LQIWAITFIFO",	0x10, 0x10 },
+	{ "LQIWORKONLQ",	0x20, 0x20 },
+	{ "LQIPHASE_OUTPKT",	0x40, 0x40 },
+	{ "PACKETIZED",		0x80, 0x80 }
+};
+
+int
+ahd_lqistat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT2_parse_table, 8, "LQISTAT2",
+	    0x52, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT3_parse_table[] = {
+	{ "OSRAMPERR",		0x01, 0x01 },
+	{ "NTRAMPERR",		0x02, 0x02 }
+};
+
+int
+ahd_sstat3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT3_parse_table, 2, "SSTAT3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE3_parse_table[] = {
+	{ "ENOSRAMPERR",	0x01, 0x01 },
+	{ "ENNTRAMPERR",	0x02, 0x02 }
+};
+
+int
+ahd_simode3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE3_parse_table, 2, "SIMODE3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT3_parse_table[] = {
+	{ "CLROSRAMPERR",	0x01, 0x01 },
+	{ "CLRNTRAMPERR",	0x02, 0x02 }
+};
+
+int
+ahd_clrsint3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT3_parse_table, 2, "CLRSINT3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOMODE0_parse_table[] = {
+	{ "ENLQOTCRC",		0x01, 0x01 },
+	{ "ENLQOATNPKT",	0x02, 0x02 },
+	{ "ENLQOATNLQ",		0x04, 0x04 },
+	{ "ENLQOSTOPT2",	0x08, 0x08 },
+	{ "ENLQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE0_parse_table, 5, "LQOMODE0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT0_parse_table[] = {
+	{ "LQOTCRC",		0x01, 0x01 },
+	{ "LQOATNPKT",		0x02, 0x02 },
+	{ "LQOATNLQ",		0x04, 0x04 },
+	{ "LQOSTOPT2",		0x08, 0x08 },
+	{ "LQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqostat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT0_parse_table, 5, "LQOSTAT0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQOINT0_parse_table[] = {
+	{ "CLRLQOTCRC",		0x01, 0x01 },
+	{ "CLRLQOATNPKT",	0x02, 0x02 },
+	{ "CLRLQOATNLQ",	0x04, 0x04 },
+	{ "CLRLQOSTOPT2",	0x08, 0x08 },
+	{ "CLRLQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_clrlqoint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQOINT0_parse_table, 5, "CLRLQOINT0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT1_parse_table[] = {
+	{ "LQOPHACHGINPKT",	0x01, 0x01 },
+	{ "LQOBUSFREE",		0x02, 0x02 },
+	{ "LQOBADQAS",		0x04, 0x04 },
+	{ "LQOSTOPI2",		0x08, 0x08 },
+	{ "LQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqostat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT1_parse_table, 5, "LQOSTAT1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQOINT1_parse_table[] = {
+	{ "CLRLQOPHACHGINPKT",	0x01, 0x01 },
+	{ "CLRLQOBUSFREE",	0x02, 0x02 },
+	{ "CLRLQOBADQAS",	0x04, 0x04 },
+	{ "CLRLQOSTOPI2",	0x08, 0x08 },
+	{ "CLRLQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_clrlqoint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQOINT1_parse_table, 5, "CLRLQOINT1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOMODE1_parse_table[] = {
+	{ "ENLQOPHACHGINPKT",	0x01, 0x01 },
+	{ "ENLQOBUSFREE",	0x02, 0x02 },
+	{ "ENLQOBADQAS",	0x04, 0x04 },
+	{ "ENLQOSTOPI2",	0x08, 0x08 },
+	{ "ENLQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE1_parse_table, 5, "LQOMODE1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT2_parse_table[] = {
+	{ "LQOSTOP0",		0x01, 0x01 },
+	{ "LQOPHACHGOUTPKT",	0x02, 0x02 },
+	{ "LQOWAITFIFO",	0x10, 0x10 },
+	{ "LQOPKT",		0xe0, 0xe0 }
+};
+
+int
+ahd_lqostat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT2_parse_table, 4, "LQOSTAT2",
+	    0x56, regvalue, cur_col, wrap));
+}
+
+int
+ahd_os_space_cnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OS_SPACE_CNT",
+	    0x56, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE1_parse_table[] = {
+	{ "ENREQINIT",		0x01, 0x01 },
+	{ "ENSTRB2FAST",	0x02, 0x02 },
+	{ "ENSCSIPERR",		0x04, 0x04 },
+	{ "ENBUSFREE",		0x08, 0x08 },
+	{ "ENPHASEMIS",		0x10, 0x10 },
+	{ "ENSCSIRST",		0x20, 0x20 },
+	{ "ENATNTARG",		0x40, 0x40 },
+	{ "ENSELTIMO",		0x80, 0x80 }
+};
+
+int
+ahd_simode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE1_parse_table, 8, "SIMODE1",
+	    0x57, regvalue, cur_col, wrap));
+}
+
+int
+ahd_gsfifo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "GSFIFO",
+	    0x58, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFFSXFRCTL_parse_table[] = {
+	{ "RSTCHN",		0x01, 0x01 },
+	{ "CLRCHN",		0x02, 0x02 },
+	{ "CLRSHCNT",		0x04, 0x04 }
+};
+
+int
+ahd_dffsxfrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFFSXFRCTL_parse_table, 3, "DFFSXFRCTL",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_nextscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEXTSCB",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSEQINTSRC_parse_table[] = {
+	{ "CLRCFG4TCMD",	0x01, 0x01 },
+	{ "CLRCFG4ICMD",	0x02, 0x02 },
+	{ "CLRCFG4TSTAT",	0x04, 0x04 },
+	{ "CLRCFG4ISTAT",	0x08, 0x08 },
+	{ "CLRCFG4DATA",	0x10, 0x10 },
+	{ "CLRSAVEPTRS",	0x20, 0x20 },
+	{ "CLRCTXTDONE",	0x40, 0x40 }
+};
+
+int
+ahd_clrseqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSEQINTSRC_parse_table, 7, "CLRSEQINTSRC",
+	    0x5b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTSRC_parse_table[] = {
+	{ "CFG4TCMD",		0x01, 0x01 },
+	{ "CFG4ICMD",		0x02, 0x02 },
+	{ "CFG4TSTAT",		0x04, 0x04 },
+	{ "CFG4ISTAT",		0x08, 0x08 },
+	{ "CFG4DATA",		0x10, 0x10 },
+	{ "SAVEPTRS",		0x20, 0x20 },
+	{ "CTXTDONE",		0x40, 0x40 }
+};
+
+int
+ahd_seqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTSRC_parse_table, 7, "SEQINTSRC",
+	    0x5b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_currscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CURRSCB",
+	    0x5c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQIMODE_parse_table[] = {
+	{ "ENCFG4TCMD",		0x01, 0x01 },
+	{ "ENCFG4ICMD",		0x02, 0x02 },
+	{ "ENCFG4TSTAT",	0x04, 0x04 },
+	{ "ENCFG4ISTAT",	0x08, 0x08 },
+	{ "ENCFG4DATA",		0x10, 0x10 },
+	{ "ENSAVEPTRS",		0x20, 0x20 },
+	{ "ENCTXTDONE",		0x40, 0x40 }
+};
+
+int
+ahd_seqimode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQIMODE_parse_table, 7, "SEQIMODE",
+	    0x5c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t MDFFSTAT_parse_table[] = {
+	{ "FIFOFREE",		0x01, 0x01 },
+	{ "DATAINFIFO",		0x02, 0x02 },
+	{ "DLZERO",		0x04, 0x04 },
+	{ "SHVALID",		0x08, 0x08 },
+	{ "LASTSDONE",		0x10, 0x10 },
+	{ "SHCNTMINUS1",	0x20, 0x20 },
+	{ "SHCNTNEGATIVE",	0x40, 0x40 }
+};
+
+int
+ahd_mdffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MDFFSTAT_parse_table, 7, "MDFFSTAT",
+	    0x5d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CRCCONTROL_parse_table[] = {
+	{ "CRCVALCHKEN",	0x40, 0x40 }
+};
+
+int
+ahd_crccontrol_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CRCCONTROL_parse_table, 1, "CRCCONTROL",
+	    0x5d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfftag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFFTAG",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lastscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LASTSCB",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSITEST_parse_table[] = {
+	{ "SEL_TXPLL_DEBUG",	0x04, 0x04 },
+	{ "CNTRTEST",		0x08, 0x08 }
+};
+
+int
+ahd_scsitest_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSITEST_parse_table, 2, "SCSITEST",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t IOPDNCTL_parse_table[] = {
+	{ "PDN_DIFFSENSE",	0x01, 0x01 },
+	{ "PDN_IDIST",		0x04, 0x04 },
+	{ "DISABLE_OE",		0x80, 0x80 }
+};
+
+int
+ahd_iopdnctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(IOPDNCTL_parse_table, 3, "IOPDNCTL",
+	    0x5f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHADDR",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negoaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGOADDR",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dgrpcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DGRPCRCI",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negperiod_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGPERIOD",
+	    0x61, regvalue, cur_col, wrap));
+}
+
+int
+ahd_packcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PACKCRCI",
+	    0x62, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negoffset_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGOFFSET",
+	    0x62, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NEGPPROPTS_parse_table[] = {
+	{ "PPROPT_IUT",		0x01, 0x01 },
+	{ "PPROPT_DT",		0x02, 0x02 },
+	{ "PPROPT_QAS",		0x04, 0x04 },
+	{ "PPROPT_PACE",	0x08, 0x08 }
+};
+
+int
+ahd_negppropts_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NEGPPROPTS_parse_table, 4, "NEGPPROPTS",
+	    0x63, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NEGCONOPTS_parse_table[] = {
+	{ "WIDEXFER",		0x01, 0x01 },
+	{ "ENAUTOATNO",		0x02, 0x02 },
+	{ "ENAUTOATNI",		0x04, 0x04 },
+	{ "ENAIP",		0x08, 0x08 }
+};
+
+int
+ahd_negconopts_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NEGCONOPTS_parse_table, 4, "NEGCONOPTS",
+	    0x64, regvalue, cur_col, wrap));
+}
+
+int
+ahd_annexcol_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ANNEXCOL",
+	    0x65, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSCHKN_parse_table[] = {
+	{ "LSTSGCLRDIS",	0x01, 0x01 },
+	{ "SHVALIDSTDIS",	0x02, 0x02 },
+	{ "DFFACTCLR",		0x04, 0x04 },
+	{ "SDONEMSKDIS",	0x08, 0x08 },
+	{ "WIDERESEN",		0x10, 0x10 },
+	{ "CURFIFODEF",		0x20, 0x20 },
+	{ "STSELSKIDDIS",	0x40, 0x40 }
+};
+
+int
+ahd_scschkn_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSCHKN_parse_table, 7, "SCSCHKN",
+	    0x66, regvalue, cur_col, wrap));
+}
+
+int
+ahd_annexdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ANNEXDAT",
+	    0x66, regvalue, cur_col, wrap));
+}
+
+int
+ahd_iownid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "IOWNID",
+	    0x67, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL960CTL0_parse_table[] = {
+	{ "PLL_ENFBM",		0x01, 0x01 },
+	{ "PLL_DLPF",		0x02, 0x02 },
+	{ "PLL_ENLPF",		0x04, 0x04 },
+	{ "PLL_ENLUD",		0x08, 0x08 },
+	{ "PLL_NS",		0x30, 0x30 },
+	{ "PLL_PWDN",		0x40, 0x40 },
+	{ "PLL_VCOSEL",		0x80, 0x80 }
+};
+
+int
+ahd_pll960ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL960CTL0_parse_table, 7, "PLL960CTL0",
+	    0x68, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHCNT",
+	    0x68, regvalue, cur_col, wrap));
+}
+
+int
+ahd_townid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TOWNID",
+	    0x69, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL960CTL1_parse_table[] = {
+	{ "PLL_RST",		0x01, 0x01 },
+	{ "PLL_CNTCLR",		0x40, 0x40 },
+	{ "PLL_CNTEN",		0x80, 0x80 }
+};
+
+int
+ahd_pll960ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL960CTL1_parse_table, 3, "PLL960CTL1",
+	    0x69, regvalue, cur_col, wrap));
+}
+
+int
+ahd_pll960cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PLL960CNT0",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_xsig_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "XSIG",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seloid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SELOID",
+	    0x6b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL400CTL0_parse_table[] = {
+	{ "PLL_ENFBM",		0x01, 0x01 },
+	{ "PLL_DLPF",		0x02, 0x02 },
+	{ "PLL_ENLPF",		0x04, 0x04 },
+	{ "PLL_ENLUD",		0x08, 0x08 },
+	{ "PLL_NS",		0x30, 0x30 },
+	{ "PLL_PWDN",		0x40, 0x40 },
+	{ "PLL_VCOSEL",		0x80, 0x80 }
+};
+
+int
+ahd_pll400ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL400CTL0_parse_table, 7, "PLL400CTL0",
+	    0x6c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_fairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FAIRNESS",
+	    0x6c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL400CTL1_parse_table[] = {
+	{ "PLL_RST",		0x01, 0x01 },
+	{ "PLL_CNTCLR",		0x40, 0x40 },
+	{ "PLL_CNTEN",		0x80, 0x80 }
+};
+
+int
+ahd_pll400ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL400CTL1_parse_table, 3, "PLL400CTL1",
+	    0x6d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_pll400cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PLL400CNT0",
+	    0x6e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_unfairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "UNFAIRNESS",
+	    0x6e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_haddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HADDR",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmaadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMAADR",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMACNT",
+	    0x78, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HCNT",
+	    0x78, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmaen_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMAEN",
+	    0x7a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sghaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGHADDR",
+	    0x7c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbhaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBHADDR",
+	    0x7c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sghcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGHCNT",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbhcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBHCNT",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFF_THRSH_parse_table[] = {
+	{ "WR_DFTHRSH_MIN",	0x00, 0x70 },
+	{ "RD_DFTHRSH_MIN",	0x00, 0x07 },
+	{ "RD_DFTHRSH_25",	0x01, 0x07 },
+	{ "RD_DFTHRSH_50",	0x02, 0x07 },
+	{ "RD_DFTHRSH_63",	0x03, 0x07 },
+	{ "RD_DFTHRSH_75",	0x04, 0x07 },
+	{ "RD_DFTHRSH_85",	0x05, 0x07 },
+	{ "RD_DFTHRSH_90",	0x06, 0x07 },
+	{ "RD_DFTHRSH_MAX",	0x07, 0x07 },
+	{ "WR_DFTHRSH_25",	0x10, 0x70 },
+	{ "WR_DFTHRSH_50",	0x20, 0x70 },
+	{ "WR_DFTHRSH_63",	0x30, 0x70 },
+	{ "WR_DFTHRSH_75",	0x40, 0x70 },
+	{ "WR_DFTHRSH_85",	0x50, 0x70 },
+	{ "WR_DFTHRSH_90",	0x60, 0x70 },
+	{ "WR_DFTHRSH_MAX",	0x70, 0x70 },
+	{ "RD_DFTHRSH",		0x07, 0x07 },
+	{ "WR_DFTHRSH",		0x70, 0x70 }
+};
+
+int
+ahd_dff_thrsh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFF_THRSH_parse_table, 18, "DFF_THRSH",
+	    0x88, regvalue, cur_col, wrap));
+}
+
+int
+ahd_romaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ROMADDR",
+	    0x8a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ROMCNTRL_parse_table[] = {
+	{ "RDY",		0x01, 0x01 },
+	{ "REPEAT",		0x02, 0x02 },
+	{ "ROMSPD",		0x18, 0x18 },
+	{ "ROMOP",		0xe0, 0xe0 }
+};
+
+int
+ahd_romcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ROMCNTRL_parse_table, 4, "ROMCNTRL",
+	    0x8d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_romdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ROMDATA",
+	    0x8e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_cmcrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG0_parse_table, 2, "CMCRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ROENABLE_parse_table[] = {
+	{ "DCH0ROEN",		0x01, 0x01 },
+	{ "DCH1ROEN",		0x02, 0x02 },
+	{ "SGROEN",		0x04, 0x04 },
+	{ "CMCROEN",		0x08, 0x08 },
+	{ "OVLYROEN",		0x10, 0x10 },
+	{ "MSIROEN",		0x20, 0x20 }
+};
+
+int
+ahd_roenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ROENABLE_parse_table, 6, "ROENABLE",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_ovlyrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG0_parse_table, 2, "OVLYRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_dchrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG0_parse_table, 2, "DCHRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_ovlyrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG1_parse_table, 1, "OVLYRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NSENABLE_parse_table[] = {
+	{ "DCH0NSEN",		0x01, 0x01 },
+	{ "DCH1NSEN",		0x02, 0x02 },
+	{ "SGNSEN",		0x04, 0x04 },
+	{ "CMCNSEN",		0x08, 0x08 },
+	{ "OVLYNSEN",		0x10, 0x10 },
+	{ "MSINSEN",		0x20, 0x20 }
+};
+
+int
+ahd_nsenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NSENABLE_parse_table, 6, "NSENABLE",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_dchrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG1_parse_table, 1, "DCHRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_cmcrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG1_parse_table, 1, "CMCRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_dchrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG2_parse_table, 1, "DCHRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_ovlyrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG2_parse_table, 1, "OVLYRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_cmcrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG2_parse_table, 1, "CMCRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ost_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OST",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_dchrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG3_parse_table, 1, "DCHRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_cmcrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG3_parse_table, 1, "CMCRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PCIXCTL_parse_table[] = {
+	{ "CMPABCDIS",		0x01, 0x01 },
+	{ "TSCSERREN",		0x02, 0x02 },
+	{ "SRSPDPEEN",		0x04, 0x04 },
+	{ "SPLTSTADIS",		0x08, 0x08 },
+	{ "SPLTSMADIS",		0x10, 0x10 },
+	{ "UNEXPSCIEN",		0x20, 0x20 },
+	{ "SERRPULSE",		0x80, 0x80 }
+};
+
+int
+ahd_pcixctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PCIXCTL_parse_table, 7, "PCIXCTL",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_ovlyrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG3_parse_table, 1, "OVLYRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ovlyseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OVLYSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmcseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMCSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dchseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DCHSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_cmcspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCSPLTSTAT0_parse_table, 8, "CMCSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_ovlyspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYSPLTSTAT0_parse_table, 8, "OVLYSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_dchspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHSPLTSTAT0_parse_table, 8, "DCHSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_dchspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHSPLTSTAT1_parse_table, 1, "DCHSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_cmcspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCSPLTSTAT1_parse_table, 1, "CMCSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_ovlyspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYSPLTSTAT1_parse_table, 1, "OVLYSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_sgrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG0_parse_table, 2, "SGRXMSG0",
+	    0x98, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR0_parse_table[] = {
+	{ "LOWER_ADDR",		0x7f, 0x7f }
+};
+
+int
+ahd_slvspltoutadr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR0_parse_table, 1, "SLVSPLTOUTADR0",
+	    0x98, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_sgrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG1_parse_table, 1, "SGRXMSG1",
+	    0x99, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR1_parse_table[] = {
+	{ "REQ_FNUM",		0x07, 0x07 },
+	{ "REQ_DNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_slvspltoutadr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR1_parse_table, 2, "SLVSPLTOUTADR1",
+	    0x99, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_sgrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG2_parse_table, 1, "SGRXMSG2",
+	    0x9a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR2_parse_table[] = {
+	{ "REQ_BNUM",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutadr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR2_parse_table, 1, "SLVSPLTOUTADR2",
+	    0x9a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_sgrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG3_parse_table, 1, "SGRXMSG3",
+	    0x9b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR3_parse_table[] = {
+	{ "RLXORD",		0x10, 0x10 },
+	{ "TAG_NUM",		0x1f, 0x1f }
+};
+
+int
+ahd_slvspltoutadr3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR3_parse_table, 2, "SLVSPLTOUTADR3",
+	    0x9b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sgseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGSEQBCNT",
+	    0x9c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR0_parse_table[] = {
+	{ "LOWER_BCNT",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutattr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR0_parse_table, 1, "SLVSPLTOUTATTR0",
+	    0x9c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR1_parse_table[] = {
+	{ "CMPLT_FNUM",		0x07, 0x07 },
+	{ "CMPLT_DNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_slvspltoutattr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR1_parse_table, 2, "SLVSPLTOUTATTR1",
+	    0x9d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR2_parse_table[] = {
+	{ "CMPLT_BNUM",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutattr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR2_parse_table, 1, "SLVSPLTOUTATTR2",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_sgspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGSPLTSTAT0_parse_table, 8, "SGSPLTSTAT0",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SFUNCT_parse_table[] = {
+	{ "TEST_NUM",		0x0f, 0x0f },
+	{ "TEST_GROUP",		0xf0, 0xf0 }
+};
+
+int
+ahd_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SFUNCT_parse_table, 2, "SFUNCT",
+	    0x9f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_sgspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGSPLTSTAT1_parse_table, 1, "SGSPLTSTAT1",
+	    0x9f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DF0PCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_df0pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DF0PCISTAT_parse_table, 8, "DF0PCISTAT",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG0",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DF1PCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_df1pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DF1PCISTAT_parse_table, 8, "DF1PCISTAT",
+	    0xa1, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_sgpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGPCISTAT_parse_table, 7, "SGPCISTAT",
+	    0xa2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG1",
+	    0xa2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_cmcpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCPCISTAT_parse_table, 8, "CMCPCISTAT",
+	    0xa3, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_ovlypcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYPCISTAT_parse_table, 7, "OVLYPCISTAT",
+	    0xa4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg_isr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG_ISR",
+	    0xa4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_STATE_parse_table[] = {
+	{ "SEGS_AVAIL",		0x01, 0x01 },
+	{ "LOADING_NEEDED",	0x02, 0x02 },
+	{ "FETCH_INPROG",	0x04, 0x04 }
+};
+
+int
+ahd_sg_state_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_STATE_parse_table, 3, "SG_STATE",
+	    0xa6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t MSIPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "CLRPENDMSI",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 }
+};
+
+int
+ahd_msipcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MSIPCISTAT_parse_table, 6, "MSIPCISTAT",
+	    0xa6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t TARGPCISTAT_parse_table[] = {
+	{ "TWATERR",		0x02, 0x02 },
+	{ "STA",		0x08, 0x08 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_targpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(TARGPCISTAT_parse_table, 4, "TARGPCISTAT",
+	    0xa6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_data_count_odd_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DATA_COUNT_ODD",
+	    0xa7, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBPTR",
+	    0xa8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBACNT",
+	    0xab, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCBAUTOPTR_parse_table[] = {
+	{ "SCBPTR_OFF",		0x07, 0x07 },
+	{ "SCBPTR_ADDR",	0x38, 0x38 },
+	{ "AUSCBPTR_EN",	0x80, 0x80 }
+};
+
+int
+ahd_scbautoptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCBAUTOPTR_parse_table, 3, "SCBAUTOPTR",
+	    0xab, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccsgaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSGADDR",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBADDR",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbadr_bk_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBADR_BK",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMC_RAMBIST_parse_table[] = {
+	{ "CMC_BUFFER_BIST_EN",	0x01, 0x01 },
+	{ "CMC_BUFFER_BIST_FAIL",0x02, 0x02 },
+	{ "SG_BIST_EN",		0x10, 0x10 },
+	{ "SG_BIST_FAIL",	0x20, 0x20 },
+	{ "SCBRAMBIST_FAIL",	0x40, 0x40 },
+	{ "SG_ELEMENT_SIZE",	0x80, 0x80 }
+};
+
+int
+ahd_cmc_rambist_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMC_RAMBIST_parse_table, 6, "CMC_RAMBIST",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CCSGCTL_parse_table[] = {
+	{ "CCSGRESET",		0x01, 0x01 },
+	{ "SG_FETCH_REQ",	0x02, 0x02 },
+	{ "CCSGEN",		0x08, 0x08 },
+	{ "SG_CACHE_AVAIL",	0x10, 0x10 },
+	{ "CCSGDONE",		0x80, 0x80 }
+};
+
+int
+ahd_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CCSGCTL_parse_table, 5, "CCSGCTL",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CCSCBCTL_parse_table[] = {
+	{ "CCSCBRESET",		0x01, 0x01 },
+	{ "CCSCBDIR",		0x04, 0x04 },
+	{ "CCSCBEN",		0x08, 0x08 },
+	{ "CCARREN",		0x10, 0x10 },
+	{ "ARRDONE",		0x40, 0x40 },
+	{ "CCSCBDONE",		0x80, 0x80 }
+};
+
+int
+ahd_ccscbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CCSCBCTL_parse_table, 6, "CCSCBCTL",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccsgram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSGRAM",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXADR",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBRAM",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXCNT",
+	    0xb3, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t FLEXDMASTAT_parse_table[] = {
+	{ "FLEXDMADONE",	0x01, 0x01 },
+	{ "FLEXDMAERR",		0x02, 0x02 }
+};
+
+int
+ahd_flexdmastat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(FLEXDMASTAT_parse_table, 2, "FLEXDMASTAT",
+	    0xb5, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXDATA",
+	    0xb6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_brddat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BRDDAT",
+	    0xb8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t BRDCTL_parse_table[] = {
+	{ "BRDSTB",		0x01, 0x01 },
+	{ "BRDRW",		0x02, 0x02 },
+	{ "BRDEN",		0x04, 0x04 },
+	{ "BRDADDR",		0x38, 0x38 },
+	{ "FLXARBREQ",		0x40, 0x40 },
+	{ "FLXARBACK",		0x80, 0x80 }
+};
+
+int
+ahd_brdctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(BRDCTL_parse_table, 6, "BRDCTL",
+	    0xb9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seeadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEEADR",
+	    0xba, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seedat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEEDAT",
+	    0xbc, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEECTL_parse_table[] = {
+	{ "SEEOP_ERAL",		0x40, 0x70 },
+	{ "SEEOP_WRITE",	0x50, 0x70 },
+	{ "SEEOP_READ",		0x60, 0x70 },
+	{ "SEEOP_ERASE",	0x70, 0x70 },
+	{ "SEESTART",		0x01, 0x01 },
+	{ "SEERST",		0x02, 0x02 },
+	{ "SEEOPCODE",		0x70, 0x70 },
+	{ "SEEOP_EWEN",		0x40, 0x40 },
+	{ "SEEOP_WALL",		0x40, 0x40 },
+	{ "SEEOP_EWDS",		0x40, 0x40 }
+};
+
+int
+ahd_seectl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEECTL_parse_table, 10, "SEECTL",
+	    0xbe, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEESTAT_parse_table[] = {
+	{ "SEESTART",		0x01, 0x01 },
+	{ "SEEBUSY",		0x02, 0x02 },
+	{ "SEEARBACK",		0x04, 0x04 },
+	{ "LDALTID_L",		0x08, 0x08 },
+	{ "SEEOPCODE",		0x70, 0x70 },
+	{ "INIT_DONE",		0x80, 0x80 }
+};
+
+int
+ahd_seestat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEESTAT_parse_table, 6, "SEESTAT",
+	    0xbe, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBCNT",
+	    0xbf, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfwaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFWADDR",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPFLTRCTL_parse_table[] = {
+	{ "DSPFCNTSEL",		0x0f, 0x0f },
+	{ "EDGESENSE",		0x10, 0x10 },
+	{ "FLTRDISABLE",	0x20, 0x20 }
+};
+
+int
+ahd_dspfltrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPFLTRCTL_parse_table, 3, "DSPFLTRCTL",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSEQINTSTAT_parse_table[] = {
+	{ "CLRSEQ_SPLTINT",	0x01, 0x01 },
+	{ "CLRSEQ_PCIINT",	0x02, 0x02 },
+	{ "CLRSEQ_SCSIINT",	0x04, 0x04 },
+	{ "CLRSEQ_SEQINT",	0x08, 0x08 },
+	{ "CLRSEQ_SWTMRTO",	0x10, 0x10 }
+};
+
+int
+ahd_clrseqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSEQINTSTAT_parse_table, 5, "CLRSEQINTSTAT",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPDATACTL_parse_table[] = {
+	{ "XMITOFFSTDIS",	0x02, 0x02 },
+	{ "RCVROFFSTDIS",	0x04, 0x04 },
+	{ "DESQDIS",		0x10, 0x10 },
+	{ "BYPASSENAB",		0x80, 0x80 }
+};
+
+int
+ahd_dspdatactl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPDATACTL_parse_table, 4, "DSPDATACTL",
+	    0xc1, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfraddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFRADDR",
+	    0xc2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPREQCTL_parse_table[] = {
+	{ "MANREQDLY",		0x3f, 0x3f },
+	{ "MANREQCTL",		0xc0, 0xc0 }
+};
+
+int
+ahd_dspreqctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPREQCTL_parse_table, 2, "DSPREQCTL",
+	    0xc2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPACKCTL_parse_table[] = {
+	{ "MANACKDLY",		0x3f, 0x3f },
+	{ "MANACKCTL",		0xc0, 0xc0 }
+};
+
+int
+ahd_dspackctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPACKCTL_parse_table, 2, "DSPACKCTL",
+	    0xc3, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFDAT",
+	    0xc4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPSELECT_parse_table[] = {
+	{ "DSPSEL",		0x1f, 0x1f },
+	{ "AUTOINCEN",		0x80, 0x80 }
+};
+
+int
+ahd_dspselect_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPSELECT_parse_table, 2, "DSPSELECT",
+	    0xc4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t WRTBIASCTL_parse_table[] = {
+	{ "XMITMANVAL",		0x3f, 0x3f },
+	{ "AUTOXBCDIS",		0x80, 0x80 }
+};
+
+int
+ahd_wrtbiasctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(WRTBIASCTL_parse_table, 2, "WRTBIASCTL",
+	    0xc5, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t RCVRBIOSCTL_parse_table[] = {
+	{ "RCVRMANVAL",		0x3f, 0x3f },
+	{ "AUTORBCDIS",		0x80, 0x80 }
+};
+
+int
+ahd_rcvrbiosctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(RCVRBIOSCTL_parse_table, 2, "RCVRBIOSCTL",
+	    0xc6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_wrtbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WRTBIASCALC",
+	    0xc7, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfptrs_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFPTRS",
+	    0xc8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_rcvrbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "RCVRBIASCALC",
+	    0xc8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFDBCTL_parse_table[] = {
+	{ "DFF_RAMBIST_EN",	0x01, 0x01 },
+	{ "DFF_RAMBIST_DONE",	0x02, 0x02 },
+	{ "DFF_RAMBIST_FAIL",	0x04, 0x04 },
+	{ "DFF_DIR_ERR",	0x08, 0x08 },
+	{ "DFF_CIO_RD_RDY",	0x10, 0x10 },
+	{ "DFF_CIO_WR_RDY",	0x20, 0x20 }
+};
+
+int
+ahd_dfdbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFDBCTL_parse_table, 6, "DFDBCTL",
+	    0xc8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfbkptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFBKPTR",
+	    0xc9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_skewcalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SKEWCALC",
+	    0xc9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfscnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFSCNT",
+	    0xcc, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFBCNT",
+	    0xce, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ovlyaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OVLYADDR",
+	    0xd4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQCTL0_parse_table[] = {
+	{ "LOADRAM",		0x01, 0x01 },
+	{ "SEQRESET",		0x02, 0x02 },
+	{ "STEP",		0x04, 0x04 },
+	{ "BRKADRINTEN",	0x08, 0x08 },
+	{ "FASTMODE",		0x10, 0x10 },
+	{ "FAILDIS",		0x20, 0x20 },
+	{ "PAUSEDIS",		0x40, 0x40 },
+	{ "PERRORDIS",		0x80, 0x80 }
+};
+
+int
+ahd_seqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQCTL0_parse_table, 8, "SEQCTL0",
+	    0xd6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQCTL1_parse_table[] = {
+	{ "RAMBIST_EN",		0x01, 0x01 },
+	{ "RAMBIST_FAIL",	0x02, 0x02 },
+	{ "RAMBIST_DONE",	0x04, 0x04 },
+	{ "OVRLAY_DATA_CHK",	0x08, 0x08 }
+};
+
+int
+ahd_seqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQCTL1_parse_table, 4, "SEQCTL1",
+	    0xd7, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t FLAGS_parse_table[] = {
+	{ "CARRY",		0x01, 0x01 },
+	{ "ZERO",		0x02, 0x02 }
+};
+
+int
+ahd_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(FLAGS_parse_table, 2, "FLAGS",
+	    0xd8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTCTL_parse_table[] = {
+	{ "IRET",		0x01, 0x01 },
+	{ "INTMASK",		0x06, 0x06 },
+	{ "SCS_SEQ_INT1M0",	0x08, 0x08 },
+	{ "SCS_SEQ_INT1M1",	0x10, 0x10 },
+	{ "INT1_CONTEXT",	0x20, 0x20 },
+	{ "INTVEC1DSL",		0x80, 0x80 }
+};
+
+int
+ahd_seqintctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTCTL_parse_table, 6, "SEQINTCTL",
+	    0xd9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seqram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEQRAM",
+	    0xda, regvalue, cur_col, wrap));
+}
+
+int
+ahd_prgmcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PRGMCNT",
+	    0xde, regvalue, cur_col, wrap));
+}
+
+int
+ahd_swtimer_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SWTIMER",
+	    0xe0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_accum_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ACCUM",
+	    0xe0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SINDEX",
+	    0xe2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DINDEX",
+	    0xe4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t BRKADDR1_parse_table[] = {
+	{ "BRKDIS",		0x80, 0x80 }
+};
+
+int
+ahd_brkaddr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(BRKADDR1_parse_table, 1, "BRKADDR1",
+	    0xe6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_brkaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BRKADDR0",
+	    0xe6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allones_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLONES",
+	    0xe8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allzeros_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLZEROS",
+	    0xea, regvalue, cur_col, wrap));
+}
+
+int
+ahd_none_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NONE",
+	    0xea, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SINDIR",
+	    0xec, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DINDIR",
+	    0xed, regvalue, cur_col, wrap));
+}
+
+int
+ahd_function1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FUNCTION1",
+	    0xf0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_stack_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "STACK",
+	    0xf2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_curaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CURADDR",
+	    0xf4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_intvec1_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INTVEC1_ADDR",
+	    0xf4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_intvec2_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INTVEC2_ADDR",
+	    0xf6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lastaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LASTADDR",
+	    0xf6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_longjmp_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LONGJMP_ADDR",
+	    0xf8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_longjmp_scb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LONGJMP_SCB",
+	    0xfa, regvalue, cur_col, wrap));
+}
+
+int
+ahd_accum_save_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ACCUM_SAVE",
+	    0xfc, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_scb_tails_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_SCB_TAILS",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ahd_pci_config_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sram_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SRAM_BASE",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_tid_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_TID_HEAD",
+	    0x120, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_tid_tail_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_TID_TAIL",
+	    0x122, regvalue, cur_col, wrap));
+}
+
+int
+ahd_next_queued_scb_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR",
+	    0x124, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD",
+	    0x128, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_scb_dmainprog_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD",
+	    0x12a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_dma_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD",
+	    0x12c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qfreeze_count_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QFREEZE_COUNT",
+	    0x12e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_mode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_MODE",
+	    0x130, regvalue, cur_col, wrap));
+}
+
+int
+ahd_msg_out_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MSG_OUT",
+	    0x131, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DMAPARAMS_parse_table[] = {
+	{ "FIFORESET",		0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SDMAEN",		0x10, 0x10 },
+	{ "SDMAENACK",		0x10, 0x10 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "WIDEODD",		0x40, 0x40 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahd_dmaparams_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DMAPARAMS_parse_table, 10, "DMAPARAMS",
+	    0x132, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQ_FLAGS_parse_table[] = {
+	{ "NO_DISCONNECT",	0x01, 0x01 },
+	{ "SPHASE_PENDING",	0x02, 0x02 },
+	{ "DPHASE_PENDING",	0x04, 0x04 },
+	{ "CMDPHASE_PENDING",	0x08, 0x08 },
+	{ "TARG_CMD_PENDING",	0x10, 0x10 },
+	{ "DPHASE",		0x20, 0x20 },
+	{ "NO_CDB_SENT",	0x40, 0x40 },
+	{ "TARGET_CMD_IS_TAGGED",0x40, 0x40 },
+	{ "NOT_IDENTIFIED",	0x80, 0x80 }
+};
+
+int
+ahd_seq_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQ_FLAGS_parse_table, 9, "SEQ_FLAGS",
+	    0x133, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_SCSIID",
+	    0x134, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_LUN",
+	    0x135, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LASTPHASE_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "P_BUSFREE",		0x01, 0x01 },
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_lastphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LASTPHASE_parse_table, 13, "LASTPHASE",
+	    0x136, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHARED_DATA_ADDR",
+	    0x137, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qoutfifo_next_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR",
+	    0x13b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qoutfifo_entry_valid_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG",
+	    0x13f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "KERNEL_TQINPOS",
+	    0x140, regvalue, cur_col, wrap));
+}
+
+int
+ahd_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TQINPOS",
+	    0x141, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ARG_1_parse_table[] = {
+	{ "CONT_MSG_LOOP_TARG",	0x02, 0x02 },
+	{ "CONT_MSG_LOOP_READ",	0x03, 0x03 },
+	{ "CONT_MSG_LOOP_WRITE",0x04, 0x04 },
+	{ "EXIT_MSG_LOOP",	0x08, 0x08 },
+	{ "MSGOUT_PHASEMIS",	0x10, 0x10 },
+	{ "SEND_REJ",		0x20, 0x20 },
+	{ "SEND_SENSE",		0x40, 0x40 },
+	{ "SEND_MSG",		0x80, 0x80 }
+};
+
+int
+ahd_arg_1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ARG_1_parse_table, 8, "ARG_1",
+	    0x142, regvalue, cur_col, wrap));
+}
+
+int
+ahd_arg_2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ARG_2",
+	    0x143, regvalue, cur_col, wrap));
+}
+
+int
+ahd_last_msg_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LAST_MSG",
+	    0x144, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ_TEMPLATE_parse_table[] = {
+	{ "ALTSTIM",		0x01, 0x01 },
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "MANUALP",		0x0c, 0x0c },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "MANUALCTL",		0x40, 0x40 }
+};
+
+int
+ahd_scsiseq_template_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ_TEMPLATE_parse_table, 6, "SCSISEQ_TEMPLATE",
+	    0x145, regvalue, cur_col, wrap));
+}
+
+int
+ahd_initiator_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INITIATOR_TAG",
+	    0x146, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQ_FLAGS2_parse_table[] = {
+	{ "TARGET_MSG_PENDING",	0x02, 0x02 },
+	{ "SELECTOUT_QFROZEN",	0x04, 0x04 }
+};
+
+int
+ahd_seq_flags2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQ_FLAGS2_parse_table, 2, "SEQ_FLAGS2",
+	    0x147, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allocfifo_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR",
+	    0x148, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdsize_table_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDSIZE_TABLE",
+	    0x14a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_BASE",
+	    0x180, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_residual_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT",
+	    0x180, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_RESIDUAL_SGPTR_parse_table[] = {
+	{ "SG_LIST_NULL",	0x01, 0x01 },
+	{ "SG_OVERRUN_RESID",	0x02, 0x02 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_scb_residual_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_RESIDUAL_SGPTR_parse_table, 3, "SCB_RESIDUAL_SGPTR",
+	    0x184, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_scsi_status_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SCSI_STATUS",
+	    0x188, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_phases_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_PHASES",
+	    0x189, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_data_dir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR",
+	    0x18a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_itag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_ITAG",
+	    0x18b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_sense_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR",
+	    0x18c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TAG",
+	    0x190, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_CDB_LEN_parse_table[] = {
+	{ "SCB_CDB_LEN_PTR",	0x80, 0x80 }
+};
+
+int
+ahd_scb_cdb_len_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_CDB_LEN_parse_table, 1, "SCB_CDB_LEN",
+	    0x192, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_task_management_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT",
+	    0x193, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_next_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_NEXT",
+	    0x194, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_next2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_NEXT2",
+	    0x196, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_dataptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_DATAPTR",
+	    0x198, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_DATACNT_parse_table[] = {
+	{ "SG_HIGH_ADDR_BITS",	0x7f, 0x7f },
+	{ "SG_LAST_SEG",	0x80, 0x80 }
+};
+
+int
+ahd_scb_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_DATACNT_parse_table, 2, "SCB_DATACNT",
+	    0x1a0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_SGPTR_parse_table[] = {
+	{ "SG_LIST_NULL",	0x01, 0x01 },
+	{ "SG_FULL_RESID",	0x02, 0x02 },
+	{ "SG_STATUS_VALID",	0x04, 0x04 }
+};
+
+int
+ahd_scb_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_SGPTR_parse_table, 3, "SCB_SGPTR",
+	    0x1a4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_CONTROL_parse_table[] = {
+	{ "SCB_TAG_TYPE",	0x03, 0x03 },
+	{ "DISCONNECTED",	0x04, 0x04 },
+	{ "STATUS_RCVD",	0x08, 0x08 },
+	{ "MK_MESSAGE",		0x10, 0x10 },
+	{ "TAG_ENB",		0x20, 0x20 },
+	{ "DISCENB",		0x40, 0x40 },
+	{ "TARGET_SCB",		0x80, 0x80 }
+};
+
+int
+ahd_scb_control_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_CONTROL_parse_table, 7, "SCB_CONTROL",
+	    0x1a8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_SCSIID_parse_table[] = {
+	{ "OID",		0x0f, 0x0f },
+	{ "TID",		0xf0, 0xf0 }
+};
+
+int
+ahd_scb_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_SCSIID_parse_table, 2, "SCB_SCSIID",
+	    0x1a9, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_LUN_parse_table[] = {
+	{ "LID",		0xff, 0xff }
+};
+
+int
+ahd_scb_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_LUN_parse_table, 1, "SCB_LUN",
+	    0x1aa, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_task_attribute_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TASK_ATTRIBUTE",
+	    0x1ab, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_BUSADDR",
+	    0x1ac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_spare_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SPARE",
+	    0x1b0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_disconnected_lists_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS",
+	    0x1b8, regvalue, cur_col, wrap));
+}
+
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.seq linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.seq
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx.seq	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx.seq	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,1756 @@
+/*
+ * Adaptec U320 device driver firmware for Linux and FreeBSD.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $FreeBSD$
+ */
+
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#60 $"
+PATCH_ARG_LIST = "struct ahd_softc *ahd"
+PREFIX = "ahd_"
+
+#include "aic79xx.reg"
+#include "scsi_message.h"
+
+idle_loop:
+	SET_MODE(M_SCSI, M_SCSI)
+	test	SCSISEQ0, ENSELO|ENARBO jnz idle_loop_checkbus;
+	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz idle_loop_checkbus;
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je idle_loop_checkbus;
+	/*
+	 * ENSELO is cleared by a SELDO, so we must test for SELDO
+	 * one last time.
+	 */
+BEGIN_CRITICAL;
+	test	SSTAT0, SELDO jnz select_out;
+END_CRITICAL;
+	call	start_selection;
+idle_loop_checkbus:
+BEGIN_CRITICAL;
+	test	SSTAT0, SELDO jnz select_out;
+END_CRITICAL;
+	test	SSTAT0, SELDI jnz select_in;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz idle_loop_check_nonpackreq;
+	test	SCSISIGO, ATNO jz idle_loop_check_nonpackreq;
+	call	unexpected_nonpkt_phase_find_ctxt;
+idle_loop_check_nonpackreq:
+	test	SSTAT2, NONPACKREQ jz idle_loop_scsi;
+	call	unexpected_nonpkt_phase_find_ctxt;
+idle_loop_scsi:
+BEGIN_CRITICAL;
+	test	LQISTAT2, LQIGSAVAIL jz idle_loop_service_fifos;
+	/*
+	 * We have received good status for this transaction.  There may
+	 * still be data in our FIFOs draining to the host.  Setup
+	 * monitoring of the draining process or complete the SCB.
+	 */
+good_status_IU_done:
+	bmov	SCBPTR, GSFIFO, 2;
+	clr	SCB_SCSI_STATUS;
+	or	SCB_CONTROL, STATUS_RCVD;
+
+	/*
+	 * Since this status did not consume a FIFO, we have to
+	 * be a bit more dilligent in how we check for FIFOs pertaining
+	 * to this transaction.  There are three states that a FIFO still
+	 * transferring data may be in.
+	 *
+	 * 1) Configured and draining to the host, with a pending CLRCHN.
+	 * 2) Configured and draining to the host, no pending CLRCHN.
+	 * 3) Pending cfg4data, fifo not empty.
+	 *
+	 * Cases 1 and 2 can be detected by noticing that a longjmp is
+	 * active for the FIFO and LONGJMP_SCB matches our SCB.  In this
+	 * case, we allow the routine servicing the FIFO to complete the SCB.
+	 * 
+	 * Case 3 implies either a pending or yet to occur save data
+	 * pointers for this same context in the other FIFO.  So, if
+	 * we detect case 2, we will properly defer the post of the SCB
+	 * and achieve the desired result.  The pending cfg4data will
+	 * notice that status has been received and complete the SCB.
+	 */
+	test	SCB_SGPTR, SG_LIST_NULL jz good_status_check_fifos;
+	/*
+	 * All segments have been loaded (or no data transfer), so
+	 * it is safe to complete the command.  Since this was a
+	 * cheap command to check for completion, loop to see if
+	 * more entries can be removed from the GSFIFO.
+	 */
+	call	complete;
+END_CRITICAL;
+	jmp	idle_loop_scsi;
+BEGIN_CRITICAL;
+good_status_check_fifos:
+	clc;
+	bmov	ARG_1, SCBPTR, 2;
+	SET_MODE(M_DFF0, M_DFF0)
+	call	check_fifo;
+	jc	idle_loop_service_fifos;
+	SET_MODE(M_DFF1, M_DFF1)
+	call	check_fifo;
+	jc	idle_loop_service_fifos;
+	SET_MODE(M_SCSI, M_SCSI)
+	call	queue_scb_completion;
+END_CRITICAL;
+idle_loop_service_fifos:
+	SET_MODE(M_DFF0, M_DFF0)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_next_fifo;
+	call	longjmp;
+idle_loop_next_fifo:
+	SET_MODE(M_DFF1, M_DFF1)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_last_fifo_done;
+	call	longjmp;
+idle_loop_last_fifo_done:
+	call	idle_loop_cchan;
+	jmp	idle_loop;
+
+idle_loop_cchan:
+	SET_MODE(M_CCHAN, M_CCHAN)
+BEGIN_CRITICAL;
+	test	CCSCBCTL, CCARREN|CCSCBEN jz scbdma_idle;
+	test	CCSCBCTL, CCSCBDIR jnz fetch_new_scb_inprog;
+	test	CCSCBCTL, CCSCBDONE jz return;
+END_CRITICAL;
+	/* FALLTHROUGH */
+scbdma_tohost_done:
+	test	CCSCBCTL, CCARREN jz fill_qoutfifo_dmadone;
+	/*
+	 * A complete SCB upload requires no intervention.
+	 * The SCB is already on the COMPLETE_SCB list
+	 * and its completion notification will now be
+	 * handled just like any other SCB.
+	 */
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN) ret;
+fill_qoutfifo_dmadone:
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	mvi	INTSTAT, CMDCMPLT;
+	mvi	COMPLETE_SCB_DMAINPROG_HEAD[1], SCB_LIST_NULL;
+	bmov	QOUTFIFO_NEXT_ADDR, SCBHADDR, 4;
+	test	QOFF_CTLSTA, SDSCB_ROLLOVR jz return;
+	bmov	QOUTFIFO_NEXT_ADDR, SHARED_DATA_ADDR, 4;
+	xor	QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID_TOGGLE ret;
+
+BEGIN_CRITICAL;
+fetch_new_scb_inprog:
+	test	CCSCBCTL, ARRDONE jz return;
+fetch_new_scb_done:
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	bmov	REG0, SCBPTR, 2;
+	/* Update the next SCB address to download. */
+	bmov	NEXT_QUEUED_SCB_ADDR, SCB_NEXT_SCB_BUSADDR, 4;
+	mvi	SCB_NEXT[1], SCB_LIST_NULL;
+	mvi	SCB_NEXT2[1], SCB_LIST_NULL;
+	/*
+	 * SCBs that want to send messages are always
+	 * queued independently.  This ensures that they
+	 * are at the head of the SCB list to select out
+	 * to a target and we will see the MK_MESSAGE flag.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jnz first_new_target_scb;
+	shr	SINDEX, 3, SCB_SCSIID;
+	and	SINDEX, ~0x1;
+	mvi	SINDEX[1], (WAITING_SCB_TAILS >> 8);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	SCBPTR, SINDIR, 2;
+	bmov	DINDIR, REG0, 2;
+	cmp	SCBPTR[1], SCB_LIST_NULL je first_new_target_scb;
+	bmov	SCB_NEXT, REG0, 2;
+fetch_new_scb_fini:
+	/* Increment our position in the QINFIFO. */
+	mov	NONE, SNSCB_QOFF ret;
+first_new_target_scb:
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je first_new_scb;
+	bmov	SCBPTR, WAITING_TID_TAIL, 2;
+	bmov	SCB_NEXT2, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2;
+	/* Increment our position in the QINFIFO. */
+	mov	NONE, SNSCB_QOFF ret;
+first_new_scb:
+	bmov	WAITING_TID_HEAD, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2;
+	/* Increment our position in the QINFIFO. */
+	mov	NONE, SNSCB_QOFF ret;
+END_CRITICAL;
+
+scbdma_idle:
+	/*
+	 * Give precedence to downloading new SCBs to execute
+	 * unless select-outs are currently frozen.
+	 * XXX Use a timer to prevent completion starvation.
+	 */
+	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz . + 2;
+BEGIN_CRITICAL;
+	test	QOFF_CTLSTA, NEW_SCB_AVAIL jnz fetch_new_scb;
+	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne dma_complete_scb;
+	cmp	COMPLETE_SCB_HEAD[1], SCB_LIST_NULL je return;
+	/* FALLTHROUGH */
+fill_qoutfifo:
+	/*
+	 * Keep track of the SCBs we are dmaing just
+	 * in case the DMA fails or is aborted.
+	 */
+	mov	A, QOUTFIFO_ENTRY_VALID_TAG;
+	bmov	COMPLETE_SCB_DMAINPROG_HEAD, COMPLETE_SCB_HEAD, 2;
+	mvi	CCSCBCTL, CCSCBRESET;
+	bmov	SCBHADDR, QOUTFIFO_NEXT_ADDR, 4;
+	mov	CCSCBRAM, COMPLETE_SCB_HEAD;
+	or	CCSCBRAM, A, COMPLETE_SCB_HEAD[1];
+	bmov	SCBPTR, COMPLETE_SCB_HEAD, 2;
+	jmp	fill_qoutfifo_first_entry;
+fill_qoutfifo_loop:
+	mov	CCSCBRAM, SCB_NEXT_COMPLETE;
+	or	CCSCBRAM, A, SCB_NEXT_COMPLETE[1];
+	bmov	SCBPTR, SCB_NEXT_COMPLETE, 2;
+fill_qoutfifo_first_entry:
+	mov	NONE, SDSCB_QOFF;
+	cmp	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL je fill_qoutfifo_done;
+	cmp	CCSCBADDR, CCSCBADDR_MAX je fill_qoutfifo_done;
+	test	QOFF_CTLSTA, SDSCB_ROLLOVR jz fill_qoutfifo_loop;
+fill_qoutfifo_done:
+	mov	SCBHCNT, CCSCBADDR;
+	mvi	CCSCBCTL, CCSCBEN|CCSCBRESET;
+	bmov	COMPLETE_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	mvi	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL ret;
+
+fetch_new_scb:
+	bmov	SCBHADDR, NEXT_QUEUED_SCB_ADDR, 4;
+	mvi	CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET jmp dma_scb;
+dma_complete_scb:
+	bmov	SCBPTR, COMPLETE_DMA_SCB_HEAD, 2;
+	bmov	SCBHADDR, SCB_BUSADDR, 4;
+	mvi	CCARREN|CCSCBEN|CCSCBRESET call dma_scb;
+	/*
+	 * Now that we've started the DMA, push us onto
+	 * the normal completion queue to have our SCBID
+	 * posted to the kernel.
+	 */
+	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
+	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
+END_CRITICAL;
+
+/*
+ * Either post or fetch an SCB from host memory.  The caller
+ * is responsible for polling for transfer completion.
+ *
+ * Prerequisits: Mode == M_CCHAN
+ *		 SINDEX contains CCSCBCTL flags
+ *		 SCBHADDR set to Host SCB address
+ *		 SCBPTR set to SCB src location on "push" operations
+ */
+SET_SRC_MODE	M_CCHAN;
+SET_DST_MODE	M_CCHAN;
+dma_scb:
+	mvi	SCBHCNT, SCB_TRANSFER_SIZE;
+	mov	CCSCBCTL, SINDEX ret;
+
+BEGIN_CRITICAL;
+setjmp_setscb:
+	bmov	LONGJMP_SCB, SCBPTR, 2;
+setjmp:
+	bmov	LONGJMP_ADDR, STACK, 2 ret;
+setjmp_inline:
+	bmov	LONGJMP_ADDR, STACK, 2;
+longjmp:
+	bmov	STACK, LONGJMP_ADDR, 2 ret;
+END_CRITICAL;
+
+/************************ Packetized LongJmp Routines *************************/
+/*
+ * Must disable interrupts when setting the mode pointer
+ * register as an interrupt occurring mid update will
+ * fail to store the new mode value for restoration on
+ * an iret.
+ */
+if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
+set_mode_work_around:
+	mvi	SEQINTCTL, INTVEC1DSL;
+	mov	MODE_PTR, SINDEX;
+	clr	SEQINTCTL ret;
+
+toggle_dff_mode_work_around:
+	mvi	SEQINTCTL, INTVEC1DSL;
+	xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
+	clr	SEQINTCTL ret;
+}
+
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+start_selection:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
+		/*
+		 * Razor #494
+		 * Rev A hardware fails to update LAST/CURR/NEXTSCB
+		 * correctly after a packetized selection in several
+		 * situations:
+		 *
+		 * 1) If only one command existed in the queue, the
+		 *    LAST/CURR/NEXTSCB are unchanged.
+		 *
+		 * 2) In a non QAS, protocol allowed phase change,
+		 *    the queue is shifted 1 too far.  LASTSCB is
+		 *    the last SCB that was correctly processed.
+		 * 
+		 * 3) In the QAS case, if the full list of commands
+		 *    was successfully sent, NEXTSCB is NULL and neither
+		 *    CURRSCB nor LASTSCB can be trusted.  We must
+		 *    manually walk the list counting MAXCMDCNT elements
+		 *    to find the last SCB that was sent correctly.
+		 *
+		 * To simplify the workaround for this bug in SELDO
+		 * handling, we initialize LASTSCB prior to enabling
+		 * selection so we can rely on it even for case #1 above.
+		 */
+		bmov	LASTSCB, WAITING_TID_HEAD, 2;
+	}
+	bmov	CURRSCB, WAITING_TID_HEAD, 2;
+	bmov	SCBPTR, WAITING_TID_HEAD, 2;
+	shr	SELOID, 4, SCB_SCSIID;
+	/*
+	 * If we want to send a message to the device, ensure
+	 * we are selecting with atn irregardless of our packetized
+	 * agreement.  Since SPI4 only allows target reset or PPR
+	 * messages if this is a packetized connection, the change
+	 * to our negotiation table entry for this selection will
+	 * be cleared when the message is acted on.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jz . + 3;
+	mov	NEGOADDR, SELOID;
+	or	NEGCONOPTS, ENAUTOATNO;
+	or	SCSISEQ0, ENSELO ret;
+END_CRITICAL;
+
+/*
+ * Allocate a FIFO for a non-packetized transaction.
+ * For some reason unkown to me, both FIFOs must be free before we
+ * can allocate a FIFO for a non-packetized transaction.  This
+ * may be fixed in Rev B.
+ */
+allocate_fifo_loop:
+	/*
+	 * Do whatever work is required to free a FIFO.
+	 */
+	SET_MODE(M_DFF0, M_DFF0)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz . + 2;
+	call	longjmp;
+	SET_MODE(M_DFF1, M_DFF1)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz . + 2;
+	call	longjmp;
+	SET_MODE(M_SCSI, M_SCSI)
+allocate_fifo:
+	and	A, FIFO0FREE|FIFO1FREE, DFFSTAT;
+	cmp	A, FIFO0FREE|FIFO1FREE jne allocate_fifo_loop;
+take_fifo:
+	or	DFFSTAT, CURRFIFO;
+	SET_MODE(M_DFF1, M_DFF1)
+	bmov	SCBPTR, ALLOCFIFO_SCBPTR, 2 ret;
+
+/*
+ * We have been reselected as an initiator
+ * or selected as a target.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+select_in:
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		/*
+		 * This exposes a window whereby a
+		 * busfree just after a selection will
+		 * be missed, but there is not other safe
+		 * way to enable busfree detection if
+		 * the busfreerev function is broken.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+		or	SIMODE1, ENBUSFREE;
+	}
+	or	SXFRCTL0, SPIOEN;
+	and	SAVED_SCSIID, SELID_MASK, SELID;
+	and	A, OID, IOWNID;
+	or	SAVED_SCSIID, A;
+	mvi	CLRSINT0, CLRSELDI;
+	jmp	ITloop;
+
+/*
+ * We have successfully selected out.
+ *
+ * Clear SELDO.
+ * Dequeue all SCBs sent from the waiting queue
+ * Requeue all SCBs *not* sent to the tail of the waiting queue
+ * Take Razor #494 into account for above.
+ *
+ * In Packetized Mode:
+ *	Return to the idle loop.  Our interrupt handler will take
+ *	care of any incoming L_Qs.
+ *
+ * In Non-Packetize Mode:
+ *	Continue to our normal state machine.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+select_out:
+BEGIN_CRITICAL;
+	/* Clear out all SCBs that have been successfully sent. */
+	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
+		/*
+		 * For packetized, the LQO manager clears ENSELO on
+		 * the assertion of SELDO.  If we are non-packetized,
+		 * LASTSCB and CURRSCB are acuate.
+		 */
+		test	SCSISEQ0, ENSELO jnz use_lastscb;
+
+		/*
+		 * The update is correct for LQOSTAT1 errors.  All
+		 * but LQOBUSFREE are handled by kernel interrupts.
+		 * If we see LQOBUSFREE, return to the idle loop.
+		 * Once we are out of the select_out critical section,
+		 * the kernel will cleanup the LQOBUSFREE and we will
+		 * eventually restart the selection if appropriate.
+		 */
+		test	LQOSTAT1, LQOBUSFREE jnz idle_loop;
+
+		/*
+		 * On a phase change oustside of packet boundaries,
+		 * LASTSCB points to the currently active SCB context
+		 * on the bus.
+		 */
+		test	LQOSTAT2, LQOPHACHGOUTPKT jnz use_lastscb;
+
+		/*
+		 * If the hardware has traversed the whole list, NEXTSCB
+		 * will be NULL, CURRSCB and LASTSCB cannot be trusted,
+		 * but MAXCMDCNT is accurate.  If we stop part way through
+		 * the list or only had one command to issue, NEXTSCB[1] is
+		 * not NULL and LASTSCB is the last command to go out.
+		 */
+		cmp	NEXTSCB[1], SCB_LIST_NULL jne use_lastscb;
+
+		/*
+		 * Brute force walk.
+		 */
+		bmov	SCBPTR, WAITING_TID_HEAD, 2;
+		mvi	SEQINTCTL, INTVEC1DSL;
+		mvi	MODE_PTR, MK_MODE(M_CFG, M_CFG);
+		mov	A, MAXCMDCNT;
+		mvi	MODE_PTR, MK_MODE(M_SCSI, M_SCSI);
+		clr	SEQINTCTL;
+find_lastscb_loop:
+		dec	A;
+		test	A, 0xFF jz found_last_sent_scb;
+		bmov	SCBPTR, SCB_NEXT, 2;
+		jmp	find_lastscb_loop;
+use_lastscb:
+		bmov	SCBPTR, LASTSCB, 2;
+found_last_sent_scb:
+		bmov	CURRSCB, SCBPTR, 2;
+curscb_ww_done:
+	} else {
+		/*
+		 * Untested - Verify with Rev B.
+		 */
+		bmov	SCBPTR, CURRSCB, 2;
+	}
+	/*
+	 * Requeue any SCBs not sent, to the tail of the waiting Q.
+	 */
+	cmp	SCB_NEXT[1], SCB_LIST_NULL je select_out_list_done;
+
+	/*
+	 * We know that neither the per-TID list nor the list of
+	 * TIDs is empty.  Use this knowledge to our advantage.
+	 */
+	bmov	REG0, SCB_NEXT, 2;
+	bmov	SCBPTR, WAITING_TID_TAIL, 2;
+	bmov	SCB_NEXT2, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2;
+	jmp	select_out_inc_tid_q;
+
+select_out_list_done:
+	/*
+	 * The whole list made it.  Just clear our TID's tail pointer
+	 * unless we were queued independently due to our need to
+	 * send a message.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jnz select_out_inc_tid_q;
+	shr	DINDEX, 3, SCB_SCSIID;
+	or	DINDEX, 1;	/* Want only the second byte */
+	mvi	DINDEX[1], ((WAITING_SCB_TAILS) >> 8);
+	mvi	DINDIR, SCB_LIST_NULL;
+select_out_inc_tid_q:
+	bmov	SCBPTR, WAITING_TID_HEAD, 2;
+	bmov	WAITING_TID_HEAD, SCB_NEXT2, 2;
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL jne . + 2;
+	mvi	WAITING_TID_TAIL[1], SCB_LIST_NULL;
+	bmov	SCBPTR, CURRSCB, 2;
+END_CRITICAL;
+
+	mvi	CLRSINT0, CLRSELDO;
+
+	test	LQOSTAT2, LQOPHACHGOUTPKT jnz unexpected_nonpkt_phase;
+	test	LQOSTAT1, LQOPHACHGINPKT jnz unexpected_nonpkt_phase;
+
+	/*
+	 * If this is a packetized connection, return to our
+	 * idle_loop and let our interrupt handler deal with
+	 * any connection setup/teardown issues.  The only
+	 * exception is the case of MK_MESSAGE SCBs.  In the
+	 * A, the LQO manager transitions to LQOSTOP0 even if
+	 * we have selected out with ATN asserted and the target
+	 * REQs in a non-packet phase.
+	 */
+	if ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0) {
+		test 	SCB_CONTROL, MK_MESSAGE jz select_out_no_message;
+		test	SCSISIGO, ATNO jnz select_out_non_packetized;
+select_out_no_message:
+	}
+	test	LQOSTAT2, LQOSTOP0 jnz idle_loop;
+
+select_out_non_packetized:
+	/* Non packetized request. */
+	and     SCSISEQ0, ~ENSELO;
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		/*
+		 * This exposes a window whereby a
+		 * busfree just after a selection will
+		 * be missed, but there is not other safe
+		 * way to enable busfree detection if
+		 * the busfreerev function is broken.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+		or	SIMODE1, ENBUSFREE;
+	}
+	mov	SAVED_SCSIID, SCB_SCSIID;
+	mov	SAVED_LUN, SCB_LUN;
+	or	SXFRCTL0, SPIOEN;
+
+	/*
+	 * As soon as we get a successful selection, the target
+	 * should go into the message out phase since we have ATN
+	 * asserted.
+	 */
+	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
+	mvi	SEQ_FLAGS, NO_CDB_SENT;
+
+	/*
+	 * Main loop for information transfer phases.  Wait for the
+	 * target to assert REQ before checking MSG, C/D and I/O for
+	 * the bus phase.
+	 */
+mesgin_phasemis:
+ITloop:
+	call	phase_lock;
+
+	mov	A, LASTPHASE;
+
+	test	A, ~P_DATAIN_DT	jz p_data;
+	cmp	A,P_COMMAND	je p_command;
+	cmp	A,P_MESGOUT	je p_mesgout;
+	cmp	A,P_STATUS	je p_status;
+	cmp	A,P_MESGIN	je p_mesgin;
+
+	mvi	SEQINTCODE, BAD_PHASE;
+	jmp	ITloop;			/* Try reading the bus again. */
+
+/*
+ * Command phase.  Set up the DMA registers and let 'er rip.
+ */
+p_command:
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz p_command_allocate_fifo;
+	/*
+	 * Command retry.  Free our current FIFO and
+	 * re-allocate a FIFO so transfer state is
+	 * reset.
+	 */
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+p_command_allocate_fifo:
+	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
+	call	allocate_fifo;
+	add	NONE, -17, SCB_CDB_LEN;
+	jnc	p_command_embedded;
+p_command_from_host:
+	bmov	HADDR[0], SCB_CDB_PTR, 11;
+	mvi	SG_CACHE_PRE, LAST_SEG;
+	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
+	jmp	p_command_loop;
+p_command_embedded:
+	bmov	SHCNT[0], SCB_CDB_LEN,  1;
+	bmov	SHCNT[1], ALLZEROS, 2;
+	bmov	DFDAT, SCB_CDB_STORE, 16; 
+	mvi	DFCNTRL, SCSIEN;
+p_command_loop:
+	test	DFCNTRL, SCSIEN jnz p_command_loop;
+	/*
+	 * DMA Channel automatically disabled.
+	 * Don't allow a data phase if the command
+	 * was not fully transferred.  Make sure that
+	 * we clear the IDENTIFY SEEN flag if a retry
+	 * falls short too.
+	 */
+	and	SEQ_FLAGS, ~NO_CDB_SENT;
+	test	SSTAT2, SDONE jnz ITloop;
+	or	SEQ_FLAGS, NO_CDB_SENT;
+	jmp	ITloop;
+
+
+/*
+ * Status phase.  Wait for the data byte to appear, then read it
+ * and store it into the SCB.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+p_status:
+	test	SEQ_FLAGS,NOT_IDENTIFIED jz p_status_okay;
+	mvi	SEQINTCODE, PROTO_VIOLATION;
+	jmp	mesgin_done;
+p_status_okay:
+	mov	SCB_SCSI_STATUS, SCSIDAT;
+	or	SCB_CONTROL, STATUS_RCVD;
+	jmp	ITloop;
+
+/*
+ * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full
+ * indentify message sequence and send it to the target.  The host may
+ * override this behavior by setting the MK_MESSAGE bit in the SCB
+ * control byte.  This will cause us to interrupt the host and allow
+ * it to handle the message phase completely on its own.  If the bit
+ * associated with this target is set, we will also interrupt the host,
+ * thereby allowing it to send a message on the next selection regardless
+ * of the transaction being sent.
+ * 
+ * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.
+ * This is done to allow the host to send messages outside of an identify
+ * sequence while protecting the seqencer from testing the MK_MESSAGE bit
+ * on an SCB that might not be for the current nexus. (For example, a
+ * BDR message in responce to a bad reselection would leave us pointed to
+ * an SCB that doesn't have anything to do with the current target).
+ *
+ * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
+ * bus device reset).
+ *
+ * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,
+ * in case the target decides to put us in this phase for some strange
+ * reason.
+ */
+p_mesgout_retry:
+	/* Turn on ATN for the retry */
+	mvi	SCSISIGO, ATNO;
+p_mesgout:
+	mov	SINDEX, MSG_OUT;
+	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
+	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
+p_mesgout_identify:
+	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
+	test	SCB_CONTROL, DISCENB jnz . + 2;
+	and	SINDEX, ~DISCENB;
+/*
+ * Send a tag message if TAG_ENB is set in the SCB control block.
+ * Use SCB_NONPACKET_TAG as the tag value.
+ */
+p_mesgout_tag:
+	test	SCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;
+	mov	SCSIDAT, SINDEX;	/* Send the identify message */
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
+	and	SCSIDAT,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
+	mov	SCBPTR jmp p_mesgout_onebyte;
+/*
+ * Interrupt the driver, and allow it to handle this message
+ * phase and any required retries.
+ */
+p_mesgout_from_host:
+	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
+	jmp	host_message_loop;
+
+p_mesgout_onebyte:
+	mvi	CLRSINT1, CLRATNO;
+	mov	SCSIDAT, SINDEX;
+
+/*
+ * If the next bus phase after ATN drops is message out, it means
+ * that the target is requesting that the last message(s) be resent.
+ */
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	je p_mesgout_retry;
+
+p_mesgout_done:
+	mvi	CLRSINT1,CLRATNO;	/* Be sure to turn ATNO off */
+	mov	LAST_MSG, MSG_OUT;
+	mvi	MSG_OUT, MSG_NOOP;	/* No message left */
+	jmp	ITloop;
+
+/*
+ * Message in phase.  Bytes are read using Automatic PIO mode.
+ */
+p_mesgin:
+	/* read the 1st message byte */
+	mvi	ACCUM		call inb_first;
+
+	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify;
+	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
+	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs;
+	cmp	ALLZEROS,A		je mesgin_complete;
+	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs;
+	cmp	A,MSG_IGN_WIDE_RESIDUE	je mesgin_ign_wide_residue;
+	cmp	A,MSG_NOOP		je mesgin_done;
+
+/*
+ * Pushed message loop to allow the kernel to
+ * run it's own message state engine.  To avoid an
+ * extra nop instruction after signaling the kernel,
+ * we perform the phase_lock before checking to see
+ * if we should exit the loop and skip the phase_lock
+ * in the ITloop.  Performing back to back phase_locks
+ * shouldn't hurt, but why do it twice...
+ */
+host_message_loop:
+	call	phase_lock;	/* Benign the first time through. */
+	mvi	SEQINTCODE, HOST_MSG_LOOP;
+	cmp	RETURN_1, EXIT_MSG_LOOP	je ITloop;
+	cmp	RETURN_1, CONT_MSG_LOOP_WRITE	jne . + 3;
+	mov	SCSIDAT, RETURN_2;
+	jmp	host_message_loop;
+	/* Must be CONT_MSG_LOOP_READ */
+	mov	NONE, SCSIDAT;	/* ACK Byte */
+	jmp	host_message_loop;
+
+mesgin_ign_wide_residue:
+	shr	NEGOADDR, 4, SAVED_SCSIID;
+	test	NEGCONOPTS, WIDEXFER jz mesgin_reject;
+	/* Pull the residue byte */
+	mvi	REG0	call inb_next;
+	cmp	REG0, 0x01 jne mesgin_reject;
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
+	test	DATA_COUNT_ODD, 0x1	jz mesgin_done;
+	mvi	SEQINTCODE, IGN_WIDE_RES;
+	jmp	mesgin_done;
+
+mesgin_reject:
+	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
+mesgin_done:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+	jmp	ITloop;
+
+#define INDEX_DISC_LIST(scsiid, lun)					\
+	and	A, 0xC0, scsiid;					\
+	or	SCBPTR, A, lun;						\
+	clr	SCBPTR[1];						\
+	and	SINDEX, 0x30, scsiid;					\
+	shr	SINDEX, 3;	/* Multiply by 2 */			\
+	add	SINDEX, (SCB_DISCONNECTED_LISTS & 0xFF);		\
+	mvi	SINDEX[1], ((SCB_DISCONNECTED_LISTS >> 8) & 0xFF)
+
+mesgin_identify:
+	/*
+	 * Determine whether a target is using tagged or non-tagged
+	 * transactions by first looking at the transaction stored in
+	 * the per-device, disconnected array.  If there is no untagged
+	 * transaction for this target, this must be a tagged transaction.
+	 */
+	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
+	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	REG0, SINDIR, 2;
+	cmp	REG0[1], SCB_LIST_NULL je snoop_tag;
+	/* Untagged.  Clear the busy table entry and setup the SCB. */
+	bmov	DINDIR, ALLONES, 2;
+	bmov	SCBPTR, REG0, 2;
+	jmp	setup_SCB;
+
+/*
+ * Here we "snoop" the bus looking for a SIMPLE QUEUE TAG message.
+ * If we get one, we use the tag returned to find the proper
+ * SCB.  After receiving the tag, look for the SCB at SCB locations tag and
+ * tag + 256.
+ */
+snoop_tag:
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x80;
+	}
+	mov	NONE, SCSIDAT;		/* ACK Identify MSG */
+	call	phase_lock;
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x1;
+	}
+	cmp	LASTPHASE, P_MESGIN	jne not_found_ITloop;
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x2;
+	}
+	cmp	SCSIBUS, MSG_SIMPLE_Q_TAG jne not_found;
+get_tag:
+	clr	SCBPTR[1];
+	mvi	SCBPTR	call inb_next;	/* tag value */
+verify_scb:
+	test	SCB_CONTROL,DISCONNECTED jz verify_other_scb;
+	mov	A, SAVED_SCSIID;
+	cmp	SCB_SCSIID, A jne verify_other_scb;
+	mov	A, SAVED_LUN;
+	cmp	SCB_LUN, A je setup_SCB_disconnected;
+verify_other_scb:
+	xor	SCBPTR[1], 1;
+	test	SCBPTR[1], 0xFF jnz verify_scb;
+	jmp	not_found;
+
+/*
+ * Ensure that the SCB the tag points to is for
+ * an SCB transaction to the reconnecting target.
+ */
+setup_SCB:
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x10;
+	}
+	test	SCB_CONTROL,DISCONNECTED jz not_found;
+setup_SCB_disconnected:
+	and	SCB_CONTROL,~DISCONNECTED;
+	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
+	test	SCB_SGPTR, SG_LIST_NULL jnz . + 3;
+	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
+	call	allocate_fifo;
+	/* See if the host wants to send a message upon reconnection */
+	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
+	mvi	HOST_MSG	call mk_mesg;
+	jmp	mesgin_done;
+
+not_found:
+	mvi	SEQINTCODE, NO_MATCH;
+	jmp	mesgin_done;
+
+not_found_ITloop:
+	mvi	SEQINTCODE, NO_MATCH;
+	jmp	ITloop;
+
+/*
+ * We received a "command complete" message.  Put the SCB on the complete
+ * queue and trigger a completion interrupt via the idle loop.  Before doing
+ * so, check to see if there
+ * is a residual or the status byte is something other than STATUS_GOOD (0).
+ * In either of these conditions, we upload the SCB back to the host so it can
+ * process this information.  In the case of a non zero status byte, we 
+ * additionally interrupt the kernel driver synchronously, allowing it to
+ * decide if sense should be retrieved.  If the kernel driver wishes to request
+ * sense, it will fill the kernel SCB with a request sense command, requeue
+ * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
+ * RETURN_1 to SEND_SENSE.
+ */
+mesgin_complete_proto_violation:
+	mvi	SEQINTCODE, PROTO_VIOLATION;
+	jmp	mesgin_done;
+mesgin_complete:
+
+	/*
+	 * If ATN is raised, we still want to give the target a message.
+	 * Perhaps there was a parity error on this last message byte.
+	 * Either way, the target should take us to message out phase
+	 * and then attempt to complete the command again.  We should use a
+	 * critical section here to guard against a timeout triggering
+	 * for this command and setting ATN while we are still processing
+	 * the completion.
+	test	SCSISIGI, ATNI jnz mesgin_done;
+	 */
+
+	/*
+	 * If we are identified and have successfully sent the CDB,
+	 * any status will do.  Optimize this fast path.
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jnz . + 2;
+	test	SCB_CONTROL, STATUS_RCVD jnz complete_accepted;
+
+	/*
+	 * If the target never sent an identify message but instead went
+	 * to mesgin to give an invalid message, let the host abort us.
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_complete_proto_violation;
+
+	/*
+	 * If the target never gave us status information, have
+	 * the host abort the command.
+	 */
+	test	SCB_CONTROL, STATUS_RCVD jz mesgin_complete_proto_violation;
+
+	/*
+	 * If we recevied good status but never successfully sent the
+	 * cdb, abort the command.
+	 */
+	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
+	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_complete_proto_violation;
+complete_accepted:
+
+	/*
+	 * See if we attempted to deliver a message but the target ingnored us.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jz . + 2;
+	mvi	SEQINTCODE, MKMSG_FAILED;
+	call	queue_scb_completion;
+	jmp	await_busfree;
+
+freeze_queue:
+	/* Cancel any pending select-out. */
+	test	SSTAT0, SELDO jnz . + 2;
+	and	SCSISEQ0, ~ENSELO;
+	mov	ACCUM_SAVE, A;
+	clr	A;
+	add	QFREEZE_COUNT, 1;
+	adc	QFREEZE_COUNT[1], A;
+	or	SEQ_FLAGS2, SELECTOUT_QFROZEN;
+	mov	A, ACCUM_SAVE ret;
+
+queue_arg1_scb_completion:
+	SET_MODE(M_SCSI, M_SCSI)
+	bmov	SCBPTR, ARG_1, 2;
+queue_scb_completion:
+	test	SCB_SCSI_STATUS,0xff	jnz bad_status;
+	/*
+	 * Check for residuals
+	 */
+	test	SCB_SGPTR, SG_LIST_NULL jnz complete;	/* No xfer */
+	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
+	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
+complete:
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
+	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
+bad_status:
+	cmp	SCB_SCSI_STATUS, STATUS_PKT_SENSE je upload_scb;
+	call	freeze_queue;
+upload_scb:
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_DMA_SCB_HEAD, 2;
+	bmov	COMPLETE_DMA_SCB_HEAD, SCBPTR, 2;
+	or	SCB_SGPTR, SG_STATUS_VALID ret;
+
+/*
+ * Is it a disconnect message?  Set a flag in the SCB to remind us
+ * and await the bus going free.  If this is an untagged transaction
+ * store the SCB id for it in our untagged target table for lookup on
+ * a reselction.
+ */
+mesgin_disconnect:
+	/*
+	 * If ATN is raised, we still want to give the target a message.
+	 * Perhaps there was a parity error on this last message byte
+	 * or we want to abort this command.  Either way, the target
+	 * should take us to message out phase and then attempt to
+	 * disconnect again.
+	 * XXX - Wait for more testing.
+	test	SCSISIGI, ATNI jnz mesgin_done;
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT	jz disconnect_allowed;
+	mvi	SEQINTCODE, PROTO_VIOLATION;
+	jmp	mesgin_done;
+disconnect_allowed:
+	or	SCB_CONTROL,DISCONNECTED;
+	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
+queue_disc_scb:
+	bmov	REG0, SCBPTR, 2;
+	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	DINDIR, REG0, 2;
+	bmov	SCBPTR, REG0, 2;
+	/* FALLTHROUGH */
+await_busfree:
+	and	SIMODE1, ~ENBUSFREE;
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0) {
+		/*
+		 * In the BUSFREEREV_BUG case, the
+		 * busfree status was cleared at the
+		 * beginning of the connection.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+	}
+	mov	NONE, SCSIDAT;		/* Ack the last byte */
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz await_busfree_not_m_dff;
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+await_busfree_clrchn:
+	mvi	DFFSXFRCTL, CLRCHN;
+await_busfree_not_m_dff:
+	call	clear_target_state;
+	test	SSTAT1,REQINIT|BUSFREE	jz .;
+	test	SSTAT1, BUSFREE jnz idle_loop;
+	mvi	SEQINTCODE, MISSED_BUSFREE;
+
+
+/*
+ * Save data pointers message:
+ * Copying RAM values back to SCB, for Save Data Pointers message, but
+ * only if we've actually been into a data phase to change them.  This
+ * protects against bogus data in scratch ram and the residual counts
+ * since they are only initialized when we go into data_in or data_out.
+ * Ack the message as soon as possible.
+ */
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+mesgin_sdptrs:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+	test	SEQ_FLAGS, DPHASE	jz ITloop;
+	call	save_pointers;
+	jmp	ITloop;
+
+save_pointers:
+	/*
+	 * If we are asked to save our position at the end of the
+	 * transfer, just mark us at the end rather than perform a
+	 * full save.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz save_pointers_full;
+	or	SCB_SGPTR, SG_LIST_NULL ret;
+
+save_pointers_full:
+	/*
+	 * The SCB_DATAPTR becomes the current SHADDR.
+	 * All other information comes directly from our residual
+	 * state.
+	 */
+	bmov	SCB_DATAPTR, SHADDR, 8;
+	bmov	SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8 ret;
+
+/*
+ * Restore pointers message?  Data pointers are recopied from the
+ * SCB anytime we enter a data phase for the first time, so all
+ * we need to do is clear the DPHASE flag and let the data phase
+ * code do the rest.  We also reset/reallocate the FIFO to make
+ * sure we have a clean start for the next data phase.
+ */
+mesgin_rdptrs:
+	and	SEQ_FLAGS, ~DPHASE;
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz msgin_rdptrs_get_fifo;
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+msgin_rdptrs_get_fifo:
+	call	allocate_fifo;
+	jmp	mesgin_done;
+
+clear_target_state:
+	mvi	LASTPHASE, P_BUSFREE;
+	/* clear target specific flags */
+	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
+
+phase_lock:     
+	test	SCSIPHASE, 0xFF jz .;
+phase_lock_latch_phase:
+	and	LASTPHASE, PHASE_MASK, SCSISIGI ret;
+
+/*
+ * Functions to read data in Automatic PIO mode.
+ *
+ * An ACK is not sent on input from the target until SCSIDATL is read from.
+ * So we wait until SCSIDATL is latched (the usual way), then read the data
+ * byte directly off the bus using SCSIBUSL.  When we have pulled the ATN
+ * line, or we just want to acknowledge the byte, then we do a dummy read
+ * from SCISDATL.  The SCSI spec guarantees that the target will hold the
+ * data byte on the bus until we send our ACK.
+ *
+ * The assumption here is that these are called in a particular sequence,
+ * and that REQ is already set when inb_first is called.  inb_{first,next}
+ * use the same calling convention as inb.
+ */
+inb_next:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+inb_next_wait:
+	/*
+	 * If there is a parity error, wait for the kernel to
+	 * see the interrupt and prepare our message response
+	 * before continuing.
+	 */
+	test	SCSIPHASE, 0xFF jz .;
+inb_next_check_phase:
+	and	LASTPHASE, PHASE_MASK, SCSISIGI;
+	cmp	LASTPHASE, P_MESGIN jne mesgin_phasemis;
+inb_first:
+	clr	DINDEX[1];
+	mov	DINDEX,SINDEX;
+	mov	DINDIR,SCSIBUS	ret;		/*read byte directly from bus*/
+inb_last:
+	mov	NONE,SCSIDAT ret;		/*dummy read from latch to ACK*/
+
+mk_mesg:
+	mvi	SCSISIGO, ATNO;
+	mov	MSG_OUT,SINDEX ret;
+
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+disable_ccsgen:
+	test	SG_STATE, FETCH_INPROG jz disable_ccsgen_fetch_done;
+	clr	CCSGCTL;
+disable_ccsgen_fetch_done:
+	clr	SG_STATE ret;
+
+data_group_idle_loop:
+	mov	SAVED_MODE, MODE_PTR;
+	test	SG_STATE, LOADING_NEEDED jz . + 2;
+	call	service_fifo;
+	TOGGLE_DFF_MODE
+	test	SG_STATE, LOADING_NEEDED jz . + 2;
+	call	service_fifo;
+	call	idle_loop_cchan;
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
+		mov	SAVED_MODE jmp set_mode_work_around;
+	} else {
+		mov	MODE_PTR, SAVED_MODE ret;
+	}
+
+service_fifo:
+	/*
+	 * Do we have any prefetch left???
+	 */
+	test	SG_STATE, SEGS_AVAIL jnz idle_sg_avail;
+
+	/*
+	 * Can this FIFO have access to the S/G cache yet?
+	 */
+	test	CCSGCTL, SG_CACHE_AVAIL jz return;
+
+	/* Did we just finish fetching segs? */
+	cmp	CCSGCTL, CCSGEN|SG_CACHE_AVAIL|CCSGDONE
+		je idle_sgfetch_complete;
+
+	/* Are we actively fetching segments? */
+	test	CCSGCTL, CCSGEN jnz return;
+
+	/*
+	 * We fetch a "cacheline aligned" and sized amount of data
+	 * so we don't end up referencing a non-existant page.
+	 * Cacheline aligned is in quotes because the kernel will
+	 * set the prefetch amount to a reasonable level if the
+	 * cacheline size is unknown.
+	 */
+	and	SGHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
+	mvi	SGHCNT, SG_PREFETCH_CNT;
+	if ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0) {
+		/*
+		 * Need two instruction between "touches" of SGHADDR.
+		 * Note the setting of SGHCNT counts as one of
+		 * these two instructions.
+		 */
+		nop;
+	}
+	bmov	SGHADDR[1], SCB_RESIDUAL_SGPTR[1], 3;
+	mvi	CCSGCTL, CCSGEN|SG_CACHE_AVAIL|CCSGRESET;
+	or	SG_STATE, FETCH_INPROG ret;
+idle_sgfetch_complete:
+	/*
+	 * Guard against SG_CACHE_AVAIL activating during sg fetch
+	 * request in the other FIFO.
+	 */
+	test	SG_STATE, FETCH_INPROG jz return;
+	clr	CCSGCTL;
+	and	CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
+	mvi	SG_STATE, SEGS_AVAIL|LOADING_NEEDED;
+idle_sg_avail:
+	/* Does the hardware have space for another SG entry? */
+	test	DFSTATUS, PRELOAD_AVAIL jz return;
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		bmov	HADDR, CCSGRAM, 8;
+	} else {
+		bmov 	HADDR, CCSGRAM, 4;
+	}
+	bmov	HCNT, CCSGRAM, 3;
+	test	HCNT[0], 0x1 jz . + 2;
+	xor	DATA_COUNT_ODD, 0x1;
+	bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
+	if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
+		and	HADDR[4], SG_HIGH_ADDR_BITS, SCB_RESIDUAL_DATACNT[3];
+	}
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		/* Skip 4 bytes of pad. */
+		add	CCSGADDR, 4;
+	}
+sg_advance:
+	clr	A;			/* add sizeof(struct scatter) */
+	add	SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
+	adc	SCB_RESIDUAL_SGPTR[1],A;
+	adc	SCB_RESIDUAL_SGPTR[2],A;
+	adc	SCB_RESIDUAL_SGPTR[3],A;
+	mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
+	test	DATA_COUNT_ODD, 0x1 jz . + 2;
+	or	SINDEX, ODD_SEG;
+	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 3;
+	or	SINDEX, LAST_SEG;
+	clr	SG_STATE;
+	mov	SG_CACHE_PRE, SINDEX;
+	/*
+	 * Load the segment.  Or in HDMAEN here too
+	 * just in case HDMAENACK has not come true
+	 * by the time this segment is loaded.  If
+	 * HDMAENACK is not true, this or will disable
+	 * HDMAEN mid-transfer.  We do not want to simply
+	 * mvi our original settings as SCSIEN automatically
+	 * de-asserts and we don't want to accidentally
+	 * re-enable it.
+	 */
+	or	DFCNTRL, PRELOADEN|HDMAEN;
+	/*
+	 * Do we have another segment in the cache?
+	 */
+	add	NONE, SG_PREFETCH_CNT_LIMIT, CCSGADDR;
+	jnc	return;
+	and	SG_STATE, ~SEGS_AVAIL ret;
+
+/*
+ * Initialize the DMA address and counter from the SCB.
+ */
+load_first_seg:
+	bmov	HADDR, SCB_DATAPTR, 11;
+	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];
+	and	REG_ISR, ~SG_FULL_RESID, SCB_SGPTR[0];
+	test	SCB_DATACNT[3], SG_LAST_SEG jz . + 2;
+	or	REG_ISR, LAST_SEG;
+	test	DATA_COUNT_ODD, 0x1 jz . + 2;
+	or	REG_ISR, ODD_SEG;
+	mov	SG_CACHE_PRE, REG_ISR;
+	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
+	/*
+	 * Since we've are entering a data phase, we will
+	 * rely on the SCB_RESID* fields.  Initialize the
+	 * residual and clear the full residual flag.
+	 */
+	and	SCB_SGPTR[0], ~SG_FULL_RESID;
+	bmov	SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
+	/* If we need more S/G elements, tell the idle loop */
+	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz . + 2;
+	mvi	SG_STATE, LOADING_NEEDED ret;
+	clr	SG_STATE ret;
+
+p_data:
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT	jz p_data_allowed;
+	mvi	SEQINTCODE, PROTO_VIOLATION;
+p_data_allowed:
+ 
+	test	SEQ_FLAGS, DPHASE	jz data_phase_initialize;
+
+	/*
+	 * If we re-enter the data phase after going through another
+	 * phase, our transfer location has almost certainly been
+	 * corrupted by the interveining, non-data, transfers.  Ask
+	 * the host driver to fix us up based on the transfer residual
+	 * unless we already know that we should be bitbucketing.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
+	mvi	SEQINTCODE, PDATA_REINIT;
+	jmp	data_group_dma_loop;
+
+p_data_bitbucket:
+	/*
+	 * Turn on `Bit Bucket' mode, wait until the target takes
+	 * us to another phase, and then notify the host.
+	 */
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz bitbucket_not_m_dff;
+	/*
+	 * Ensure that any FIFO contents are cleared out and the
+	 * FIFO free'd prior to starting the BITBUCKET.  BITBUCKET
+	 * doesn't discard data already in the FIFO.
+	 */
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+	SET_MODE(M_SCSI, M_SCSI)
+bitbucket_not_m_dff:
+	or	SXFRCTL1,BITBUCKET;
+	/* Wait for non-data phase. */
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz .;
+	and	SXFRCTL1, ~BITBUCKET;
+	SET_MODE(M_DFF1, M_DFF1)
+	mvi	SEQINTCODE, DATA_OVERRUN;
+	jmp	ITloop;
+
+data_phase_initialize:
+	test	SCB_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
+	call	load_first_seg;
+data_phase_inbounds:
+	/* We have seen a data phase at least once. */
+	or	SEQ_FLAGS, DPHASE;
+data_group_dma_loop:
+	/*
+	 * The transfer is complete if either the last segment
+	 * completes or the target changes phase.  Both conditions
+	 * will clear SCSIEN.
+	 */
+	call	data_group_idle_loop;
+	test	DFCNTRL, SCSIEN jnz data_group_dma_loop;
+
+data_group_dmafinish:
+	/*
+	 * The transfer has terminated either due to a phase
+	 * change, and/or the completion of the last segment.
+	 * We have two goals here.  Do as much other work
+	 * as possible while the data fifo drains on a read
+	 * and respond as quickly as possible to the standard
+	 * messages (save data pointers/disconnect and command
+	 * complete) that usually follow a data phase.
+	 */
+	call	calc_residual;
+
+	/*
+	 * Go ahead and shut down the DMA engine now.
+	 */
+	test	DFCNTRL, DIRECTION jnz data_phase_finish;
+data_group_fifoflush:
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	/*
+	 * We have enabled the auto-ack feature.  This means
+	 * that the controller may have already transferred
+	 * some overrun bytes into the data FIFO and acked them
+	 * on the bus.  The only way to detect this situation is
+	 * to wait for LAST_SEG_DONE to come true on a completed
+	 * transfer and then test to see if the data FIFO is
+	 * non-empty.  We know there is more data yet to transfer
+	 * if SG_LIST_NULL is not yet set, thus there cannot be
+	 * an overrun.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_finish;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
+	test	DFSTATUS, FIFOEMP jnz data_phase_finish;
+	/* Overrun */
+	jmp	p_data;
+data_phase_finish:
+	/*
+	 * If the target has left us in data phase, loop through
+	 * the dma code again.  We will only loop if there is a
+	 * data overrun.  
+	 */
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		test	SSTAT0, TARGET jnz data_phase_done;
+	}
+	if ((ahd->flags & AHD_INITIATORROLE) != 0) {
+		test	SSTAT1, REQINIT jz .;
+		test	SCSIPHASE, DATA_PHASE_MASK jnz p_data;
+	}
+
+data_phase_done:
+	/* Kill off any pending prefetch */
+	call	disable_ccsgen;
+
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		test	SEQ_FLAGS, DPHASE_PENDING jz ITloop;
+		/*
+		and	SEQ_FLAGS, ~DPHASE_PENDING;
+		 * For data-in phases, wait for any pending acks from the
+		 * initiator before changing phase.  We only need to
+		 * send Ignore Wide Residue messages for data-in phases.
+		test	DFCNTRL, DIRECTION jz target_ITloop;
+		test	SSTAT1, REQINIT	jnz .;
+		test	DATA_COUNT_ODD, 0x1 jz target_ITloop;
+		SET_MODE(M_SCSI, M_SCSI)
+		test	NEGCONOPTS, WIDEXFER jz target_ITloop;
+		 */
+		/*
+		 * Issue an Ignore Wide Residue Message.
+		mvi	P_MESGIN|BSYO call change_phase;
+		mvi	MSG_IGN_WIDE_RESIDUE call target_outb;
+		mvi	1 call target_outb;
+		jmp	target_ITloop;
+		 */
+	} else {
+		jmp	ITloop;
+	}
+
+/*
+ * We assume that, even though data may still be
+ * transferring to the host, that the SCSI side of
+ * the DMA engine is now in a static state.  This
+ * allows us to update our notion of where we are
+ * in this transfer.
+ *
+ * If, by chance, we stopped before being able
+ * to fetch additional segments for this transfer,
+ * yet the last S/G was completely exhausted,
+ * call our idle loop until it is able to load
+ * another segment.  This will allow us to immediately
+ * pickup on the next segment on the next data phase.
+ *
+ * If we happened to stop on the last segment, then
+ * our residual information is still correct from
+ * the idle loop and there is no need to perform
+ * any fixups.
+ */
+calc_residual:
+	test	SG_CACHE_SHADOW, LAST_SEG jz residual_before_last_seg;
+	/* Record if we've consumed all S/G entries */
+	test	MDFFSTAT, SHVALID	jz . + 2;
+	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
+	or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL ret;
+residual_before_last_seg:
+	test    MDFFSTAT, SHVALID	jnz sgptr_fixup;
+	/*
+	 * Can never happen from an interrupt as the packetized
+	 * hardware will only interrupt us once SHVALID or
+	 * LAST_SEG_DONE.
+	 */
+	call	data_group_idle_loop;
+	jmp	calc_residual;
+
+sgptr_fixup:
+	/*
+	 * Fixup the residual next S/G pointer.  The S/G preload
+	 * feature of the chip allows us to load two elements
+	 * in addition to the currently active element.  We
+	 * store the bottom byte of the next S/G pointer in
+	 * the SG_CACHE_PTR register so we can restore the
+	 * correct value when the DMA completes.  If the next
+	 * sg ptr value has advanced to the point where higher
+	 * bytes in the address have been affected, fix them
+	 * too.
+	 */
+	test	SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
+	test	SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
+	add	SCB_RESIDUAL_SGPTR[1], -1;
+	adc	SCB_RESIDUAL_SGPTR[2], -1; 
+	adc	SCB_RESIDUAL_SGPTR[3], -1;
+sgptr_fixup_done:
+	and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
+	clr	DATA_COUNT_ODD;
+	test	SG_CACHE_SHADOW, ODD_SEG jz . + 2;
+	or	DATA_COUNT_ODD, 0x1;
+	clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
+	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
+
+export seq_isr:
+	nop;	/* Jumps in the first ISR instruction fail on Rev A. */
+	test	SEQINTSRC, SAVEPTRS	jnz saveptr_intr;
+	test	SEQINTSRC, CFG4DATA	jnz cfg4data_intr;
+	test	SEQINTSRC, CFG4ISTAT	jnz cfg4istat_intr;
+	test	SEQINTSRC, CFG4ICMD	jnz cfg4icmd_intr;
+	mvi	SEQINTCODE, INVALID_SEQINT;
+
+/*
+ * There are two types of save pointers interrupts:
+ * The first is a snapshot save pointers where the current FIFO is not
+ * active and contains a snapshot of the current poniter information.
+ * This happens between packets in a stream for a single L_Q.  Since we
+ * are not performing a pointer save, we can safely clear the channel
+ * so it can be used for other transactions.
+ *
+ * The second case is a save pointers on an active FIFO which occurs
+ * if the target changes to a new L_Q or busfrees/QAS' and the transfer
+ * has a residual.  This should occur coincident with a ctxtdone.  We
+ * disable the interrupt and allow our active routine to handle the
+ * save.
+ */
+saveptr_intr:
+	test	DFCNTRL, HDMAENACK jz snapshot_saveptr;
+	and	SEQIMODE, ~ENSAVEPTRS;
+	or	SEQINTCTL, IRET ret;
+snapshot_saveptr:
+	mvi	DFFSXFRCTL, CLRCHN;
+	or	SEQINTCTL, IRET ret;
+
+cfg4data_intr:
+	test	SCB_SGPTR[0], SG_LIST_NULL jnz pkt_handle_overrun;
+	call	load_first_seg;
+	call	pkt_handle_xfer;
+	or	SEQINTCTL, IRET ret;
+
+cfg4istat_intr:
+	call	freeze_queue;
+	add	NONE, -13, SCB_CDB_LEN;
+	jnc	cfg4istat_have_sense_addr;
+	test	SCB_CDB_LEN, SCB_CDB_LEN_PTR jnz cfg4istat_have_sense_addr;
+	/*
+	 * Host sets up address/count and enables transfer.
+	 */
+	mvi	SEQINTCODE, CFG4ISTAT_INTR;
+	jmp	cfg4istat_setup_handler;
+cfg4istat_have_sense_addr:
+	bmov	HADDR, SCB_SENSE_BUSADDR, 4;
+	mvi	HCNT[1], (AHD_SENSE_BUFSIZE >> 8);
+	mvi	SG_CACHE_PRE, LAST_SEG;
+	mvi	DFCNTRL, PRELOADEN|SCSIEN|HDMAEN;
+cfg4istat_setup_handler:
+	/*
+	 * Status pkt is transferring to host.
+	 * Wait in idle loop for transfer to complete.
+	 */
+	call	pkt_handle_status;
+	or	SEQINTCTL, IRET ret;
+
+/*
+ * See if the target has gone on in this context creating an
+ * overrun condition.  For the write case, the hardware cannot
+ * ack bytes until data are provided.  So, if the target begins
+ * another  packet without changing contexts, implying we are
+ * not sitting on a packet boundary, we are in an overrun
+ * situation.  For the read case, the hardware will continue to
+ * ack bytes into the FIFO, and may even ack the last overrun packet
+ * into the FIFO.   If the FIFO should become non-empty, we are in
+ * a read overrun case.
+ */
+#define check_overrun							\
+	/* Not on a packet boundary. */					\
+	test 	MDFFSTAT, DLZERO jz pkt_handle_overrun;			\
+	test	DFSTATUS, FIFOEMP jz pkt_handle_overrun
+
+pkt_handle_xfer:
+	bmov	LONGJMP_SCB, SCBPTR, 2;
+	test	SG_STATE, LOADING_NEEDED jz pkt_last_seg;
+	call	setjmp;
+	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
+	test	SCSISIGO, ATNO jnz . + 2;
+	test	SSTAT2, NONPACKREQ jz pkt_service_fifo;
+	/*
+	 * Defer handling of this NONPACKREQ until we
+	 * can be sure it pertains to this FIFO.  SAVEPTRS
+	 * will not be asserted if the NONPACKREQ is for us,
+	 * so we must simulate it if shaddow is valid.  If
+	 * shaddow is not valid, keep running this FIFO until we
+	 * have satisfied the transfer by loading segments and
+	 * waiting for either shaddow valid or last_seg_done.
+	 */
+	test	MDFFSTAT, SHVALID jnz pkt_saveptrs;
+pkt_service_fifo:
+	test	SG_STATE, LOADING_NEEDED jnz service_fifo;
+pkt_last_seg:
+	call	setjmp;
+	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz last_pkt_done;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
+	test	SCSISIGO, ATNO jnz . + 2;
+	test	SSTAT2, NONPACKREQ jz return;
+	test	MDFFSTAT, SHVALID jz return;
+	/* FALLTHROUGH */
+
+/*
+ * Either a SAVEPTRS interrupt condition is pending for this FIFO
+ * or we have a pending nonpackreq for this FIFO.  We differentiate
+ * between the two by capturing the state of the SAVEPTRS interrupt
+ * prior to clearing this status and executing the common code for
+ * these two cases.
+ */
+pkt_saveptrs:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	mov	REG0, SEQINTSRC;
+	call	calc_residual;
+	call	save_pointers;
+	mvi	CLRSEQINTSRC, CLRSAVEPTRS;
+	call	disable_ccsgen;
+	or	SEQIMODE, ENSAVEPTRS;
+	test	DFCNTRL, DIRECTION jnz pkt_saveptrs_check_status;
+	test	DFSTATUS, FIFOEMP jnz pkt_saveptrs_check_status;
+	/*
+	 * Keep a handler around for this FIFO until it drains
+	 * to the host to guarantee that we don't complete the
+	 * command to the host before the data arrives.
+	 */
+pkt_saveptrs_wait_fifoemp:
+	call	setjmp;
+	test	DFSTATUS, FIFOEMP jz return;
+pkt_saveptrs_check_status:
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	test	REG0, SAVEPTRS jz unexpected_nonpkt_phase;
+	test	SCB_CONTROL, STATUS_RCVD jz pkt_saveptrs_clrchn;
+	jmp	last_pkt_complete;
+pkt_saveptrs_clrchn:
+	mvi	DFFSXFRCTL, CLRCHN ret;
+END_CRITICAL;
+
+last_pkt_done:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	test	SCB_CONTROL, STATUS_RCVD jz wait_pkt_end;
+	check_overrun;
+	or	SCB_SGPTR, SG_LIST_NULL;
+	/*
+	 * It is safe to skip the other FIFO check since
+	 * we defer CLRCHN on SAVEPTRS until all data in
+	 * the FIFO are seen by the host and a CFG4DATA
+	 * in this FIFO for the same context is held off
+	 * by hardware.
+	 */
+last_pkt_queue_scb:
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	bmov	ARG_1, SCBPTR, 2;
+	mvi	DFFSXFRCTL, CLRCHN;
+	jmp	queue_arg1_scb_completion;
+
+last_pkt_complete:
+	bmov	ARG_1, SCBPTR, 2;
+	mvi	DFFSXFRCTL, CLRCHN;
+check_other_fifo:
+	clc;
+	TOGGLE_DFF_MODE
+	call	check_fifo;
+	jnc	queue_arg1_scb_completion;
+return:
+	ret;
+
+wait_pkt_end:
+	call	setjmp;
+END_CRITICAL;
+wait_pkt_end_loop:
+	test	SEQINTSRC, CTXTDONE jnz pkt_end;
+	check_overrun;
+	test	SSTAT2, NONPACKREQ jz return;
+	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
+pkt_end:
+BEGIN_CRITICAL;
+	check_overrun;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	or	SCB_SGPTR, SG_LIST_NULL;
+	test	SCB_CONTROL, STATUS_RCVD jnz last_pkt_complete;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+END_CRITICAL;
+
+check_status_overrun:
+	test	SHCNT[2], 0xFF jz status_IU_done;
+	mvi	SEQINTCODE, STATUS_OVERRUN;
+	jmp	status_IU_done;
+pkt_handle_status:
+	call	setjmp_setscb;
+	test	MDFFSTAT, LASTSDONE jnz check_status_overrun;
+	test	SEQINTSRC, CTXTDONE jz return;
+status_IU_done:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	mvi	SCB_SCSI_STATUS, STATUS_PKT_SENSE;
+	or	SCB_CONTROL, STATUS_RCVD;
+	jmp	last_pkt_complete;
+END_CRITICAL;
+
+SET_SRC_MODE	M_DFF0;
+SET_DST_MODE	M_DFF0;
+BEGIN_CRITICAL;
+check_fifo:
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz return;
+	mov	A, ARG_2;
+	cmp	LONGJMP_SCB[1], A	jne return;
+	mov	A, ARG_1;
+	cmp	LONGJMP_SCB[0], A	jne return;
+	stc	ret;
+END_CRITICAL;
+
+/*
+ * Nonpackreq is a polled status.  It can come true in three situations:
+ * we have received an L_Q, we have sent one or more L_Qs, or there is no
+ * L_Q context associated with this REQ (REQ occurs immediately after a
+ * (re)selection).  Routines that know that the context responsible for this
+ * nonpackreq call directly into unexpected_nonpkt_phase.  In the case of the
+ * top level idle loop, we exhaust all active contexts prior to determining that
+ * we simply do not have the full I_T_L_Q for this phase.
+ */
+unexpected_nonpkt_phase_find_ctxt:
+	/*
+	 * This nonpackreq is most likely associated with one of the tags
+	 * in a FIFO or an outgoing LQ.  Only treat it as an I_T only
+	 * nonpackreq if we've cleared out the FIFOs and handled any
+	 * pending SELDO.
+	 */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+	and	A, FIFO1FREE|FIFO0FREE, DFFSTAT;
+	cmp	A, FIFO1FREE|FIFO0FREE jne return;
+	test	SSTAT0, SELDO jnz return;
+	mvi	SCBPTR[1], SCB_LIST_NULL;
+unexpected_nonpkt_phase:
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz . + 3;
+SET_SRC_MODE	M_DFF0;
+SET_DST_MODE	M_DFF0;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	mvi	DFFSXFRCTL, CLRCHN;
+	mvi	CLRSINT2, CLRNONPACKREQ;
+	test	SCSIPHASE, ~(MSG_IN_PHASE|MSG_OUT_PHASE) jnz illegal_phase;
+	mvi	SEQINTCODE, ENTERING_NONPACK;
+	jmp	ITloop;
+
+illegal_phase:
+	mvi	SEQINTCODE, ILLEGAL_PHASE;
+	jmp	ITloop;
+
+/*
+ * We have entered an overrun situation.  If we have working
+ * BITBUCKET, flip that on and let the hardware eat any overrun
+ * data.  Otherwise use an overrun buffer in the host to simulate
+ * BITBUCKET.
+ */
+pkt_handle_overrun:
+	mvi	SEQINTCODE, CFG4OVERRUN;
+	call	freeze_queue;
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0) {
+		SET_MODE(M_SCSI, M_SCSI)
+		or	SXFRCTL1,BITBUCKET;
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	} else {
+		call	load_overrun_buf;
+		mvi	DFCNTRL, (HDMAEN|SCSIEN|PRELOADEN);
+	}
+	call	setjmp;
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+		test	DFSTATUS, PKT_PRELOAD_AVAIL jz overrun_load_done;
+		call	load_overrun_buf;
+		or	DFCNTRL, PRELOADEN;
+overrun_load_done:
+	}
+	test	SEQINTSRC, CTXTDONE jnz pkt_overrun_end;
+	test	SSTAT2, NONPACKREQ jz return;
+pkt_overrun_end:
+	or	SCB_RESIDUAL_SGPTR, SG_OVERRUN_RESID;
+	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
+	test	SCB_CONTROL, STATUS_RCVD jnz last_pkt_queue_scb;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+
+if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+load_overrun_buf:
+	/*
+	 * Load a dummy segment if preload space is available.
+	 */
+	mov 	HADDR[0], SHARED_DATA_ADDR;
+	add	HADDR[1], PKT_OVERRUN_BUFOFFSET, SHARED_DATA_ADDR[1];
+	mov	ACCUM_SAVE, A;
+	clr	A;
+	adc	HADDR[2], A, SHARED_DATA_ADDR[2];
+	adc	HADDR[3], A, SHARED_DATA_ADDR[3];
+	mov	A, ACCUM_SAVE;
+	bmov	HADDR[4], ALLZEROS, 4;
+	/* PKT_OVERRUN_BUFSIZE is a multiple of 256 */
+	clr	HCNT[0];
+	mvi	HCNT[1], ((PKT_OVERRUN_BUFSIZE >> 8) & 0xFF);
+	clr	HCNT[2];
+}
+
+cfg4icmd_intr:
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_seq.h linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_seq.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aic79xx_seq.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aic79xx_seq.h	2002-09-11 18:39:01.000000000 -0600
@@ -0,0 +1,913 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#60 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#45 $
+ */
+static uint8_t seqprog[] = {
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x60, 0x3a, 0x0e, 0x68,
+	0x04, 0x47, 0x0f, 0x68,
+	0xff, 0x21, 0x0f, 0x70,
+	0x40, 0x4b, 0x3a, 0x69,
+	0x00, 0xe2, 0xfa, 0x58,
+	0x40, 0x4b, 0x3a, 0x69,
+	0x20, 0x4b, 0x2a, 0x69,
+	0xfc, 0x42, 0x18, 0x78,
+	0x10, 0x40, 0x18, 0x78,
+	0x00, 0xe2, 0x0a, 0x5d,
+	0x20, 0x4d, 0x1c, 0x78,
+	0x00, 0xe2, 0x0a, 0x5d,
+	0x01, 0x52, 0x44, 0x78,
+	0x02, 0x58, 0x50, 0x31,
+	0xff, 0xea, 0x10, 0x0b,
+	0x08, 0xa8, 0x51, 0x03,
+	0x01, 0xa4, 0x2b, 0x78,
+	0x00, 0xe2, 0xd4, 0x5a,
+	0x00, 0xe2, 0x1c, 0x40,
+	0xff, 0xea, 0xd4, 0x19,
+	0x02, 0xa8, 0x84, 0x32,
+	0x00, 0xea, 0xee, 0x58,
+	0xff, 0xea, 0x00, 0x08,
+	0x00, 0xe2, 0xfe, 0x5c,
+	0x00, 0xe2, 0x44, 0x48,
+	0x11, 0xea, 0xee, 0x58,
+	0x11, 0xea, 0x00, 0x00,
+	0x00, 0xe2, 0xfe, 0x5c,
+	0x00, 0xe2, 0x44, 0x48,
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x00, 0xe2, 0xcc, 0x5a,
+	0x00, 0xea, 0xee, 0x58,
+	0xff, 0xea, 0x00, 0x08,
+	0x80, 0xf9, 0x4c, 0x68,
+	0x00, 0xe2, 0xec, 0x58,
+	0x11, 0xea, 0xee, 0x58,
+	0x11, 0xea, 0x00, 0x00,
+	0x80, 0xf9, 0x54, 0x68,
+	0x00, 0xe2, 0xec, 0x58,
+	0x00, 0xe2, 0x58, 0x58,
+	0x00, 0xe2, 0x00, 0x40,
+	0x22, 0xea, 0xee, 0x58,
+	0x22, 0xea, 0x00, 0x00,
+	0x18, 0xad, 0xa4, 0x78,
+	0x04, 0xad, 0x74, 0x68,
+	0x80, 0xad, 0xce, 0x7c,
+	0x10, 0xad, 0x66, 0x78,
+	0xe7, 0xad, 0x5a, 0x0d,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x02, 0xea, 0x02, 0x00,
+	0xff, 0xea, 0x56, 0x02,
+	0x04, 0x7c, 0x76, 0x32,
+	0x20, 0x16, 0xce, 0x7c,
+	0x04, 0x37, 0x77, 0x32,
+	0x80, 0x3f, 0x7f, 0x16,
+	0x40, 0xad, 0xce, 0x7c,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x02, 0xa8, 0x40, 0x31,
+	0x04, 0x94, 0x49, 0x32,
+	0xff, 0xea, 0x2a, 0x03,
+	0xff, 0xea, 0x2e, 0x03,
+	0x10, 0xa8, 0x95, 0x68,
+	0x3d, 0xa9, 0xc5, 0x29,
+	0xfe, 0xe2, 0xc4, 0x09,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xec, 0x50, 0x31,
+	0x02, 0xa0, 0xda, 0x31,
+	0xff, 0xa9, 0x94, 0x70,
+	0x02, 0xa0, 0x28, 0x33,
+	0x01, 0x10, 0xd4, 0x35,
+	0xff, 0x21, 0x9f, 0x70,
+	0x02, 0x22, 0x51, 0x31,
+	0x02, 0xa0, 0x2c, 0x33,
+	0x02, 0xa0, 0x44, 0x32,
+	0x01, 0x10, 0xd4, 0x35,
+	0x02, 0xa0, 0x40, 0x32,
+	0x02, 0xa0, 0x44, 0x32,
+	0x01, 0x10, 0xd4, 0x35,
+	0x04, 0x47, 0xa9, 0x68,
+	0x40, 0x16, 0xd2, 0x68,
+	0xff, 0x2d, 0xd7, 0x60,
+	0xff, 0x29, 0xcf, 0x74,
+	0x01, 0x3f, 0xc1, 0x31,
+	0x02, 0x28, 0x55, 0x32,
+	0x01, 0xea, 0x5a, 0x01,
+	0x04, 0x3b, 0xf9, 0x30,
+	0x01, 0x28, 0x61, 0x31,
+	0x00, 0x29, 0x61, 0x01,
+	0x02, 0x28, 0x51, 0x31,
+	0x00, 0xe2, 0xc2, 0x40,
+	0x01, 0x8c, 0x61, 0x31,
+	0x00, 0x8d, 0x61, 0x01,
+	0x02, 0x8c, 0x51, 0x31,
+	0x01, 0x14, 0xd4, 0x31,
+	0xff, 0x8d, 0xcb, 0x70,
+	0x80, 0xac, 0xca, 0x70,
+	0x20, 0x16, 0xbc, 0x78,
+	0x01, 0xac, 0x08, 0x31,
+	0x09, 0xea, 0x5a, 0x01,
+	0x02, 0x8c, 0x51, 0x32,
+	0xff, 0xea, 0x1a, 0x07,
+	0x04, 0x24, 0xf9, 0x30,
+	0x1d, 0xea, 0xe2, 0x40,
+	0x02, 0x2c, 0x51, 0x31,
+	0x04, 0xac, 0xf9, 0x30,
+	0x19, 0xea, 0xe2, 0x58,
+	0x02, 0x8c, 0x59, 0x32,
+	0x02, 0x28, 0x19, 0x33,
+	0x02, 0xa8, 0x50, 0x36,
+	0x06, 0xea, 0x08, 0x81,
+	0x01, 0xe2, 0x5a, 0x35,
+	0x02, 0xa8, 0xf4, 0x31,
+	0x02, 0xf2, 0xf0, 0x35,
+	0x02, 0xf2, 0xf0, 0x31,
+	0x02, 0xf8, 0xe4, 0x35,
+	0x80, 0xea, 0xb2, 0x01,
+	0x01, 0xe2, 0x00, 0x30,
+	0xff, 0xea, 0xb2, 0x0d,
+	0x80, 0xea, 0xb2, 0x01,
+	0x11, 0x00, 0x00, 0x10,
+	0xff, 0xea, 0xb2, 0x0d,
+	0x02, 0x20, 0xbd, 0x30,
+	0x02, 0x20, 0xb9, 0x30,
+	0x02, 0x20, 0x51, 0x31,
+	0x4c, 0xa9, 0xd7, 0x28,
+	0x10, 0xa8, 0x09, 0x79,
+	0x01, 0x6b, 0xc0, 0x30,
+	0x02, 0x64, 0xc8, 0x00,
+	0x40, 0x3a, 0x74, 0x04,
+	0x00, 0xea, 0xee, 0x58,
+	0xff, 0xea, 0x00, 0x08,
+	0x80, 0xf9, 0x12, 0x69,
+	0x00, 0xe2, 0xec, 0x58,
+	0x11, 0xea, 0xee, 0x58,
+	0x11, 0xea, 0x00, 0x00,
+	0x80, 0xf9, 0x1a, 0x69,
+	0x00, 0xe2, 0xec, 0x58,
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x30, 0x3f, 0xc0, 0x09,
+	0x30, 0xe0, 0x0a, 0x61,
+	0x01, 0x3f, 0x7e, 0x00,
+	0x11, 0xea, 0xee, 0x58,
+	0x11, 0xea, 0x00, 0x00,
+	0x02, 0x48, 0x51, 0x35,
+	0x08, 0xea, 0x98, 0x00,
+	0x08, 0x57, 0xae, 0x00,
+	0x08, 0x3c, 0x78, 0x00,
+	0xf0, 0x49, 0x68, 0x0a,
+	0x0f, 0x67, 0xc0, 0x09,
+	0x00, 0x34, 0x69, 0x02,
+	0x20, 0xea, 0x96, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0x40, 0x3a, 0x56, 0x69,
+	0x02, 0x55, 0x00, 0x68,
+	0x02, 0x56, 0x56, 0x69,
+	0xff, 0x5b, 0x56, 0x61,
+	0x02, 0x20, 0x51, 0x31,
+	0x80, 0xea, 0xb2, 0x01,
+	0x44, 0xea, 0x00, 0x00,
+	0x01, 0x33, 0xc0, 0x31,
+	0x33, 0xea, 0x00, 0x00,
+	0xff, 0xea, 0xb2, 0x09,
+	0xff, 0xe0, 0xc0, 0x19,
+	0xff, 0xe0, 0x58, 0x79,
+	0x02, 0x94, 0x51, 0x31,
+	0x00, 0xe2, 0x4e, 0x41,
+	0x02, 0x5e, 0x50, 0x31,
+	0x02, 0xa8, 0xb8, 0x30,
+	0x02, 0x5c, 0x50, 0x31,
+	0xff, 0x95, 0x69, 0x71,
+	0x02, 0x94, 0x41, 0x31,
+	0x02, 0x22, 0x51, 0x31,
+	0x02, 0xa0, 0x2c, 0x33,
+	0x02, 0xa0, 0x44, 0x32,
+	0x00, 0xe2, 0x72, 0x41,
+	0x10, 0xa8, 0x73, 0x69,
+	0x3d, 0xa9, 0xc9, 0x29,
+	0x01, 0xe4, 0xc8, 0x01,
+	0x01, 0xea, 0xca, 0x01,
+	0xff, 0xea, 0xda, 0x01,
+	0x02, 0x20, 0x51, 0x31,
+	0x02, 0x96, 0x41, 0x32,
+	0xff, 0x21, 0x7b, 0x61,
+	0xff, 0xea, 0x46, 0x02,
+	0x02, 0x5c, 0x50, 0x31,
+	0x40, 0xea, 0x96, 0x00,
+	0x02, 0x56, 0x12, 0x6d,
+	0x01, 0x55, 0x12, 0x6d,
+	0x10, 0xa8, 0x87, 0x79,
+	0x10, 0x40, 0x88, 0x69,
+	0x01, 0x56, 0x00, 0x68,
+	0xbf, 0x3a, 0x74, 0x08,
+	0x08, 0xea, 0x98, 0x00,
+	0x08, 0x57, 0xae, 0x00,
+	0x01, 0xa9, 0x69, 0x32,
+	0x01, 0xaa, 0x6b, 0x32,
+	0x08, 0x3c, 0x78, 0x00,
+	0x80, 0xea, 0x62, 0x02,
+	0x40, 0xea, 0x66, 0x02,
+	0x00, 0xe2, 0x32, 0x5b,
+	0x01, 0x36, 0xc1, 0x31,
+	0x9f, 0xe0, 0xce, 0x7b,
+	0x80, 0xe0, 0xaa, 0x71,
+	0xa0, 0xe0, 0xde, 0x71,
+	0xc0, 0xe0, 0xd0, 0x71,
+	0xe0, 0xe0, 0x0e, 0x72,
+	0x01, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0xee, 0x00, 0xae, 0x69,
+	0x05, 0xea, 0xb4, 0x00,
+	0x02, 0xa8, 0x90, 0x32,
+	0x00, 0xe2, 0x1e, 0x59,
+	0xef, 0x92, 0xd5, 0x19,
+	0x00, 0xe2, 0xbe, 0x51,
+	0x0b, 0x84, 0xe1, 0x30,
+	0x02, 0xea, 0x36, 0x00,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0xc6, 0x41,
+	0x01, 0x92, 0xd1, 0x30,
+	0x02, 0xea, 0xd2, 0x30,
+	0x10, 0x80, 0x89, 0x31,
+	0x20, 0xea, 0x32, 0x00,
+	0x20, 0x19, 0xc6, 0x69,
+	0xbf, 0x33, 0x67, 0x0a,
+	0x02, 0x4d, 0x98, 0x69,
+	0x40, 0x33, 0x67, 0x02,
+	0x00, 0xe2, 0x98, 0x41,
+	0x80, 0x33, 0xd7, 0x79,
+	0x03, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x40, 0x42,
+	0x01, 0x44, 0x10, 0x33,
+	0x08, 0xa8, 0x51, 0x03,
+	0x00, 0xe2, 0x98, 0x41,
+	0x10, 0xea, 0x80, 0x00,
+	0x01, 0x31, 0xc5, 0x31,
+	0x80, 0xe2, 0xfa, 0x61,
+	0x10, 0xa8, 0x1f, 0x6a,
+	0xc0, 0xaa, 0xc5, 0x01,
+	0x40, 0xa8, 0xeb, 0x69,
+	0xbf, 0xe2, 0xc4, 0x09,
+	0x20, 0xa8, 0xff, 0x79,
+	0x01, 0xe2, 0x88, 0x30,
+	0x00, 0xe2, 0x32, 0x5b,
+	0xa0, 0x36, 0x07, 0x62,
+	0x23, 0xa8, 0x89, 0x08,
+	0x00, 0xe2, 0x32, 0x5b,
+	0xa0, 0x36, 0x07, 0x62,
+	0x00, 0xa8, 0xfe, 0x41,
+	0xff, 0xe2, 0xfe, 0x61,
+	0x00, 0xe2, 0x1e, 0x42,
+	0x40, 0xea, 0x98, 0x00,
+	0x01, 0xe2, 0x88, 0x30,
+	0x00, 0xe2, 0x32, 0x5b,
+	0xa0, 0x36, 0xdd, 0x71,
+	0x40, 0xea, 0x98, 0x00,
+	0x01, 0x31, 0x89, 0x32,
+	0x08, 0xea, 0x62, 0x02,
+	0x00, 0xe2, 0x98, 0x41,
+	0xe0, 0xea, 0x3e, 0x5b,
+	0x80, 0xe0, 0x44, 0x6a,
+	0x04, 0xe0, 0xe2, 0x72,
+	0x02, 0xe0, 0x14, 0x73,
+	0x00, 0xea, 0xa2, 0x72,
+	0x03, 0xe0, 0x24, 0x73,
+	0x23, 0xe0, 0x2e, 0x72,
+	0x08, 0xe0, 0x40, 0x72,
+	0x00, 0xe2, 0x32, 0x5b,
+	0x07, 0xea, 0x04, 0x00,
+	0x08, 0x42, 0x99, 0x71,
+	0x04, 0x42, 0x2b, 0x62,
+	0x01, 0x43, 0x89, 0x30,
+	0x00, 0xe2, 0x1e, 0x42,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0x1e, 0x42,
+	0x4c, 0x34, 0xc1, 0x28,
+	0x01, 0x64, 0x3e, 0x7a,
+	0xa0, 0xea, 0x36, 0x5b,
+	0x01, 0xa0, 0x3e, 0x62,
+	0x01, 0x84, 0x3b, 0x7a,
+	0x01, 0xa7, 0x40, 0x7a,
+	0x05, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x40, 0x42,
+	0x07, 0xea, 0x46, 0x5b,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0x98, 0x41,
+	0x3f, 0xe0, 0x6a, 0x0a,
+	0xc0, 0x34, 0xc1, 0x09,
+	0x00, 0x35, 0x51, 0x01,
+	0xff, 0xea, 0x52, 0x09,
+	0x30, 0x34, 0xc5, 0x09,
+	0x3d, 0xe2, 0xc4, 0x29,
+	0xb8, 0xe2, 0xc4, 0x19,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xec, 0x40, 0x31,
+	0xff, 0xa1, 0x60, 0x72,
+	0x02, 0xe8, 0xda, 0x31,
+	0x02, 0xa0, 0x50, 0x31,
+	0x00, 0xe2, 0x82, 0x42,
+	0x80, 0x33, 0x67, 0x02,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0x32, 0x5b,
+	0x01, 0x33, 0x67, 0x02,
+	0xe0, 0x36, 0x9b, 0x62,
+	0x02, 0x33, 0x67, 0x02,
+	0x20, 0x46, 0x96, 0x62,
+	0xff, 0xea, 0x52, 0x09,
+	0xa8, 0xea, 0x36, 0x5b,
+	0x04, 0xa8, 0x7d, 0x7a,
+	0x01, 0x34, 0xc1, 0x31,
+	0x00, 0xa9, 0x7d, 0x62,
+	0x01, 0x35, 0xc1, 0x31,
+	0x00, 0xaa, 0x87, 0x72,
+	0x01, 0xa9, 0x52, 0x11,
+	0xff, 0xa9, 0x72, 0x6a,
+	0x00, 0xe2, 0x96, 0x42,
+	0x10, 0x33, 0x67, 0x02,
+	0x04, 0xa8, 0x97, 0x7a,
+	0xfb, 0xa8, 0x51, 0x0b,
+	0xff, 0xea, 0x66, 0x0a,
+	0x01, 0xa4, 0x91, 0x6a,
+	0x02, 0xa8, 0x90, 0x32,
+	0x00, 0xe2, 0x1e, 0x59,
+	0x10, 0xa8, 0x41, 0x7a,
+	0xff, 0xea, 0x46, 0x5b,
+	0x00, 0xe2, 0x40, 0x42,
+	0x04, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x40, 0x42,
+	0x04, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0x03, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x40, 0x42,
+	0xc0, 0x33, 0xa7, 0x6a,
+	0x08, 0xa8, 0xaf, 0x6a,
+	0x80, 0x33, 0x9f, 0x6a,
+	0x08, 0xa8, 0x9f, 0x7a,
+	0xff, 0x88, 0xaf, 0x6a,
+	0x40, 0x33, 0x9f, 0x6a,
+	0x10, 0xa8, 0xb3, 0x7a,
+	0x0a, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xcc, 0x5a,
+	0x00, 0xe2, 0x02, 0x43,
+	0x40, 0x4b, 0xba, 0x6a,
+	0xbf, 0x3a, 0x74, 0x08,
+	0x01, 0xe0, 0xf8, 0x31,
+	0xff, 0xea, 0xc0, 0x09,
+	0x01, 0x2e, 0x5d, 0x1a,
+	0x00, 0x2f, 0x5f, 0x22,
+	0x04, 0x47, 0x8f, 0x02,
+	0x01, 0xfc, 0xc0, 0x35,
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x02, 0x42, 0x51, 0x31,
+	0xff, 0x88, 0xd9, 0x6a,
+	0x01, 0xa4, 0xd5, 0x6a,
+	0x02, 0xa4, 0xdd, 0x6a,
+	0x01, 0x84, 0xdd, 0x7a,
+	0x02, 0x28, 0x19, 0x33,
+	0x02, 0xa8, 0x50, 0x36,
+	0xff, 0x88, 0xdd, 0x72,
+	0x00, 0xe2, 0xb6, 0x5a,
+	0x02, 0x2c, 0x19, 0x33,
+	0x02, 0xa8, 0x58, 0x32,
+	0x04, 0xa4, 0x49, 0x07,
+	0xc0, 0x33, 0xe9, 0x7a,
+	0x03, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x40, 0x42,
+	0x04, 0xa8, 0x51, 0x03,
+	0x20, 0xa8, 0x03, 0x6b,
+	0x02, 0xa8, 0x40, 0x31,
+	0xc0, 0x34, 0xc1, 0x09,
+	0x00, 0x35, 0x51, 0x01,
+	0xff, 0xea, 0x52, 0x09,
+	0x30, 0x34, 0xc5, 0x09,
+	0x3d, 0xe2, 0xc4, 0x29,
+	0xb8, 0xe2, 0xc4, 0x19,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xa0, 0xda, 0x31,
+	0x02, 0xa0, 0x50, 0x31,
+	0xf7, 0x57, 0xae, 0x08,
+	0x08, 0xea, 0x98, 0x00,
+	0x01, 0x44, 0xd4, 0x31,
+	0xee, 0x00, 0x0c, 0x6b,
+	0x02, 0xea, 0xb4, 0x00,
+	0x00, 0xe2, 0x2e, 0x5b,
+	0x09, 0x4c, 0x0e, 0x7b,
+	0x08, 0x4c, 0x00, 0x68,
+	0x0b, 0xea, 0x04, 0x00,
+	0x01, 0x44, 0xd4, 0x31,
+	0x20, 0x33, 0x99, 0x79,
+	0x00, 0xe2, 0x1c, 0x5b,
+	0x00, 0xe2, 0x98, 0x41,
+	0x01, 0x84, 0x21, 0x7b,
+	0x01, 0xa4, 0x49, 0x07,
+	0x08, 0x60, 0x30, 0x33,
+	0x08, 0x80, 0x41, 0x37,
+	0xdf, 0x33, 0x67, 0x0a,
+	0xee, 0x00, 0x2a, 0x6b,
+	0x05, 0xea, 0xb4, 0x00,
+	0x00, 0xe2, 0x1e, 0x59,
+	0x00, 0xe2, 0x40, 0x42,
+	0x01, 0xea, 0x6c, 0x02,
+	0xc0, 0xea, 0x66, 0x06,
+	0xff, 0x42, 0x32, 0x7b,
+	0xe0, 0x41, 0x6c, 0x0e,
+	0x01, 0x44, 0xd4, 0x31,
+	0xff, 0x42, 0x38, 0x7b,
+	0xe0, 0x41, 0x6c, 0x0a,
+	0xe0, 0x36, 0x99, 0x61,
+	0xff, 0xea, 0xca, 0x09,
+	0x01, 0xe2, 0xc8, 0x31,
+	0x01, 0x46, 0xda, 0x35,
+	0x01, 0x44, 0xd4, 0x35,
+	0x10, 0xea, 0x80, 0x00,
+	0x01, 0xe2, 0x62, 0x36,
+	0x04, 0xa6, 0x4e, 0x7b,
+	0xff, 0xea, 0x5a, 0x09,
+	0xff, 0xea, 0x4c, 0x0d,
+	0x01, 0x00, 0x60, 0x32,
+	0x02, 0xa6, 0x56, 0x7b,
+	0x00, 0xe2, 0x64, 0x5b,
+	0x00, 0xe2, 0xf4, 0x58,
+	0x11, 0x00, 0x00, 0x10,
+	0x02, 0xa6, 0x5e, 0x7b,
+	0x00, 0xe2, 0x64, 0x5b,
+	0x00, 0xe2, 0x58, 0x58,
+	0x00, 0x30, 0xef, 0x40,
+	0x01, 0x30, 0x01, 0x34,
+	0x01, 0xa6, 0x80, 0x6b,
+	0x10, 0xad, 0xce, 0x7c,
+	0x98, 0xad, 0x78, 0x73,
+	0x08, 0xad, 0xce, 0x6c,
+	0x02, 0x84, 0xf9, 0x88,
+	0x00, 0xea, 0x08, 0x81,
+	0xff, 0xea, 0xd4, 0x09,
+	0x03, 0x85, 0xfb, 0x30,
+	0x19, 0xea, 0x5a, 0x01,
+	0x04, 0xa6, 0x4c, 0x05,
+	0x04, 0xa6, 0xce, 0x7c,
+	0xff, 0xea, 0x5a, 0x09,
+	0x03, 0x84, 0x59, 0x89,
+	0x03, 0xea, 0x4c, 0x01,
+	0x80, 0x1a, 0xce, 0x7c,
+	0x08, 0xb0, 0xe0, 0x30,
+	0x04, 0xb0, 0xe0, 0x30,
+	0x03, 0xb0, 0xf0, 0x30,
+	0x01, 0x78, 0x8c, 0x7b,
+	0x01, 0xa7, 0x4e, 0x11,
+	0x01, 0xb0, 0x06, 0x33,
+	0x7f, 0x83, 0xe9, 0x08,
+	0x04, 0xac, 0x58, 0x19,
+	0xff, 0xea, 0xc0, 0x09,
+	0x04, 0x84, 0x09, 0x9b,
+	0x00, 0x85, 0x0b, 0x23,
+	0x00, 0x86, 0x0d, 0x23,
+	0x00, 0x87, 0x0f, 0x23,
+	0x01, 0x84, 0xc5, 0x31,
+	0x01, 0xa7, 0xa2, 0x7b,
+	0x04, 0xe2, 0xc4, 0x01,
+	0x80, 0x83, 0xa9, 0x7b,
+	0x02, 0xe2, 0xc4, 0x01,
+	0xff, 0xea, 0x4c, 0x09,
+	0x01, 0xe2, 0x36, 0x30,
+	0x88, 0x19, 0x32, 0x00,
+	0x01, 0xac, 0xd4, 0x99,
+	0x00, 0xe2, 0xce, 0x54,
+	0xfe, 0xa6, 0x4c, 0x0d,
+	0x0b, 0x98, 0xe1, 0x30,
+	0x01, 0xa0, 0x4f, 0x09,
+	0xfd, 0xa4, 0x49, 0x09,
+	0x80, 0xa3, 0xbd, 0x7b,
+	0x02, 0xa4, 0x48, 0x01,
+	0x01, 0xa7, 0xc0, 0x7b,
+	0x04, 0xa4, 0x48, 0x01,
+	0x01, 0xa4, 0x36, 0x30,
+	0xa8, 0xea, 0x32, 0x00,
+	0xfd, 0xa4, 0x49, 0x0b,
+	0x05, 0xa3, 0x07, 0x33,
+	0x80, 0x83, 0xcd, 0x6b,
+	0x02, 0xea, 0x4c, 0x05,
+	0xff, 0xea, 0x4c, 0x0d,
+	0xc0, 0x33, 0xd3, 0x7b,
+	0x03, 0xea, 0x04, 0x00,
+	0x20, 0x33, 0xf1, 0x7b,
+	0x01, 0x84, 0xdb, 0x6b,
+	0x06, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf6, 0x43,
+	0xee, 0x00, 0xe2, 0x6b,
+	0x05, 0xea, 0xb4, 0x00,
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x80, 0x3d, 0x7a, 0x00,
+	0xfc, 0x42, 0xe4, 0x7b,
+	0x7f, 0x3d, 0x7a, 0x08,
+	0x11, 0xea, 0xee, 0x58,
+	0x11, 0xea, 0x00, 0x00,
+	0x09, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0x01, 0xa4, 0xdb, 0x6b,
+	0x00, 0xe2, 0xb2, 0x5b,
+	0x20, 0x33, 0x67, 0x02,
+	0x00, 0xe2, 0x50, 0x5b,
+	0x20, 0x19, 0xf6, 0x6b,
+	0x00, 0xe2, 0x14, 0x5c,
+	0x04, 0x19, 0x08, 0x6c,
+	0x02, 0x19, 0x32, 0x00,
+	0x01, 0x84, 0x09, 0x7c,
+	0x01, 0x1b, 0x02, 0x7c,
+	0x01, 0x1a, 0x08, 0x6c,
+	0x00, 0xe2, 0xce, 0x43,
+	0x80, 0x4b, 0x0e, 0x6c,
+	0x01, 0x4c, 0x0a, 0x7c,
+	0x03, 0x42, 0xce, 0x6b,
+	0x00, 0xe2, 0x4a, 0x5b,
+	0x04, 0x33, 0x99, 0x79,
+	0x00, 0xe2, 0x98, 0x41,
+	0x02, 0x1b, 0x1c, 0x7c,
+	0x08, 0x5d, 0x1a, 0x7c,
+	0x03, 0x68, 0x00, 0x37,
+	0x01, 0x84, 0x09, 0x07,
+	0x08, 0x5d, 0x22, 0x6c,
+	0x00, 0xe2, 0x50, 0x5b,
+	0x00, 0xe2, 0x14, 0x44,
+	0x80, 0x1b, 0x2c, 0x7c,
+	0x80, 0x84, 0x2d, 0x6c,
+	0xff, 0x85, 0x0b, 0x1b,
+	0xff, 0x86, 0x0d, 0x23,
+	0xff, 0x87, 0x0f, 0x23,
+	0xf8, 0x1b, 0x08, 0x0b,
+	0xff, 0xea, 0x4e, 0x09,
+	0x04, 0x1b, 0x34, 0x7c,
+	0x01, 0xa7, 0x4e, 0x01,
+	0xff, 0xea, 0x06, 0x0b,
+	0x03, 0x68, 0x00, 0x37,
+	0xff, 0xea, 0xd4, 0x09,
+	0x20, 0x5b, 0x44, 0x6c,
+	0x10, 0x5b, 0x4e, 0x6c,
+	0x08, 0x5b, 0x56, 0x6c,
+	0x02, 0x5b, 0x5c, 0x6d,
+	0x0e, 0xea, 0x04, 0x00,
+	0x08, 0x19, 0x4a, 0x7c,
+	0xdf, 0x5c, 0xb8, 0x08,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x02, 0xea, 0xb4, 0x00,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x01, 0xa4, 0x25, 0x6d,
+	0x00, 0xe2, 0xb2, 0x5b,
+	0x00, 0xe2, 0x6e, 0x5c,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x00, 0xe2, 0xb6, 0x5a,
+	0xf3, 0x92, 0xd5, 0x19,
+	0x00, 0xe2, 0x62, 0x54,
+	0x80, 0x92, 0x63, 0x6c,
+	0x0f, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x6a, 0x44,
+	0x04, 0x8c, 0xe1, 0x30,
+	0x01, 0xea, 0xf2, 0x00,
+	0x02, 0xea, 0x36, 0x00,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0xee, 0x5c,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x02, 0xa8, 0xf4, 0x31,
+	0x02, 0xa6, 0x80, 0x7c,
+	0x00, 0xe2, 0xe8, 0x58,
+	0x20, 0x5b, 0x8e, 0x6c,
+	0xfc, 0x42, 0x7a, 0x7c,
+	0x10, 0x40, 0x7c, 0x6c,
+	0x20, 0x4d, 0x7e, 0x7c,
+	0x08, 0x5d, 0x8e, 0x6c,
+	0x02, 0xa6, 0x64, 0x6b,
+	0x00, 0xe2, 0xe8, 0x58,
+	0x20, 0x5b, 0x8e, 0x6c,
+	0x01, 0x1b, 0xae, 0x6c,
+	0xfc, 0x42, 0x8a, 0x7c,
+	0x10, 0x40, 0x8c, 0x6c,
+	0x20, 0x4d, 0xce, 0x7c,
+	0x08, 0x5d, 0xce, 0x7c,
+	0x02, 0x19, 0x32, 0x00,
+	0x01, 0x5b, 0x40, 0x31,
+	0x00, 0xe2, 0x14, 0x5c,
+	0x00, 0xe2, 0x1c, 0x5b,
+	0x20, 0xea, 0xb6, 0x00,
+	0x00, 0xe2, 0x4a, 0x5b,
+	0x20, 0x5c, 0xb8, 0x00,
+	0x04, 0x19, 0xa4, 0x6c,
+	0x01, 0x1a, 0xa4, 0x6c,
+	0x00, 0xe2, 0xe8, 0x58,
+	0x01, 0x1a, 0xce, 0x7c,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x20, 0xa0, 0x12, 0x7d,
+	0x08, 0xa8, 0xad, 0x7c,
+	0x00, 0xe2, 0xc0, 0x44,
+	0x02, 0xea, 0xb4, 0x04,
+	0x02, 0x19, 0x32, 0x00,
+	0x08, 0xa8, 0xd1, 0x7c,
+	0x04, 0x5d, 0x24, 0x7d,
+	0x01, 0x1a, 0x24, 0x7d,
+	0x01, 0xa4, 0x49, 0x03,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x02, 0xa8, 0x84, 0x32,
+	0x02, 0xea, 0xb4, 0x00,
+	0x00, 0xe2, 0xc6, 0x42,
+	0x02, 0xa8, 0x84, 0x32,
+	0x02, 0xea, 0xb4, 0x00,
+	0xff, 0xea, 0xd4, 0x19,
+	0x00, 0xe2, 0xf4, 0x58,
+	0x11, 0x00, 0x00, 0x10,
+	0x00, 0xe2, 0xfe, 0x5c,
+	0x00, 0xe2, 0xc6, 0x52,
+	0xff, 0xea, 0xd4, 0x0d,
+	0x00, 0xe2, 0xe8, 0x58,
+	0x40, 0x5b, 0xdc, 0x6c,
+	0x04, 0x5d, 0x24, 0x7d,
+	0x01, 0x1a, 0x24, 0x7d,
+	0x20, 0x4d, 0xce, 0x7c,
+	0x40, 0x5b, 0x12, 0x7d,
+	0x04, 0x5d, 0x24, 0x7d,
+	0x01, 0x1a, 0x24, 0x7d,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x01, 0xa4, 0x49, 0x03,
+	0x08, 0xa8, 0xc1, 0x6c,
+	0x02, 0xea, 0xb4, 0x04,
+	0xff, 0x6a, 0xf4, 0x7c,
+	0x10, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf4, 0x44,
+	0x00, 0xe2, 0xe6, 0x58,
+	0x10, 0x5d, 0xe8, 0x6c,
+	0x40, 0x5b, 0xce, 0x7c,
+	0x02, 0x19, 0x32, 0x00,
+	0x80, 0xf9, 0xf2, 0x01,
+	0xff, 0xea, 0x10, 0x03,
+	0x08, 0xa8, 0x51, 0x03,
+	0x00, 0xe2, 0xc0, 0x44,
+	0x80, 0xf9, 0xce, 0x6c,
+	0x01, 0x43, 0xc1, 0x31,
+	0x00, 0xfb, 0xce, 0x64,
+	0x01, 0x42, 0xc1, 0x31,
+	0x00, 0xfa, 0xce, 0x64,
+	0x01, 0xe8, 0xd4, 0x1d,
+	0x30, 0x3f, 0xc0, 0x09,
+	0x30, 0xe0, 0xce, 0x64,
+	0x40, 0x4b, 0xce, 0x6c,
+	0xff, 0xea, 0x52, 0x01,
+	0xee, 0x00, 0x18, 0x6d,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x02, 0xea, 0xb4, 0x00,
+	0x20, 0xea, 0x9a, 0x00,
+	0xf3, 0x42, 0x20, 0x6d,
+	0x12, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0x0d, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x98, 0x41,
+	0x11, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xb6, 0x5a,
+	0x33, 0xea, 0xee, 0x58,
+	0x33, 0xea, 0x00, 0x00,
+	0x80, 0x3d, 0x7a, 0x00,
+	0x00, 0xe2, 0x46, 0x5d,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0xe8, 0x58,
+	0x40, 0x1a, 0x3a, 0x7d,
+	0x00, 0xe2, 0x46, 0x5d,
+	0x80, 0x19, 0x32, 0x00,
+	0x40, 0x5b, 0x3e, 0x6d,
+	0x20, 0x4d, 0xce, 0x7c,
+	0x02, 0x84, 0x09, 0x03,
+	0x40, 0x5b, 0x12, 0x7d,
+	0x08, 0xa8, 0xb9, 0x6c,
+	0x02, 0xea, 0xb4, 0x04,
+	0x01, 0x37, 0xe1, 0x30,
+	0x05, 0x38, 0xe3, 0x98,
+	0x01, 0xe0, 0xf8, 0x31,
+	0xff, 0xea, 0xc0, 0x09,
+	0x00, 0x39, 0xe5, 0x20,
+	0x00, 0x3a, 0xe7, 0x20,
+	0x01, 0xfc, 0xc0, 0x31,
+	0x04, 0xea, 0xe8, 0x30,
+	0xff, 0xea, 0xf0, 0x08,
+	0x02, 0xea, 0xf2, 0x00,
+	0xff, 0xea, 0xf4, 0x08
+};
+
+typedef int ahd_patch_func_t (struct ahd_softc *ahd);
+static ahd_patch_func_t ahd_patch14_func;
+
+static int
+ahd_patch14_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch13_func;
+
+static int
+ahd_patch13_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0);
+}
+
+static ahd_patch_func_t ahd_patch12_func;
+
+static int
+ahd_patch12_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_INITIATORROLE) != 0);
+}
+
+static ahd_patch_func_t ahd_patch11_func;
+
+static int
+ahd_patch11_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_TARGETROLE) != 0);
+}
+
+static ahd_patch_func_t ahd_patch10_func;
+
+static int
+ahd_patch10_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch9_func;
+
+static int
+ahd_patch9_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_39BIT_ADDRESSING) != 0);
+}
+
+static ahd_patch_func_t ahd_patch8_func;
+
+static int
+ahd_patch8_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_64BIT_ADDRESSING) != 0);
+}
+
+static ahd_patch_func_t ahd_patch7_func;
+
+static int
+ahd_patch7_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch6_func;
+
+static int
+ahd_patch6_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0);
+}
+
+static ahd_patch_func_t ahd_patch5_func;
+
+static int
+ahd_patch5_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch4_func;
+
+static int
+ahd_patch4_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch3_func;
+
+static int
+ahd_patch3_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch2_func;
+
+static int
+ahd_patch2_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch1_func;
+
+static int
+ahd_patch1_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_SET_MODE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch0_func;
+
+static int
+ahd_patch0_func(struct ahd_softc *ahd)
+{
+	return (0);
+}
+
+static struct patch {
+	ahd_patch_func_t		*patch_func;
+	uint32_t		 begin		:10,
+				 skip_instr	:10,
+				 skip_patch	:12;
+} patches[] = {
+	{ ahd_patch1_func, 0, 1, 2 },
+	{ ahd_patch0_func, 1, 1, 1 },
+	{ ahd_patch1_func, 23, 1, 2 },
+	{ ahd_patch0_func, 24, 1, 1 },
+	{ ahd_patch1_func, 27, 1, 2 },
+	{ ahd_patch0_func, 28, 1, 1 },
+	{ ahd_patch1_func, 31, 1, 2 },
+	{ ahd_patch0_func, 32, 1, 1 },
+	{ ahd_patch1_func, 34, 1, 2 },
+	{ ahd_patch0_func, 35, 1, 1 },
+	{ ahd_patch1_func, 38, 1, 2 },
+	{ ahd_patch0_func, 39, 1, 1 },
+	{ ahd_patch1_func, 44, 1, 2 },
+	{ ahd_patch0_func, 45, 1, 1 },
+	{ ahd_patch1_func, 119, 6, 1 },
+	{ ahd_patch2_func, 125, 1, 1 },
+	{ ahd_patch1_func, 133, 1, 2 },
+	{ ahd_patch0_func, 134, 1, 1 },
+	{ ahd_patch1_func, 137, 1, 2 },
+	{ ahd_patch0_func, 138, 1, 1 },
+	{ ahd_patch1_func, 141, 1, 2 },
+	{ ahd_patch0_func, 142, 1, 1 },
+	{ ahd_patch1_func, 146, 1, 2 },
+	{ ahd_patch0_func, 147, 1, 1 },
+	{ ahd_patch3_func, 149, 2, 1 },
+	{ ahd_patch2_func, 157, 16, 2 },
+	{ ahd_patch0_func, 173, 1, 1 },
+	{ ahd_patch4_func, 193, 2, 1 },
+	{ ahd_patch3_func, 197, 2, 1 },
+	{ ahd_patch5_func, 304, 1, 1 },
+	{ ahd_patch5_func, 307, 1, 1 },
+	{ ahd_patch5_func, 309, 1, 1 },
+	{ ahd_patch5_func, 321, 1, 1 },
+	{ ahd_patch1_func, 355, 1, 2 },
+	{ ahd_patch0_func, 356, 1, 1 },
+	{ ahd_patch6_func, 386, 1, 1 },
+	{ ahd_patch1_func, 427, 1, 2 },
+	{ ahd_patch0_func, 428, 1, 1 },
+	{ ahd_patch1_func, 432, 1, 2 },
+	{ ahd_patch0_func, 433, 1, 1 },
+	{ ahd_patch7_func, 440, 1, 1 },
+	{ ahd_patch8_func, 449, 1, 2 },
+	{ ahd_patch0_func, 450, 1, 1 },
+	{ ahd_patch9_func, 455, 1, 1 },
+	{ ahd_patch8_func, 456, 1, 1 },
+	{ ahd_patch1_func, 495, 1, 2 },
+	{ ahd_patch0_func, 496, 1, 1 },
+	{ ahd_patch1_func, 500, 1, 2 },
+	{ ahd_patch0_func, 501, 1, 1 },
+	{ ahd_patch10_func, 511, 1, 1 },
+	{ ahd_patch11_func, 516, 1, 1 },
+	{ ahd_patch12_func, 517, 2, 1 },
+	{ ahd_patch11_func, 520, 1, 2 },
+	{ ahd_patch0_func, 521, 1, 1 },
+	{ ahd_patch10_func, 583, 1, 1 },
+	{ ahd_patch10_func, 599, 1, 1 },
+	{ ahd_patch1_func, 611, 1, 2 },
+	{ ahd_patch0_func, 612, 1, 1 },
+	{ ahd_patch10_func, 634, 1, 1 },
+	{ ahd_patch13_func, 660, 3, 4 },
+	{ ahd_patch1_func, 660, 1, 2 },
+	{ ahd_patch0_func, 661, 1, 1 },
+	{ ahd_patch0_func, 663, 2, 1 },
+	{ ahd_patch14_func, 666, 3, 1 },
+	{ ahd_patch14_func, 675, 11, 1 }
+};
+
+static struct cs {
+	uint16_t	begin;
+	uint16_t	end;
+} critical_sections[] = {
+	{ 5, 6 },
+	{ 7, 8 },
+	{ 14, 20 },
+	{ 21, 34 },
+	{ 46, 49 },
+	{ 58, 82 },
+	{ 83, 113 },
+	{ 115, 119 },
+	{ 125, 133 },
+	{ 157, 190 },
+	{ 583, 599 },
+	{ 599, 617 },
+	{ 622, 628 },
+	{ 634, 639 },
+	{ 639, 645 }
+};
+
+static const int num_critical_sections = sizeof(critical_sections)
+				       / sizeof(*critical_sections);
Binary files linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm and linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm differ
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm.c	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm.c	2002-09-11 15:08:12.000000000 -0600
@@ -2,7 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler
  *
  * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#15 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#22 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.29 2000/10/05 04:25:42 gibbs Exp $
+ * $FreeBSD$
  */
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -85,12 +85,15 @@
 struct path_list search_path;
 int includes_search_curdir;
 char *appname;
+char *stock_include_file;
 FILE *ofile;
 char *ofilename;
 char *regfilename;
 FILE *regfile;
 char *listfilename;
 FILE *listfile;
+char *regdiagfilename;
+FILE *regdiagfile;
 int   src_mode;
 int   dst_mode;
 
@@ -140,7 +143,7 @@
 	yydebug = 0;
 	mmdebug = 0;
 #endif
-	while ((ch = getopt(argc, argv, "d:l:n:o:r:I:O:")) != -1) {
+	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
 		switch(ch) {
 		case 'd':
 #if DEBUG
@@ -160,6 +163,9 @@
 			     "information", EX_SOFTWARE);
 #endif
 			break;
+		case 'i':
+			stock_include_file = optarg;
+			break;
 		case 'l':
 			/* Create a program listing */
 			if ((listfile = fopen(optarg, "w")) == NULL) {
@@ -184,6 +190,14 @@
 			}
 			ofilename = optarg;
 			break;
+		case 'p':
+			/* Create Register Diagnostic "printing" Functions */
+			if ((regdiagfile = fopen(optarg, "w")) == NULL) {
+				perror(optarg);
+				stop(NULL, EX_CANTCREAT);
+			}
+			regdiagfilename = optarg;
+			break;
 		case 'r':
 			if ((regfile = fopen(optarg, "w")) == NULL) {
 				perror(optarg);
@@ -245,6 +259,14 @@
 		/* NOTREACHED */
 	}
 
+	if (regdiagfile != NULL
+	 && (regfile == NULL || stock_include_file == NULL)) {
+		fprintf(stderr,
+			"%s: The -p option requires the -r and -i options.\n",
+			appname);
+		usage();
+		/* NOTREACHED */
+	}
 	symtable_open();
 	inputfilename = *argv;
 	include_file(*argv, SOURCE_FILE);
@@ -271,9 +293,8 @@
 
 		if (ofile != NULL)
 			output_code();
-		if (regfile != NULL) {
-			symtable_dump(regfile);
-		}
+		if (regfile != NULL)
+			symtable_dump(regfile, regdiagfile);
 		if (listfile != NULL)
 			output_listing(inputfilename);
 	}
@@ -288,10 +309,10 @@
 {
 
 	(void)fprintf(stderr,
-"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]
-			[-r register_output_file] [-l program_list_file]
-			input_file\n",
-			appname);
+"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
+"	[-r register_output_file [-p register_diag_file -i includefile]]\n"
+"	[-l program_list_file]\n"
+"	input_file\n", appname);
 	exit(EX_USAGE);
 }
 
@@ -335,11 +356,11 @@
 
 	instrcount = 0;
 	fprintf(ofile,
-"/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
-%s */\n", versions);
+"/*\n"
+" * DO NOT EDIT - This file is automatically generated\n"
+" *		 from the following source files:\n"
+" *\n"
+"%s */\n", versions);
 
 	fprintf(ofile, "static uint8_t seqprog[] = {\n");
 	for (cur_instr = STAILQ_FIRST(&seq_program);
@@ -370,49 +391,54 @@
 	/*
 	 *  Output patch information.  Patch functions first.
 	 */
+	fprintf(ofile,
+"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
+
 	for (cur_node = SLIST_FIRST(&patch_functions);
 	     cur_node != NULL;
 	     cur_node = SLIST_NEXT(cur_node,links)) {
 		fprintf(ofile,
-"static int aic_patch%d_func(%s);
-
-static int
-aic_patch%d_func(%s)
-{
-	return (%s);
-}\n\n",
+"static %spatch_func_t %spatch%d_func;\n"
+"\n"
+"static int\n"
+"%spatch%d_func(%s)\n"
+"{\n"
+"	return (%s);\n"
+"}\n\n",
+			prefix,
+			prefix,
 			cur_node->symbol->info.condinfo->func_num,
-			patch_arg_list,
+			prefix,
 			cur_node->symbol->info.condinfo->func_num,
 			patch_arg_list,
 			cur_node->symbol->name);
 	}
 
 	fprintf(ofile,
-"typedef int patch_func_t (%s);
-static struct patch {
-	patch_func_t	*patch_func;
-	uint32_t	begin	   :10,
-			skip_instr :10,
-			skip_patch :12;
-} patches[] = {\n", patch_arg_list);
+"static struct patch {\n"
+"	%spatch_func_t		*patch_func;\n"
+"	uint32_t		 begin		:10,\n"
+"				 skip_instr	:10,\n"
+"				 skip_patch	:12;\n"
+"} patches[] = {\n", prefix);
 
 	for (cur_patch = STAILQ_FIRST(&patches);
 	     cur_patch != NULL;
 	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
-		fprintf(ofile, "%s\t{ aic_patch%d_func, %d, %d, %d }",
+		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
 			cur_patch == STAILQ_FIRST(&patches) ? "" : ",\n",
+			prefix,
 			cur_patch->patch_func, cur_patch->begin,
 			cur_patch->skip_instr, cur_patch->skip_patch);
 	}
 
-	fprintf(ofile, "\n};\n");
+	fprintf(ofile, "\n};\n\n");
 
 	fprintf(ofile,
-"static struct cs {
-	u_int16_t	begin;
-	u_int16_t	end;
-} critical_sections[] = {\n");
+"static struct cs {\n"
+"	uint16_t	begin;\n"
+"	uint16_t	end;\n"
+"} critical_sections[] = {\n");
 
 	for (cs = TAILQ_FIRST(&cs_tailq);
 	     cs != NULL;
@@ -422,11 +448,11 @@
 			cs->begin_addr, cs->end_addr);
 	}
 
-	fprintf(ofile, "\n};\n");
+	fprintf(ofile, "\n};\n\n");
 
 	fprintf(ofile,
-"static const int num_critical_sections = sizeof(critical_sections)
-				       / sizeof(*critical_sections);\n");
+"static const int num_critical_sections = sizeof(critical_sections)\n"
+"				       / sizeof(*critical_sections);\n");
 
 	fprintf(stderr, "%s: %d instructions used\n", appname, instrcount);
 }
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.c	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,2772 @@
+#ifndef lint
+static char const 
+yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
+#endif
+#include <stdlib.h>
+#define YYBYACC 1
+#define YYMAJOR 1
+#define YYMINOR 9
+#define YYLEX yylex()
+#define YYEMPTY -1
+#define yyclearin (yychar=(YYEMPTY))
+#define yyerrok (yyerrflag=0)
+#define YYRECOVERING() (yyerrflag!=0)
+static int yygrowstack();
+#define YYPREFIX "yy"
+#line 2 "aicasm_gram.y"
+/*
+ * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.
+ *
+ * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#21 $
+ *
+ * $FreeBSD$
+ */
+
+#include <inttypes.h>
+#include <sys/types.h>
+
+#include <inttypes.h>
+#include <regex.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysexits.h>
+
+#ifdef __linux__
+#include "../queue.h"
+#else
+#include <sys/queue.h>
+#endif
+
+#include "aicasm.h"
+#include "aicasm_symbol.h"
+#include "aicasm_insformat.h"
+
+int yylineno;
+char *yyfilename;
+char stock_prefix[] = "aic_";
+char *prefix = stock_prefix;
+char *patch_arg_list;
+char *versions;
+static char errbuf[255];
+static char regex_pattern[255];
+static symbol_t *cur_symbol;
+static symbol_t *field_symbol;
+static symbol_t *scb_or_sram_symbol;
+static symtype cur_symtype;
+static symbol_ref_t accumulator;
+static symbol_ref_t mode_ptr;
+static symbol_ref_t allones;
+static symbol_ref_t allzeros;
+static symbol_ref_t none;
+static symbol_ref_t sindex;
+static int instruction_ptr;
+static int num_srams;
+static int sram_or_scb_offset;
+static int download_constant_count;
+static int in_critical_section;
+static u_int enum_increment;
+static u_int enum_next_value;
+
+static void process_field(int field_type, symbol_t *sym, int mask);
+static void initialize_symbol(symbol_t *symbol);
+static void add_macro_arg(const char *argtext, int position);
+static void add_macro_body(const char *bodytext);
+static void process_register(symbol_t **p_symbol);
+static void format_1_instr(int opcode, symbol_ref_t *dest,
+			   expression_t *immed, symbol_ref_t *src, int ret);
+static void format_2_instr(int opcode, symbol_ref_t *dest,
+			   expression_t *places, symbol_ref_t *src, int ret);
+static void format_3_instr(int opcode, symbol_ref_t *src,
+			   expression_t *immed, symbol_ref_t *address);
+static void test_readable_symbol(symbol_t *symbol);
+static void test_writable_symbol(symbol_t *symbol);
+static void type_check(symbol_t *symbol, expression_t *expression, int and_op);
+static void make_expression(expression_t *immed, int value);
+static void add_conditional(symbol_t *symbol);
+static void add_version(const char *verstring);
+static int  is_download_const(expression_t *immed);
+
+#define SRAM_SYMNAME "SRAM_BASE"
+#define SCB_SYMNAME "SCB_BASE"
+#line 115 "aicasm_gram.y"
+typedef union {
+	u_int		value;
+	char		*str;
+	symbol_t	*sym;
+	symbol_ref_t	sym_ref;
+	expression_t	expression;
+} YYSTYPE;
+#line 137 "aicasm_gram.tab.c"
+#define YYERRCODE 256
+#define T_REGISTER 257
+#define T_CONST 258
+#define T_EXPORT 259
+#define T_DOWNLOAD 260
+#define T_SCB 261
+#define T_SRAM 262
+#define T_ALIAS 263
+#define T_SIZE 264
+#define T_EXPR_LSHIFT 265
+#define T_EXPR_RSHIFT 266
+#define T_ADDRESS 267
+#define T_ACCESS_MODE 268
+#define T_MODES 269
+#define T_DEFINE 270
+#define T_SET_SRC_MODE 271
+#define T_SET_DST_MODE 272
+#define T_MODE 273
+#define T_BEGIN_CS 274
+#define T_END_CS 275
+#define T_FIELD 276
+#define T_ENUM 277
+#define T_MASK 278
+#define T_NUMBER 279
+#define T_PATH 280
+#define T_STRING 281
+#define T_ARG 282
+#define T_MACROBODY 283
+#define T_CEXPR 284
+#define T_EOF 285
+#define T_INCLUDE 286
+#define T_VERSION 287
+#define T_PREFIX 288
+#define T_PATCH_ARG_LIST 289
+#define T_SHR 290
+#define T_SHL 291
+#define T_ROR 292
+#define T_ROL 293
+#define T_MVI 294
+#define T_MOV 295
+#define T_CLR 296
+#define T_BMOV 297
+#define T_JMP 298
+#define T_JC 299
+#define T_JNC 300
+#define T_JE 301
+#define T_JNE 302
+#define T_JNZ 303
+#define T_JZ 304
+#define T_CALL 305
+#define T_ADD 306
+#define T_ADC 307
+#define T_INC 308
+#define T_DEC 309
+#define T_STC 310
+#define T_CLC 311
+#define T_CMP 312
+#define T_NOT 313
+#define T_XOR 314
+#define T_TEST 315
+#define T_AND 316
+#define T_OR 317
+#define T_RET 318
+#define T_NOP 319
+#define T_ACCUM 320
+#define T_ALLONES 321
+#define T_ALLZEROS 322
+#define T_NONE 323
+#define T_SINDEX 324
+#define T_MODE_PTR 325
+#define T_A 326
+#define T_SYMBOL 327
+#define T_NL 328
+#define T_IF 329
+#define T_ELSE 330
+#define T_ELSE_IF 331
+#define T_ENDIF 332
+#define UMINUS 333
+const short yylhs[] = {                                        -1,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,   20,   20,   21,   22,   23,   37,   24,   39,
+   36,   38,   38,   40,   40,   40,   40,   40,   40,   40,
+   40,   40,   40,   40,   40,   40,   40,   41,   42,   43,
+   44,   18,   18,   17,   17,   55,   45,   57,   45,   45,
+   58,   46,   59,   46,   56,   56,   60,   60,   47,   48,
+   49,   50,   51,   52,   53,   54,    6,    6,    6,    6,
+    6,    6,    6,    6,    6,    6,    6,    6,    6,   25,
+   25,   61,   26,   26,   19,   19,   19,   16,   16,   62,
+   63,   65,   27,   66,   67,   68,   28,   64,   64,   64,
+   64,   69,   69,    1,    1,    1,    1,    3,    7,    8,
+    8,    4,    5,    5,   10,   10,   30,   31,   32,   33,
+    9,    9,   29,    2,    2,    2,    2,    2,    2,   34,
+   34,   34,   34,   11,   11,   11,   11,   35,   35,   35,
+   35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
+   35,   35,   12,   12,   12,   12,   35,   13,   13,   13,
+   13,   14,   14,   15,   15,   35,   35,   35,   35,   35,
+   35,
+};
+const short yylen[] = {                                         2,
+    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
+    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
+    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
+    1,    2,    4,    4,    3,    3,    3,    0,    3,    0,
+    5,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+    1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
+    2,    1,    3,    1,    1,    0,    5,    0,    7,    3,
+    0,    5,    0,    7,    1,    3,    1,    2,    3,    2,
+    1,    1,    1,    1,    1,    1,    3,    3,    3,    3,
+    3,    3,    3,    3,    3,    2,    2,    1,    1,    3,
+    3,    2,    2,    5,    0,    1,    3,    1,    2,    0,
+    0,    0,    9,    0,    0,    0,    9,    0,    1,    1,
+    2,    1,    2,    1,    4,    4,    1,    1,    1,    1,
+    1,    1,    0,    2,    0,    1,    3,    3,    2,    2,
+    0,    1,    3,    1,    3,    3,    1,    3,    3,    3,
+    4,    2,    1,    1,    1,    1,    1,    7,    7,    5,
+    5,    3,    7,    3,    4,    8,    6,    6,    5,    4,
+    3,    2,    1,    1,    1,    1,    7,    1,    1,    1,
+    1,    1,    1,    1,    1,    3,    7,    7,    7,    5,
+    5,
+};
+const short yydefred[] = {                                      0,
+   38,    0,  142,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  174,  173,  176,  175,    0,    0,
+    0,    0,  178,  179,  180,  181,  156,  157,    0,    0,
+    0,    0,    0,    0,  155,    0,  154,    0,    0,    0,
+    0,    0,  153,    0,    0,    0,    0,    0,    1,    3,
+    5,    7,    9,   11,   13,   15,   17,   19,   21,   23,
+   25,   27,   29,   31,    0,    0,    0,  114,  110,  102,
+    0,    0,  139,  140,    0,    0,    0,    0,    0,   98,
+  127,    0,    0,    0,    0,  128,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,  136,    0,    0,
+    0,    0,  132,    0,    0,    0,    0,  172,    0,    0,
+    0,  152,    2,    4,    6,    8,   10,   12,   14,   16,
+   18,   20,   22,   24,   26,   28,   30,   32,    0,    0,
+    0,    0,    0,    0,  103,    0,    0,   39,  101,  108,
+    0,  100,    0,    0,  137,  138,    0,    0,   37,   35,
+   36,    0,   99,   97,   96,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  164,    0,  162,    0,    0,    0,
+    0,  171,  150,    0,  143,    0,    0,    0,    0,    0,
+    0,  186,  106,    0,   40,  109,    0,  115,  111,   33,
+   34,    0,    0,   95,  131,    0,    0,    0,    0,    0,
+    0,    0,    0,   91,   92,    0,    0,    0,  170,    0,
+  134,    0,    0,  165,    0,    0,    0,    0,    0,    0,
+    0,  151,    0,    0,  145,  146,  148,  149,    0,    0,
+    0,   58,    0,    0,  126,  125,    0,  191,    0,  190,
+    0,  160,  161,    0,  184,  185,    0,  169,  183,  182,
+    0,    0,    0,    0,    0,  107,  104,    0,    0,    0,
+    0,    0,    0,    0,   81,   83,   84,   85,   86,   82,
+    0,   42,   44,   45,   46,   47,   48,   49,   50,   51,
+   52,   53,   54,   55,   56,   57,  116,  112,  168,  167,
+    0,    0,    0,    0,    0,    0,    0,    0,   80,   59,
+   60,   64,   65,   62,    0,    0,    0,    0,    0,    0,
+   41,   43,    0,    0,    0,  163,  189,  188,  187,  159,
+  158,  177,    0,    0,    0,    0,    0,    0,  122,    0,
+    0,    0,    0,  166,   63,    0,    0,    0,   75,    0,
+    0,    0,  117,  123,  113,    0,    0,   67,    0,    0,
+   72,    0,   76,    0,   69,   74,
+};
+const short yydgoto[] = {                                      44,
+   86,  134,   87,   93,  172,  206,   89,  207,   45,  100,
+   46,   47,   48,  261,  257,  142,  314,  315,  194,   49,
+   50,   51,   52,   53,   54,   55,   56,   57,   58,   59,
+   60,   61,   62,   63,   64,  339,   66,  281,  241,  282,
+  283,  284,  285,  286,  287,  288,  289,  290,  291,  292,
+  293,  294,  295,  296,  317,  348,  346,  319,  350,  349,
+   65,  144,  244,  341,  324,  143,  243,  323,  342,
+};
+const short yysindex[] = {                                    476,
+    0, -294,    0,  -72,  -63, -248, -175, -148,   49,   78,
+  -16,   88,   93,   96,    0,    0,    0,    0,  -14, -230,
+ -230, -230,    0,    0,    0,    0,    0,    0, -230, -230,
+ -255, -264, -230, -230,    0, -230,    0, -230,  113, -134,
+  -96, -120,    0,  476, -136, -230, -230,  -44,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  -34, -135,   55,    0,    0,    0,
+  135,  138,    0,    0,  -81,  -80,  -73,  -71,  -70,    0,
+    0,  110,  -17,  -17,  -17,    0,  162,  178, -180,  110,
+    0,  168, -180, -134,  169,  170,  170,    0, -134,  158,
+ -230,  159,    0,  175,  170,  180,  182,    0,  163,  104,
+  -56,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  171,  186,
+  187,   25,   87,  192,    0,  -29,  129,    0,    0,    0,
+  -25,    0,  -10,  -10,    0,    0,  193,  226,    0,    0,
+    0, -245,    0,    0,    0,  132,   -3,  -17,  -17,  -17,
+  -17,  -17,  -17,  -17,  -17,  -44, -230,  -44,  222, -230,
+ -230, -134, -134,  227,    0,  245,    0,   -3, -134,   -3,
+   -3,    0,    0,  173,    0,   -3,  -17,   21,   35,   47,
+   48,    0,    0,    9,    0,    0,   50,    0,    0,    0,
+    0,  218,  232,    0,    0,  178, -134,  124,  124,  140,
+   -7,   60,   60,    0,    0,  274, -134,  276,    0,  305,
+    0,  292,  296,    0,   -3, -185,  309, -182,  178, -180,
+  170,    0,  170,  160,    0,    0,    0,    0,   89,   90,
+  195,    0,  106,  106,    0,    0,  315,    0,  317,    0,
+  -17,    0,    0, -134,    0,    0,  -44,    0,    0,    0,
+  -44,  -44, -134, -134, -134,    0,    0,   51,   98,  115,
+ -238,   52,   65,   72,    0,    0,    0,    0,    0,    0,
+  551,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+ -134,  341,  342,  343,  344,  345,  348,  349,    0,    0,
+    0,    0,    0,    0,  365,  -17,  288,  -17,  290,  -17,
+    0,    0, -252, -252,  351,    0,    0,    0,    0,    0,
+    0,    0, -238,  178,   97,  178,   97,  178,    0, -135,
+  289, -135,  298,    0,    0,  304,  -17,  -39,    0,  307,
+  -24, -135,    0,    0,    0,   97,  178,    0,   97,   97,
+    0,  -12,    0,   -1,    0,    0,
+};
+const short yyrindex[] = {                                    101,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  372,  372,    0,    0,    0,    0,    0,    0,    0,  372,
+    0,    0,    0,  101,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   91,    0,    0,    0,    0,    0,  -55,    0,  -20,
+   54,    0,    0,  372,    0,  -52,  -52,    0,  372,    0,
+    0,    0,    0,    0,  -52,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  373,  374,    0,    0,   46,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,  372,  372,    0,    0,    0,    0,    0,  372,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   18,  372,  117,  223,  406,
+  328,  -30,   40,    0,    0,    0,  372,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   32,    0,
+  -52,    0,  -52,  -52,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  372,    0,    0,    0,    0,    0,    0,
+    0,    0,  372,  372,  372,    0,    0,    0,    0,    0,
+    0,  313,  322,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  372,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,  287,    0,    0,    0,    0,    0,
+    0,    0,  321,  321,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,  533,    0,  325,    0,  567,    0,  324,
+    0,  329,    0,    0,    0,    0,    1,    0,    0,    0,
+    0,  330,    0,    0,    0,    0,    2,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,
+};
+const short yygindex[] = {                                      0,
+  -11, -147,   27,   19,  -38,  -19, -171,  -75,    0,  335,
+    0,    0,  -77,    0,    0,    0,  123,    0,    0,  413,
+  416,  417,  422,  423,  424,  425,  426,  430,  431,  432,
+  433,  434,  435,  436,  437,  -65,    0,    0,    0,  201,
+    4,  -92,    0, -143,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0, -268,    0,    0,    0,  125,
+    0,    0,    0,  161,    0,    0,    0,    0,  143,
+};
+#define YYTABLESIZE 892
+const short yytable[] = {                                      88,
+  138,  133,  112,  129,  359,  136,  133,   89,   91,  230,
+   89,  166,   89,   89,   89,  168,  271,   76,  216,  359,
+  218,  103,   85,  124,  103,   85,  107,   83,   89,  101,
+   83,  359,   67,  202,  164,  162,   85,  163,  124,  165,
+  312,   83,  359,   75,   77,   78,   92,   94,   95,  240,
+   68,  104,  239,   98,  106,   96,   97,   99,  173,   69,
+  105,  130,   98,  154,  155,  156,  179,  188,  351,  189,
+   81,   90,  130,  131,  137,  130,  130,   90,   70,  301,
+   90,  203,   90,   90,   90,  358,  105,  362,  313,  105,
+  130,  364,   89,   89,   89,   81,   90,  128,   90,  141,
+  361,  164,  226,   71,  228,  231,  165,   73,   84,  303,
+  233,   84,  365,  304,  305,  255,  256,   23,   24,   25,
+  259,  260,   84,  366,   26,   77,   78,  176,   99,  190,
+   72,  191,   99,   99,  124,   99,   74,   99,  208,  209,
+  210,  211,  212,  213,  214,  215,  198,  199,   77,  254,
+  297,  298,  262,   78,   93,  103,   79,   93,  103,  103,
+   93,  229,   90,   90,   90,  164,  162,  234,  163,  161,
+  165,  108,  204,  164,  162,   93,  163,  161,  165,  340,
+  340,  164,  162,   98,  163,  217,  165,  110,  220,  221,
+  129,  137,  263,  145,  264,  265,  146,  161,  147,  148,
+  152,  164,  162,  171,  163,  157,  165,  149,  111,  150,
+  151,  167,  170,  171,   99,  161,  175,  177,  178,  164,
+  162,  182,  163,  180,  165,  181,  183,  184,  185,  186,
+  187,   88,   89,   89,   89,   89,   89,   89,   89,   93,
+   93,   93,  129,  129,  129,   89,   89,   89,  135,  129,
+  192,  195,  193,  196,  200,  160,  197,  158,  159,  201,
+   94,   80,  129,   94,   80,  133,   94,   89,   89,   89,
+   89,   89,   89,   89,   89,   80,  354,  124,  124,  124,
+  219,   94,  132,  160,  124,  224,  354,   89,  225,   89,
+   89,   89,   89,   89,   89,  232,  334,  124,  336,  235,
+  338,  160,   90,   90,   90,   90,   90,   90,   90,  153,
+  245,   81,   82,  236,  139,   90,   90,   90,  130,  130,
+  130,  130,  205,  153,  246,  237,  238,  357,  242,  129,
+  129,  129,  248,  140,  250,  130,  129,   90,   90,   90,
+   90,   90,   90,   90,   90,   94,   94,   94,  251,  130,
+  252,  132,  132,  132,  253,   99,   99,   90,  132,   90,
+   90,   90,   90,   90,   90,   88,  102,  258,   88,  269,
+  266,   88,  267,  299,  109,  300,  310,  309,  316,   93,
+   93,   93,   93,   93,   93,   93,   88,  311,   99,   99,
+   99,  318,   93,   93,   93,   99,  158,  159,  320,  326,
+  327,  328,  329,  330,  158,  159,  331,  332,  333,  344,
+  335,   61,  337,  353,   93,   93,   93,   93,   93,   93,
+   93,   93,  355,  347,  158,  159,  356,  141,  169,  360,
+  135,  144,  147,  174,   93,   66,   93,   93,   93,   93,
+   93,   93,  158,  159,   71,  118,   87,   73,  119,   87,
+   88,   88,   88,  120,  121,  345,  113,  268,  269,  114,
+  115,  197,  270,  271,   87,  116,  117,  118,  119,  120,
+  272,  273,  274,  121,  122,  123,  124,  125,  126,  127,
+  128,  322,  352,  363,  343,   94,   94,   94,   94,   94,
+   94,   94,    0,    0,    0,    0,    0,    0,   94,   94,
+   94,    0,    0,    0,    0,    0,  222,  223,    0,    0,
+    0,    0,    0,  227,  275,  276,  277,  278,  279,  280,
+   94,   94,   94,   94,   94,   94,   94,   94,   87,   87,
+   87,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+   94,  247,   94,   94,   94,   94,   94,   94,    0,   61,
+   61,  249,    0,   61,   61,   61,    0,    0,    0,    0,
+    0,    0,   61,   61,   61,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,  302,    0,
+   88,   88,    0,    0,   88,   88,   88,  306,  307,  308,
+   43,    0,    0,   88,   88,   88,   61,   61,   61,   61,
+   61,   61,    0,   61,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   88,   88,   88,   88,   88,
+   88,   88,   88,    0,    0,  325,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,   88,    0,   88,   88,   88,
+   88,   88,   88,    0,    0,   68,    0,   70,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,   87,   87,
+    0,    0,   87,   87,   87,  321,    0,    0,    0,    0,
+    0,   87,   87,   87,    0,    0,    0,    0,    0,    0,
+    0,   79,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   87,   87,   87,   87,   87,   87,   87,
+   87,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,   87,    0,   87,   87,   87,   87,   87,
+   87,    0,    1,    2,    3,    0,    4,    5,    0,    0,
+    0,    0,    0,    0,    0,    6,    7,    8,    0,    9,
+   10,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,   11,   12,   13,   14,   15,   16,   17,   18,   19,
+   20,   21,   22,   23,   24,   25,    0,    0,    0,    0,
+   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,
+   36,   37,   38,   39,   40,   70,   70,    0,    0,   70,
+   70,   70,    0,    0,   41,   42,    0,    0,   70,   70,
+   70,    0,    0,  268,  269,    0,    0,  197,  270,  271,
+    0,    0,    0,    0,    0,    0,  272,  273,  274,   79,
+   79,    0,    0,   79,   79,   79,    0,    0,    0,    0,
+    0,    0,   79,   79,   79,    0,    0,    0,    0,    0,
+    0,    0,   70,   70,   70,   70,   70,   70,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+  275,  276,  277,  278,  279,  280,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,   79,   79,   79,   79,
+   79,   79,
+};
+const short yycheck[] = {                                      19,
+   66,   46,  123,   59,   44,   40,   59,   38,   20,  181,
+   41,   89,   43,   44,   45,   93,  269,   34,  166,   44,
+  168,   33,   40,   44,   36,   40,   38,   45,   59,  294,
+   45,   44,  327,  279,   42,   43,   40,   45,   59,   47,
+  279,   45,   44,   60,   44,   44,   20,   21,   22,   41,
+  123,   33,   44,  318,   36,   29,   30,   31,   97,  123,
+   34,   44,  318,   83,   84,   85,  105,   43,  337,   45,
+  326,  327,   46,   47,  327,   44,   59,   38,  327,  251,
+   41,  327,   43,   44,   45,  125,   41,  356,  327,   44,
+   59,  360,  123,  124,  125,  326,  327,   44,   59,   45,
+  125,   42,  178,  279,  180,  181,   47,   59,  126,  257,
+  186,  126,  125,  261,  262,  301,  302,  298,  299,  300,
+  303,  304,  126,  125,  305,  125,  125,  101,   38,   43,
+  279,   45,   42,   43,   44,   45,   59,   47,  158,  159,
+  160,  161,  162,  163,  164,  165,  143,  144,   61,  225,
+  243,  244,  230,   61,   38,  167,   61,   41,  170,  171,
+   44,  181,  123,  124,  125,   42,   43,  187,   45,   38,
+   47,   59,   41,   42,   43,   59,   45,   38,   47,  323,
+  324,   42,   43,  318,   45,  167,   47,  284,  170,  171,
+  327,  327,  231,   59,  233,  234,   59,   38,  280,  280,
+   91,   42,   43,   44,   45,   44,   47,  281,  329,  281,
+  281,   44,   44,   44,  124,   38,   59,   59,   44,   42,
+   43,   59,   45,   44,   47,   44,  123,  284,   58,   44,
+   44,  251,  263,  264,  265,  266,  267,  268,  269,  123,
+  124,  125,  298,  299,  300,  276,  277,  278,  283,  305,
+   59,  123,  282,  279,   62,  124,  267,  265,  266,   34,
+   38,  279,  318,   41,  279,  318,   44,  298,  299,  300,
+  301,  302,  303,  304,  305,  279,  342,  298,  299,  300,
+   59,   59,  327,  124,  305,   59,  352,  318,   44,  320,
+  321,  322,  323,  324,  325,  123,  316,  318,  318,  279,
+  320,  124,  263,  264,  265,  266,  267,  268,  269,  327,
+   93,  326,  327,  279,  260,  276,  277,  278,  301,  302,
+  303,  304,  326,  327,   93,  279,  279,  347,  279,  298,
+  299,  300,   59,  279,   59,  318,  305,  298,  299,  300,
+  301,  302,  303,  304,  305,  123,  124,  125,   44,  318,
+   59,  298,  299,  300,   59,  265,  266,  318,  305,  320,
+  321,  322,  323,  324,  325,   38,   32,   59,   41,  264,
+  282,   44,  283,   59,   40,   59,  279,  327,  327,  263,
+  264,  265,  266,  267,  268,  269,   59,  273,  298,  299,
+  300,  327,  276,  277,  278,  305,  265,  266,  327,   59,
+   59,   59,   59,   59,  265,  266,   59,   59,   44,   59,
+  123,  125,  123,  125,  298,  299,  300,  301,  302,  303,
+  304,  305,  125,  327,  265,  266,  123,  327,   94,  123,
+   59,   59,   59,   99,  318,  123,  320,  321,  322,  323,
+  324,  325,  265,  266,  123,  125,   41,  123,  125,   44,
+  123,  124,  125,  125,  125,  333,   44,  263,  264,   44,
+   44,  267,  268,  269,   59,   44,   44,   44,   44,   44,
+  276,  277,  278,   44,   44,   44,   44,   44,   44,   44,
+   44,  281,  340,  359,  324,  263,  264,  265,  266,  267,
+  268,  269,   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,
+  278,   -1,   -1,   -1,   -1,   -1,  172,  173,   -1,   -1,
+   -1,   -1,   -1,  179,  320,  321,  322,  323,  324,  325,
+  298,  299,  300,  301,  302,  303,  304,  305,  123,  124,
+  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  318,  207,  320,  321,  322,  323,  324,  325,   -1,  263,
+  264,  217,   -1,  267,  268,  269,   -1,   -1,   -1,   -1,
+   -1,   -1,  276,  277,  278,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  254,   -1,
+  263,  264,   -1,   -1,  267,  268,  269,  263,  264,  265,
+  125,   -1,   -1,  276,  277,  278,  320,  321,  322,  323,
+  324,  325,   -1,  327,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  298,  299,  300,  301,  302,
+  303,  304,  305,   -1,   -1,  301,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  318,   -1,  320,  321,  322,
+  323,  324,  325,   -1,   -1,  123,   -1,  125,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  263,  264,
+   -1,   -1,  267,  268,  269,  125,   -1,   -1,   -1,   -1,
+   -1,  276,  277,  278,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  125,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  298,  299,  300,  301,  302,  303,  304,
+  305,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,  318,   -1,  320,  321,  322,  323,  324,
+  325,   -1,  257,  258,  259,   -1,  261,  262,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,  270,  271,  272,   -1,  274,
+  275,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,  286,  287,  288,  289,  290,  291,  292,  293,  294,
+  295,  296,  297,  298,  299,  300,   -1,   -1,   -1,   -1,
+  305,  306,  307,  308,  309,  310,  311,  312,  313,  314,
+  315,  316,  317,  318,  319,  263,  264,   -1,   -1,  267,
+  268,  269,   -1,   -1,  329,  330,   -1,   -1,  276,  277,
+  278,   -1,   -1,  263,  264,   -1,   -1,  267,  268,  269,
+   -1,   -1,   -1,   -1,   -1,   -1,  276,  277,  278,  263,
+  264,   -1,   -1,  267,  268,  269,   -1,   -1,   -1,   -1,
+   -1,   -1,  276,  277,  278,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,  320,  321,  322,  323,  324,  325,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+  320,  321,  322,  323,  324,  325,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,  320,  321,  322,  323,
+  324,  325,
+};
+#define YYFINAL 44
+#ifndef YYDEBUG
+#define YYDEBUG 0
+#endif
+#define YYMAXTOKEN 333
+#if YYDEBUG
+const char * const yyname[] = {
+"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+"'\"'",0,0,0,"'&'",0,"'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,0,0,0,
+0,0,0,0,0,"':'","';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,"'{'","'|'","'}'","'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_REGISTER","T_CONST",
+"T_EXPORT","T_DOWNLOAD","T_SCB","T_SRAM","T_ALIAS","T_SIZE","T_EXPR_LSHIFT",
+"T_EXPR_RSHIFT","T_ADDRESS","T_ACCESS_MODE","T_MODES","T_DEFINE",
+"T_SET_SRC_MODE","T_SET_DST_MODE","T_MODE","T_BEGIN_CS","T_END_CS","T_FIELD",
+"T_ENUM","T_MASK","T_NUMBER","T_PATH","T_STRING","T_ARG","T_MACROBODY",
+"T_CEXPR","T_EOF","T_INCLUDE","T_VERSION","T_PREFIX","T_PATCH_ARG_LIST","T_SHR",
+"T_SHL","T_ROR","T_ROL","T_MVI","T_MOV","T_CLR","T_BMOV","T_JMP","T_JC","T_JNC",
+"T_JE","T_JNE","T_JNZ","T_JZ","T_CALL","T_ADD","T_ADC","T_INC","T_DEC","T_STC",
+"T_CLC","T_CMP","T_NOT","T_XOR","T_TEST","T_AND","T_OR","T_RET","T_NOP",
+"T_ACCUM","T_ALLONES","T_ALLZEROS","T_NONE","T_SINDEX","T_MODE_PTR","T_A",
+"T_SYMBOL","T_NL","T_IF","T_ELSE","T_ELSE_IF","T_ENDIF","UMINUS",
+};
+const char * const yyrule[] = {
+"$accept : program",
+"program : include",
+"program : program include",
+"program : prefix",
+"program : program prefix",
+"program : patch_arg_list",
+"program : program patch_arg_list",
+"program : version",
+"program : program version",
+"program : register",
+"program : program register",
+"program : constant",
+"program : program constant",
+"program : macrodefn",
+"program : program macrodefn",
+"program : scratch_ram",
+"program : program scratch_ram",
+"program : scb",
+"program : program scb",
+"program : label",
+"program : program label",
+"program : set_src_mode",
+"program : program set_src_mode",
+"program : set_dst_mode",
+"program : program set_dst_mode",
+"program : critical_section_start",
+"program : program critical_section_start",
+"program : critical_section_end",
+"program : program critical_section_end",
+"program : conditional",
+"program : program conditional",
+"program : code",
+"program : program code",
+"include : T_INCLUDE '<' T_PATH '>'",
+"include : T_INCLUDE '\"' T_PATH '\"'",
+"prefix : T_PREFIX '=' T_STRING",
+"patch_arg_list : T_PATCH_ARG_LIST '=' T_STRING",
+"version : T_VERSION '=' T_STRING",
+"$$1 :",
+"register : T_REGISTER $$1 reg_definition",
+"$$2 :",
+"reg_definition : T_SYMBOL '{' $$2 reg_attribute_list '}'",
+"reg_attribute_list : reg_attribute",
+"reg_attribute_list : reg_attribute_list reg_attribute",
+"reg_attribute : reg_address",
+"reg_attribute : size",
+"reg_attribute : access_mode",
+"reg_attribute : modes",
+"reg_attribute : field_defn",
+"reg_attribute : enum_defn",
+"reg_attribute : mask_defn",
+"reg_attribute : alias",
+"reg_attribute : accumulator",
+"reg_attribute : mode_pointer",
+"reg_attribute : allones",
+"reg_attribute : allzeros",
+"reg_attribute : none",
+"reg_attribute : sindex",
+"reg_address : T_ADDRESS T_NUMBER",
+"size : T_SIZE T_NUMBER",
+"access_mode : T_ACCESS_MODE T_MODE",
+"modes : T_MODES mode_list",
+"mode_list : mode_value",
+"mode_list : mode_list ',' mode_value",
+"mode_value : T_NUMBER",
+"mode_value : T_SYMBOL",
+"$$3 :",
+"field_defn : T_FIELD $$3 '{' enum_entry_list '}'",
+"$$4 :",
+"field_defn : T_FIELD T_SYMBOL expression $$4 '{' enum_entry_list '}'",
+"field_defn : T_FIELD T_SYMBOL expression",
+"$$5 :",
+"enum_defn : T_ENUM $$5 '{' enum_entry_list '}'",
+"$$6 :",
+"enum_defn : T_ENUM T_SYMBOL expression $$6 '{' enum_entry_list '}'",
+"enum_entry_list : enum_entry",
+"enum_entry_list : enum_entry_list ',' enum_entry",
+"enum_entry : T_SYMBOL",
+"enum_entry : T_SYMBOL expression",
+"mask_defn : T_MASK T_SYMBOL expression",
+"alias : T_ALIAS T_SYMBOL",
+"accumulator : T_ACCUM",
+"mode_pointer : T_MODE_PTR",
+"allones : T_ALLONES",
+"allzeros : T_ALLZEROS",
+"none : T_NONE",
+"sindex : T_SINDEX",
+"expression : expression '|' expression",
+"expression : expression '&' expression",
+"expression : expression '+' expression",
+"expression : expression '-' expression",
+"expression : expression '*' expression",
+"expression : expression '/' expression",
+"expression : expression T_EXPR_LSHIFT expression",
+"expression : expression T_EXPR_RSHIFT expression",
+"expression : '(' expression ')'",
+"expression : '~' expression",
+"expression : '-' expression",
+"expression : T_NUMBER",
+"expression : T_SYMBOL",
+"constant : T_CONST T_SYMBOL numerical_value",
+"constant : T_CONST T_SYMBOL T_DOWNLOAD",
+"macrodefn_prologue : T_DEFINE T_SYMBOL",
+"macrodefn : macrodefn_prologue T_MACROBODY",
+"macrodefn : macrodefn_prologue '(' macro_arglist ')' T_MACROBODY",
+"macro_arglist :",
+"macro_arglist : T_ARG",
+"macro_arglist : macro_arglist ',' T_ARG",
+"numerical_value : T_NUMBER",
+"numerical_value : '-' T_NUMBER",
+"$$7 :",
+"$$8 :",
+"$$9 :",
+"scratch_ram : T_SRAM '{' $$7 reg_address $$8 size $$9 scb_or_sram_attributes '}'",
+"$$10 :",
+"$$11 :",
+"$$12 :",
+"scb : T_SCB '{' $$10 reg_address $$11 size $$12 scb_or_sram_attributes '}'",
+"scb_or_sram_attributes :",
+"scb_or_sram_attributes : modes",
+"scb_or_sram_attributes : scb_or_sram_reg_list",
+"scb_or_sram_attributes : modes scb_or_sram_reg_list",
+"scb_or_sram_reg_list : reg_definition",
+"scb_or_sram_reg_list : scb_or_sram_reg_list reg_definition",
+"reg_symbol : T_SYMBOL",
+"reg_symbol : T_SYMBOL '[' T_SYMBOL ']'",
+"reg_symbol : T_SYMBOL '[' T_NUMBER ']'",
+"reg_symbol : T_A",
+"destination : reg_symbol",
+"immediate : expression",
+"immediate_or_a : expression",
+"immediate_or_a : T_A",
+"source : reg_symbol",
+"opt_source :",
+"opt_source : ',' source",
+"ret :",
+"ret : T_RET",
+"set_src_mode : T_SET_SRC_MODE T_NUMBER ';'",
+"set_dst_mode : T_SET_DST_MODE T_NUMBER ';'",
+"critical_section_start : T_BEGIN_CS ';'",
+"critical_section_end : T_END_CS ';'",
+"export :",
+"export : T_EXPORT",
+"label : export T_SYMBOL ':'",
+"address : T_SYMBOL",
+"address : T_SYMBOL '+' T_NUMBER",
+"address : T_SYMBOL '-' T_NUMBER",
+"address : '.'",
+"address : '.' '+' T_NUMBER",
+"address : '.' '-' T_NUMBER",
+"conditional : T_IF T_CEXPR '{'",
+"conditional : T_ELSE T_IF T_CEXPR '{'",
+"conditional : T_ELSE '{'",
+"conditional : '}'",
+"f1_opcode : T_AND",
+"f1_opcode : T_XOR",
+"f1_opcode : T_ADD",
+"f1_opcode : T_ADC",
+"code : f1_opcode destination ',' immediate_or_a opt_source ret ';'",
+"code : T_OR reg_symbol ',' immediate_or_a opt_source ret ';'",
+"code : T_INC destination opt_source ret ';'",
+"code : T_DEC destination opt_source ret ';'",
+"code : T_CLC ret ';'",
+"code : T_CLC T_MVI destination ',' immediate_or_a ret ';'",
+"code : T_STC ret ';'",
+"code : T_STC destination ret ';'",
+"code : T_BMOV destination ',' source ',' immediate ret ';'",
+"code : T_MOV destination ',' source ret ';'",
+"code : T_MVI destination ',' immediate_or_a ret ';'",
+"code : T_NOT destination opt_source ret ';'",
+"code : T_CLR destination ret ';'",
+"code : T_NOP ret ';'",
+"code : T_RET ';'",
+"f2_opcode : T_SHL",
+"f2_opcode : T_SHR",
+"f2_opcode : T_ROL",
+"f2_opcode : T_ROR",
+"code : f2_opcode destination ',' expression opt_source ret ';'",
+"jmp_jc_jnc_call : T_JMP",
+"jmp_jc_jnc_call : T_JC",
+"jmp_jc_jnc_call : T_JNC",
+"jmp_jc_jnc_call : T_CALL",
+"jz_jnz : T_JZ",
+"jz_jnz : T_JNZ",
+"je_jne : T_JE",
+"je_jne : T_JNE",
+"code : jmp_jc_jnc_call address ';'",
+"code : T_OR reg_symbol ',' immediate jmp_jc_jnc_call address ';'",
+"code : T_TEST source ',' immediate_or_a jz_jnz address ';'",
+"code : T_CMP source ',' immediate_or_a je_jne address ';'",
+"code : T_MOV source jmp_jc_jnc_call address ';'",
+"code : T_MVI immediate jmp_jc_jnc_call address ';'",
+};
+#endif
+#if YYDEBUG
+#include <stdio.h>
+#endif
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH YYSTACKSIZE
+#else
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 10000
+#define YYMAXDEPTH 10000
+#endif
+#endif
+#define YYINITSTACKSIZE 200
+int yydebug;
+int yynerrs;
+int yyerrflag;
+int yychar;
+short *yyssp;
+YYSTYPE *yyvsp;
+YYSTYPE yyval;
+YYSTYPE yylval;
+short *yyss;
+short *yysslim;
+YYSTYPE *yyvs;
+int yystacksize;
+#line 1375 "aicasm_gram.y"
+
+static void
+process_field(int field_type, symbol_t *sym, int value)
+{
+	/*
+	 * Add the current register to its
+	 * symbol list, if it already exists,
+	 * warn if we are setting it to a
+	 * different value, or in the bit to
+	 * the "allowed bits" of this register.
+	 */
+	if (sym->type == UNINITIALIZED) {
+		sym->type = field_type;
+		initialize_symbol(sym);
+		sym->info.finfo->value = value;
+		if (field_type != ENUM_ENTRY) {
+			if (field_type != MASK && value == 0) {
+				stop("Empty Field, or Enum", EX_DATAERR);
+				/* NOTREACHED */
+			}
+			sym->info.finfo->value = value;
+			sym->info.finfo->mask = value;
+		} else if (field_symbol != NULL) {
+			sym->info.finfo->mask = field_symbol->info.finfo->value;
+		} else {
+			sym->info.finfo->mask = 0xFF;
+		}
+	} else if (sym->type != field_type) {
+		stop("Field definition mirrors a definition of the same "
+		     " name, but a different type", EX_DATAERR);
+		/* NOTREACHED */
+	} else if (value != sym->info.finfo->value) {
+		stop("Field redefined with a conflicting value", EX_DATAERR);
+		/* NOTREACHED */
+	}
+	/* Fail if this symbol is already listed */
+	if (symlist_search(&(sym->info.finfo->symrefs),
+			   cur_symbol->name) != NULL) {
+		stop("Field defined multiple times for register", EX_DATAERR);
+		/* NOTREACHED */
+	}
+	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
+		    SYMLIST_INSERT_HEAD);
+	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
+	cur_symbol->info.rinfo->typecheck_masks = TRUE;
+	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
+}
+
+static void
+initialize_symbol(symbol_t *symbol)
+{
+	switch (symbol->type) {
+	case UNINITIALIZED:
+		stop("Call to initialize_symbol with type field unset",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+		break;
+	case REGISTER:
+	case SRAMLOC:
+	case SCBLOC:
+		symbol->info.rinfo =
+		    (struct reg_info *)malloc(sizeof(struct reg_info));
+		if (symbol->info.rinfo == NULL) {
+			stop("Can't create register info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.rinfo, 0,
+		       sizeof(struct reg_info));
+		SLIST_INIT(&(symbol->info.rinfo->fields));
+		/*
+		 * Default to allowing access in all register modes
+		 * or to the mode specified by the SCB or SRAM space
+		 * we are in.
+		 */
+		if (scb_or_sram_symbol != NULL)
+			symbol->info.rinfo->modes =
+			    scb_or_sram_symbol->info.rinfo->modes;
+		else
+			symbol->info.rinfo->modes = ~0;
+		break;
+	case ALIAS:
+		symbol->info.ainfo =
+		    (struct alias_info *)malloc(sizeof(struct alias_info));
+		if (symbol->info.ainfo == NULL) {
+			stop("Can't create alias info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.ainfo, 0,
+		       sizeof(struct alias_info));
+		break;
+	case MASK:
+	case FIELD:
+	case ENUM:
+	case ENUM_ENTRY:
+		symbol->info.finfo =
+		    (struct field_info *)malloc(sizeof(struct field_info));
+		if (symbol->info.finfo == NULL) {
+			stop("Can't create field info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.finfo, 0, sizeof(struct field_info));
+		SLIST_INIT(&(symbol->info.finfo->symrefs));
+		break;
+	case CONST:
+	case DOWNLOAD_CONST:
+		symbol->info.cinfo =
+		    (struct const_info *)malloc(sizeof(struct const_info));
+		if (symbol->info.cinfo == NULL) {
+			stop("Can't create alias info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.cinfo, 0,
+		       sizeof(struct const_info));
+		break;
+	case LABEL:
+		symbol->info.linfo =
+		    (struct label_info *)malloc(sizeof(struct label_info));
+		if (symbol->info.linfo == NULL) {
+			stop("Can't create label info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.linfo, 0,
+		       sizeof(struct label_info));
+		break;
+	case CONDITIONAL:
+		symbol->info.condinfo =
+		    (struct cond_info *)malloc(sizeof(struct cond_info));
+		if (symbol->info.condinfo == NULL) {
+			stop("Can't create conditional info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.condinfo, 0,
+		       sizeof(struct cond_info));
+		break;
+	case MACRO:
+		symbol->info.macroinfo = 
+		    (struct macro_info *)malloc(sizeof(struct macro_info));
+		if (symbol->info.macroinfo == NULL) {
+			stop("Can't create macro info", EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		memset(symbol->info.macroinfo, 0,
+		       sizeof(struct macro_info));
+		STAILQ_INIT(&symbol->info.macroinfo->args);
+		break;
+	default:
+		stop("Call to initialize_symbol with invalid symbol type",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+		break;
+	}
+}
+
+static void
+add_macro_arg(const char *argtext, int argnum)
+{
+	struct macro_arg *marg;
+	int i;
+	int retval;
+		
+
+	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
+		stop("Invalid current symbol for adding macro arg",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+
+	marg = (struct macro_arg *)malloc(sizeof(*marg));
+	if (marg == NULL) {
+		stop("Can't create macro_arg structure", EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+	marg->replacement_text = NULL;
+	retval = snprintf(regex_pattern, sizeof(regex_pattern),
+			  "[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)",
+			  argtext);
+	if (retval >= sizeof(regex_pattern)) {
+		stop("Regex text buffer too small for arg",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+	retval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);
+	if (retval != 0) {
+		stop("Regex compilation failed", EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+	STAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);
+}
+
+static void
+add_macro_body(const char *bodytext)
+{
+	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
+		stop("Invalid current symbol for adding macro arg",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+	cur_symbol->info.macroinfo->body = strdup(bodytext);
+	if (cur_symbol->info.macroinfo->body == NULL) {
+		stop("Can't duplicate macro body text", EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+}
+
+static void
+process_register(symbol_t **p_symbol)
+{
+	symbol_t *symbol = *p_symbol;
+
+	if (symbol->type == UNINITIALIZED) {
+		snprintf(errbuf, sizeof(errbuf), "Undefined register %s",
+			 symbol->name);
+		stop(errbuf, EX_DATAERR);
+		/* NOTREACHED */
+	} else if (symbol->type == ALIAS) {
+		*p_symbol = symbol->info.ainfo->parent;
+	} else if ((symbol->type != REGISTER)
+		&& (symbol->type != SCBLOC)
+		&& (symbol->type != SRAMLOC)) {
+		snprintf(errbuf, sizeof(errbuf),
+			 "Specified symbol %s is not a register",
+			 symbol->name);
+		stop(errbuf, EX_DATAERR);
+	}
+}
+
+static void
+format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
+	       symbol_ref_t *src, int ret)
+{
+	struct instruction *instr;
+	struct ins_format1 *f1_instr;
+
+	if (src->symbol == NULL)
+		src = dest;
+
+	/* Test register permissions */
+	test_writable_symbol(dest->symbol);
+	test_readable_symbol(src->symbol);
+
+	/* Ensure that immediate makes sense for this destination */
+	type_check(dest->symbol, immed, opcode);
+
+	/* Allocate sequencer space for the instruction and fill it out */
+	instr = seq_alloc();
+	f1_instr = &instr->format.format1;
+	f1_instr->ret = ret ? 1 : 0;
+	f1_instr->opcode = opcode;
+	f1_instr->destination = dest->symbol->info.rinfo->address
+			      + dest->offset;
+	f1_instr->source = src->symbol->info.rinfo->address
+			 + src->offset;
+	f1_instr->immediate = immed->value;
+
+	if (is_download_const(immed))
+		f1_instr->parity = 1;
+	else if (dest->symbol == mode_ptr.symbol) {
+		u_int src_value;
+		u_int dst_value;
+
+		/*
+		 * Attempt to update mode information if
+		 * we are operating on the mode register.
+		 */
+		if (src->symbol == allones.symbol)
+			src_value = 0xFF;
+		else if (src->symbol == allzeros.symbol)
+			src_value = 0;
+		else if (src->symbol == mode_ptr.symbol)
+			src_value = (dst_mode << 4) | src_mode;
+		else
+			goto cant_update;
+
+		switch (opcode) {
+		case AIC_OP_AND:
+			dst_value = src_value & immed->value;
+			break;
+		case AIC_OP_XOR:
+			dst_value = src_value ^ immed->value;
+			break;
+		case AIC_OP_ADD:
+			dst_value = (src_value + immed->value) & 0xFF;
+			break;
+		case AIC_OP_OR:
+			dst_value = src_value | immed->value;
+			break;
+		case AIC_OP_BMOV:
+			dst_value = src_value;
+			break;
+		default:
+			goto cant_update;
+		}
+		src_mode = dst_value & 0xF;
+		dst_mode = (dst_value >> 4) & 0xF;
+	}
+
+cant_update:
+	symlist_free(&immed->referenced_syms);
+	instruction_ptr++;
+}
+
+static void
+format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
+	       symbol_ref_t *src, int ret)
+{
+	struct instruction *instr;
+	struct ins_format2 *f2_instr;
+	uint8_t shift_control;
+
+	if (src->symbol == NULL)
+		src = dest;
+
+	/* Test register permissions */
+	test_writable_symbol(dest->symbol);
+	test_readable_symbol(src->symbol);
+
+	/* Allocate sequencer space for the instruction and fill it out */
+	instr = seq_alloc();
+	f2_instr = &instr->format.format2;
+	f2_instr->ret = ret ? 1 : 0;
+	f2_instr->opcode = AIC_OP_ROL;
+	f2_instr->destination = dest->symbol->info.rinfo->address
+			      + dest->offset;
+	f2_instr->source = src->symbol->info.rinfo->address
+			 + src->offset;
+	if (places->value > 8 || places->value <= 0) {
+		stop("illegal shift value", EX_DATAERR);
+		/* NOTREACHED */
+	}
+	switch (opcode) {
+	case AIC_OP_SHL:
+		if (places->value == 8)
+			shift_control = 0xf0;
+		else
+			shift_control = (places->value << 4) | places->value;
+		break;
+	case AIC_OP_SHR:
+		if (places->value == 8) {
+			shift_control = 0xf8;
+		} else {
+			shift_control = (places->value << 4)
+				      | (8 - places->value)
+				      | 0x08;
+		}
+		break;
+	case AIC_OP_ROL:
+		shift_control = places->value & 0x7;
+		break;
+	case AIC_OP_ROR:
+		shift_control = (8 - places->value) | 0x08;
+		break;
+	default:
+		shift_control = 0; /* Quiet Compiler */
+		stop("Invalid shift operation specified", EX_SOFTWARE);
+		/* NOTREACHED */
+		break;
+	};
+	f2_instr->shift_control = shift_control;
+	symlist_free(&places->referenced_syms);
+	instruction_ptr++;
+}
+
+static void
+format_3_instr(int opcode, symbol_ref_t *src,
+	       expression_t *immed, symbol_ref_t *address)
+{
+	struct instruction *instr;
+	struct ins_format3 *f3_instr;
+	int addr;
+
+	/* Test register permissions */
+	test_readable_symbol(src->symbol);
+
+	/* Ensure that immediate makes sense for this source */
+	type_check(src->symbol, immed, opcode);
+
+	/* Allocate sequencer space for the instruction and fill it out */
+	instr = seq_alloc();
+	f3_instr = &instr->format.format3;
+	if (address->symbol == NULL) {
+		/* 'dot' referrence.  Use the current instruction pointer */
+		addr = instruction_ptr + address->offset;
+	} else if (address->symbol->type == UNINITIALIZED) {
+		/* forward reference */
+		addr = address->offset;
+		instr->patch_label = address->symbol;
+	} else
+		addr = address->symbol->info.linfo->address + address->offset;
+	f3_instr->opcode = opcode;
+	f3_instr->address = addr;
+	f3_instr->source = src->symbol->info.rinfo->address
+			 + src->offset;
+	f3_instr->immediate = immed->value;
+
+	if (is_download_const(immed))
+		f3_instr->parity = 1;
+
+	symlist_free(&immed->referenced_syms);
+	instruction_ptr++;
+}
+
+static void
+test_readable_symbol(symbol_t *symbol)
+{
+	
+	if ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {
+		snprintf(errbuf, sizeof(errbuf),
+			"Register %s unavailable in source reg mode %d",
+			symbol->name, src_mode);
+		stop(errbuf, EX_DATAERR);
+	}
+
+	if (symbol->info.rinfo->mode == WO) {
+		stop("Write Only register specified as source",
+		     EX_DATAERR);
+		/* NOTREACHED */
+	}
+}
+
+static void
+test_writable_symbol(symbol_t *symbol)
+{
+	
+	if ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {
+		snprintf(errbuf, sizeof(errbuf),
+			"Register %s unavailable in destination reg mode %d",
+			symbol->name, dst_mode);
+		stop(errbuf, EX_DATAERR);
+	}
+
+	if (symbol->info.rinfo->mode == RO) {
+		stop("Read Only register specified as destination",
+		     EX_DATAERR);
+		/* NOTREACHED */
+	}
+}
+
+static void
+type_check(symbol_t *symbol, expression_t *expression, int opcode)
+{
+	symbol_node_t *node;
+	int and_op;
+
+	and_op = FALSE;
+	if (opcode == AIC_OP_AND || opcode == AIC_OP_JNZ || AIC_OP_JZ)
+		and_op = TRUE;
+
+	/*
+	 * Make sure that we aren't attempting to write something
+	 * that hasn't been defined.  If this is an and operation,
+	 * this is a mask, so "undefined" bits are okay.
+	 */
+	if (and_op == FALSE
+	 && (expression->value & ~symbol->info.rinfo->valid_bitmask) != 0) {
+		snprintf(errbuf, sizeof(errbuf),
+			 "Invalid bit(s) 0x%x in immediate written to %s",
+			 expression->value & ~symbol->info.rinfo->valid_bitmask,
+			 symbol->name);
+		stop(errbuf, EX_DATAERR);
+		/* NOTREACHED */
+	}
+
+	/*
+	 * Now make sure that all of the symbols referenced by the
+	 * expression are defined for this register.
+	 */
+	if (symbol->info.rinfo->typecheck_masks != FALSE) {
+		for(node = expression->referenced_syms.slh_first;
+		    node != NULL;
+		    node = node->links.sle_next) {
+			if ((node->symbol->type == MASK
+			  || node->symbol->type == FIELD
+			  || node->symbol->type == ENUM
+			  || node->symbol->type == ENUM_ENTRY)
+			 && symlist_search(&node->symbol->info.finfo->symrefs,
+					   symbol->name) == NULL) {
+				snprintf(errbuf, sizeof(errbuf),
+					 "Invalid field or mask %s "
+					 "for register %s",
+					 node->symbol->name, symbol->name);
+				stop(errbuf, EX_DATAERR);
+				/* NOTREACHED */
+			}
+		}
+	}
+}
+
+static void
+make_expression(expression_t *immed, int value)
+{
+	SLIST_INIT(&immed->referenced_syms);
+	immed->value = value & 0xff;
+}
+
+static void
+add_conditional(symbol_t *symbol)
+{
+	static int numfuncs;
+
+	if (numfuncs == 0) {
+		/* add a special conditional, "0" */
+		symbol_t *false_func;
+
+		false_func = symtable_get("0");
+		if (false_func->type != UNINITIALIZED) {
+			stop("Conditional expression '0' "
+			     "conflicts with a symbol", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		false_func->type = CONDITIONAL;
+		initialize_symbol(false_func);
+		false_func->info.condinfo->func_num = numfuncs++;
+		symlist_add(&patch_functions, false_func, SYMLIST_INSERT_HEAD);
+	}
+
+	/* This condition has occurred before */
+	if (symbol->type == CONDITIONAL)
+		return;
+
+	if (symbol->type != UNINITIALIZED) {
+		stop("Conditional expression conflicts with a symbol",
+		     EX_DATAERR);
+		/* NOTREACHED */
+	}
+
+	symbol->type = CONDITIONAL;
+	initialize_symbol(symbol);
+	symbol->info.condinfo->func_num = numfuncs++;
+	symlist_add(&patch_functions, symbol, SYMLIST_INSERT_HEAD);
+}
+
+static void
+add_version(const char *verstring)
+{
+	const char prefix[] = " * ";
+	int newlen;
+	int oldlen;
+
+	newlen = strlen(verstring) + strlen(prefix);
+	oldlen = 0;
+	if (versions != NULL)
+		oldlen = strlen(versions);
+	versions = realloc(versions, newlen + oldlen + 2);
+	if (versions == NULL)
+		stop("Can't allocate version string", EX_SOFTWARE);
+	strcpy(&versions[oldlen], prefix);
+	strcpy(&versions[oldlen + strlen(prefix)], verstring);
+	versions[newlen + oldlen] = '\n';
+	versions[newlen + oldlen + 1] = '\0';
+}
+
+void
+yyerror(const char *string)
+{
+	stop(string, EX_DATAERR);
+}
+
+static int
+is_download_const(expression_t *immed)
+{
+	if ((immed->referenced_syms.slh_first != NULL)
+	 && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))
+		return (TRUE);
+
+	return (FALSE);
+}
+#line 1395 "aicasm_gram.tab.c"
+/* allocate initial stack or double stack size, up to YYMAXDEPTH */
+static int yygrowstack()
+{
+    int newsize, i;
+    short *newss;
+    YYSTYPE *newvs;
+
+    if ((newsize = yystacksize) == 0)
+        newsize = YYINITSTACKSIZE;
+    else if (newsize >= YYMAXDEPTH)
+        return -1;
+    else if ((newsize *= 2) > YYMAXDEPTH)
+        newsize = YYMAXDEPTH;
+    i = yyssp - yyss;
+    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
+      (short *)malloc(newsize * sizeof *newss);
+    if (newss == NULL)
+        return -1;
+    yyss = newss;
+    yyssp = newss + i;
+    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
+      (YYSTYPE *)malloc(newsize * sizeof *newvs);
+    if (newvs == NULL)
+        return -1;
+    yyvs = newvs;
+    yyvsp = newvs + i;
+    yystacksize = newsize;
+    yysslim = yyss + newsize - 1;
+    return 0;
+}
+
+#define YYABORT goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR goto yyerrlab
+
+#ifndef YYPARSE_PARAM
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG void
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif	/* ANSI-C/C++ */
+#else	/* YYPARSE_PARAM */
+#ifndef YYPARSE_PARAM_TYPE
+#define YYPARSE_PARAM_TYPE void *
+#endif
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
+#endif	/* ANSI-C/C++ */
+#endif	/* ! YYPARSE_PARAM */
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+    YYPARSE_PARAM_DECL
+{
+    register int yym, yyn, yystate;
+#if YYDEBUG
+    register const char *yys;
+
+    if ((yys = getenv("YYDEBUG")))
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+#endif
+
+    yynerrs = 0;
+    yyerrflag = 0;
+    yychar = (-1);
+
+    if (yyss == NULL && yygrowstack()) goto yyoverflow;
+    yyssp = yyss;
+    yyvsp = yyvs;
+    *yyssp = yystate = 0;
+
+yyloop:
+    if ((yyn = yydefred[yystate])) goto yyreduce;
+    if (yychar < 0)
+    {
+        if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, reading %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+    }
+    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: state %d, shifting to state %d\n",
+                    YYPREFIX, yystate, yytable[yyn]);
+#endif
+        if (yyssp >= yysslim && yygrowstack())
+        {
+            goto yyoverflow;
+        }
+        *++yyssp = yystate = yytable[yyn];
+        *++yyvsp = yylval;
+        yychar = (-1);
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
+    }
+    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+        yyn = yytable[yyn];
+        goto yyreduce;
+    }
+    if (yyerrflag) goto yyinrecovery;
+#if defined(lint) || defined(__GNUC__)
+    goto yynewerror;
+#endif
+yynewerror:
+    yyerror("syntax error");
+#if defined(lint) || defined(__GNUC__)
+    goto yyerrlab;
+#endif
+yyerrlab:
+    ++yynerrs;
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: state %d, error recovery shifting\
+ to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
+#endif
+                if (yyssp >= yysslim && yygrowstack())
+                {
+                    goto yyoverflow;
+                }
+                *++yyssp = yystate = yytable[yyn];
+                *++yyvsp = yylval;
+                goto yyloop;
+            }
+            else
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: error recovery discarding state %d\n",
+                            YYPREFIX, *yyssp);
+#endif
+                if (yyssp <= yyss) goto yyabort;
+                --yyssp;
+                --yyvsp;
+            }
+        }
+    }
+    else
+    {
+        if (yychar == 0) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+        yychar = (-1);
+        goto yyloop;
+    }
+yyreduce:
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
+                YYPREFIX, yystate, yyn, yyrule[yyn]);
+#endif
+    yym = yylen[yyn];
+    yyval = yyvsp[1-yym];
+    switch (yyn)
+    {
+case 33:
+#line 261 "aicasm_gram.y"
+{
+		include_file(yyvsp[-1].str, BRACKETED_INCLUDE);
+	}
+break;
+case 34:
+#line 265 "aicasm_gram.y"
+{
+		include_file(yyvsp[-1].str, QUOTED_INCLUDE);
+	}
+break;
+case 35:
+#line 272 "aicasm_gram.y"
+{
+		if (prefix != stock_prefix)
+			stop("Prefix multiply defined",
+			     EX_DATAERR);
+		prefix = strdup(yyvsp[0].str);
+		if (prefix == NULL)
+			stop("Unable to record prefix", EX_SOFTWARE);
+	}
+break;
+case 36:
+#line 284 "aicasm_gram.y"
+{
+		if (patch_arg_list != NULL)
+			stop("Patch argument list multiply defined",
+			     EX_DATAERR);
+		patch_arg_list = strdup(yyvsp[0].str);
+		if (patch_arg_list == NULL)
+			stop("Unable to record patch arg list", EX_SOFTWARE);
+	}
+break;
+case 37:
+#line 296 "aicasm_gram.y"
+{ add_version(yyvsp[0].str); }
+break;
+case 38:
+#line 300 "aicasm_gram.y"
+{ cur_symtype = REGISTER; }
+break;
+case 40:
+#line 305 "aicasm_gram.y"
+{
+			if (yyvsp[-1].sym->type != UNINITIALIZED) {
+				stop("Register multiply defined", EX_DATAERR);
+				/* NOTREACHED */
+			}
+			cur_symbol = yyvsp[-1].sym; 
+			cur_symbol->type = cur_symtype;
+			initialize_symbol(cur_symbol);
+		}
+break;
+case 41:
+#line 316 "aicasm_gram.y"
+{                    
+			/*
+			 * Default to allowing everything in for registers
+			 * with no bit or mask definitions.
+			 */
+			if (cur_symbol->info.rinfo->valid_bitmask == 0)
+				cur_symbol->info.rinfo->valid_bitmask = 0xFF;
+
+			if (cur_symbol->info.rinfo->size == 0)
+				cur_symbol->info.rinfo->size = 1;
+
+			/*
+			 * This might be useful for registers too.
+			 */
+			if (cur_symbol->type != REGISTER) {
+				if (cur_symbol->info.rinfo->address == 0)
+					cur_symbol->info.rinfo->address =
+					    sram_or_scb_offset;
+				sram_or_scb_offset +=
+				    cur_symbol->info.rinfo->size;
+			}
+			cur_symbol = NULL;
+		}
+break;
+case 58:
+#line 365 "aicasm_gram.y"
+{
+		cur_symbol->info.rinfo->address = yyvsp[0].value;
+	}
+break;
+case 59:
+#line 372 "aicasm_gram.y"
+{
+		cur_symbol->info.rinfo->size = yyvsp[0].value;
+		if (scb_or_sram_symbol != NULL) {
+			u_int max_addr;
+			u_int sym_max_addr;
+
+			max_addr = scb_or_sram_symbol->info.rinfo->address
+				 + scb_or_sram_symbol->info.rinfo->size;
+			sym_max_addr = cur_symbol->info.rinfo->address
+				     + cur_symbol->info.rinfo->size;
+
+			if (sym_max_addr > max_addr)
+				stop("SCB or SRAM space exhausted", EX_DATAERR);
+		}
+	}
+break;
+case 60:
+#line 391 "aicasm_gram.y"
+{
+		cur_symbol->info.rinfo->mode = yyvsp[0].value;
+	}
+break;
+case 61:
+#line 398 "aicasm_gram.y"
+{
+		cur_symbol->info.rinfo->modes = yyvsp[0].value;
+	}
+break;
+case 62:
+#line 405 "aicasm_gram.y"
+{
+		yyval.value = yyvsp[0].value;
+	}
+break;
+case 63:
+#line 409 "aicasm_gram.y"
+{
+		yyval.value = yyvsp[-2].value | yyvsp[0].value;
+	}
+break;
+case 64:
+#line 416 "aicasm_gram.y"
+{
+		if (yyvsp[0].value > 4) {
+			stop("Valid register modes range between 0 and 4.",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+
+		yyval.value = (0x1 << yyvsp[0].value);
+	}
+break;
+case 65:
+#line 426 "aicasm_gram.y"
+{
+		symbol_t *symbol;
+
+		symbol = yyvsp[0].sym;
+		if (symbol->type != CONST) {
+			stop("Only \"const\" symbols allowed in "
+			     "mode definitions.", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		if (symbol->info.cinfo->value > 4) {
+			stop("Valid register modes range between 0 and 4.",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.value = (0x1 << symbol->info.cinfo->value);
+	}
+break;
+case 66:
+#line 446 "aicasm_gram.y"
+{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+break;
+case 68:
+#line 453 "aicasm_gram.y"
+{
+			process_field(FIELD, yyvsp[-1].sym, yyvsp[0].expression.value);
+			field_symbol = yyvsp[-1].sym;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs(yyvsp[0].expression.value) - 1);
+		}
+break;
+case 70:
+#line 461 "aicasm_gram.y"
+{
+		process_field(FIELD, yyvsp[-1].sym, yyvsp[0].expression.value);
+	}
+break;
+case 71:
+#line 468 "aicasm_gram.y"
+{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+break;
+case 73:
+#line 475 "aicasm_gram.y"
+{
+			process_field(ENUM, yyvsp[-1].sym, yyvsp[0].expression.value);
+			field_symbol = yyvsp[-1].sym;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs(yyvsp[0].expression.value) - 1);
+		}
+break;
+case 77:
+#line 491 "aicasm_gram.y"
+{
+		process_field(ENUM_ENTRY, yyvsp[0].sym, enum_next_value);
+		enum_next_value += enum_increment;
+	}
+break;
+case 78:
+#line 496 "aicasm_gram.y"
+{
+		process_field(ENUM_ENTRY, yyvsp[-1].sym, yyvsp[0].expression.value);
+		enum_next_value = yyvsp[0].expression.value + enum_increment;
+	}
+break;
+case 79:
+#line 504 "aicasm_gram.y"
+{
+		process_field(MASK, yyvsp[-1].sym, yyvsp[0].expression.value);
+	}
+break;
+case 80:
+#line 511 "aicasm_gram.y"
+{
+		if (yyvsp[0].sym->type != UNINITIALIZED) {
+			stop("Re-definition of register alias",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyvsp[0].sym->type = ALIAS;
+		initialize_symbol(yyvsp[0].sym);
+		yyvsp[0].sym->info.ainfo->parent = cur_symbol;
+	}
+break;
+case 81:
+#line 525 "aicasm_gram.y"
+{
+		if (accumulator.symbol != NULL) {
+			stop("Only one accumulator definition allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		accumulator.symbol = cur_symbol;
+	}
+break;
+case 82:
+#line 537 "aicasm_gram.y"
+{
+		if (mode_ptr.symbol != NULL) {
+			stop("Only one mode pointer definition allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		mode_ptr.symbol = cur_symbol;
+	}
+break;
+case 83:
+#line 549 "aicasm_gram.y"
+{
+		if (allones.symbol != NULL) {
+			stop("Only one definition of allones allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		allones.symbol = cur_symbol;
+	}
+break;
+case 84:
+#line 561 "aicasm_gram.y"
+{
+		if (allzeros.symbol != NULL) {
+			stop("Only one definition of allzeros allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		allzeros.symbol = cur_symbol;
+	}
+break;
+case 85:
+#line 573 "aicasm_gram.y"
+{
+		if (none.symbol != NULL) {
+			stop("Only one definition of none allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		none.symbol = cur_symbol;
+	}
+break;
+case 86:
+#line 585 "aicasm_gram.y"
+{
+		if (sindex.symbol != NULL) {
+			stop("Only one definition of sindex allowed",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		sindex.symbol = cur_symbol;
+	}
+break;
+case 87:
+#line 597 "aicasm_gram.y"
+{
+		 yyval.expression.value = yyvsp[-2].expression.value | yyvsp[0].expression.value;
+		 symlist_merge(&yyval.expression.referenced_syms,
+			       &yyvsp[-2].expression.referenced_syms,
+			       &yyvsp[0].expression.referenced_syms);
+	}
+break;
+case 88:
+#line 604 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value & yyvsp[0].expression.value;
+		symlist_merge(&yyval.expression.referenced_syms,
+			       &yyvsp[-2].expression.referenced_syms,
+			       &yyvsp[0].expression.referenced_syms);
+	}
+break;
+case 89:
+#line 611 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value + yyvsp[0].expression.value;
+		symlist_merge(&yyval.expression.referenced_syms,
+			       &yyvsp[-2].expression.referenced_syms,
+			       &yyvsp[0].expression.referenced_syms);
+	}
+break;
+case 90:
+#line 618 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value - yyvsp[0].expression.value;
+		symlist_merge(&(yyval.expression.referenced_syms),
+			       &(yyvsp[-2].expression.referenced_syms),
+			       &(yyvsp[0].expression.referenced_syms));
+	}
+break;
+case 91:
+#line 625 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value * yyvsp[0].expression.value;
+		symlist_merge(&(yyval.expression.referenced_syms),
+			       &(yyvsp[-2].expression.referenced_syms),
+			       &(yyvsp[0].expression.referenced_syms));
+	}
+break;
+case 92:
+#line 632 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value / yyvsp[0].expression.value;
+		symlist_merge(&(yyval.expression.referenced_syms),
+			       &(yyvsp[-2].expression.referenced_syms),
+			       &(yyvsp[0].expression.referenced_syms));
+	}
+break;
+case 93:
+#line 639 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value << yyvsp[0].expression.value;
+		symlist_merge(&yyval.expression.referenced_syms,
+			       &yyvsp[-2].expression.referenced_syms,
+			       &yyvsp[0].expression.referenced_syms);
+	}
+break;
+case 94:
+#line 646 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[-2].expression.value >> yyvsp[0].expression.value;
+		symlist_merge(&yyval.expression.referenced_syms,
+			       &yyvsp[-2].expression.referenced_syms,
+			       &yyvsp[0].expression.referenced_syms);
+	}
+break;
+case 95:
+#line 653 "aicasm_gram.y"
+{
+		yyval.expression = yyvsp[-1].expression;
+	}
+break;
+case 96:
+#line 657 "aicasm_gram.y"
+{
+		yyval.expression = yyvsp[0].expression;
+		yyval.expression.value = (~yyval.expression.value) & 0xFF;
+	}
+break;
+case 97:
+#line 662 "aicasm_gram.y"
+{
+		yyval.expression = yyvsp[0].expression;
+		yyval.expression.value = -yyval.expression.value;
+	}
+break;
+case 98:
+#line 667 "aicasm_gram.y"
+{
+		yyval.expression.value = yyvsp[0].value;
+		SLIST_INIT(&yyval.expression.referenced_syms);
+	}
+break;
+case 99:
+#line 672 "aicasm_gram.y"
+{
+		symbol_t *symbol;
+
+		symbol = yyvsp[0].sym;
+		switch (symbol->type) {
+		case ALIAS:
+			symbol = yyvsp[0].sym->info.ainfo->parent;
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+			yyval.expression.value = symbol->info.rinfo->address;
+			break;
+		case MASK:
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			yyval.expression.value = symbol->info.finfo->value;
+			break;
+		case DOWNLOAD_CONST:
+		case CONST:
+			yyval.expression.value = symbol->info.cinfo->value;
+			break;
+		case UNINITIALIZED:
+		default:
+		{
+			snprintf(errbuf, sizeof(errbuf),
+				 "Undefined symbol %s referenced",
+				 symbol->name);
+			stop(errbuf, EX_DATAERR);
+			/* NOTREACHED */
+			break;
+		}
+		}
+		SLIST_INIT(&yyval.expression.referenced_syms);
+		symlist_add(&yyval.expression.referenced_syms, symbol, SYMLIST_INSERT_HEAD);
+	}
+break;
+case 100:
+#line 712 "aicasm_gram.y"
+{
+		if (yyvsp[-1].sym->type != UNINITIALIZED) {
+			stop("Re-definition of symbol as a constant",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyvsp[-1].sym->type = CONST;
+		initialize_symbol(yyvsp[-1].sym);
+		yyvsp[-1].sym->info.cinfo->value = yyvsp[0].value;
+	}
+break;
+case 101:
+#line 723 "aicasm_gram.y"
+{
+		if (yyvsp[-2].value) {
+			stop("Invalid downloaded constant declaration",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		if (yyvsp[-1].sym->type != UNINITIALIZED) {
+			stop("Re-definition of symbol as a downloaded constant",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyvsp[-1].sym->type = DOWNLOAD_CONST;
+		initialize_symbol(yyvsp[-1].sym);
+		yyvsp[-1].sym->info.cinfo->value = download_constant_count++;
+	}
+break;
+case 102:
+#line 742 "aicasm_gram.y"
+{
+		if (yyvsp[0].sym->type != UNINITIALIZED) {
+			stop("Re-definition of symbol as a macro",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		cur_symbol = yyvsp[0].sym;
+		cur_symbol->type = MACRO;
+		initialize_symbol(cur_symbol);
+	}
+break;
+case 103:
+#line 756 "aicasm_gram.y"
+{
+		add_macro_body(yyvsp[0].str);
+	}
+break;
+case 104:
+#line 760 "aicasm_gram.y"
+{
+		add_macro_body(yyvsp[0].str);
+		cur_symbol->info.macroinfo->narg = yyvsp[-2].value;
+	}
+break;
+case 105:
+#line 767 "aicasm_gram.y"
+{
+		/* Macros can take no arguments */
+		yyval.value = 0;
+	}
+break;
+case 106:
+#line 772 "aicasm_gram.y"
+{
+		yyval.value = 1;
+		add_macro_arg(yyvsp[0].str, 0);
+	}
+break;
+case 107:
+#line 777 "aicasm_gram.y"
+{
+		if (yyvsp[-2].value == 0) {
+			stop("Comma without preceeding argument in arg list",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.value = yyvsp[-2].value + 1;
+		add_macro_arg(yyvsp[0].str, yyvsp[-2].value);
+	}
+break;
+case 108:
+#line 790 "aicasm_gram.y"
+{
+		yyval.value = yyvsp[0].value;
+	}
+break;
+case 109:
+#line 794 "aicasm_gram.y"
+{
+		yyval.value = -yyvsp[0].value;
+	}
+break;
+case 110:
+#line 801 "aicasm_gram.y"
+{
+			snprintf(errbuf, sizeof(errbuf), "%s%d", SRAM_SYMNAME,
+				 num_srams);
+			cur_symbol = symtable_get(SRAM_SYMNAME);
+			cur_symtype = SRAMLOC;
+			cur_symbol->type = SRAMLOC;
+			initialize_symbol(cur_symbol);
+		}
+break;
+case 111:
+#line 810 "aicasm_gram.y"
+{
+			sram_or_scb_offset = cur_symbol->info.rinfo->address;
+		}
+break;
+case 112:
+#line 814 "aicasm_gram.y"
+{
+			scb_or_sram_symbol = cur_symbol;
+		}
+break;
+case 113:
+#line 819 "aicasm_gram.y"
+{
+			cur_symbol = NULL;
+			scb_or_sram_symbol = NULL;
+		}
+break;
+case 114:
+#line 827 "aicasm_gram.y"
+{
+			cur_symbol = symtable_get(SCB_SYMNAME);
+			cur_symtype = SCBLOC;
+			if (cur_symbol->type != UNINITIALIZED) {
+				stop("Only one SRAM definition allowed",
+				     EX_SOFTWARE);
+				/* NOTREACHED */
+			}
+			cur_symbol->type = SCBLOC;
+			initialize_symbol(cur_symbol);
+			/* 64 bytes of SCB space */
+			cur_symbol->info.rinfo->size = 64;
+		}
+break;
+case 115:
+#line 841 "aicasm_gram.y"
+{
+			sram_or_scb_offset = cur_symbol->info.rinfo->address;
+		}
+break;
+case 116:
+#line 845 "aicasm_gram.y"
+{
+			scb_or_sram_symbol = cur_symbol;
+		}
+break;
+case 117:
+#line 850 "aicasm_gram.y"
+{
+			cur_symbol = NULL;
+			scb_or_sram_symbol = NULL;
+		}
+break;
+case 124:
+#line 870 "aicasm_gram.y"
+{
+		process_register(&yyvsp[0].sym);
+		yyval.sym_ref.symbol = yyvsp[0].sym;
+		yyval.sym_ref.offset = 0;
+	}
+break;
+case 125:
+#line 876 "aicasm_gram.y"
+{
+		process_register(&yyvsp[-3].sym);
+		if (yyvsp[-1].sym->type != CONST) {
+			stop("register offset must be a constant", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		if ((yyvsp[-1].sym->info.cinfo->value + 1) > yyvsp[-3].sym->info.rinfo->size) {
+			stop("Accessing offset beyond range of register",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.sym_ref.symbol = yyvsp[-3].sym;
+		yyval.sym_ref.offset = yyvsp[-1].sym->info.cinfo->value;
+	}
+break;
+case 126:
+#line 891 "aicasm_gram.y"
+{
+		process_register(&yyvsp[-3].sym);
+		if ((yyvsp[-1].value + 1) > yyvsp[-3].sym->info.rinfo->size) {
+			stop("Accessing offset beyond range of register",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.sym_ref.symbol = yyvsp[-3].sym;
+		yyval.sym_ref.offset = yyvsp[-1].value;
+	}
+break;
+case 127:
+#line 902 "aicasm_gram.y"
+{
+		if (accumulator.symbol == NULL) {
+			stop("No accumulator has been defined", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.sym_ref.symbol = accumulator.symbol;
+		yyval.sym_ref.offset = 0;
+	}
+break;
+case 128:
+#line 914 "aicasm_gram.y"
+{
+		test_writable_symbol(yyvsp[0].sym_ref.symbol);
+		yyval.sym_ref = yyvsp[0].sym_ref;
+	}
+break;
+case 129:
+#line 922 "aicasm_gram.y"
+{ yyval.expression = yyvsp[0].expression; }
+break;
+case 130:
+#line 927 "aicasm_gram.y"
+{
+		if (yyvsp[0].expression.value == 0 && is_download_const(&yyvsp[0].expression) == 0) {
+			snprintf(errbuf, sizeof(errbuf),
+				 "\nExpression evaluates to 0 and thus "
+				 "references the accumulator.\n "
+				 "If this is the desired effect, use 'A' "
+				 "instead.\n");
+			stop(errbuf, EX_DATAERR);
+		}
+		yyval.expression = yyvsp[0].expression;
+	}
+break;
+case 131:
+#line 939 "aicasm_gram.y"
+{
+		SLIST_INIT(&yyval.expression.referenced_syms);
+		yyval.expression.value = 0;
+	}
+break;
+case 132:
+#line 947 "aicasm_gram.y"
+{
+		test_readable_symbol(yyvsp[0].sym_ref.symbol);
+		yyval.sym_ref = yyvsp[0].sym_ref;
+	}
+break;
+case 133:
+#line 954 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = NULL;
+		yyval.sym_ref.offset = 0;
+	}
+break;
+case 134:
+#line 959 "aicasm_gram.y"
+{ yyval.sym_ref = yyvsp[0].sym_ref; }
+break;
+case 135:
+#line 963 "aicasm_gram.y"
+{ yyval.value = 0; }
+break;
+case 136:
+#line 965 "aicasm_gram.y"
+{ yyval.value = 1; }
+break;
+case 137:
+#line 970 "aicasm_gram.y"
+{
+		src_mode = yyvsp[-1].value;
+	}
+break;
+case 138:
+#line 977 "aicasm_gram.y"
+{
+		dst_mode = yyvsp[-1].value;
+	}
+break;
+case 139:
+#line 984 "aicasm_gram.y"
+{
+		critical_section_t *cs;
+
+		if (in_critical_section != FALSE) {
+			stop("Critical Section within Critical Section",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		cs = cs_alloc();
+		cs->begin_addr = instruction_ptr;
+		in_critical_section = TRUE;
+	}
+break;
+case 140:
+#line 999 "aicasm_gram.y"
+{
+		critical_section_t *cs;
+
+		if (in_critical_section == FALSE) {
+			stop("Unballanced 'end_cs'", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		cs = TAILQ_LAST(&cs_tailq, cs_tailq);
+		cs->end_addr = instruction_ptr;
+		in_critical_section = FALSE;
+	}
+break;
+case 141:
+#line 1012 "aicasm_gram.y"
+{ yyval.value = 0; }
+break;
+case 142:
+#line 1014 "aicasm_gram.y"
+{ yyval.value = 1; }
+break;
+case 143:
+#line 1019 "aicasm_gram.y"
+{
+		if (yyvsp[-1].sym->type != UNINITIALIZED) {
+			stop("Program label multiply defined", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyvsp[-1].sym->type = LABEL;
+		initialize_symbol(yyvsp[-1].sym);
+		yyvsp[-1].sym->info.linfo->address = instruction_ptr;
+		yyvsp[-1].sym->info.linfo->exported = yyvsp[-2].value;
+	}
+break;
+case 144:
+#line 1033 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = yyvsp[0].sym;
+		yyval.sym_ref.offset = 0;
+	}
+break;
+case 145:
+#line 1038 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = yyvsp[-2].sym;
+		yyval.sym_ref.offset = yyvsp[0].value;
+	}
+break;
+case 146:
+#line 1043 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = yyvsp[-2].sym;
+		yyval.sym_ref.offset = -yyvsp[0].value;
+	}
+break;
+case 147:
+#line 1048 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = NULL;
+		yyval.sym_ref.offset = 0;
+	}
+break;
+case 148:
+#line 1053 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = NULL;
+		yyval.sym_ref.offset = yyvsp[0].value;
+	}
+break;
+case 149:
+#line 1058 "aicasm_gram.y"
+{
+		yyval.sym_ref.symbol = NULL;
+		yyval.sym_ref.offset = -yyvsp[0].value;
+	}
+break;
+case 150:
+#line 1066 "aicasm_gram.y"
+{
+		scope_t *new_scope;
+
+		add_conditional(yyvsp[-1].sym);
+		new_scope = scope_alloc();
+		new_scope->type = SCOPE_IF;
+		new_scope->begin_addr = instruction_ptr;
+		new_scope->func_num = yyvsp[-1].sym->info.condinfo->func_num;
+	}
+break;
+case 151:
+#line 1076 "aicasm_gram.y"
+{
+		scope_t *new_scope;
+		scope_t *scope_context;
+		scope_t *last_scope;
+
+		/*
+		 * Ensure that the previous scope is either an
+		 * if or and else if.
+		 */
+		scope_context = SLIST_FIRST(&scope_stack);
+		last_scope = TAILQ_LAST(&scope_context->inner_scope,
+					scope_tailq);
+		if (last_scope == NULL
+		 || last_scope->type == T_ELSE) {
+
+			stop("'else if' without leading 'if'", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		add_conditional(yyvsp[-1].sym);
+		new_scope = scope_alloc();
+		new_scope->type = SCOPE_ELSE_IF;
+		new_scope->begin_addr = instruction_ptr;
+		new_scope->func_num = yyvsp[-1].sym->info.condinfo->func_num;
+	}
+break;
+case 152:
+#line 1101 "aicasm_gram.y"
+{
+		scope_t *new_scope;
+		scope_t *scope_context;
+		scope_t *last_scope;
+
+		/*
+		 * Ensure that the previous scope is either an
+		 * if or and else if.
+		 */
+		scope_context = SLIST_FIRST(&scope_stack);
+		last_scope = TAILQ_LAST(&scope_context->inner_scope,
+					scope_tailq);
+		if (last_scope == NULL
+		 || last_scope->type == SCOPE_ELSE) {
+
+			stop("'else' without leading 'if'", EX_DATAERR);
+			/* NOTREACHED */
+		}
+		new_scope = scope_alloc();
+		new_scope->type = SCOPE_ELSE;
+		new_scope->begin_addr = instruction_ptr;
+	}
+break;
+case 153:
+#line 1127 "aicasm_gram.y"
+{
+		scope_t *scope_context;
+
+		scope_context = SLIST_FIRST(&scope_stack);
+		if (scope_context->type == SCOPE_ROOT) {
+			stop("Unexpected '}' encountered", EX_DATAERR);
+			/* NOTREACHED */
+		}
+
+		scope_context->end_addr = instruction_ptr;
+
+		/* Pop the scope */
+		SLIST_REMOVE_HEAD(&scope_stack, scope_stack_links);
+
+		process_scope(scope_context);
+
+		if (SLIST_FIRST(&scope_stack) == NULL) {
+			stop("Unexpected '}' encountered", EX_DATAERR);
+			/* NOTREACHED */
+		}
+	}
+break;
+case 154:
+#line 1151 "aicasm_gram.y"
+{ yyval.value = AIC_OP_AND; }
+break;
+case 155:
+#line 1152 "aicasm_gram.y"
+{ yyval.value = AIC_OP_XOR; }
+break;
+case 156:
+#line 1153 "aicasm_gram.y"
+{ yyval.value = AIC_OP_ADD; }
+break;
+case 157:
+#line 1154 "aicasm_gram.y"
+{ yyval.value = AIC_OP_ADC; }
+break;
+case 158:
+#line 1159 "aicasm_gram.y"
+{
+		format_1_instr(yyvsp[-6].value, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 159:
+#line 1166 "aicasm_gram.y"
+{
+		format_1_instr(AIC_OP_OR, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 160:
+#line 1173 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 1);
+		format_1_instr(AIC_OP_ADD, &yyvsp[-3].sym_ref, &immed, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 161:
+#line 1183 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, -1);
+		format_1_instr(AIC_OP_ADD, &yyvsp[-3].sym_ref, &immed, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 162:
+#line 1193 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, -1);
+		format_1_instr(AIC_OP_ADD, &none, &immed, &allzeros, yyvsp[-1].value);
+	}
+break;
+case 163:
+#line 1200 "aicasm_gram.y"
+{
+		format_1_instr(AIC_OP_ADD, &yyvsp[-4].sym_ref, &yyvsp[-2].expression, &allzeros, yyvsp[-1].value);
+	}
+break;
+case 164:
+#line 1207 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 1);
+		format_1_instr(AIC_OP_ADD, &none, &immed, &allones, yyvsp[-1].value);
+	}
+break;
+case 165:
+#line 1214 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 1);
+		format_1_instr(AIC_OP_ADD, &yyvsp[-2].sym_ref, &immed, &allones, yyvsp[-1].value);
+	}
+break;
+case 166:
+#line 1224 "aicasm_gram.y"
+{
+		format_1_instr(AIC_OP_BMOV, &yyvsp[-6].sym_ref, &yyvsp[-2].expression, &yyvsp[-4].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 167:
+#line 1231 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 1);
+		format_1_instr(AIC_OP_BMOV, &yyvsp[-4].sym_ref, &immed, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 168:
+#line 1241 "aicasm_gram.y"
+{
+		format_1_instr(AIC_OP_OR, &yyvsp[-4].sym_ref, &yyvsp[-2].expression, &allzeros, yyvsp[-1].value);
+	}
+break;
+case 169:
+#line 1248 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0xff);
+		format_1_instr(AIC_OP_XOR, &yyvsp[-3].sym_ref, &immed, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 170:
+#line 1258 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0xff);
+		format_1_instr(AIC_OP_AND, &yyvsp[-2].sym_ref, &immed, &allzeros, yyvsp[-1].value);
+	}
+break;
+case 171:
+#line 1268 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0xff);
+		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, yyvsp[-1].value);
+	}
+break;
+case 172:
+#line 1278 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0xff);
+		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, TRUE);
+	}
+break;
+case 173:
+#line 1296 "aicasm_gram.y"
+{ yyval.value = AIC_OP_SHL; }
+break;
+case 174:
+#line 1297 "aicasm_gram.y"
+{ yyval.value = AIC_OP_SHR; }
+break;
+case 175:
+#line 1298 "aicasm_gram.y"
+{ yyval.value = AIC_OP_ROL; }
+break;
+case 176:
+#line 1299 "aicasm_gram.y"
+{ yyval.value = AIC_OP_ROR; }
+break;
+case 177:
+#line 1304 "aicasm_gram.y"
+{
+		format_2_instr(yyvsp[-6].value, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-2].sym_ref, yyvsp[-1].value);
+	}
+break;
+case 178:
+#line 1310 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JMP; }
+break;
+case 179:
+#line 1311 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JC; }
+break;
+case 180:
+#line 1312 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JNC; }
+break;
+case 181:
+#line 1313 "aicasm_gram.y"
+{ yyval.value = AIC_OP_CALL; }
+break;
+case 182:
+#line 1317 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JZ; }
+break;
+case 183:
+#line 1318 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JNZ; }
+break;
+case 184:
+#line 1322 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JE; }
+break;
+case 185:
+#line 1323 "aicasm_gram.y"
+{ yyval.value = AIC_OP_JNE; }
+break;
+case 186:
+#line 1328 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0);
+		format_3_instr(yyvsp[-2].value, &sindex, &immed, &yyvsp[-1].sym_ref);
+	}
+break;
+case 187:
+#line 1338 "aicasm_gram.y"
+{
+		format_3_instr(yyvsp[-2].value, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-1].sym_ref);
+	}
+break;
+case 188:
+#line 1345 "aicasm_gram.y"
+{
+		format_3_instr(yyvsp[-2].value, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-1].sym_ref);
+	}
+break;
+case 189:
+#line 1352 "aicasm_gram.y"
+{
+		format_3_instr(yyvsp[-2].value, &yyvsp[-5].sym_ref, &yyvsp[-3].expression, &yyvsp[-1].sym_ref);
+	}
+break;
+case 190:
+#line 1359 "aicasm_gram.y"
+{
+		expression_t immed;
+
+		make_expression(&immed, 0);
+		format_3_instr(yyvsp[-2].value, &yyvsp[-3].sym_ref, &immed, &yyvsp[-1].sym_ref);
+	}
+break;
+case 191:
+#line 1369 "aicasm_gram.y"
+{
+		format_3_instr(yyvsp[-2].value, &allzeros, &yyvsp[-3].expression, &yyvsp[-1].sym_ref);
+	}
+break;
+#line 2717 "aicasm_gram.tab.c"
+    }
+    yyssp -= yym;
+    yystate = *yyssp;
+    yyvsp -= yym;
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: after reduction, shifting from state 0 to\
+ state %d\n", YYPREFIX, YYFINAL);
+#endif
+        yystate = YYFINAL;
+        *++yyssp = YYFINAL;
+        *++yyvsp = yyval;
+        if (yychar < 0)
+        {
+            if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+            if (yydebug)
+            {
+                yys = 0;
+                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+                if (!yys) yys = "illegal-symbol";
+                printf("%sdebug: state %d, reading %d (%s)\n",
+                        YYPREFIX, YYFINAL, yychar, yys);
+            }
+#endif
+        }
+        if (yychar == 0) goto yyaccept;
+        goto yyloop;
+    }
+    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
+        yystate = yytable[yyn];
+    else
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: after reduction, shifting from state %d \
+to state %d\n", YYPREFIX, *yyssp, yystate);
+#endif
+    if (yyssp >= yysslim && yygrowstack())
+    {
+        goto yyoverflow;
+    }
+    *++yyssp = yystate;
+    *++yyvsp = yyval;
+    goto yyloop;
+yyoverflow:
+    yyerror("yacc stack overflow");
+yyabort:
+    return (1);
+yyaccept:
+    return (0);
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.h	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,89 @@
+#ifndef YYERRCODE
+#define YYERRCODE 256
+#endif
+
+#define T_REGISTER 257
+#define T_CONST 258
+#define T_EXPORT 259
+#define T_DOWNLOAD 260
+#define T_SCB 261
+#define T_SRAM 262
+#define T_ALIAS 263
+#define T_SIZE 264
+#define T_EXPR_LSHIFT 265
+#define T_EXPR_RSHIFT 266
+#define T_ADDRESS 267
+#define T_ACCESS_MODE 268
+#define T_MODES 269
+#define T_DEFINE 270
+#define T_SET_SRC_MODE 271
+#define T_SET_DST_MODE 272
+#define T_MODE 273
+#define T_BEGIN_CS 274
+#define T_END_CS 275
+#define T_FIELD 276
+#define T_ENUM 277
+#define T_MASK 278
+#define T_NUMBER 279
+#define T_PATH 280
+#define T_STRING 281
+#define T_ARG 282
+#define T_MACROBODY 283
+#define T_CEXPR 284
+#define T_EOF 285
+#define T_INCLUDE 286
+#define T_VERSION 287
+#define T_PREFIX 288
+#define T_PATCH_ARG_LIST 289
+#define T_SHR 290
+#define T_SHL 291
+#define T_ROR 292
+#define T_ROL 293
+#define T_MVI 294
+#define T_MOV 295
+#define T_CLR 296
+#define T_BMOV 297
+#define T_JMP 298
+#define T_JC 299
+#define T_JNC 300
+#define T_JE 301
+#define T_JNE 302
+#define T_JNZ 303
+#define T_JZ 304
+#define T_CALL 305
+#define T_ADD 306
+#define T_ADC 307
+#define T_INC 308
+#define T_DEC 309
+#define T_STC 310
+#define T_CLC 311
+#define T_CMP 312
+#define T_NOT 313
+#define T_XOR 314
+#define T_TEST 315
+#define T_AND 316
+#define T_OR 317
+#define T_RET 318
+#define T_NOP 319
+#define T_ACCUM 320
+#define T_ALLONES 321
+#define T_ALLZEROS 322
+#define T_NONE 323
+#define T_SINDEX 324
+#define T_MODE_PTR 325
+#define T_A 326
+#define T_SYMBOL 327
+#define T_NL 328
+#define T_IF 329
+#define T_ELSE 330
+#define T_ELSE_IF 331
+#define T_ENDIF 332
+#define UMINUS 333
+typedef union {
+	u_int		value;
+	char		*str;
+	symbol_t	*sym;
+	symbol_ref_t	sym_ref;
+	expression_t	expression;
+} YYSTYPE;
+extern YYSTYPE yylval;
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y	2002-09-16 14:45:12.000000000 -0600
@@ -3,7 +3,7 @@
  * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.
  *
  * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,11 +38,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#14 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#24 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.12 2000/10/31 18:44:32 gibbs Exp $
+ * $FreeBSD$
  */
 
+#include <inttypes.h>
 #include <sys/types.h>
 
 #include <inttypes.h>
@@ -64,11 +65,14 @@
 
 int yylineno;
 char *yyfilename;
+char stock_prefix[] = "aic_";
+char *prefix = stock_prefix;
 char *patch_arg_list;
 char *versions;
 static char errbuf[255];
 static char regex_pattern[255];
 static symbol_t *cur_symbol;
+static symbol_t *field_symbol;
 static symbol_t *scb_or_sram_symbol;
 static symtype cur_symtype;
 static symbol_ref_t accumulator;
@@ -82,8 +86,10 @@
 static int sram_or_scb_offset;
 static int download_constant_count;
 static int in_critical_section;
+static u_int enum_increment;
+static u_int enum_next_value;
 
-static void process_bitmask(int mask_type, symbol_t *sym, int mask);
+static void process_field(int field_type, symbol_t *sym, int mask);
 static void initialize_symbol(symbol_t *symbol);
 static void add_macro_arg(const char *argtext, int position);
 static void add_macro_body(const char *bodytext);
@@ -152,7 +158,9 @@
 
 %token T_END_CS
 
-%token T_BIT
+%token T_FIELD
+
+%token T_ENUM
 
 %token T_MASK
 
@@ -162,7 +170,7 @@
 
 %token <sym> T_CEXPR
 
-%token T_EOF T_INCLUDE T_VERSION T_PATCH_ARG_LIST
+%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST
 
 %token <value> T_SHR T_SHL T_ROR T_ROL
 
@@ -216,6 +224,8 @@
 program:
 	include
 |	program include
+|	prefix
+|	program prefix
 |	patch_arg_list
 |	program patch_arg_list
 |	version
@@ -257,6 +267,18 @@
 	}
 ;
 
+prefix:
+	T_PREFIX '=' T_STRING
+	{
+		if (prefix != stock_prefix)
+			stop("Prefix multiply defined",
+			     EX_DATAERR);
+		prefix = strdup($3);
+		if (prefix == NULL)
+			stop("Unable to record prefix", EX_SOFTWARE);
+	}
+;
+
 patch_arg_list:
 	T_PATCH_ARG_LIST '=' T_STRING
 	{
@@ -326,7 +348,8 @@
 |	size
 |	access_mode
 |	modes
-|	bit_defn
+|	field_defn
+|	enum_defn
 |	mask_defn
 |	alias
 |	accumulator
@@ -418,17 +441,68 @@
 	}
 ;
 
-bit_defn:
-	T_BIT T_SYMBOL T_NUMBER
+field_defn:
+	T_FIELD
+		{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+	'{' enum_entry_list '}'
+|	T_FIELD T_SYMBOL expression
+		{
+			process_field(FIELD, $2, $3.value);
+			field_symbol = $2;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs($3.value) - 1);
+		}
+	'{' enum_entry_list '}'
+|	T_FIELD T_SYMBOL expression
 	{
-		process_bitmask(BIT, $2, $3);
+		process_field(FIELD, $2, $3.value);
+	}
+;
+
+enum_defn:
+	T_ENUM
+		{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+	'{' enum_entry_list '}'
+|	T_ENUM T_SYMBOL expression
+		{
+			process_field(ENUM, $2, $3.value);
+			field_symbol = $2;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs($3.value) - 1);
+		}
+	'{' enum_entry_list '}'
+;
+
+enum_entry_list:
+	enum_entry
+|	enum_entry_list ',' enum_entry
+;
+
+enum_entry:
+	T_SYMBOL
+	{
+		process_field(ENUM_ENTRY, $1, enum_next_value);
+		enum_next_value += enum_increment;
+	}
+|	T_SYMBOL expression
+	{
+		process_field(ENUM_ENTRY, $1, $2.value);
+		enum_next_value = $2.value + enum_increment;
 	}
 ;
 
 mask_defn:
 	T_MASK T_SYMBOL expression
 	{
-		process_bitmask(MASK, $2, $3.value);
+		process_field(MASK, $2, $3.value);
 	}
 ;
 
@@ -608,8 +682,10 @@
 			$$.value = symbol->info.rinfo->address;
 			break;
 		case MASK:
-		case BIT:
-			$$.value = symbol->info.minfo->mask;
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			$$.value = symbol->info.finfo->value;
 			break;
 		case DOWNLOAD_CONST:
 		case CONST:
@@ -862,6 +938,8 @@
 |	T_A
 	{
 		SLIST_INIT(&$$.referenced_syms);
+		symlist_add(&$$.referenced_syms, accumulator.symbol,
+			    SYMLIST_INSERT_HEAD);
 		$$.value = 0;
 	}
 ;
@@ -1161,9 +1239,22 @@
 ;
 
 code:
-	T_MVI destination ',' immediate_or_a ret ';'
+	T_MVI destination ',' immediate ret ';'
 	{
-		format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
+		if ($4.value == 0
+		 && is_download_const(&$4) == 0) {
+			expression_t immed;
+
+			/*
+			 * Allow move immediates of 0 so that macros,
+			 * that can't know the immediate's value and
+			 * otherwise compensate, still work.
+			 */
+			make_expression(&immed, 0xff);
+			format_1_instr(AIC_OP_AND, &$2, &immed, &allzeros, $5);
+		} else {
+			format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
+		}
 	}
 ;
 
@@ -1298,7 +1389,7 @@
 %%
 
 static void
-process_bitmask(int mask_type, symbol_t *sym, int mask)
+process_field(int field_type, symbol_t *sym, int value)
 {
 	/*
 	 * Add the current register to its
@@ -1308,52 +1399,54 @@
 	 * the "allowed bits" of this register.
 	 */
 	if (sym->type == UNINITIALIZED) {
-		sym->type = mask_type;
+		sym->type = field_type;
 		initialize_symbol(sym);
-		if (mask_type == BIT) {
-			if (mask == 0) {
-				stop("Bitmask with no bits set", EX_DATAERR);
-				/* NOTREACHED */
-			}
-			if ((mask & ~(0x01 << (ffs(mask) - 1))) != 0) {
-				stop("Bitmask with more than one bit set",
-				     EX_DATAERR);
+		sym->info.finfo->value = value;
+		if (field_type != ENUM_ENTRY) {
+			if (field_type != MASK && value == 0) {
+				stop("Empty Field, or Enum", EX_DATAERR);
 				/* NOTREACHED */
 			}
+			sym->info.finfo->value = value;
+			sym->info.finfo->mask = value;
+		} else if (field_symbol != NULL) {
+			sym->info.finfo->mask = field_symbol->info.finfo->value;
+		} else {
+			sym->info.finfo->mask = 0xFF;
 		}
-		sym->info.minfo->mask = mask;
-	} else if (sym->type != mask_type) {
-		stop("Bit definition mirrors a definition of the same "
+	} else if (sym->type != field_type) {
+		stop("Field definition mirrors a definition of the same "
 		     " name, but a different type", EX_DATAERR);
 		/* NOTREACHED */
-	} else if (mask != sym->info.minfo->mask) {
-		stop("Bitmask redefined with a conflicting value", EX_DATAERR);
+	} else if (value != sym->info.finfo->value) {
+		stop("Field redefined with a conflicting value", EX_DATAERR);
 		/* NOTREACHED */
 	}
 	/* Fail if this symbol is already listed */
-	if (symlist_search(&(sym->info.minfo->symrefs),
+	if (symlist_search(&(sym->info.finfo->symrefs),
 			   cur_symbol->name) != NULL) {
-		stop("Bitmask defined multiple times for register", EX_DATAERR);
+		stop("Field defined multiple times for register", EX_DATAERR);
 		/* NOTREACHED */
 	}
-	symlist_add(&(sym->info.minfo->symrefs), cur_symbol,
+	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
 		    SYMLIST_INSERT_HEAD);
-	cur_symbol->info.rinfo->valid_bitmask |= mask;
+	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
 	cur_symbol->info.rinfo->typecheck_masks = TRUE;
+	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
 }
 
 static void
 initialize_symbol(symbol_t *symbol)
 {
 	switch (symbol->type) {
-        case UNINITIALIZED:
+	case UNINITIALIZED:
 		stop("Call to initialize_symbol with type field unset",
 		     EX_SOFTWARE);
 		/* NOTREACHED */
 		break;
-        case REGISTER:
-        case SRAMLOC:
-        case SCBLOC:
+	case REGISTER:
+	case SRAMLOC:
+	case SCBLOC:
 		symbol->info.rinfo =
 		    (struct reg_info *)malloc(sizeof(struct reg_info));
 		if (symbol->info.rinfo == NULL) {
@@ -1362,6 +1455,7 @@
 		}
 		memset(symbol->info.rinfo, 0,
 		       sizeof(struct reg_info));
+		SLIST_INIT(&(symbol->info.rinfo->fields));
 		/*
 		 * Default to allowing access in all register modes
 		 * or to the mode specified by the SCB or SRAM space
@@ -1373,7 +1467,7 @@
 		else
 			symbol->info.rinfo->modes = ~0;
 		break;
-        case ALIAS:
+	case ALIAS:
 		symbol->info.ainfo =
 		    (struct alias_info *)malloc(sizeof(struct alias_info));
 		if (symbol->info.ainfo == NULL) {
@@ -1383,19 +1477,21 @@
 		memset(symbol->info.ainfo, 0,
 		       sizeof(struct alias_info));
 		break;
-        case MASK:
-        case BIT:
-		symbol->info.minfo =
-		    (struct mask_info *)malloc(sizeof(struct mask_info));
-		if (symbol->info.minfo == NULL) {
-			stop("Can't create bitmask info", EX_SOFTWARE);
+	case MASK:
+	case FIELD:
+	case ENUM:
+	case ENUM_ENTRY:
+		symbol->info.finfo =
+		    (struct field_info *)malloc(sizeof(struct field_info));
+		if (symbol->info.finfo == NULL) {
+			stop("Can't create field info", EX_SOFTWARE);
 			/* NOTREACHED */
 		}
-		memset(symbol->info.minfo, 0, sizeof(struct mask_info));
-		SLIST_INIT(&(symbol->info.minfo->symrefs));
+		memset(symbol->info.finfo, 0, sizeof(struct field_info));
+		SLIST_INIT(&(symbol->info.finfo->symrefs));
 		break;
-        case CONST:
-        case DOWNLOAD_CONST:
+	case CONST:
+	case DOWNLOAD_CONST:
 		symbol->info.cinfo =
 		    (struct const_info *)malloc(sizeof(struct const_info));
 		if (symbol->info.cinfo == NULL) {
@@ -1577,7 +1673,6 @@
 		case AIC_OP_OR:
 			dst_value = src_value | immed->value;
 			break;
-			break;
 		case AIC_OP_BMOV:
 			dst_value = src_value;
 			break;
@@ -1586,9 +1681,9 @@
 		}
 		src_mode = dst_value & 0xF;
 		dst_mode = (dst_value >> 4) & 0xF;
-cant_update:
 	}
 
+cant_update:
 	symlist_free(&immed->referenced_syms);
 	instruction_ptr++;
 }
@@ -1763,11 +1858,13 @@
 		    node != NULL;
 		    node = node->links.sle_next) {
 			if ((node->symbol->type == MASK
-			  || node->symbol->type == BIT)
-			 && symlist_search(&node->symbol->info.minfo->symrefs,
+			  || node->symbol->type == FIELD
+			  || node->symbol->type == ENUM
+			  || node->symbol->type == ENUM_ENTRY)
+			 && symlist_search(&node->symbol->info.finfo->symrefs,
 					   symbol->name) == NULL) {
 				snprintf(errbuf, sizeof(errbuf),
-					 "Invalid bit or mask %s "
+					 "Invalid field or mask %s "
 					 "for register %s",
 					 node->symbol->name, symbol->name);
 				stop(errbuf, EX_DATAERR);
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm.h	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm.h	2002-09-11 15:08:12.000000000 -0600
@@ -2,7 +2,7 @@
  * Assembler for the sequencer program downloaded to Aic7xxx SCSI host adapters
  *
  * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#9 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#14 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.h,v 1.11 2000/09/22 22:19:54 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -76,8 +76,10 @@
 extern struct symlist patch_functions;
 extern int includes_search_curdir;		/* False if we've seen -I- */
 extern char *appname;
+extern char *stock_include_file;
 extern int yylineno;
 extern char *yyfilename;
+extern char *prefix;
 extern char *patch_arg_list;
 extern char *versions;
 extern int   src_mode;
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h	2002-09-11 15:08:12.000000000 -0600
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#8 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#10 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_insformat.h,v 1.3 2000/09/22 22:19:54 gibbs Exp $
+ * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_insformat.h,v 1.3.2.3 2002/04/29 19:36:36 gibbs Exp $
  */
 
 struct ins_format1 {
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.c	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,534 @@
+#ifndef lint
+static char const 
+yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
+#endif
+#include <stdlib.h>
+#define YYBYACC 1
+#define YYMAJOR 1
+#define YYMINOR 9
+#define YYLEX yylex()
+#define YYEMPTY -1
+#define yyclearin (yychar=(YYEMPTY))
+#define yyerrok (yyerrflag=0)
+#define YYRECOVERING() (yyerrflag!=0)
+static int yygrowstack();
+#define yyparse mmparse
+#define yylex mmlex
+#define yyerror mmerror
+#define yychar mmchar
+#define yyval mmval
+#define yylval mmlval
+#define yydebug mmdebug
+#define yynerrs mmnerrs
+#define yyerrflag mmerrflag
+#define yyss mmss
+#define yyssp mmssp
+#define yyvs mmvs
+#define yyvsp mmvsp
+#define yylhs mmlhs
+#define yylen mmlen
+#define yydefred mmdefred
+#define yydgoto mmdgoto
+#define yysindex mmsindex
+#define yyrindex mmrindex
+#define yygindex mmgindex
+#define yytable mmtable
+#define yycheck mmcheck
+#define yyname mmname
+#define yyrule mmrule
+#define yysslim mmsslim
+#define yystacksize mmstacksize
+#define YYPREFIX "mm"
+#line 2 "aicasm_macro_gram.y"
+/*
+ * Sub-parser for macro invocation in the Aic7xxx SCSI
+ * Host adapter sequencer assembler.
+ *
+ * Copyright (c) 2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#5 $
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/types.h>
+
+#include <inttypes.h>
+#include <regex.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysexits.h>
+
+#ifdef __linux__
+#include "../queue.h"
+#else
+#include <sys/queue.h>
+#endif
+
+#include "aicasm.h"
+#include "aicasm_symbol.h"
+#include "aicasm_insformat.h"
+
+static symbol_t *macro_symbol;
+
+static void add_macro_arg(const char *argtext, int position);
+
+#line 71 "aicasm_macro_gram.y"
+typedef union {
+	int		value;
+	char		*str;
+	symbol_t	*sym;
+} YYSTYPE;
+#line 117 "aicasm_macro_gram.tab.c"
+#define YYERRCODE 256
+#define T_ARG 257
+#define T_SYMBOL 258
+const short mmlhs[] = {                                        -1,
+    2,    0,    1,    1,    1,
+};
+const short mmlen[] = {                                         2,
+    0,    5,    0,    1,    3,
+};
+const short mmdefred[] = {                                      0,
+    0,    0,    1,    0,    4,    0,    2,    0,    5,
+};
+const short mmdgoto[] = {                                       2,
+    6,    4,
+};
+const short mmsindex[] = {                                   -256,
+  -35,    0,    0, -251,    0,  -41,    0, -250,    0,
+};
+const short mmrindex[] = {                                      0,
+    0,    0,    0,  -40,    0,    0,    0,    0,    0,
+};
+const short mmgindex[] = {                                      0,
+    0,    0,
+};
+#define YYTABLESIZE 7
+const short mmtable[] = {                                       7,
+    3,    1,    8,    3,    3,    5,    9,
+};
+const short mmcheck[] = {                                      41,
+   41,  258,   44,   44,   40,  257,  257,
+};
+#define YYFINAL 2
+#ifndef YYDEBUG
+#define YYDEBUG 0
+#endif
+#define YYMAXTOKEN 258
+#if YYDEBUG
+const char * const mmname[] = {
+"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,"'('","')'",0,0,"','",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"T_ARG","T_SYMBOL",
+};
+const char * const mmrule[] = {
+"$accept : macrocall",
+"$$1 :",
+"macrocall : T_SYMBOL '(' $$1 macro_arglist ')'",
+"macro_arglist :",
+"macro_arglist : T_ARG",
+"macro_arglist : macro_arglist ',' T_ARG",
+};
+#endif
+#if YYDEBUG
+#include <stdio.h>
+#endif
+#ifdef YYSTACKSIZE
+#undef YYMAXDEPTH
+#define YYMAXDEPTH YYSTACKSIZE
+#else
+#ifdef YYMAXDEPTH
+#define YYSTACKSIZE YYMAXDEPTH
+#else
+#define YYSTACKSIZE 10000
+#define YYMAXDEPTH 10000
+#endif
+#endif
+#define YYINITSTACKSIZE 200
+int yydebug;
+int yynerrs;
+int yyerrflag;
+int yychar;
+short *yyssp;
+YYSTYPE *yyvsp;
+YYSTYPE yyval;
+YYSTYPE yylval;
+short *yyss;
+short *yysslim;
+YYSTYPE *yyvs;
+int yystacksize;
+#line 127 "aicasm_macro_gram.y"
+
+static void
+add_macro_arg(const char *argtext, int argnum)
+{
+	struct macro_arg *marg;
+	int i;
+
+	if (macro_symbol == NULL || macro_symbol->type != MACRO) {
+		stop("Invalid current symbol for adding macro arg",
+		     EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+	/*
+	 * Macro Invocation.  Find the appropriate argument and fill
+	 * in the replace ment text for this call.
+	 */
+	i = 0;
+	STAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
+		i++;
+		if (i == argnum)
+			break;
+	}
+	if (marg == NULL) {
+		stop("Too many arguments for macro invocation", EX_DATAERR);
+		/* NOTREACHED */
+	}
+	marg->replacement_text = strdup(argtext);
+	if (marg->replacement_text == NULL) {
+		stop("Unable to replicate replacement text", EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+}
+
+void
+mmerror(const char *string)
+{
+	stop(string, EX_DATAERR);
+}
+#line 239 "aicasm_macro_gram.tab.c"
+/* allocate initial stack or double stack size, up to YYMAXDEPTH */
+static int yygrowstack()
+{
+    int newsize, i;
+    short *newss;
+    YYSTYPE *newvs;
+
+    if ((newsize = yystacksize) == 0)
+        newsize = YYINITSTACKSIZE;
+    else if (newsize >= YYMAXDEPTH)
+        return -1;
+    else if ((newsize *= 2) > YYMAXDEPTH)
+        newsize = YYMAXDEPTH;
+    i = yyssp - yyss;
+    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
+      (short *)malloc(newsize * sizeof *newss);
+    if (newss == NULL)
+        return -1;
+    yyss = newss;
+    yyssp = newss + i;
+    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
+      (YYSTYPE *)malloc(newsize * sizeof *newvs);
+    if (newvs == NULL)
+        return -1;
+    yyvs = newvs;
+    yyvsp = newvs + i;
+    yystacksize = newsize;
+    yysslim = yyss + newsize - 1;
+    return 0;
+}
+
+#define YYABORT goto yyabort
+#define YYREJECT goto yyabort
+#define YYACCEPT goto yyaccept
+#define YYERROR goto yyerrlab
+
+#ifndef YYPARSE_PARAM
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG void
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif	/* ANSI-C/C++ */
+#else	/* YYPARSE_PARAM */
+#ifndef YYPARSE_PARAM_TYPE
+#define YYPARSE_PARAM_TYPE void *
+#endif
+#if defined(__cplusplus) || __STDC__
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else	/* ! ANSI-C/C++ */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
+#endif	/* ANSI-C/C++ */
+#endif	/* ! YYPARSE_PARAM */
+
+int
+yyparse (YYPARSE_PARAM_ARG)
+    YYPARSE_PARAM_DECL
+{
+    register int yym, yyn, yystate;
+#if YYDEBUG
+    register const char *yys;
+
+    if ((yys = getenv("YYDEBUG")))
+    {
+        yyn = *yys;
+        if (yyn >= '0' && yyn <= '9')
+            yydebug = yyn - '0';
+    }
+#endif
+
+    yynerrs = 0;
+    yyerrflag = 0;
+    yychar = (-1);
+
+    if (yyss == NULL && yygrowstack()) goto yyoverflow;
+    yyssp = yyss;
+    yyvsp = yyvs;
+    *yyssp = yystate = 0;
+
+yyloop:
+    if ((yyn = yydefred[yystate])) goto yyreduce;
+    if (yychar < 0)
+    {
+        if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, reading %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+    }
+    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: state %d, shifting to state %d\n",
+                    YYPREFIX, yystate, yytable[yyn]);
+#endif
+        if (yyssp >= yysslim && yygrowstack())
+        {
+            goto yyoverflow;
+        }
+        *++yyssp = yystate = yytable[yyn];
+        *++yyvsp = yylval;
+        yychar = (-1);
+        if (yyerrflag > 0)  --yyerrflag;
+        goto yyloop;
+    }
+    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
+    {
+        yyn = yytable[yyn];
+        goto yyreduce;
+    }
+    if (yyerrflag) goto yyinrecovery;
+#if defined(lint) || defined(__GNUC__)
+    goto yynewerror;
+#endif
+yynewerror:
+    yyerror("syntax error");
+#if defined(lint) || defined(__GNUC__)
+    goto yyerrlab;
+#endif
+yyerrlab:
+    ++yynerrs;
+yyinrecovery:
+    if (yyerrflag < 3)
+    {
+        yyerrflag = 3;
+        for (;;)
+        {
+            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
+                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: state %d, error recovery shifting\
+ to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
+#endif
+                if (yyssp >= yysslim && yygrowstack())
+                {
+                    goto yyoverflow;
+                }
+                *++yyssp = yystate = yytable[yyn];
+                *++yyvsp = yylval;
+                goto yyloop;
+            }
+            else
+            {
+#if YYDEBUG
+                if (yydebug)
+                    printf("%sdebug: error recovery discarding state %d\n",
+                            YYPREFIX, *yyssp);
+#endif
+                if (yyssp <= yyss) goto yyabort;
+                --yyssp;
+                --yyvsp;
+            }
+        }
+    }
+    else
+    {
+        if (yychar == 0) goto yyabort;
+#if YYDEBUG
+        if (yydebug)
+        {
+            yys = 0;
+            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+            if (!yys) yys = "illegal-symbol";
+            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
+                    YYPREFIX, yystate, yychar, yys);
+        }
+#endif
+        yychar = (-1);
+        goto yyloop;
+    }
+yyreduce:
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
+                YYPREFIX, yystate, yyn, yyrule[yyn]);
+#endif
+    yym = yylen[yyn];
+    yyval = yyvsp[1-yym];
+    switch (yyn)
+    {
+case 1:
+#line 88 "aicasm_macro_gram.y"
+{
+		macro_symbol = yyvsp[-1].sym;
+	}
+break;
+case 2:
+#line 92 "aicasm_macro_gram.y"
+{
+		if (macro_symbol->info.macroinfo->narg != yyvsp[-1].value) {
+			printf("Narg == %d", macro_symbol->info.macroinfo->narg);
+			stop("Too few arguments for macro invocation",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		macro_symbol = NULL;
+		YYACCEPT;
+	}
+break;
+case 3:
+#line 105 "aicasm_macro_gram.y"
+{
+		/* Macros can take 0 arguments */
+		yyval.value = 0;
+	}
+break;
+case 4:
+#line 110 "aicasm_macro_gram.y"
+{
+		yyval.value = 1;
+		add_macro_arg(yyvsp[0].str, 1);
+	}
+break;
+case 5:
+#line 115 "aicasm_macro_gram.y"
+{
+		if (yyvsp[-2].value == 0) {
+			stop("Comma without preceeding argument in arg list",
+			     EX_DATAERR);
+			/* NOTREACHED */
+		}
+		yyval.value = yyvsp[-2].value + 1;
+		add_macro_arg(yyvsp[0].str, yyval.value);
+	}
+break;
+#line 479 "aicasm_macro_gram.tab.c"
+    }
+    yyssp -= yym;
+    yystate = *yyssp;
+    yyvsp -= yym;
+    yym = yylhs[yyn];
+    if (yystate == 0 && yym == 0)
+    {
+#if YYDEBUG
+        if (yydebug)
+            printf("%sdebug: after reduction, shifting from state 0 to\
+ state %d\n", YYPREFIX, YYFINAL);
+#endif
+        yystate = YYFINAL;
+        *++yyssp = YYFINAL;
+        *++yyvsp = yyval;
+        if (yychar < 0)
+        {
+            if ((yychar = yylex()) < 0) yychar = 0;
+#if YYDEBUG
+            if (yydebug)
+            {
+                yys = 0;
+                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
+                if (!yys) yys = "illegal-symbol";
+                printf("%sdebug: state %d, reading %d (%s)\n",
+                        YYPREFIX, YYFINAL, yychar, yys);
+            }
+#endif
+        }
+        if (yychar == 0) goto yyaccept;
+        goto yyloop;
+    }
+    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
+            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
+        yystate = yytable[yyn];
+    else
+        yystate = yydgoto[yym];
+#if YYDEBUG
+    if (yydebug)
+        printf("%sdebug: after reduction, shifting from state %d \
+to state %d\n", YYPREFIX, *yyssp, yystate);
+#endif
+    if (yyssp >= yysslim && yygrowstack())
+    {
+        goto yyoverflow;
+    }
+    *++yyssp = yystate;
+    *++yyvsp = yyval;
+    goto yyloop;
+yyoverflow:
+    yyerror("yacc stack overflow");
+yyabort:
+    return (1);
+yyaccept:
+    return (0);
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.h	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,12 @@
+#ifndef YYERRCODE
+#define YYERRCODE 256
+#endif
+
+#define T_ARG 257
+#define T_SYMBOL 258
+typedef union {
+	int		value;
+	char		*str;
+	symbol_t	*sym;
+} YYSTYPE;
+extern YYSTYPE mmlval;
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y	2002-09-11 15:08:12.000000000 -0600
@@ -38,7 +38,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#5 $
  *
  * $FreeBSD$
  */
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.c	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,1697 @@
+#define yy_create_buffer mm_create_buffer
+#define yy_delete_buffer mm_delete_buffer
+#define yy_scan_buffer mm_scan_buffer
+#define yy_scan_string mm_scan_string
+#define yy_scan_bytes mm_scan_bytes
+#define yy_flex_debug mm_flex_debug
+#define yy_init_buffer mm_init_buffer
+#define yy_flush_buffer mm_flush_buffer
+#define yy_load_buffer_state mm_load_buffer_state
+#define yy_switch_to_buffer mm_switch_to_buffer
+#define yyin mmin
+#define yyleng mmleng
+#define yylex mmlex
+#define yyout mmout
+#define yyrestart mmrestart
+#define yytext mmtext
+#define yywrap mmwrap
+
+#line 20 "aicasm_macro_scan.c"
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <unistd.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 9
+#define YY_END_OF_BUFFER 10
+static yyconst short int yy_accept[19] =
+    {   0,
+        0,    0,    0,    0,   10,    8,    1,    8,    5,    2,
+        3,    4,    6,    7,    0,    5,    2,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    1,    1,    1,    1,    1,    4,
+        5,    1,    1,    6,    7,    1,    1,    7,    7,    7,
+        7,    7,    7,    7,    7,    7,    7,    1,    1,    1,
+        1,    1,    1,    1,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        1,    1,    1,    1,    8,    1,    8,    8,    8,    8,
+
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[9] =
+    {   0,
+        1,    2,    1,    3,    2,    2,    4,    4
+    } ;
+
+static yyconst short int yy_base[22] =
+    {   0,
+        0,    6,   14,    0,    7,   33,   33,    2,    0,    3,
+       33,   33,   33,   33,    0,    0,    0,   33,   22,   24,
+       28
+    } ;
+
+static yyconst short int yy_def[22] =
+    {   0,
+       19,   19,   18,    3,   18,   18,   18,   20,   21,   18,
+       18,   18,   18,   18,   20,   21,   18,    0,   18,   18,
+       18
+    } ;
+
+static yyconst short int yy_nxt[42] =
+    {   0,
+       18,   17,    7,   14,   17,   14,   18,    8,    7,   18,
+       18,   18,   18,    8,    9,   10,    9,   11,   12,   13,
+        9,    9,    6,    6,    6,    6,   15,   15,   16,   18,
+       18,   16,    5,   18,   18,   18,   18,   18,   18,   18,
+       18
+    } ;
+
+static yyconst short int yy_chk[42] =
+    {   0,
+        0,   17,    1,   15,   10,    8,    5,    1,    2,    0,
+        0,    0,    0,    2,    3,    3,    3,    3,    3,    3,
+        3,    3,   19,   19,   19,   19,   20,   20,   21,    0,
+        0,   21,   18,   18,   18,   18,   18,   18,   18,   18,
+       18
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "aicasm_macro_scan.l"
+#define INITIAL 0
+#line 2 "aicasm_macro_scan.l"
+/*
+ * Sub-Lexical Analyzer for macro invokation in 
+ * the Aic7xxx SCSI Host adapter sequencer assembler.
+ *
+ * Copyright (c) 2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#5 $
+ *
+ * $FreeBSD$
+ */
+
+#include <inttypes.h>
+#include <sys/types.h>
+
+#include <limits.h>
+#include <regex.h>
+#include <stdio.h>
+#include <string.h>
+#include <sysexits.h>
+#ifdef __linux__
+#include "../queue.h"
+#else
+#include <sys/queue.h>
+#endif
+
+#include "aicasm.h"
+#include "aicasm_symbol.h"
+#include "aicasm_macro_gram.h"
+
+#define MAX_STR_CONST 4096
+static char string_buf[MAX_STR_CONST];
+static char *string_buf_ptr;
+static int  parren_count;
+static char buf[255];
+#define ARGLIST 1
+
+#line 465 "aicasm_macro_scan.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp = NULL, *yy_bp = NULL;
+	register int yy_act;
+
+#line 77 "aicasm_macro_scan.l"
+
+#line 618 "aicasm_macro_scan.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 19 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 33 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 78 "aicasm_macro_scan.l"
+{
+				++yylineno;
+			}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 81 "aicasm_macro_scan.l"
+;
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 82 "aicasm_macro_scan.l"
+{
+				parren_count++;
+				if (parren_count == 1) {
+					string_buf_ptr = string_buf;
+					return ('(');
+				}
+				*string_buf_ptr++ = '(';
+			}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 90 "aicasm_macro_scan.l"
+{
+				if (parren_count == 1) {
+					if (string_buf_ptr != string_buf) {
+						/*
+						 * Return an argument and
+						 * rescan this parren so we
+						 * can return it as well.
+						 */
+						*string_buf_ptr = '\0';
+						mmlval.str = string_buf;
+						string_buf_ptr = string_buf;
+						unput(')');
+						return T_ARG;
+					}
+					BEGIN INITIAL;
+					return (')');
+				}
+				parren_count--;
+				*string_buf_ptr++ = ')';
+			}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 110 "aicasm_macro_scan.l"
+{
+				char *yptr;
+
+				yptr = mmtext;
+				while (*yptr)
+					*string_buf_ptr++ = *yptr++;
+			}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 117 "aicasm_macro_scan.l"
+{
+				if (string_buf_ptr != string_buf) {
+					/*
+					 * Return an argument and
+					 * rescan this comma so we
+					 * can return it as well.
+					 */
+					*string_buf_ptr = '\0';
+					mmlval.str = string_buf;
+					string_buf_ptr = string_buf;
+					unput(',');
+					return T_ARG;
+				}
+				return ',';
+			}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 132 "aicasm_macro_scan.l"
+{
+				/* May be a symbol or a macro invocation. */
+				mmlval.sym = symtable_get(mmtext);
+				if (mmlval.sym->type != MACRO) {
+					stop("Expecting Macro Name",
+					     EX_DATAERR);
+				}
+				unput('(');
+				parren_count = 0;
+				BEGIN ARGLIST;
+				return T_SYMBOL;
+			}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 144 "aicasm_macro_scan.l"
+{ 
+				snprintf(buf, sizeof(buf), "Invalid character "
+					 "'%c'", mmtext[0]);
+				stop(buf, EX_DATAERR);
+			}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 149 "aicasm_macro_scan.l"
+ECHO;
+	YY_BREAK
+#line 809 "aicasm_macro_scan.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(ARGLIST):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 19 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 19 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 18);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 149 "aicasm_macro_scan.l"
+
+
+int
+mmwrap()
+{
+	stop("EOF encountered in macro call", EX_DATAERR);
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l	2002-09-16 14:45:12.000000000 -0600
@@ -38,11 +38,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#6 $
  *
  * $FreeBSD$
  */
 
+#include <inttypes.h>
 #include <sys/types.h>
 
 #include <limits.h>
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_scan.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_scan.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_scan.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_scan.c	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1,2855 @@
+#line 2 "aicasm_scan.c"
+/* A lexical scanner generated by flex */
+
+/* Scanner skeleton version:
+ * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
+ */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+
+#include <stdio.h>
+#include <unistd.h>
+
+
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
+
+
+#ifdef __cplusplus
+
+#include <stdlib.h>
+
+/* Use prototypes in function declarations. */
+#define YY_USE_PROTOS
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_PROTOS
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#include <io.h>
+#include <stdlib.h>
+#define YY_USE_CONST
+#define YY_USE_PROTOS
+#endif
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+
+#ifdef YY_USE_PROTOS
+#define YY_PROTO(proto) proto
+#else
+#define YY_PROTO(proto) ()
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yy_start = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yy_start - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#define YY_BUF_SIZE 16384
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+
+extern int yyleng;
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ * 	if ( condition_holds )
+ *		yyless( 5 );
+ *	else
+ *		do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		*yy_cp = yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, yytext_ptr )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+typedef unsigned int yy_size_t;
+
+
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+	};
+
+static YY_BUFFER_STATE yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ */
+#define YY_CURRENT_BUFFER yy_current_buffer
+
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+
+
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 1;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart YY_PROTO(( FILE *input_file ));
+
+void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
+void yy_load_buffer_state YY_PROTO(( void ));
+YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
+void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
+void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
+#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
+
+YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
+YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
+YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
+
+static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
+static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
+static void yy_flex_free YY_PROTO(( void * ));
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! yy_current_buffer ) \
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
+	yy_current_buffer->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+typedef int yy_state_type;
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state YY_PROTO(( void ));
+static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
+static int yy_get_next_buffer YY_PROTO(( void ));
+static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yy_c_buf_p = yy_cp;
+
+#define YY_NUM_RULES 109
+#define YY_END_OF_BUFFER 110
+static yyconst short int yy_accept[360] =
+    {   0,
+        0,    0,    5,    5,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,  105,  105,  110,  108,
+       20,    1,   80,   17,  108,   80,   81,   83,   80,   80,
+       46,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,    5,    4,    6,    7,   13,   12,
+       10,   11,   89,  109,   87,   88,   89,   85,   86,   18,
+       19,  109,   97,   94,   95,   96,   93,  101,   98,   99,
+      100,  102,  105,  104,  109,   20,    0,    0,    2,   81,
+        0,   83,   78,   79,  106,  107,  107,  107,  107,  107,
+
+       28,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+       55,   57,  107,  107,   59,  107,  107,  107,  107,   74,
+      107,  107,  107,  107,  107,  107,  107,  107,    5,    6,
+        6,    8,    7,    3,    7,   13,   88,    0,   18,   91,
+       92,    0,   94,   93,  101,   98,  105,    0,  105,  103,
+        0,    0,   82,  107,  107,  107,  107,  107,  107,  107,
+       63,   62,  107,  107,   73,  107,  107,   68,   53,   69,
+      107,   66,  107,  107,  107,  107,  107,    0,    9,   65,
+       54,   56,   58,   60,  107,  107,   52,   51,  107,   76,
+
+       70,  107,   75,   50,   49,   38,  107,   47,   48,  107,
+      107,   67,  107,   71,    0,    0,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,   64,   61,
+      107,  107,   77,   34,  107,  107,    9,   35,  107,   44,
+      107,  107,  107,   37,   72,    0,    0,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,   36,  107,  107,
+       23,  107,  107,   33,  107,   27,  107,  107,  107,    0,
+        0,  107,  107,  107,   15,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,   21,  107,  107,  107,   45,    0,
+        0,  107,  107,  107,  107,  107,   14,  107,  107,   25,
+
+       42,  107,  107,  107,  107,  107,   90,    0,  107,  107,
+      107,  107,  107,  107,  107,   43,   24,  107,   22,  107,
+       84,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
+      107,  107,  107,  107,   26,   40,  107,   39,  107,   30,
+      107,   32,   31,   41,  107,  107,   29,   16,    0
+    } ;
+
+static yyconst int yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    4,    1,    7,
+        8,    9,    4,   10,   11,   12,   13,   14,   15,   15,
+       15,   15,   15,   15,   15,   16,   16,    4,    4,   17,
+        4,   18,    1,    1,   19,   20,   21,   22,   23,   24,
+       25,   26,   27,   28,   28,   29,   30,   31,   32,   33,
+       28,   34,   35,   36,   28,   37,   38,   39,   28,   28,
+        4,   40,    4,    1,   41,    1,   42,   43,   44,   45,
+
+       46,   47,   48,   49,   50,   51,   52,   53,   54,   55,
+       56,   57,   28,   58,   59,   60,   61,   62,   63,   64,
+       28,   65,    4,    4,    4,    4,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst int yy_meta[66] =
+    {   0,
+        1,    2,    3,    1,    4,    1,    5,    6,    7,    8,
+        9,   10,   11,   12,   12,   12,    1,    1,   12,   12,
+       12,   12,   12,   12,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    1,
+        9,   12,   12,   12,   12,   12,   12,    9,    9,    9,
+        9,    9,    9,    9,    9,    9,    9,    9,    9,    9,
+        9,    9,    9,    9,    9
+    } ;
+
+static yyconst short int yy_base[381] =
+    {   0,
+        0,    0,   63,   64,   67,   75,   83,  123,  923,  922,
+      163,  203,  243,  283,   95,  102,   66,   68,  926,  929,
+      923,  929,  929,  929,   49,  915,  120,   65,  906,  904,
+      914,   88,  913,   91,  295,  106,  114,  132,  110,  107,
+       61,  140,  100,  136,  111,  143,  261,  180,  141,  176,
+      146,  179,  112,  181,    0,  929,  107,  136,    0,  929,
+      929,  929,  929,  929,  929,  906,  905,  929,  929,    0,
+      929,  223,  929,  915,  929,  929,    0,    0,  914,  929,
+      929,  929,  875,  929,  911,  911,  866,  856,  929,  212,
+        0,  217,  929,  929,  929,  903,  255,  256,  188,  178,
+
+      902,  228,  231,  233,  259,  260,  234,  262,  264,  267,
+      263,  266,  265,  268,  269,  274,  275,  299,  317,  305,
+      901,  900,  301,  315,  899,  320,  323,  326,  327,  898,
+      329,  330,  332,  333,  337,  334,  335,  339,    0,  334,
+      339,  929,  341,  929,  342,    0,  891,  890,    0,  900,
+      929,  355,  899,    0,    0,  898,  859,  895,  857,  929,
+      849,  851,    0,  346,  331,  349,  357,  358,  360,  359,
+      887,  353,  356,  362,  886,  364,  386,  885,  884,  883,
+      389,  882,  367,  394,  393,  396,  397,  405,  929,  881,
+      880,  879,  878,  877,  147,  399,  876,  875,  403,  874,
+
+      873,  401,  872,  871,  870,  869,  402,  868,  867,  408,
+      409,  866,  406,  844,  794,  789,  407,  410,  416,  414,
+      421,  427,  412,  418,  417,  422,  423,  428,  834,  831,
+      425,  426,  828,  827,  429,  430,  929,  824,  439,  823,
+      450,  451,  453,  821,  820,  771,  763,  452,  454,  455,
+      458,  457,  460,  463,  461,  462,  466,  816,  469,  470,
+      806,  475,  476,  792,  477,  791,  479,  482,  483,  750,
+      739,  484,  494,  493,  765,  496,  495,  499,  497,  500,
+      501,  503,  507,  506,  761,  510,  511,  512,  757,  758,
+      710,  515,  520,  517,  526,  528,  748,  522,  530,  746,
+
+      745,  533,  534,  535,  536,  537,  749,  650,  538,  543,
+      539,  545,  547,  548,  551,  644,  642,  552,  641,  561,
+      645,  564,  566,  567,  573,  574,  575,  576,  577,  579,
+      582,  583,  581,  590,  591,  584,  586,  588,  589,  594,
+      596,  609,  610,  615,  635,  634,  592,  633,  607,  632,
+      611,  628,  624,  622,  616,  617,  621,  620,  929,  653,
+      665,  677,  689,  701,  713,  725,  737,  745,  757,  769,
+      781,  793,  797,  809,  820,  824,  836,  848,  860,  145
+    } ;
+
+static yyconst short int yy_def[381] =
+    {   0,
+      359,    1,  360,  360,  361,  361,  362,  362,  363,  363,
+      364,  364,  365,  365,  366,  366,  367,  367,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  369,  359,  370,  371,  372,  359,
+      359,  359,  359,  359,  359,  373,  373,  359,  359,  374,
+      359,  375,  359,  359,  359,  359,  376,  377,  359,  359,
+      359,  359,  378,  359,  379,  359,  359,  359,  359,  359,
+      380,  359,  359,  359,  359,  368,  368,  368,  368,  368,
+
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  369,  370,
+      370,  359,  371,  359,  371,  372,  373,  373,  374,  359,
+      359,  375,  359,  376,  377,  359,  378,  379,  378,  359,
+      359,  359,  380,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  359,  359,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  359,  359,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  359,  368,  368,  368,
+      368,  368,  368,  368,  368,  359,  359,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  359,
+      359,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  359,
+      359,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+
+      368,  368,  368,  368,  368,  368,  359,  359,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      359,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,  368,  368,
+      368,  368,  368,  368,  368,  368,  368,  368,    0,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359
+    } ;
+
+static yyconst short int yy_nxt[995] =
+    {   0,
+       20,   21,   22,   23,   24,   25,   23,   23,   23,   23,
+       23,   23,   26,   27,   28,   28,   29,   30,   31,   32,
+       33,   33,   34,   33,   33,   33,   33,   33,   33,   33,
+       33,   33,   35,   36,   37,   33,   38,   39,   33,   20,
+       33,   40,   41,   42,   43,   44,   45,   33,   33,   46,
+       47,   33,   33,   48,   49,   50,   33,   51,   52,   53,
+       33,   33,   33,   54,   33,   56,   56,   95,   84,   60,
+       84,   57,   57,   61,   62,   58,   58,   60,   92,   92,
+       92,   61,   62,   63,   63,   64,   63,   65,   63,   63,
+       63,   63,   63,   87,   95,   67,   79,   95,   88,   68,
+
+       69,   80,   81,   79,   82,   85,   95,   85,   80,   81,
+       97,   82,   95,   95,  108,  141,   95,   95,   95,  142,
+       95,   98,   63,   63,   63,   64,   63,   65,   63,   63,
+       63,   63,   63,   90,   90,   67,  102,  101,   95,   68,
+       69,  101,   95,  101,  144,  113,   95,   95,  145,   95,
+      104,  105,   95,   95,  103,  114,  163,  137,   91,  106,
+      118,  107,   63,   64,   64,   64,   64,   64,   64,   64,
+       64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
+       64,  109,   95,   91,   95,   95,   95,   95,  115,  119,
+      116,  131,  110,  111,   95,  112,  129,  120,  238,  117,
+
+      167,  132,   64,   64,   64,   64,   64,   64,   64,   64,
+       64,   64,   64,   64,   64,   64,   64,   64,   64,   64,
+       64,  126,  133,  166,  150,   90,   90,  134,  135,  151,
+       92,   92,   92,  130,   95,  127,  138,   95,  136,   95,
+       95,  128,   64,   73,   74,   64,   73,   73,   73,   75,
+       76,   73,   75,   73,   73,   73,   73,   73,   73,   73,
+       73,   95,   95,  168,  169,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   95,  170,  165,  175,  164,
+       95,   95,   73,   73,   74,   64,   73,   73,   73,   75,
+       76,   73,   75,   73,   73,   73,   73,   73,   73,   73,
+
+       73,   95,  171,  172,  121,   95,  122,   95,  182,  173,
+      178,   95,  174,   99,  123,  124,  177,  176,  188,  180,
+      181,   95,   73,  189,  179,  125,   95,  184,  100,   95,
+      183,  186,   95,   95,  185,   95,   95,   95,   95,   95,
+       95,   95,  359,   95,  187,   95,  359,  141,  190,  359,
+      359,  142,   95,  359,  145,   95,  150,  191,  192,   95,
+      193,  151,   95,   95,   95,   95,   95,  196,   95,  219,
+       95,  218,  217,   95,  206,  198,  202,  212,  195,  194,
+      220,  199,  204,  200,  197,  208,  201,  205,  203,  207,
+      209,  210,   95,  213,  222,   95,  214,  226,  221,   95,
+
+       95,  211,   95,   95,  223,   95,  188,   95,   95,   95,
+      225,  237,   95,   95,   95,   95,   95,  227,   95,  224,
+       95,  232,   95,   95,   95,  229,  228,   95,   95,   95,
+      249,   95,   95,   95,   95,   95,   95,  248,  230,  233,
+      251,  250,  252,  242,  239,   95,  234,  231,  240,  236,
+      241,  235,  243,  254,  244,  253,   95,   95,   95,   95,
+       95,   95,  257,   95,   95,  245,   95,   95,   95,   95,
+      255,  256,   95,  260,  264,   95,   95,  259,  262,  265,
+      258,   95,   95,   95,  261,   95,  263,  273,   95,   95,
+       95,  276,  272,  277,  278,  274,  275,  266,  269,   95,
+
+       95,   95,   95,   95,  292,   95,   95,   95,  267,   95,
+      268,  294,   95,   95,  282,  296,   95,   95,   95,  279,
+      293,   95,  280,   95,  281,  288,   95,  283,   95,  297,
+      284,  295,   95,  286,   95,  285,   95,  298,  287,   95,
+       95,   95,   95,   95,   95,   95,  289,  303,  309,   95,
+      311,   95,  299,   95,   95,  310,  305,   95,   95,  300,
+      306,  301,  302,  324,  322,  304,  312,   95,  313,  323,
+       95,  315,   95,   95,  325,  314,  326,  320,  317,   95,
+       95,   95,   95,   95,  318,   95,  332,   95,   95,   95,
+       95,  316,   95,  319,   95,   95,   95,   95,   95,  331,
+
+       95,  341,   95,  327,  334,  335,  329,  333,  340,  342,
+      328,  343,  344,   95,  349,   95,   95,   95,  330,  336,
+      339,   95,   95,   95,  350,  355,   95,   95,   95,  345,
+       95,  337,  352,  347,   95,  351,  338,  353,   95,   95,
+       95,   95,  348,  346,  357,  356,  321,   95,   95,  354,
+       95,  321,  358,   55,   55,   55,   55,   55,   55,   55,
+       55,   55,   55,   55,   55,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   66,   66,   66,
+       66,   66,   66,   66,   66,   66,   66,   66,   66,   70,
+       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
+
+       70,   72,   72,   72,   72,   72,   72,   72,   72,   72,
+       72,   72,   72,   77,   77,   77,   77,   77,   77,   77,
+       77,   77,   77,   77,   77,   78,   78,   78,   78,   78,
+       78,   78,   78,   78,   78,   78,   78,   83,   83,   83,
+       83,   83,   83,   83,   83,   83,   83,   83,   83,   96,
+      307,   95,   95,   96,   95,  308,   96,  139,  139,  307,
+      139,  139,  139,   95,  139,  139,  139,   95,  139,  140,
+      140,   95,  140,  140,  140,  140,  140,  140,  140,  140,
+      140,  143,  143,  291,  143,  143,  143,  143,  143,  143,
+      143,  143,  143,  146,  146,  290,  146,   95,   95,  146,
+
+      146,  146,  146,  146,  146,  147,  147,  147,  147,  149,
+      149,  149,   95,  149,  149,  149,  149,  149,  149,  149,
+      149,  152,   95,  271,  152,  270,   95,   95,  152,   95,
+       95,  152,  154,   95,   95,  154,  155,   95,  155,  155,
+       95,  247,  155,  246,  155,  155,  155,  155,  157,  157,
+       95,  157,  157,  157,  157,  157,  157,  157,  157,  157,
+      159,  159,  159,  159,  159,  159,  159,  159,  159,  159,
+      159,  159,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
+       95,   95,   95,   95,  216,  215,  158,  359,  158,  156,
+
+      153,  150,  148,  148,   95,   95,   95,   95,   95,   95,
+      162,  161,   86,  160,  158,  156,  153,  148,  148,   95,
+       95,   94,   93,   89,   86,  359,   71,   71,   19,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359
+
+    } ;
+
+static yyconst short int yy_chk[995] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    3,    4,   41,   17,    5,
+       18,    3,    4,    5,    5,    3,    4,    6,   28,   28,
+       28,    6,    6,    7,    7,    7,    7,    7,    7,    7,
+        7,    7,    7,   25,   32,    7,   15,   34,   25,    7,
+
+        7,   15,   15,   16,   15,   17,   43,   18,   16,   16,
+       32,   16,   36,   40,   41,   57,   39,   45,   53,   57,
+       37,   34,    7,    8,    8,    8,    8,    8,    8,    8,
+        8,    8,    8,   27,   27,    8,   37,   36,   38,    8,
+        8,   39,   44,   36,   58,   43,   42,   49,   58,   46,
+       40,   40,   51,  195,   38,   43,  380,   53,   27,   40,
+       45,   40,    8,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   42,   50,   27,  100,   52,   48,   54,   44,   46,
+       44,   51,   42,   42,   99,   42,   49,   46,  195,   44,
+
+      100,   51,   11,   12,   12,   12,   12,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,   48,   52,   99,   72,   90,   90,   52,   52,   72,
+       92,   92,   92,   50,  102,   48,   54,  103,   52,  104,
+      107,   48,   12,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   97,   98,  102,  103,  105,  106,   47,  108,  111,
+      109,  113,  112,  110,  114,  115,  104,   98,  107,   97,
+      116,  117,   13,   14,   14,   14,   14,   14,   14,   14,
+       14,   14,   14,   14,   14,   14,   14,   14,   14,   14,
+
+       14,   35,  105,  105,   47,  118,   47,  123,  113,  106,
+      110,  120,  106,   35,   47,   47,  109,  108,  119,  111,
+      112,  124,   14,  119,  110,   47,  126,  115,   35,  127,
+      114,  117,  128,  129,  116,  131,  132,  165,  133,  134,
+      136,  137,  140,  135,  118,  138,  140,  141,  120,  143,
+      145,  141,  164,  143,  145,  166,  152,  123,  124,  172,
+      124,  152,  173,  167,  168,  170,  169,  127,  174,  166,
+      176,  165,  164,  183,  133,  128,  131,  136,  126,  124,
+      167,  129,  132,  129,  127,  134,  129,  132,  131,  133,
+      134,  135,  177,  137,  169,  181,  138,  173,  168,  185,
+
+      184,  135,  186,  187,  170,  196,  188,  202,  207,  199,
+      172,  188,  213,  217,  210,  211,  218,  174,  223,  170,
+      220,  183,  219,  225,  224,  176,  174,  221,  226,  227,
+      218,  231,  232,  222,  228,  235,  236,  217,  177,  184,
+      220,  219,  221,  207,  196,  239,  185,  181,  199,  187,
+      202,  186,  210,  222,  211,  221,  241,  242,  248,  243,
+      249,  250,  225,  252,  251,  213,  253,  255,  256,  254,
+      223,  224,  257,  228,  236,  259,  260,  227,  232,  239,
+      226,  262,  263,  265,  231,  267,  235,  249,  268,  269,
+      272,  252,  248,  253,  254,  250,  251,  239,  243,  274,
+
+      273,  277,  276,  279,  272,  278,  280,  281,  241,  282,
+      242,  274,  284,  283,  259,  277,  286,  287,  288,  255,
+      273,  292,  256,  294,  257,  268,  293,  260,  298,  278,
+      262,  276,  295,  265,  296,  263,  299,  279,  267,  302,
+      303,  304,  305,  306,  309,  311,  269,  284,  292,  310,
+      294,  312,  280,  313,  314,  293,  287,  315,  318,  281,
+      288,  282,  283,  311,  309,  286,  295,  320,  296,  310,
+      322,  299,  323,  324,  312,  298,  313,  306,  303,  325,
+      326,  327,  328,  329,  304,  330,  323,  333,  331,  332,
+      336,  302,  337,  305,  338,  339,  334,  335,  347,  322,
+
+      340,  332,  341,  314,  325,  326,  318,  324,  331,  333,
+      315,  334,  335,  349,  340,  342,  343,  351,  320,  327,
+      330,  344,  355,  356,  341,  349,  358,  357,  354,  336,
+      353,  328,  343,  338,  352,  342,  329,  344,  350,  348,
+      346,  345,  339,  337,  355,  351,  321,  319,  317,  347,
+      316,  308,  356,  360,  360,  360,  360,  360,  360,  360,
+      360,  360,  360,  360,  360,  361,  361,  361,  361,  361,
+      361,  361,  361,  361,  361,  361,  361,  362,  362,  362,
+      362,  362,  362,  362,  362,  362,  362,  362,  362,  363,
+      363,  363,  363,  363,  363,  363,  363,  363,  363,  363,
+
+      363,  364,  364,  364,  364,  364,  364,  364,  364,  364,
+      364,  364,  364,  365,  365,  365,  365,  365,  365,  365,
+      365,  365,  365,  365,  365,  366,  366,  366,  366,  366,
+      366,  366,  366,  366,  366,  366,  366,  367,  367,  367,
+      367,  367,  367,  367,  367,  367,  367,  367,  367,  368,
+      307,  301,  300,  368,  297,  291,  368,  369,  369,  290,
+      369,  369,  369,  289,  369,  369,  369,  285,  369,  370,
+      370,  275,  370,  370,  370,  370,  370,  370,  370,  370,
+      370,  371,  371,  271,  371,  371,  371,  371,  371,  371,
+      371,  371,  371,  372,  372,  270,  372,  266,  264,  372,
+
+      372,  372,  372,  372,  372,  373,  373,  373,  373,  374,
+      374,  374,  261,  374,  374,  374,  374,  374,  374,  374,
+      374,  375,  258,  247,  375,  246,  245,  244,  375,  240,
+      238,  375,  376,  234,  233,  376,  377,  230,  377,  377,
+      229,  216,  377,  215,  377,  377,  377,  377,  378,  378,
+      214,  378,  378,  378,  378,  378,  378,  378,  378,  378,
+      379,  379,  379,  379,  379,  379,  379,  379,  379,  379,
+      379,  379,  212,  209,  208,  206,  205,  204,  203,  201,
+      200,  198,  197,  194,  193,  192,  191,  190,  182,  180,
+      179,  178,  175,  171,  162,  161,  159,  158,  157,  156,
+
+      153,  150,  148,  147,  130,  125,  122,  121,  101,   96,
+       88,   87,   86,   85,   83,   79,   74,   67,   66,   33,
+       31,   30,   29,   26,   21,   19,   10,    9,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359,  359,  359,  359,  359,  359,  359,
+      359,  359,  359,  359
+
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "aicasm_scan.l"
+#define INITIAL 0
+#line 2 "aicasm_scan.l"
+/*
+ * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.
+ *
+ * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#16 $
+ *
+ * $FreeBSD$
+ */
+
+#include <inttypes.h>
+#include <sys/types.h>
+
+#include <limits.h>
+#include <regex.h>
+#include <stdio.h>
+#include <string.h>
+#include <sysexits.h>
+#ifdef __linux__
+#include "../queue.h"
+#else
+#include <sys/queue.h>
+#endif
+
+#include "aicasm.h"
+#include "aicasm_symbol.h"
+#include "aicasm_gram.h"
+
+/* This is used for macro body capture too, so err on the large size. */
+#define MAX_STR_CONST 4096
+static char string_buf[MAX_STR_CONST];
+static char *string_buf_ptr;
+static int  parren_count;
+static int  quote_count;
+static char buf[255];
+#define COMMENT 1
+
+#define CEXPR 2
+
+#define INCLUDE 3
+
+#define STRING 4
+
+#define MACRODEF 5
+
+#define MACROARGLIST 6
+
+#define MACROCALLARGS 7
+
+#define MACROBODY 8
+
+#line 792 "aicasm_scan.c"
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap YY_PROTO(( void ));
+#else
+extern int yywrap YY_PROTO(( void ));
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+static void yyunput YY_PROTO(( int c, char *buf_ptr ));
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput YY_PROTO(( void ));
+#else
+static int input YY_PROTO(( void ));
+#endif
+#endif
+
+#if YY_STACK_USED
+static int yy_start_stack_ptr = 0;
+static int yy_start_stack_depth = 0;
+static int *yy_start_stack = 0;
+#ifndef YY_NO_PUSH_STATE
+static void yy_push_state YY_PROTO(( int new_state ));
+#endif
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state YY_PROTO(( void ));
+#endif
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state YY_PROTO(( void ));
+#endif
+
+#else
+#define YY_NO_PUSH_STATE 1
+#define YY_NO_POP_STATE 1
+#define YY_NO_TOP_STATE 1
+#endif
+
+#ifdef YY_MALLOC_DECL
+YY_MALLOC_DECL
+#else
+#if __STDC__
+#ifndef __cplusplus
+#include <stdlib.h>
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( yy_current_buffer->yy_is_interactive ) \
+		{ \
+		int c = '*', n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
+		  && ferror( yyin ) ) \
+		YY_FATAL_ERROR( "input in flex scanner failed" );
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL int yylex YY_PROTO(( void ))
+#endif
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+YY_DECL
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp = NULL, *yy_bp = NULL;
+	register int yy_act;
+
+#line 88 "aicasm_scan.l"
+
+#line 945 "aicasm_scan.c"
+
+	if ( yy_init )
+		{
+		yy_init = 0;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yy_start )
+			yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! yy_current_buffer )
+			yy_current_buffer =
+				yy_create_buffer( yyin, YY_BUF_SIZE );
+
+		yy_load_buffer_state();
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yy_start;
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				yy_last_accepting_state = yy_current_state;
+				yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 360 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 929 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+
+do_action:	/* This label is used only to access EOF actions. */
+
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yy_hold_char;
+			yy_cp = yy_last_accepting_cpos;
+			yy_current_state = yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 89 "aicasm_scan.l"
+{ ++yylineno; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 90 "aicasm_scan.l"
+{ BEGIN COMMENT;  /* Enter comment eating state */ }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 91 "aicasm_scan.l"
+{ fprintf(stderr, "Warning! Comment within comment."); }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 92 "aicasm_scan.l"
+{ ++yylineno; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 93 "aicasm_scan.l"
+;
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 94 "aicasm_scan.l"
+;
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 95 "aicasm_scan.l"
+;
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 96 "aicasm_scan.l"
+{ BEGIN INITIAL; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 97 "aicasm_scan.l"
+{
+				string_buf_ptr = string_buf;
+				parren_count = 1;
+				BEGIN CEXPR;
+				return T_IF;
+			}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 103 "aicasm_scan.l"
+{	*string_buf_ptr++ = '('; parren_count++; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 104 "aicasm_scan.l"
+{
+				parren_count--;
+				if (parren_count == 0) {
+					/* All done */
+					BEGIN INITIAL;
+					*string_buf_ptr = '\0';
+					yylval.sym = symtable_get(string_buf);
+					return T_CEXPR;
+				} else {
+					*string_buf_ptr++ = ')';
+				}
+			}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 116 "aicasm_scan.l"
+{ ++yylineno; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 117 "aicasm_scan.l"
+{
+				char *yptr;
+
+				yptr = yytext;
+				while (*yptr != '\0') {
+					/* Remove duplicate spaces */
+					if (*yptr == '\t')
+						*yptr = ' ';
+					if (*yptr == ' '
+					 && string_buf_ptr != string_buf
+					 && string_buf_ptr[-1] == ' ')
+						yptr++;
+					else 
+						*string_buf_ptr++ = *yptr++;
+				}
+			}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 134 "aicasm_scan.l"
+{ return T_VERSION; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 135 "aicasm_scan.l"
+{ return T_PREFIX; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 136 "aicasm_scan.l"
+{ return T_PATCH_ARG_LIST; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 137 "aicasm_scan.l"
+{
+				string_buf_ptr = string_buf;
+				BEGIN STRING;
+			}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 141 "aicasm_scan.l"
+{
+				char *yptr;
+
+				yptr = yytext;
+				while (*yptr)
+					*string_buf_ptr++ = *yptr++;
+			}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 148 "aicasm_scan.l"
+{
+				/* All done */
+				BEGIN INITIAL;
+				*string_buf_ptr = '\0';
+				yylval.str = string_buf;
+				return T_STRING;
+			}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 155 "aicasm_scan.l"
+;
+	YY_BREAK
+/* Register/SCB/SRAM definition keywords */
+case 21:
+YY_RULE_SETUP
+#line 158 "aicasm_scan.l"
+{ return T_EXPORT; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 159 "aicasm_scan.l"
+{ return T_REGISTER; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 160 "aicasm_scan.l"
+{ yylval.value = FALSE; return T_CONST; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 161 "aicasm_scan.l"
+{ return T_DOWNLOAD; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 162 "aicasm_scan.l"
+{ return T_ADDRESS; }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 163 "aicasm_scan.l"
+{ return T_ACCESS_MODE; }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 164 "aicasm_scan.l"
+{ return T_MODES; }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 165 "aicasm_scan.l"
+{
+				 if (strcmp(yytext, "RW") == 0)
+					yylval.value = RW;
+				 else if (strcmp(yytext, "RO") == 0)
+					yylval.value = RO;
+				 else
+					yylval.value = WO;
+				 return T_MODE;
+			}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 174 "aicasm_scan.l"
+{ return T_BEGIN_CS; }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 175 "aicasm_scan.l"
+{ return T_END_CS; }
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 176 "aicasm_scan.l"
+{ return T_SET_SRC_MODE; }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 177 "aicasm_scan.l"
+{ return T_SET_DST_MODE; }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 178 "aicasm_scan.l"
+{ return T_FIELD; }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 179 "aicasm_scan.l"
+{ return T_ENUM; }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 180 "aicasm_scan.l"
+{ return T_MASK; }
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 181 "aicasm_scan.l"
+{ return T_ALIAS; }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 182 "aicasm_scan.l"
+{ return T_SIZE; }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 183 "aicasm_scan.l"
+{ return T_SCB; }
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 184 "aicasm_scan.l"
+{ return T_SRAM; }
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 185 "aicasm_scan.l"
+{ return T_ACCUM; }
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 186 "aicasm_scan.l"
+{ return T_MODE_PTR; }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 187 "aicasm_scan.l"
+{ return T_ALLONES; }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 188 "aicasm_scan.l"
+{ return T_ALLZEROS; }
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 189 "aicasm_scan.l"
+{ return T_NONE; }
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 190 "aicasm_scan.l"
+{ return T_SINDEX; }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 191 "aicasm_scan.l"
+{ return T_A; }
+	YY_BREAK
+/* Opcodes */
+case 47:
+YY_RULE_SETUP
+#line 194 "aicasm_scan.l"
+{ return T_SHL; }
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 195 "aicasm_scan.l"
+{ return T_SHR; }
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 196 "aicasm_scan.l"
+{ return T_ROR; }
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 197 "aicasm_scan.l"
+{ return T_ROL; }
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 198 "aicasm_scan.l"
+{ return T_MVI; }
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 199 "aicasm_scan.l"
+{ return T_MOV; }
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 200 "aicasm_scan.l"
+{ return T_CLR; }
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 201 "aicasm_scan.l"
+{ return T_JMP; }
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 202 "aicasm_scan.l"
+{ return T_JC;	}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 203 "aicasm_scan.l"
+{ return T_JNC;	}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 204 "aicasm_scan.l"
+{ return T_JE;	}
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 205 "aicasm_scan.l"
+{ return T_JNE;	}
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 206 "aicasm_scan.l"
+{ return T_JZ;	}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 207 "aicasm_scan.l"
+{ return T_JNZ;	}
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 208 "aicasm_scan.l"
+{ return T_CALL; }
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 209 "aicasm_scan.l"
+{ return T_ADD; }
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 210 "aicasm_scan.l"
+{ return T_ADC; }
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 211 "aicasm_scan.l"
+{ return T_BMOV; }
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 212 "aicasm_scan.l"
+{ return T_INC; }
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 213 "aicasm_scan.l"
+{ return T_DEC; }
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 214 "aicasm_scan.l"
+{ return T_STC;	}
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 215 "aicasm_scan.l"
+{ return T_CLC; }
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 216 "aicasm_scan.l"
+{ return T_CMP;	}
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 217 "aicasm_scan.l"
+{ return T_NOT;	}
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 218 "aicasm_scan.l"
+{ return T_XOR;	}
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 219 "aicasm_scan.l"
+{ return T_TEST;}
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 220 "aicasm_scan.l"
+{ return T_AND;	}
+	YY_BREAK
+case 74:
+YY_RULE_SETUP
+#line 221 "aicasm_scan.l"
+{ return T_OR;	}
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 222 "aicasm_scan.l"
+{ return T_RET; }
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 223 "aicasm_scan.l"
+{ return T_NOP; }
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 224 "aicasm_scan.l"
+{ return T_ELSE; }
+	YY_BREAK
+/* Allowed Symbols */
+case 78:
+YY_RULE_SETUP
+#line 227 "aicasm_scan.l"
+{ return T_EXPR_LSHIFT; }
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 228 "aicasm_scan.l"
+{ return T_EXPR_RSHIFT; }
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 229 "aicasm_scan.l"
+{ return yytext[0]; }
+	YY_BREAK
+/* Number processing */
+case 81:
+YY_RULE_SETUP
+#line 232 "aicasm_scan.l"
+{
+				yylval.value = strtol(yytext, NULL, 8);
+				return T_NUMBER;
+			}
+	YY_BREAK
+case 82:
+YY_RULE_SETUP
+#line 237 "aicasm_scan.l"
+{
+				yylval.value = strtoul(yytext + 2, NULL, 16);
+				return T_NUMBER;
+			}
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 242 "aicasm_scan.l"
+{
+				yylval.value = strtol(yytext, NULL, 10);
+				return T_NUMBER;
+			}
+	YY_BREAK
+/* Include Files */
+case 84:
+YY_RULE_SETUP
+#line 247 "aicasm_scan.l"
+{
+				BEGIN INCLUDE;
+				quote_count = 0;
+				return T_INCLUDE;
+			}
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+#line 252 "aicasm_scan.l"
+{ return yytext[0]; }
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+#line 253 "aicasm_scan.l"
+{ BEGIN INITIAL; return yytext[0]; }
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+#line 254 "aicasm_scan.l"
+{
+				if (quote_count != 0)
+					BEGIN INITIAL;
+				quote_count++;
+				return yytext[0];
+			}
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+#line 260 "aicasm_scan.l"
+{
+				char *yptr;
+
+				yptr = yytext;
+				string_buf_ptr = string_buf;
+				while (*yptr)
+					*string_buf_ptr++ = *yptr++;
+				yylval.str = string_buf;
+				*string_buf_ptr = '\0';
+				return T_PATH;
+			}
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 271 "aicasm_scan.l"
+{ stop("Invalid include line", EX_DATAERR); }
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 272 "aicasm_scan.l"
+{
+				BEGIN MACRODEF;
+				return T_DEFINE;
+			}
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 276 "aicasm_scan.l"
+{ 
+				char *yptr;
+
+				/* Strip space and return as a normal symbol */
+				yptr = yytext;
+				while (*yptr != ' ' && *yptr != '\t')
+					yptr++;
+				*yptr = '\0';
+				yylval.sym = symtable_get(yytext);
+				string_buf_ptr = string_buf;
+				BEGIN MACROBODY;
+				return T_SYMBOL;
+			}
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+#line 289 "aicasm_scan.l"
+{
+				/*
+				 * We store the symbol with its opening
+				 * parren so we can differentiate macros
+				 * that take args from macros with the
+				 * same name that do not take args as
+				 * is allowed in C.
+				 */
+				BEGIN MACROARGLIST;
+				yylval.sym = symtable_get(yytext);
+				unput('(');
+				return T_SYMBOL;
+			}
+	YY_BREAK
+case 93:
+YY_RULE_SETUP
+#line 302 "aicasm_scan.l"
+{
+				yylval.str = yytext;
+				return T_ARG;
+			}
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+#line 306 "aicasm_scan.l"
+;
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 307 "aicasm_scan.l"
+{
+				return yytext[0];
+			}
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+#line 310 "aicasm_scan.l"
+{
+				string_buf_ptr = string_buf;
+				BEGIN MACROBODY;
+				return ')';
+			}
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+#line 315 "aicasm_scan.l"
+{
+				snprintf(buf, sizeof(buf), "Invalid character "
+					 "'%c' in macro argument list",
+					 yytext[0]);
+				stop(buf, EX_DATAERR);
+			}
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+#line 321 "aicasm_scan.l"
+;
+	YY_BREAK
+case 99:
+YY_RULE_SETUP
+#line 322 "aicasm_scan.l"
+{
+				parren_count++;
+				if (parren_count == 1)
+					return ('(');
+				*string_buf_ptr++ = '(';
+			}
+	YY_BREAK
+case 100:
+YY_RULE_SETUP
+#line 328 "aicasm_scan.l"
+{
+				parren_count--;
+				if (parren_count == 0) {
+					BEGIN INITIAL;
+					return (')');
+				}
+				*string_buf_ptr++ = ')';
+			}
+	YY_BREAK
+case 101:
+YY_RULE_SETUP
+#line 336 "aicasm_scan.l"
+{
+				char *yptr;
+
+				yptr = yytext;
+				while (*yptr)
+					*string_buf_ptr++ = *yptr++;
+			}
+	YY_BREAK
+case 102:
+YY_RULE_SETUP
+#line 343 "aicasm_scan.l"
+{
+				if (string_buf_ptr != string_buf) {
+					/*
+					 * Return an argument and
+					 * rescan this comma so we
+					 * can return it as well.
+					 */
+					*string_buf_ptr = '\0';
+					yylval.str = string_buf;
+					string_buf_ptr = string_buf;
+					unput(',');
+					return T_ARG;
+				}
+				return ',';
+			}
+	YY_BREAK
+case 103:
+YY_RULE_SETUP
+#line 358 "aicasm_scan.l"
+{
+				/* Eat escaped newlines. */
+				++yylineno;
+			}
+	YY_BREAK
+case 104:
+YY_RULE_SETUP
+#line 362 "aicasm_scan.l"
+{
+				/* Macros end on the first unescaped newline. */
+				BEGIN INITIAL;
+				*string_buf_ptr = '\0';
+				yylval.str = string_buf;
+				++yylineno;
+				return T_MACROBODY;
+			}
+	YY_BREAK
+case 105:
+YY_RULE_SETUP
+#line 370 "aicasm_scan.l"
+{
+				char *yptr;
+
+				yptr = yytext;
+				while (*yptr)
+					*string_buf_ptr++ = *yptr++;
+			}
+	YY_BREAK
+case 106:
+YY_RULE_SETUP
+#line 377 "aicasm_scan.l"
+{
+				char *yptr;
+				char *ycopy;
+
+				/* May be a symbol or a macro invocation. */
+				yylval.sym = symtable_get(yytext);
+				if (yylval.sym->type == MACRO) {
+					YY_BUFFER_STATE old_state;
+					YY_BUFFER_STATE temp_state;
+
+					ycopy = strdup(yytext);
+					yptr = ycopy + yyleng;
+					while (yptr > ycopy)
+						unput(*--yptr);
+					old_state = YY_CURRENT_BUFFER;
+					temp_state =
+					    yy_create_buffer(stdin,
+							     YY_BUF_SIZE);
+					yy_switch_to_buffer(temp_state);
+					mm_switch_to_buffer(old_state);
+					mmparse();
+					mm_switch_to_buffer(temp_state);
+					yy_switch_to_buffer(old_state);
+					mm_delete_buffer(temp_state);
+					expand_macro(yylval.sym);
+				} else {
+					if (yylval.sym->type == UNINITIALIZED) {
+						/* Try without the '(' */
+						symbol_delete(yylval.sym);
+						yytext[yyleng-1] = '\0';
+						yylval.sym =
+						    symtable_get(yytext);
+					}
+					unput('(');
+					return T_SYMBOL;
+				}
+			}
+	YY_BREAK
+case 107:
+YY_RULE_SETUP
+#line 414 "aicasm_scan.l"
+{
+				yylval.sym = symtable_get(yytext);
+				if (yylval.sym->type == MACRO) {
+					expand_macro(yylval.sym);
+				} else {
+					return T_SYMBOL;
+				}
+			}
+	YY_BREAK
+case 108:
+YY_RULE_SETUP
+#line 422 "aicasm_scan.l"
+{ 
+				snprintf(buf, sizeof(buf), "Invalid character "
+					 "'%c'", yytext[0]);
+				stop(buf, EX_DATAERR);
+			}
+	YY_BREAK
+case 109:
+YY_RULE_SETUP
+#line 427 "aicasm_scan.l"
+ECHO;
+	YY_BREAK
+#line 1796 "aicasm_scan.c"
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMENT):
+case YY_STATE_EOF(CEXPR):
+case YY_STATE_EOF(INCLUDE):
+case YY_STATE_EOF(STRING):
+case YY_STATE_EOF(MACRODEF):
+case YY_STATE_EOF(MACROARGLIST):
+case YY_STATE_EOF(MACROCALLARGS):
+case YY_STATE_EOF(MACROBODY):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between yy_current_buffer and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yy_n_chars = yy_current_buffer->yy_n_chars;
+			yy_current_buffer->yy_input_file = yyin;
+			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state();
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yy_c_buf_p;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer() )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap() )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yy_c_buf_p =
+					yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yy_c_buf_p =
+				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+
+				yy_current_state = yy_get_previous_state();
+
+				yy_cp = yy_c_buf_p;
+				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of yylex */
+
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int yy_get_next_buffer()
+	{
+	register char *dest = yy_current_buffer->yy_ch_buf;
+	register char *source = yytext_ptr;
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( yy_current_buffer->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+
+	else
+		{
+		int num_to_read =
+			yy_current_buffer->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+#ifdef YY_USES_REJECT
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = yy_current_buffer;
+
+			int yy_c_buf_p_offset =
+				(int) (yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yy_flex_realloc( (void *) b->yy_ch_buf,
+							 b->yy_buf_size + 2 );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = yy_current_buffer->yy_buf_size -
+						number_to_move - 1;
+#endif
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
+			yy_n_chars, num_to_read );
+
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	if ( yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			yy_current_buffer->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	yy_n_chars += number_to_move;
+	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+
+	return ret_val;
+	}
+
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+static yy_state_type yy_get_previous_state()
+	{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = yy_start;
+
+	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yy_last_accepting_state = yy_current_state;
+			yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 360 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+	}
+
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+
+#ifdef YY_USE_PROTOS
+static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
+#else
+static yy_state_type yy_try_NUL_trans( yy_current_state )
+yy_state_type yy_current_state;
+#endif
+	{
+	register int yy_is_jam;
+	register char *yy_cp = yy_c_buf_p;
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yy_last_accepting_state = yy_current_state;
+		yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 360 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 359);
+
+	return yy_is_jam ? 0 : yy_current_state;
+	}
+
+
+#ifndef YY_NO_UNPUT
+#ifdef YY_USE_PROTOS
+static void yyunput( int c, register char *yy_bp )
+#else
+static void yyunput( c, yy_bp )
+int c;
+register char *yy_bp;
+#endif
+	{
+	register char *yy_cp = yy_c_buf_p;
+
+	/* undo effects of setting up yytext */
+	*yy_cp = yy_hold_char;
+
+	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = yy_n_chars + 2;
+		register char *dest = &yy_current_buffer->yy_ch_buf[
+					yy_current_buffer->yy_buf_size + 2];
+		register char *source =
+				&yy_current_buffer->yy_ch_buf[number_to_move];
+
+		while ( source > yy_current_buffer->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		yy_current_buffer->yy_n_chars =
+			yy_n_chars = yy_current_buffer->yy_buf_size;
+
+		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+
+	yytext_ptr = yy_bp;
+	yy_hold_char = *yy_cp;
+	yy_c_buf_p = yy_cp;
+	}
+#endif	/* ifndef YY_NO_UNPUT */
+
+
+#ifdef __cplusplus
+static int yyinput()
+#else
+static int input()
+#endif
+	{
+	int c;
+
+	*yy_c_buf_p = yy_hold_char;
+
+	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+			/* This was really a NUL. */
+			*yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = yy_c_buf_p - yytext_ptr;
+			++yy_c_buf_p;
+
+			switch ( yy_get_next_buffer() )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin );
+
+					/* fall through */
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap() )
+						return EOF;
+
+					if ( ! yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yy_c_buf_p = yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
+	*yy_c_buf_p = '\0';	/* preserve yytext */
+	yy_hold_char = *++yy_c_buf_p;
+
+
+	return c;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yyrestart( FILE *input_file )
+#else
+void yyrestart( input_file )
+FILE *input_file;
+#endif
+	{
+	if ( ! yy_current_buffer )
+		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+
+	yy_init_buffer( yy_current_buffer, input_file );
+	yy_load_buffer_state();
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
+#else
+void yy_switch_to_buffer( new_buffer )
+YY_BUFFER_STATE new_buffer;
+#endif
+	{
+	if ( yy_current_buffer == new_buffer )
+		return;
+
+	if ( yy_current_buffer )
+		{
+		/* Flush out information for old buffer. */
+		*yy_c_buf_p = yy_hold_char;
+		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
+		yy_current_buffer->yy_n_chars = yy_n_chars;
+		}
+
+	yy_current_buffer = new_buffer;
+	yy_load_buffer_state();
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yy_did_buffer_switch_on_eof = 1;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_load_buffer_state( void )
+#else
+void yy_load_buffer_state()
+#endif
+	{
+	yy_n_chars = yy_current_buffer->yy_n_chars;
+	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
+	yyin = yy_current_buffer->yy_input_file;
+	yy_hold_char = *yy_c_buf_p;
+	}
+
+
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
+#else
+YY_BUFFER_STATE yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file );
+
+	return b;
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_delete_buffer( YY_BUFFER_STATE b )
+#else
+void yy_delete_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+	{
+	if ( ! b )
+		return;
+
+	if ( b == yy_current_buffer )
+		yy_current_buffer = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yy_flex_free( (void *) b->yy_ch_buf );
+
+	yy_flex_free( (void *) b );
+	}
+
+
+
+#ifdef YY_USE_PROTOS
+void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
+#else
+void yy_init_buffer( b, file )
+YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+	{
+	yy_flush_buffer( b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+#if YY_ALWAYS_INTERACTIVE
+	b->yy_is_interactive = 1;
+#else
+#if YY_NEVER_INTERACTIVE
+	b->yy_is_interactive = 0;
+#else
+	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+	}
+
+
+#ifdef YY_USE_PROTOS
+void yy_flush_buffer( YY_BUFFER_STATE b )
+#else
+void yy_flush_buffer( b )
+YY_BUFFER_STATE b;
+#endif
+
+	{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == yy_current_buffer )
+		yy_load_buffer_state();
+	}
+
+
+#ifndef YY_NO_SCAN_BUFFER
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
+#else
+YY_BUFFER_STATE yy_scan_buffer( base, size )
+char *base;
+yy_size_t size;
+#endif
+	{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b );
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_STRING
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
+#else
+YY_BUFFER_STATE yy_scan_string( yy_str )
+yyconst char *yy_str;
+#endif
+	{
+	int len;
+	for ( len = 0; yy_str[len]; ++len )
+		;
+
+	return yy_scan_bytes( yy_str, len );
+	}
+#endif
+
+
+#ifndef YY_NO_SCAN_BYTES
+#ifdef YY_USE_PROTOS
+YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
+#else
+YY_BUFFER_STATE yy_scan_bytes( bytes, len )
+yyconst char *bytes;
+int len;
+#endif
+	{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = len + 2;
+	buf = (char *) yy_flex_alloc( n );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
+
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+	}
+#endif
+
+
+#ifndef YY_NO_PUSH_STATE
+#ifdef YY_USE_PROTOS
+static void yy_push_state( int new_state )
+#else
+static void yy_push_state( new_state )
+int new_state;
+#endif
+	{
+	if ( yy_start_stack_ptr >= yy_start_stack_depth )
+		{
+		yy_size_t new_size;
+
+		yy_start_stack_depth += YY_START_STACK_INCR;
+		new_size = yy_start_stack_depth * sizeof( int );
+
+		if ( ! yy_start_stack )
+			yy_start_stack = (int *) yy_flex_alloc( new_size );
+
+		else
+			yy_start_stack = (int *) yy_flex_realloc(
+					(void *) yy_start_stack, new_size );
+
+		if ( ! yy_start_stack )
+			YY_FATAL_ERROR(
+			"out of memory expanding start-condition stack" );
+		}
+
+	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+
+	BEGIN(new_state);
+	}
+#endif
+
+
+#ifndef YY_NO_POP_STATE
+static void yy_pop_state()
+	{
+	if ( --yy_start_stack_ptr < 0 )
+		YY_FATAL_ERROR( "start-condition stack underflow" );
+
+	BEGIN(yy_start_stack[yy_start_stack_ptr]);
+	}
+#endif
+
+
+#ifndef YY_NO_TOP_STATE
+static int yy_top_state()
+	{
+	return yy_start_stack[yy_start_stack_ptr - 1];
+	}
+#endif
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+#ifdef YY_USE_PROTOS
+static void yy_fatal_error( yyconst char msg[] )
+#else
+static void yy_fatal_error( msg )
+char msg[];
+#endif
+	{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+	}
+
+
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+		yytext[yyleng] = yy_hold_char; \
+		yy_c_buf_p = yytext + n; \
+		yy_hold_char = *yy_c_buf_p; \
+		*yy_c_buf_p = '\0'; \
+		yyleng = n; \
+		} \
+	while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef yytext_ptr
+#ifdef YY_USE_PROTOS
+static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
+#else
+static void yy_flex_strncpy( s1, s2, n )
+char *s1;
+yyconst char *s2;
+int n;
+#endif
+	{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+	}
+#endif
+
+#ifdef YY_NEED_STRLEN
+#ifdef YY_USE_PROTOS
+static int yy_flex_strlen( yyconst char *s )
+#else
+static int yy_flex_strlen( s )
+yyconst char *s;
+#endif
+	{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+	}
+#endif
+
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_alloc( yy_size_t size )
+#else
+static void *yy_flex_alloc( size )
+yy_size_t size;
+#endif
+	{
+	return (void *) malloc( size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void *yy_flex_realloc( void *ptr, yy_size_t size )
+#else
+static void *yy_flex_realloc( ptr, size )
+void *ptr;
+yy_size_t size;
+#endif
+	{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+	}
+
+#ifdef YY_USE_PROTOS
+static void yy_flex_free( void *ptr )
+#else
+static void yy_flex_free( ptr )
+void *ptr;
+#endif
+	{
+	free( ptr );
+	}
+
+#if YY_MAIN
+int main()
+	{
+	yylex();
+	return 0;
+	}
+#endif
+#line 427 "aicasm_scan.l"
+
+
+typedef struct include {
+        YY_BUFFER_STATE  buffer;
+        int              lineno;
+        char            *filename;
+	SLIST_ENTRY(include) links;
+}include_t;
+
+SLIST_HEAD(, include) include_stack;
+
+void
+include_file(char *file_name, include_type type)
+{
+	FILE *newfile;
+	include_t *include;
+
+	newfile = NULL;
+	/* Try the current directory first */
+	if (includes_search_curdir != 0 || type == SOURCE_FILE)
+		newfile = fopen(file_name, "r");
+
+	if (newfile == NULL && type != SOURCE_FILE) {
+                path_entry_t include_dir;
+                for (include_dir = search_path.slh_first;
+                     include_dir != NULL;                
+                     include_dir = include_dir->links.sle_next) {
+			char fullname[PATH_MAX];
+
+			if ((include_dir->quoted_includes_only == TRUE)
+			 && (type != QUOTED_INCLUDE))
+				continue;
+
+			snprintf(fullname, sizeof(fullname),
+				 "%s/%s", include_dir->directory, file_name);
+
+			if ((newfile = fopen(fullname, "r")) != NULL)
+				break;
+                }
+        }
+
+	if (newfile == NULL) {
+		perror(file_name);
+		stop("Unable to open input file", EX_SOFTWARE);
+		/* NOTREACHED */
+	}
+
+	if (type != SOURCE_FILE) {
+		include = (include_t *)malloc(sizeof(include_t));
+		if (include == NULL) {
+			stop("Unable to allocate include stack entry",
+			     EX_SOFTWARE);
+			/* NOTREACHED */
+		}
+		include->buffer = YY_CURRENT_BUFFER;
+		include->lineno = yylineno;
+		include->filename = yyfilename;
+		SLIST_INSERT_HEAD(&include_stack, include, links);
+	}
+	yy_switch_to_buffer(yy_create_buffer(newfile, YY_BUF_SIZE));
+	yylineno = 1;
+	yyfilename = strdup(file_name);
+}
+
+static void next_substitution(struct symbol *mac_symbol, const char *body_pos,
+			      const char **next_match,
+			      struct macro_arg **match_marg, regmatch_t *match);
+
+void
+expand_macro(struct symbol *macro_symbol)
+{
+	struct macro_arg *marg;
+	struct macro_arg *match_marg;
+	const char *body_head;
+	const char *body_pos;
+	const char *next_match;
+
+	/*
+	 * Due to the nature of unput, we must work
+	 * backwards through the macro body performing
+	 * any expansions.
+	 */
+	body_head = macro_symbol->info.macroinfo->body;
+	body_pos = body_head + strlen(body_head);
+	while (body_pos > body_head) {
+		regmatch_t match;
+
+		next_match = body_head;
+		match_marg = NULL;
+		next_substitution(macro_symbol, body_pos, &next_match,
+				  &match_marg, &match);
+
+		/* Put back everything up until the replacement. */
+		while (body_pos > next_match)
+			unput(*--body_pos);
+
+		/* Perform the replacement. */
+		if (match_marg != NULL) {
+			const char *strp;
+
+			next_match = match_marg->replacement_text;
+			strp = next_match + strlen(next_match);
+			while (strp > next_match)
+				unput(*--strp);
+
+			/* Skip past the unexpanded macro arg. */
+			body_pos -= match.rm_eo - match.rm_so;
+		}
+	}
+
+	/* Cleanup replacement text. */
+	STAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
+		free(marg->replacement_text);
+	}
+}
+
+/*
+ * Find the next substitution in the macro working backwards from
+ * body_pos until the beginning of the macro buffer.  next_match
+ * should be initialized to the beginning of the macro buffer prior
+ * to calling this routine.
+ */
+static void
+next_substitution(struct symbol *mac_symbol, const char *body_pos,
+		  const char **next_match, struct macro_arg **match_marg,
+		  regmatch_t *match)
+{
+	regmatch_t	  matches[2];
+	struct macro_arg *marg;
+	const char	 *search_pos;
+	int		  retval;
+
+	do {
+		search_pos = *next_match;
+
+		STAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {
+
+			retval = regexec(&marg->arg_regex, search_pos, 2,
+					 matches, 0);
+			if (retval == 0
+			 && (matches[1].rm_eo + search_pos) <= body_pos
+			 && (matches[1].rm_eo + search_pos) > *next_match) {
+				*match = matches[1];
+				*next_match = match->rm_eo + search_pos;
+				*match_marg = marg;
+			}
+		}
+	} while (search_pos != *next_match);
+}
+
+int
+yywrap()
+{
+	include_t *include;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER);
+	(void)fclose(yyin);
+	if (yyfilename != NULL)
+		free(yyfilename);
+	yyfilename = NULL;
+	include = include_stack.slh_first;
+	if (include != NULL) {
+		yy_switch_to_buffer(include->buffer);
+		yylineno = include->lineno;
+		yyfilename = include->filename;
+		SLIST_REMOVE_HEAD(&include_stack, links);
+		free(include);
+		return (0);
+	}
+	return (1);
+}
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l	2002-09-16 14:45:12.000000000 -0600
@@ -3,7 +3,7 @@
  * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.
  *
  * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,11 +38,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#10 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#17 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.13.2.3 2001/07/28 18:46:44 gibbs Exp $
+ * $FreeBSD$
  */
 
+#include <inttypes.h>
 #include <sys/types.h>
 
 #include <limits.h>
@@ -131,6 +132,7 @@
 			}
 
 VERSION			{ return T_VERSION; }
+PREFIX			{ return T_PREFIX; }
 PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
 \"			{
 				string_buf_ptr = string_buf;
@@ -173,7 +175,8 @@
 END_CRITICAL		{ return T_END_CS; }
 SET_SRC_MODE		{ return T_SET_SRC_MODE; }
 SET_DST_MODE		{ return T_SET_DST_MODE; }
-bit			{ return T_BIT; }
+field			{ return T_FIELD; }
+enum			{ return T_ENUM; }
 mask			{ return T_MASK; }
 alias			{ return T_ALIAS; }
 size			{ return T_SIZE; }
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c	2002-09-16 14:45:12.000000000 -0600
@@ -2,6 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler symbol table implementation
  *
  * Copyright (c) 1997 Justin T. Gibbs.
+ * Copyright (c) 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,11 +37,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#13 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#22 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.11 2000/09/22 22:19:54 gibbs Exp $
+ * $FreeBSD$
  */
 
+#include <inttypes.h>
 #include <sys/types.h>
 
 #ifdef __linux__
@@ -72,6 +74,8 @@
 	}
 	memset(new_symbol, 0, sizeof(*new_symbol));
 	new_symbol->name = strdup(name);
+	if (new_symbol->name == NULL)
+		 stop("Unable to strdup symbol name", EX_SOFTWARE);
 	new_symbol->type = UNINITIALIZED;
 	return (new_symbol);
 }
@@ -98,10 +102,12 @@
 			free(symbol->info.ainfo);
 		break;
 	case MASK:
-	case BIT:
-		if (symbol->info.minfo != NULL) {
-			symlist_free(&symbol->info.minfo->symrefs);
-			free(symbol->info.minfo);
+	case FIELD:
+	case ENUM:
+	case ENUM_ENTRY:
+		if (symbol->info.finfo != NULL) {
+			symlist_free(&symbol->info.finfo->symrefs);
+			free(symbol->info.finfo);
 		}
 		break;
 	case DOWNLOAD_CONST:
@@ -222,17 +228,19 @@
 	newnode->symbol = symbol;
 	if (how == SYMLIST_SORT) {
 		symbol_node_t *curnode;
-		int mask;
+		int field;
 
-		mask = FALSE;
+		field = FALSE;
 		switch(symbol->type) {
 		case REGISTER:
 		case SCBLOC:
 		case SRAMLOC:
 			break;
-		case BIT:
+		case FIELD:
 		case MASK:
-			mask = TRUE;
+		case ENUM:
+		case ENUM_ENTRY:
+			field = TRUE;
 			break;
 		default:
 			stop("symlist_add: Invalid symbol type for sorting",
@@ -242,9 +250,12 @@
 
 		curnode = SLIST_FIRST(symlist);
 		if (curnode == NULL
-		 || (mask && (curnode->symbol->info.minfo->mask >
-		              newnode->symbol->info.minfo->mask))
-		 || (!mask && (curnode->symbol->info.rinfo->address >
+		 || (field
+		  && (curnode->symbol->type > newnode->symbol->type
+		   || (curnode->symbol->type == newnode->symbol->type
+		    && (curnode->symbol->info.finfo->value >
+			newnode->symbol->info.finfo->value))))
+		 || (!field && (curnode->symbol->info.rinfo->address >
 		               newnode->symbol->info.rinfo->address))) {
 			SLIST_INSERT_HEAD(symlist, newnode, links);
 			return;
@@ -259,10 +270,14 @@
 				symbol_t *cursymbol;
 
 				cursymbol = SLIST_NEXT(curnode, links)->symbol;
-				if ((mask && (cursymbol->info.minfo->mask >
-				              symbol->info.minfo->mask))
-				 || (!mask &&(cursymbol->info.rinfo->address >
-				              symbol->info.rinfo->address))){
+				if ((field
+		  		  && (cursymbol->type > symbol->type
+				   || (cursymbol->type == symbol->type
+				    && (cursymbol->info.finfo->value >
+					symbol->info.finfo->value))))
+				 || (!field
+				   && (cursymbol->info.rinfo->address >
+				       symbol->info.rinfo->address))) {
 					SLIST_INSERT_AFTER(curnode, newnode,
 							   links);
 					break;
@@ -307,20 +322,160 @@
 }
 
 void
-symtable_dump(FILE *ofile)
+aic_print_file_prologue(FILE *ofile)
+{
+
+	if (ofile == NULL)
+		return;
+
+	fprintf(ofile,
+"/*\n"
+" * DO NOT EDIT - This file is automatically generated\n"
+" *		 from the following source files:\n"
+" *\n"
+"%s */\n",
+		versions);
+}
+
+void
+aic_print_include(FILE *dfile, char *include_file)
+{
+
+	if (dfile == NULL)
+		return;
+	fprintf(dfile, "\n#include \"%s\"\n\n", include_file);
+}
+
+void
+aic_print_reg_dump_types(FILE *ofile)
+{
+	if (ofile == NULL)
+		return;
+		
+	fprintf(ofile,
+"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"
+"typedef struct %sreg_parse_entry {\n"
+"	char	*name;\n"
+"	uint8_t	 value;\n"
+"	uint8_t	 mask;\n"
+"} %sreg_parse_entry_t;\n"
+"\n",
+		prefix, prefix, prefix);
+}
+
+static void
+aic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)
+{
+	if (dfile == NULL)
+		return;
+
+	fprintf(dfile,
+"static %sreg_parse_entry_t %s_parse_table[] = {\n",
+		prefix,
+		regnode->symbol->name);
+}
+
+static void
+aic_print_reg_dump_end(FILE *ofile, FILE *dfile,
+		       symbol_node_t *regnode, u_int num_entries)
+{
+	char *lower_name;
+	char *letter;
+
+	lower_name = strdup(regnode->symbol->name);
+	if (lower_name == NULL)
+		 stop("Unable to strdup symbol name", EX_SOFTWARE);
+	
+	for (letter = lower_name; *letter != '\0'; letter++)
+		*letter = tolower(*letter);
+
+	if (dfile != NULL) {
+		if (num_entries != 0)
+			fprintf(dfile,
+"\n"
+"};\n"
+"\n");
+
+		fprintf(dfile,
+"int\n"
+"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"
+"{\n"
+"	return (%sprint_register(%s%s, %d, \"%s\",\n"
+"	    0x%02x, regvalue, cur_col, wrap));\n"
+"}\n"
+"\n",
+			prefix,
+			lower_name,
+			prefix,
+			num_entries != 0 ? regnode->symbol->name : "NULL",
+			num_entries != 0 ? "_parse_table" : "",
+			num_entries,
+			regnode->symbol->name,
+			regnode->symbol->info.rinfo->address);
+	}
+
+	fprintf(ofile,
+"#if AIC_DEBUG_REGISTERS\n"
+"%sreg_print_t %s%s_print;\n"
+"#else\n"
+"#define %s%s_print(regvalue, cur_col, wrap) \\\n"
+"    %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"
+"#endif\n"
+"\n",
+		prefix,
+		prefix,
+		lower_name,
+		prefix,
+		lower_name,
+		prefix,
+		regnode->symbol->name,
+		regnode->symbol->info.rinfo->address);
+}
+
+static void
+aic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)
+{
+	int num_tabs;
+
+	if (dfile == NULL)
+		return;
+
+	fprintf(dfile,
+"	{ \"%s\",",
+		curnode->symbol->name);
+
+	num_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;
+
+	while (num_tabs-- > 0)
+		fputc('\t', dfile);
+	fprintf(dfile, "0x%02x, 0x%02x }",
+		curnode->symbol->info.finfo->value,
+		curnode->symbol->info.finfo->mask);
+}
+
+void
+symtable_dump(FILE *ofile, FILE *dfile)
 {
 	/*
 	 * Sort the registers by address with a simple insertion sort.
 	 * Put bitmasks next to the first register that defines them.
 	 * Put constants at the end.
 	 */
-	symlist_t registers;
-	symlist_t masks;
-	symlist_t constants;
-	symlist_t download_constants;
-	symlist_t aliases;
-	symlist_t exported_labels;
-	u_int	  i;
+	symlist_t	 registers;
+	symlist_t	 masks;
+	symlist_t	 constants;
+	symlist_t	 download_constants;
+	symlist_t	 aliases;
+	symlist_t	 exported_labels;
+	symbol_node_t	*curnode;
+	symbol_node_t	*regnode;
+	DBT		 key;
+	DBT		 data;
+	int		 flag;
+	u_int		 i;
+
+	if (symtable == NULL)
+		return;
 
 	SLIST_INIT(&registers);
 	SLIST_INIT(&masks);
@@ -328,173 +483,195 @@
 	SLIST_INIT(&download_constants);
 	SLIST_INIT(&aliases);
 	SLIST_INIT(&exported_labels);
+	flag = R_FIRST;
+	while (symtable->seq(symtable, &key, &data, flag) == 0) {
+		symbol_t *cursym;
 
-	if (symtable != NULL) {
-		DBT	 key;
-		DBT	 data;
-		int	 flag = R_FIRST;
+		memcpy(&cursym, data.data, sizeof(cursym));
+		switch(cursym->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+			symlist_add(&registers, cursym, SYMLIST_SORT);
+			break;
+		case MASK:
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			symlist_add(&masks, cursym, SYMLIST_SORT);
+			break;
+		case CONST:
+			symlist_add(&constants, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case DOWNLOAD_CONST:
+			symlist_add(&download_constants, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case ALIAS:
+			symlist_add(&aliases, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case LABEL:
+			if (cursym->info.linfo->exported == 0)
+				break;
+			symlist_add(&exported_labels, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		default:
+			break;
+		}
+		flag = R_NEXT;
+	}
 
-		while (symtable->seq(symtable, &key, &data, flag) == 0) {
-			symbol_t *cursym;
+	/* Register dianostic functions/declarations first. */
+	aic_print_file_prologue(ofile);
+	aic_print_reg_dump_types(ofile);
+	aic_print_file_prologue(dfile);
+	aic_print_include(dfile, stock_include_file);
+	SLIST_FOREACH(curnode, &registers, links) {
 
-			memcpy(&cursym, data.data, sizeof(cursym));
-			switch(cursym->type) {
-			case REGISTER:
-			case SCBLOC:
-			case SRAMLOC:
-				symlist_add(&registers, cursym, SYMLIST_SORT);
-				break;
-			case MASK:
-			case BIT:
-				symlist_add(&masks, cursym, SYMLIST_SORT);
-				break;
-			case CONST:
-				symlist_add(&constants, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case DOWNLOAD_CONST:
-				symlist_add(&download_constants, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case ALIAS:
-				symlist_add(&aliases, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case LABEL:
-				if (cursym->info.linfo->exported == 0)
-					break;
-				symlist_add(&exported_labels, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			default:
-				break;
+		switch(curnode->symbol->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+		{
+			symlist_t	*fields;
+			symbol_node_t	*fieldnode;
+			int		 num_entries;
+
+			num_entries = 0;
+			fields = &curnode->symbol->info.rinfo->fields;
+			SLIST_FOREACH(fieldnode, fields, links) {
+				if (num_entries == 0)
+					aic_print_reg_dump_start(dfile,
+								 curnode);
+				else
+					fputs(",\n", dfile);
+				num_entries++;
+				aic_print_reg_dump_entry(dfile, fieldnode);
 			}
-			flag = R_NEXT;
+			aic_print_reg_dump_end(ofile, dfile,
+					       curnode, num_entries);
+		}
+		default:
+			break;
 		}
+	}
 
-		/* Put in the masks and bits */
-		while (SLIST_FIRST(&masks) != NULL) {
-			symbol_node_t *curnode;
-			symbol_node_t *regnode;
-			char *regname;
+	/* Fold in the masks and bits */
+	while (SLIST_FIRST(&masks) != NULL) {
+		char *regname;
 
-			curnode = SLIST_FIRST(&masks);
-			SLIST_REMOVE_HEAD(&masks, links);
+		curnode = SLIST_FIRST(&masks);
+		SLIST_REMOVE_HEAD(&masks, links);
 
-			regnode =
-			    SLIST_FIRST(&curnode->symbol->info.minfo->symrefs);
-			regname = regnode->symbol->name;
-			regnode = symlist_search(&registers, regname);
-			SLIST_INSERT_AFTER(regnode, curnode, links);
-		}
+		regnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);
+		regname = regnode->symbol->name;
+		regnode = symlist_search(&registers, regname);
+		SLIST_INSERT_AFTER(regnode, curnode, links);
+	}
 
-		/* Add the aliases */
-		while (SLIST_FIRST(&aliases) != NULL) {
-			symbol_node_t *curnode;
-			symbol_node_t *regnode;
-			char *regname;
+	/* Add the aliases */
+	while (SLIST_FIRST(&aliases) != NULL) {
+		char *regname;
 
-			curnode = SLIST_FIRST(&aliases);
-			SLIST_REMOVE_HEAD(&aliases, links);
+		curnode = SLIST_FIRST(&aliases);
+		SLIST_REMOVE_HEAD(&aliases, links);
 
-			regname = curnode->symbol->info.ainfo->parent->name;
-			regnode = symlist_search(&registers, regname);
-			SLIST_INSERT_AFTER(regnode, curnode, links);
-		}
+		regname = curnode->symbol->info.ainfo->parent->name;
+		regnode = symlist_search(&registers, regname);
+		SLIST_INSERT_AFTER(regnode, curnode, links);
+	}
 
-		/* Output what we have */
-		fprintf(ofile,
-"/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
-%s */\n", versions);
-		while (SLIST_FIRST(&registers) != NULL) {
-			symbol_node_t *curnode;
-			u_int value;
-			char *tab_str;
-			char *tab_str2;
-
-			curnode = SLIST_FIRST(&registers);
-			SLIST_REMOVE_HEAD(&registers, links);
-			switch(curnode->symbol->type) {
-			case REGISTER:
-			case SCBLOC:
-			case SRAMLOC:
-				fprintf(ofile, "\n");
-				value = curnode->symbol->info.rinfo->address;
-				tab_str = "\t";
-				tab_str2 = "\t\t";
-				break;
-			case ALIAS:
-			{
-				symbol_t *parent;
-
-				parent = curnode->symbol->info.ainfo->parent;
-				value = parent->info.rinfo->address;
-				tab_str = "\t";
-				tab_str2 = "\t\t";
-				break;
-			}
-			case MASK:
-			case BIT:
-				value = curnode->symbol->info.minfo->mask;
-				tab_str = "\t\t";
-				tab_str2 = "\t";
-				break;
-			default:
-				value = 0; /* Quiet compiler */
-				tab_str = NULL;
-				tab_str2 = NULL;
-				stop("symtable_dump: Invalid symbol type "
-				     "encountered", EX_SOFTWARE);
-				break;
-			}
-			fprintf(ofile, "#define%s%-16s%s0x%02x\n",
-				tab_str, curnode->symbol->name, tab_str2,
-				value);
-			free(curnode);
-		}
-		fprintf(ofile, "\n\n");
-
-		while (SLIST_FIRST(&constants) != NULL) {
-			symbol_node_t *curnode;
-
-			curnode = SLIST_FIRST(&constants);
-			SLIST_REMOVE_HEAD(&constants, links);
-			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.cinfo->value);
-			free(curnode);
+	/* Output generated #defines. */
+	while (SLIST_FIRST(&registers) != NULL) {
+		symbol_node_t *curnode;
+		u_int value;
+		char *tab_str;
+		char *tab_str2;
+
+		curnode = SLIST_FIRST(&registers);
+		SLIST_REMOVE_HEAD(&registers, links);
+		switch(curnode->symbol->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+			fprintf(ofile, "\n");
+			value = curnode->symbol->info.rinfo->address;
+			tab_str = "\t";
+			tab_str2 = "\t\t";
+			break;
+		case ALIAS:
+		{
+			symbol_t *parent;
+
+			parent = curnode->symbol->info.ainfo->parent;
+			value = parent->info.rinfo->address;
+			tab_str = "\t";
+			tab_str2 = "\t\t";
+			break;
 		}
+		case MASK:
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			value = curnode->symbol->info.finfo->value;
+			tab_str = "\t\t";
+			tab_str2 = "\t";
+			break;
+		default:
+			value = 0; /* Quiet compiler */
+			tab_str = NULL;
+			tab_str2 = NULL;
+			stop("symtable_dump: Invalid symbol type "
+			     "encountered", EX_SOFTWARE);
+			break;
+		}
+		fprintf(ofile, "#define%s%-16s%s0x%02x\n",
+			tab_str, curnode->symbol->name, tab_str2,
+			value);
+		free(curnode);
+	}
+	fprintf(ofile, "\n\n");
 
-		
-		fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
+	while (SLIST_FIRST(&constants) != NULL) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&constants);
+		SLIST_REMOVE_HEAD(&constants, links);
+		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.cinfo->value);
+		free(curnode);
+	}
 
-		for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
-			symbol_node_t *curnode;
+	
+	fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
 
-			curnode = SLIST_FIRST(&download_constants);
-			SLIST_REMOVE_HEAD(&download_constants, links);
-			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.cinfo->value);
-			free(curnode);
-		}
-		fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);
-
-		fprintf(ofile, "\n\n/* Exported Labels */\n");
-
-		while (SLIST_FIRST(&exported_labels) != NULL) {
-			symbol_node_t *curnode;
-
-			curnode = SLIST_FIRST(&exported_labels);
-			SLIST_REMOVE_HEAD(&exported_labels, links);
-			fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.linfo->address);
-			free(curnode);
-		}
+	for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&download_constants);
+		SLIST_REMOVE_HEAD(&download_constants, links);
+		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.cinfo->value);
+		free(curnode);
+	}
+	fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);
+
+	fprintf(ofile, "\n\n/* Exported Labels */\n");
+
+	while (SLIST_FIRST(&exported_labels) != NULL) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&exported_labels);
+		SLIST_REMOVE_HEAD(&exported_labels, links);
+		fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.linfo->address);
+		free(curnode);
 	}
 }
 
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h	2002-09-11 15:08:12.000000000 -0600
@@ -2,6 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler symbol table definitions
  *
  * Copyright (c) 1997 Justin T. Gibbs.
+ * Copyright (c) 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#10 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#17 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.h,v 1.11 2000/09/22 22:19:55 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -53,8 +54,10 @@
 	ALIAS,
 	SCBLOC,
 	SRAMLOC,
+	ENUM_ENTRY,
+	FIELD,
 	MASK,
-	BIT,
+	ENUM,
 	CONST,
 	DOWNLOAD_CONST,
 	LABEL,
@@ -68,20 +71,22 @@
 	RW = 0x03
 }amode_t;
 
+typedef SLIST_HEAD(symlist, symbol_node) symlist_t;
+
 struct reg_info {
-	u_int	 address;
-	int	 size;
-	amode_t	 mode;
-	u_int8_t valid_bitmask;
-	u_int8_t modes;
-	int	 typecheck_masks;
+	u_int	  address;
+	int	  size;
+	amode_t	  mode;
+	symlist_t fields;
+	uint8_t	  valid_bitmask;
+	uint8_t	  modes;
+	int	  typecheck_masks;
 };
 
-typedef SLIST_HEAD(symlist, symbol_node) symlist_t;
-
-struct mask_info {
+struct field_info {
 	symlist_t symrefs;
-	u_int8_t mask;
+	uint8_t	  value;
+	uint8_t	  mask;
 };
 
 struct const_info {
@@ -125,7 +130,7 @@
 	symtype	type;
 	union	{
 		struct reg_info	  *rinfo;
-		struct mask_info  *minfo;
+		struct field_info *finfo;
 		struct const_info *cinfo;
 		struct alias_info *ainfo;
 		struct label_info *linfo;
@@ -178,25 +183,25 @@
 SLIST_HEAD(scope_list, scope);
 TAILQ_HEAD(scope_tailq, scope);
 
-void	symbol_delete __P((symbol_t *symbol));
+void	symbol_delete(symbol_t *symbol);
 
-void	symtable_open __P((void));
+void	symtable_open(void);
 
-void	symtable_close __P((void));
+void	symtable_close(void);
 
 symbol_t *
-	symtable_get __P((char *name));
+	symtable_get(char *name);
 
 symbol_node_t *
-	symlist_search __P((symlist_t *symlist, char *symname));
+	symlist_search(symlist_t *symlist, char *symname);
 
 void
-	symlist_add __P((symlist_t *symlist, symbol_t *symbol, int how));
+	symlist_add(symlist_t *symlist, symbol_t *symbol, int how);
 #define SYMLIST_INSERT_HEAD	0x00
 #define SYMLIST_SORT		0x01
 
-void	symlist_free __P((symlist_t *symlist));
+void	symlist_free(symlist_t *symlist);
 
-void	symlist_merge __P((symlist_t *symlist_dest, symlist_t *symlist_src1,
-			   symlist_t *symlist_src2));
-void	symtable_dump __P((FILE *ofile));
+void	symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
+		      symlist_t *symlist_src2);
+void	symtable_dump(FILE *ofile, FILE *dfile);
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicdb.h linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicdb.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/aicasm/aicdb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/aicasm/aicdb.h	2002-09-04 23:41:38.000000000 -0600
@@ -0,0 +1 @@
+#include <db3/db_185.h>
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/cam.h linux-2.4.20/drivers/scsi/aic7xxx/cam.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/cam.h	2001-10-25 14:53:49.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/cam.h	2002-09-11 15:08:12.000000000 -0600
@@ -29,7 +29,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#11 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#13 $
  */
 
 #ifndef _AIC7XXX_CAM_H
@@ -81,6 +81,8 @@
 	CAM_DATA_RUN_ERR	= DID_ERROR,
 	/* Unexpected Bus Free */
 	CAM_UNEXP_BUSFREE	= DID_ERROR,
+	/* Protocol Violation */
+	CAM_SEQUENCE_FAIL	= DID_ERROR,
 	/* CCB length supplied is inadequate */
 	CAM_CCB_LEN_ERR		= DID_ERROR,
 	/* Unable to provide requested capability */
@@ -101,7 +103,7 @@
 	 * requests for the target at the sim level
 	 * back into the XPT queue.
 	 */
-	CAM_REQUEUE_REQ		= DID_BUS_BUSY,
+	CAM_REQUEUE_REQ		= 0x3E, /* Another unsued value.*/
 
 	CAM_STATUS_MASK		= 0x3F
 } cam_status;
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/Config.in linux-2.4.20/drivers/scsi/aic7xxx/Config.in
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/Config.in	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/Config.in	2002-09-24 15:05:58.000000000 -0600
@@ -2,7 +2,7 @@
    dep_tristate 'Adaptec AIC7xxx support' CONFIG_SCSI_AIC7XXX $CONFIG_SCSI
    if [ "$CONFIG_SCSI_AIC7XXX" != "n" ]; then
       int  '  Maximum number of TCQ commands per device' \
-	CONFIG_AIC7XXX_CMDS_PER_DEVICE 253
+	CONFIG_AIC7XXX_CMDS_PER_DEVICE 32
       int  '  Initial bus reset delay in milli-seconds' \
 	CONFIG_AIC7XXX_RESET_DELAY_MS 15000
       bool  '  Probe for EISA and VL AIC7XXX Adapters' \
@@ -11,3 +11,18 @@
 	CONFIG_AIC7XXX_BUILD_FIRMWARE
    fi
 fi
+dep_tristate 'Adaptec AIC79xx support' CONFIG_SCSI_AIC79XX $CONFIG_SCSI
+if [ "$CONFIG_SCSI_AIC79XX" != "n" ]; then
+   int  '  Maximum number of TCQ commands per device' \
+	CONFIG_AIC79XX_CMDS_PER_DEVICE 32
+   int  '  Initial bus reset delay in milli-seconds' \
+	CONFIG_AIC79XX_RESET_DELAY_MS 15000
+   bool  '  Build Adapter Firmware with Kernel Build' \
+	CONFIG_AIC79XX_BUILD_FIRMWARE
+   bool  '  Enable Read Streaming for All Targets' \
+	CONFIG_AIC79XX_ENABLE_RD_STRM
+   bool  '  Compile in Debugging Code' \
+	CONFIG_AIC79XX_DEBUG_ENABLE
+   int  '  Debug code enable mask (16384 for all debugging)' \
+	CONFIG_AIC79XX_DEBUG_MASK 0
+fi
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/Configure.help linux-2.4.20/drivers/scsi/aic7xxx/Configure.help
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/Configure.help	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/Configure.help	2002-09-11 15:08:11.000000000 -0600
@@ -0,0 +1,17477 @@
+# Maintained by Axel Boldt (axel@uni-paderborn.de)
+#
+# This version of the Linux kernel configuration help texts
+# corresponds to the kernel versions 2.3.x.
+#
+# Translations of this file available on the WWW:
+#
+#   - Japanese, maintained by the JF Project (JF@linux.or.jp), at
+#     http://www.linux.or.jp/JF/JFdocs/Configure.help/
+#   - Russian, by kaf@linux.nevod.perm.su, at
+#     http://nevod.perm.su/service/linux/doc/kernel/Configure.help
+#   - French, by Pierre Tane (tanep@bigfoot.com), at
+#     http://www.traduc.org/kernelfr
+#   - Spanish, by Carlos Perell Marn (fperllo@ehome.encis.es), at
+#     http://visar.csustan.edu/~carlos/
+#   - Italian, by Alessandro Rubini (rubini@linux.it), at
+#     ftp://ftp-pavia1.linux.it/pub/linux/Configure.help
+#   - Polish, by Cezar Cichocki (cezar@cs.net.pl), at
+#     http://www.cs.net.pl/~cezar/Kernel
+#   - German, by SuSE, at http://www.suse.de/~ke/kernel . This patch
+#     also includes infrastructure to support different languages.
+#
+# To access a document on the WWW, you need to have a direct Internet
+# connection and a browser program such as netscape or lynx. If you
+# only have email access, you can still use FTP and WWW servers: send
+# an email to mail-server@rtfm.mit.edu with the text 
+#   send usenet/news.answers/internet-services/access-via-email 
+# in the body of the message.
+#
+# Information about what a kernel is, what it does, how to patch and
+# compile it and much more is contained in the Kernel-HOWTO, available
+# at http://www.linuxdoc.org/docs.html#howto . Before you start
+# compiling, make sure that you have the necessary versions of all
+# programs and libraries required to compile and run this kernel; they
+# are listed in the file Documentation/Changes. Make sure to read the
+# toplevel kernel README file as well.
+#
+# Format of this file: description<nl>variable<nl>help text<nl><nl>. If
+# the question being documented is of type "choice", we list only the
+# first occurring config variable. The help texts may contain empty
+# lines, but every non-empty line must be indented two positions.
+# Order of the help texts does not matter, however, no variable should
+# be documented twice: if it is, only the first occurrence will be
+# used by Configure. We try to keep the help texts of related variables
+# close together. Lines starting with `#' are ignored. To be nice to
+# menuconfig, limit your line length to 70 characters. Use emacs'
+# kfill.el to edit and ispell.el to spell check this file or you lose.
+#
+# If you add a help text to this file, please try to be as gentle as
+# possible. Don't use unexplained acronyms and generally write for the
+# hypothetical ignorant but intelligent user who has just bought a PC,
+# removed Windows, installed Linux and is now recompiling the kernel
+# for the first time. Tell them what to do if they're unsure. Technical 
+# information should go in a README in the Documentation directory.
+# Mention all the relevant READMEs and HOWTOs in the help text.
+# Repetitions are fine since the help texts are not meant to be read
+# in sequence.
+#
+# All this was shamelessly stolen from several different sources. Many
+# thanks to all the contributors. Feel free to use these help texts in
+# your own kernel configuration tools. The texts are copyrighted (c)
+# 1995-2000 by Axel Boldt and many others and are governed by the GNU
+# General Public License.
+
+Prompt for development and/or incomplete code/drivers
+CONFIG_EXPERIMENTAL
+  Some of the various things that Linux supports (such as network 
+  drivers, file systems, network protocols, etc.) can be in a state 
+  of development where the functionality, stability, or the level of 
+  testing is not yet high enough for general use. This is usually
+  known as the "alpha-test" phase amongst developers. If a feature is
+  currently in alpha-test, then the developers usually discourage 
+  uninformed widespread use of this feature by the general public to
+  avoid "Why doesn't this work?" type mail messages. However, active
+  testing and use of these systems is welcomed. Just be aware that it
+  may not meet the normal level of reliability or it may fail to work
+  in some special cases. Detailed bug reports from people familiar
+  with the kernel internals are usually welcomed by the developers
+  (before submitting bug reports, please read the documents README,
+  MAINTAINERS, REPORTING-BUGS, Documentation/BUG-HUNTING, and
+  Documentation/oops-tracing.txt in the kernel source). 
+
+  This option will also make obsoleted drivers available. These are
+  drivers that have been replaced by something else, and/or are
+  scheduled to be removed in a future kernel release.
+
+  Unless you intend to help test and develop a feature or driver that
+  falls into this category, or you have a situation that requires
+  using these features, you should probably say N here, which will
+  cause this configure script to present you with fewer choices. If
+  you say Y here, you will be offered the choice of using features or
+  drivers that are currently considered to be in the alpha-test phase.
+
+Symmetric Multi Processing
+CONFIG_SMP
+  This enables support for systems with more than one CPU. If you have
+  a system with only one CPU, like most personal computers, say N. If
+  you have a system with more than one CPU, say Y.
+
+  If you say N here, the kernel will run on single and multiprocessor
+  machines, but will use only one CPU of a multiprocessor machine. If
+  you say Y here, the kernel will run on many, but not all,
+  singleprocessor machines. On a singleprocessor machine, the kernel
+  will run faster if you say N here.
+
+  Note that if you say Y here and choose architecture "586" or
+  "Pentium" under "Processor family", the kernel will not work on 486
+  architectures. Similarly, multiprocessor kernels for the "PPro"
+  architecture may not work on all Pentium based boards.
+
+  People using multiprocessor machines who say Y here should also say
+  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
+  Management" code will be disabled if you say Y here.
+
+  See also the files Documentation/smp.tex, Documentation/smp.txt,
+  Documentation/i386/IO-APIC.txt, Documentation/nmi_watchdog.txt and the 
+  SMP-FAQ on the WWW at http://www.irisa.fr/prive/mentre/smp-faq/ .
+  
+  If you don't know what to do here, say N.
+  
+APIC and IO-APIC Support on Uniprocessors
+CONFIG_X86_UP_IOAPIC
+  APIC (Advanced Programmable Interrupt Controller) is a scheme for
+  delivering hardware interrupt requests to the CPU. It is commonly
+  used on systems with several CPU's. If you have a single-CPU system
+  which uses APIC, you can say Y here to use it. If you say Y here
+  even though your machine doesn't have APIC, then the kernel will
+  still run with no slowdown at all.
+
+  If you have system with several CPU's, you do not need to say Y
+  here: APIC will be used automatically.
+
+Kernel math emulation
+CONFIG_MATH_EMULATION
+  Linux can emulate a math coprocessor (used for floating point
+  operations) if you don't have one. 486DX and Pentium processors have
+  a math coprocessor built in, 486SX and 386 do not, unless you added
+  a 487DX or 387, respectively. (The messages during boot time can
+  give you some hints here ["man dmesg"].) Everyone needs either a
+  coprocessor or this emulation. 
+
+  If you don't have a math coprocessor, you need to say Y here; if you
+  say Y here even though you have a coprocessor, the coprocessor will
+  be used nevertheless. (This behavior can be changed with the kernel
+  command line option "no387", which comes handy if your coprocessor
+  is broken. Try "man bootparam" or see the documentation of your boot
+  loader (lilo or loadlin) about how to pass options to the kernel at
+  boot time.) This means that it is a good idea to say Y here if you
+  intend to use this kernel on different machines.
+
+  More information about the internals of the Linux math coprocessor
+  emulation can be found in arch/i386/math-emu/README.
+
+  If you are not sure, say Y; apart from resulting in a 66 KB bigger
+  kernel, it won't hurt.
+
+Timer and CPU usage LEDs
+CONFIG_LEDS
+  If you say Y here, the LEDs on your machine will be used
+  to provide useful information about your current system status.
+
+  If you are compiling a kernel for a NetWinder or EBSA-285, you will
+  be able to select which LEDs are active using the options below. If
+  you are compiling a kernel for the EBSA-110 or the LART however, the
+  red LED will simply flash regularly to indicate that the system is
+  still functional. It is safe to say Y here if you have a CATS
+  system, but the driver will do nothing.
+
+Timer LED
+CONFIG_LEDS_TIMER
+  If you say Y here, one of the system LEDs (the green one on the
+  NetWinder, the amber one on the EBSA285, or the red one on the LART)
+  will flash regularly to indicate that the system is still
+  operational. This is mainly useful to kernel hackers who are
+  debugging unstable kernels.
+
+  The LART uses the same LED for both Timer LED and CPU usage LED
+  functions. You may choose to use both, but the Timer LED function
+  will overrule the CPU usage LED.
+
+CPU usage LED
+CONFIG_LEDS_CPU
+  If you say Y here, the red LED will be used to give a good real
+  time indication of CPU usage, by lighting whenever the idle task
+  is not currently executing.
+
+  The LART uses the same LED for both Timer LED and CPU usage LED
+  functions. You may choose to use both, but the Timer LED function
+  will overrule the CPU usage LED.
+
+Kernel FP software completion (EXPERIMENTAL)
+CONFIG_MATHEMU
+  This option is required for IEEE compliant floating point arithmetic
+  on the Alpha. The only time you would ever not say Y is to say M in
+  order to debug the code. Say Y unless you know what you are doing.
+
+High Memory support
+CONFIG_NOHIGHMEM
+  Linux can use up to 64 Gigabytes of physical memory on x86 systems.
+  However, the address space of 32-bit x86 processors is only 4
+  Gigabytes large. That means that, if you have a large amount of
+  physical memory, not all of it can be "permanently mapped" by the
+  kernel. The physical memory that's not permanently mapped is called
+  "high memory".
+
+  If you are compiling a kernel which will never run on a machine with
+  more than 1 Gigabyte total physical RAM, answer "off" here (default
+  choice and suitable for most users). This will result in a "3GB/1GB"
+  split: 3GB are mapped so that each process sees a 3GB virtual memory
+  space and the remaining part of the 4GB virtual memory space is used
+  by the kernel to permanently map as much physical memory as
+  possible.
+
+  If the machine has between 1 and 4 Gigabytes physical RAM, then
+  answer "4GB" here.
+
+  If more than 4 Gigabytes is used then answer "64GB" here. This
+  selection turns Intel PAE (Physical Address Extension) mode on.
+  PAE implements 3-level paging on IA32 processors. PAE is fully
+  supported by Linux, PAE mode is implemented on all recent Intel
+  processors (Pentium Pro and better). NOTE: If you say "64GB" here,
+  then the kernel will not boot on CPUs that don't support PAE!
+
+  The actual amount of total physical memory will either be
+  auto detected or can be forced by using a kernel command line option
+  such as "mem=256M". (Try "man bootparam" or see the documentation of
+  your boot loader (lilo or loadlin) about how to pass options to the
+  kernel at boot time.) 
+
+  If unsure, say "off".
+
+Normal PC floppy disk support
+CONFIG_BLK_DEV_FD
+  If you want to use the floppy disk drive(s) of your PC under Linux,
+  say Y. Information about this driver, especially important for IBM
+  Thinkpad users, is contained in Documentation/floppy.txt. That file
+  also contains the location of the Floppy driver FAQ as well as
+  location of the fdutils package used to configure additional
+  parameters of the driver at run time.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called floppy.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Support for PowerMac floppy
+CONFIG_MAC_FLOPPY
+  If you have a SWIM-3 (Super Woz Integrated Machine 3; from Apple)
+  floppy controller, say Y here. Most commonly found in PowerMacs.
+
+RAM disk support
+CONFIG_BLK_DEV_RAM
+  Saying Y here will allow you to use a portion of your RAM memory as
+  a block device, so that you can make file systems on it, read and
+  write to it and do all the other things that you can do with normal
+  block devices (such as hard drives). It is usually used to load and
+  store a copy of a minimal root file system off of a floppy into RAM
+  during the initial install of Linux. 
+
+  Note that the kernel command line option "ramdisk=XX" is now
+  obsolete. For details, read Documentation/ramdisk.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. The module will be called
+  rd.o. 
+
+  Most normal users won't need the RAM disk functionality, and can
+  thus say N here.
+
+Initial RAM disk (initrd) support
+CONFIG_BLK_DEV_INITRD
+  The initial RAM disk is a RAM disk that is loaded by the boot loader
+  (loadlin or lilo) and that is mounted as root before the normal boot
+  procedure. It is typically used to load modules needed to mount the
+  "real" root file system, etc. See Documentation/initrd.txt for
+  details.
+
+Loop device support
+CONFIG_BLK_DEV_LOOP
+  Saying Y here will allow you to use a regular file as a block
+  device; you can then create a file system on that block device and
+  mount it just as you would mount other block devices such as hard
+  drive partitions, CDROM drives or floppy drives. The loop devices
+  are block special device files with major number 7 and typically
+  called /dev/loop0, /dev/loop1 etc.
+
+  This is useful if you want to check an ISO 9660 file system before
+  burning the CD, or if you want to use floppy images without first
+  writing them to floppy. Furthermore, some Linux distributions avoid
+  the need for a dedicated Linux partition by keeping their complete
+  root file system inside a DOS FAT file using this loop device
+  driver. 
+
+  The loop device driver can also be used to "hide" a file system in a
+  disk partition, floppy, or regular file, either using encryption
+  (scrambling the data) or steganography (hiding the data in the low
+  bits of, say, a sound file). This is also safe if the file resides
+  on a remote file server. If you want to do this, you will first have
+  to acquire and install a kernel patch from
+  ftp://ftp.kerneli.org/pub/kerneli/ , and then you need to
+  say Y to this option.
+
+  Note that alternative ways to use encrypted file systems are
+  provided by the cfs package, which can be gotten from
+  ftp://ftp.kerneli.org/pub/kerneli/net-source/ , and the newer tcfs
+  package, available at http://tcfs.dia.unisa.it/ . You do not need to
+  say Y here if you want to use one of these. However, using cfs
+  requires saying Y to "NFS file system support" below while using
+  tcfs requires applying a kernel patch. An alternative steganography
+  solution is provided by StegFS, also available from
+  ftp://ftp.kerneli.org/pub/kerneli/net-source/ .
+
+  To use the loop device, you need the losetup utility and a recent
+  version of the mount program, both contained in the util-linux
+  package. The location and current version number of util-linux is
+  contained in the file Documentation/Changes.
+
+  Note that this loop device has nothing to do with the loopback
+  device used for network connections from the machine to itself.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called loop.o.
+
+  Most users will answer N here.
+
+Network Block Device support
+CONFIG_BLK_DEV_NBD
+  Saying Y here will allow your computer to be a client for network
+  block devices, i.e. it will be able to use block devices exported by
+  servers (mount file systems on them etc.). Communication between
+  client and server works over TCP/IP networking, but to the client
+  program this is hidden: it looks like a regular local file access to
+  a block device special file such as /dev/nd0. 
+
+  Network block devices also allows you to run a block-device in
+  userland (making server and client physically the same computer,
+  communicating using the loopback network device).
+  
+  Read Documentation/nbd.txt for more information, especially about
+  where to find the server code, which runs in user space and does not
+  need special kernel support.
+
+  Note that this has nothing to do with the network file systems NFS
+  or Coda; you can say N here even if you intend to use NFS or Coda.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called nbd.o.
+
+  If unsure, say N.
+
+ATA/IDE/MFM/RLL support
+CONFIG_IDE
+  If you say Y here, your kernel will be able to manage low cost mass
+  storage units such as ATA/(E)IDE and ATAPI units. The most common
+  cases are IDE hard drives and ATAPI CDROM drives.
+
+  If your system is pure SCSI and doesn't use these interfaces, you
+  can say N here.
+ 
+  Integrated Disk Electronics (IDE aka ATA-1) is a connecting standard
+  for mass storage units such as hard disks. It was designed by
+  Western Digital and Compaq Computer in 1984. It was then named
+  ST506. Quite a number of disks use the IDE interface.
+	
+  AT Attachment (ATA) is the superset of the IDE specifications.
+  ST506 was also called ATA-1.
+
+  Fast-IDE is ATA-2 (also named Fast ATA), Enhanced IDE (EIDE) is
+  ATA-3. It provides support for larger disks (up to 8.4GB by means of
+  the LBA standard), more disks (4 instead of 2) and for other mass
+  storage units such as tapes and cdrom. UDMA/33 (aka UltraDMA/33) is
+  ATA-4 and provides faster (and more CPU friendly) transfer modes
+  than previous PIO (Programmed processor Input/Output) from previous
+  ATA/IDE standards by means of fast DMA controllers.
+
+  ATA Packet Interface (ATAPI) is a protocol used by EIDE tape and
+  CDROM drives, similar in many respects to the SCSI protocol.
+  
+  SMART IDE (Self Monitoring, Analysis and Reporting Technology) was
+  designed in order to prevent data corruption and disk crash by
+  detecting pre hardware failure conditions (heat, access time, and
+  the like...). Disks built since June 1995 may follow this
+  standard. The kernel itself don't manage this; however there are
+  quite a number of user programs such as smart that can query the
+  status of SMART parameters disk.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide.o.
+
+  For further information, please read Documentation/ide.txt.
+
+  If unsure, say Y.
+
+Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
+CONFIG_BLK_DEV_IDE
+  If you say Y here, you will use the full-featured IDE driver to
+  control up to ten ATA/IDE interfaces, each being able to serve a
+  "master" and a "slave" device, for a total of up to twenty ATA/IDE
+  disk/cdrom/tape/floppy drives.
+
+  Useful information about large (>540 MB) IDE disks, multiple
+  interfaces, what to do if ATA/IDE devices are not automatically
+  detected, sound card ATA/IDE ports, module support, and other
+  topics, is contained in Documentation/ide.txt. For detailed
+  information about hard drives, consult the Disk-HOWTO and the
+  Multi-Disk-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  To fine-tune ATA/IDE drive/interface parameters for improved
+  performance, look for the hdparm package at
+  ftp://metalab.unc.edu/pub/Linux/kernel/patches/diskdrives/ .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/ide.txt. The module will be called ide-mod.o. Do not
+  compile this driver as a module if your root file system (the one
+  containing the directory /) is located on an IDE device.
+
+  If you have one or more IDE drives, say Y or M here. If your system
+  has no IDE drives, or if memory requirements are really tight, you
+  could say N here, and select the "Old hard disk driver" below
+  instead to save about 13 KB of memory in the kernel.
+
+Old hard disk (MFM/RLL/IDE) driver
+CONFIG_BLK_DEV_HD_ONLY
+  There are two drivers for MFM/RLL/IDE hard disks. Most people use
+  the newer enhanced driver, but this old one is still around for two
+  reasons. Some older systems have strange timing problems and seem to
+  work only with the old driver (which itself does not work with some
+  newer systems). The other reason is that the old driver is smaller,
+  since it lacks the enhanced functionality of the new one. This makes
+  it a good choice for systems with very tight memory restrictions, or
+  for systems with only older MFM/RLL/ESDI drives. Choosing the old
+  driver can save 13 KB or so of kernel memory. 
+
+  If you are unsure, then just choose the Enhanced IDE/MFM/RLL driver
+  instead of this one. For more detailed information, read the
+  Disk-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+Use old disk-only driver on primary interface
+CONFIG_BLK_DEV_HD_IDE
+  There are two drivers for MFM/RLL/IDE disks. Most people use just
+  the new enhanced driver by itself. This option however installs the
+  old hard disk driver to control the primary IDE/disk interface in
+  the system, leaving the new enhanced IDE driver to take care of only
+  the 2nd/3rd/4th IDE interfaces. Doing this will prevent you from
+  having an IDE/ATAPI CDROM or tape drive connected to the primary IDE
+  interface. Choosing this option may be useful for older systems
+  which have MFM/RLL/ESDI controller+drives at the primary port
+  address (0x1f0), along with IDE drives at the secondary/3rd/4th port
+  addresses. 
+
+  Normally, just say N here; you will then use the new driver for all
+  4 interfaces.
+
+Include IDE/ATA-2 DISK support
+CONFIG_BLK_DEV_IDEDISK
+  This will include enhanced support for MFM/RLL/IDE hard disks. If
+  you have a MFM/RLL/IDE disk, and there is no special reason to use
+  the old hard disk driver instead, say Y. If you have an SCSI-only
+  system, you can say N here.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-disk.o. Do not compile this driver as a module if your
+  root file system (the one containing the directory /) is located on
+  the IDE disk. If unsure, say Y.
+
+Use multi-mode by default
+CONFIG_IDEDISK_MULTI_MODE
+  If you get this error, try to say Y here:
+
+  hda: set_multmode: status=0x51 { DriveReady SeekComplete Error }
+  hda: set_multmode: error=0x04 { DriveStatusError }
+
+  If in doubt, say N.
+
+Include IDE/ATAPI CDROM support
+CONFIG_BLK_DEV_IDECD
+  If you have a CDROM drive using the ATAPI protocol, say Y. ATAPI is
+  a newer protocol used by IDE CDROM and TAPE drives, similar to the
+  SCSI protocol. Most new CDROM drives use ATAPI, including the
+  NEC-260, Mitsumi FX400, Sony 55E, and just about all non-SCSI
+  double(2X) or better speed drives.
+
+  If you say Y here, the CDROM drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar (check the boot messages with dmesg). If this is your only
+  CDROM drive, you can say N to all other CDROM options, but be sure
+  to say Y or M to "ISO 9660 CDROM file system support".
+
+  Read the CDROM-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto and the file
+  Documentation/cdrom/ide-cd. Note that older versions of lilo (the
+  Linux boot loader) cannot properly deal with IDE/ATAPI CDROMs, so
+  install lilo-16 or higher, available from
+  ftp://metalab.unc.edu/pub/Linux/system/boot/lilo .
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-cd.o.
+
+Include IDE/ATAPI TAPE support
+CONFIG_BLK_DEV_IDETAPE
+  If you have an IDE tape drive using the ATAPI protocol, say Y.
+  ATAPI is a newer protocol used by IDE tape and CDROM drives, similar
+  to the SCSI protocol. If you have an SCSI tape drive however, you
+  can say N here.
+
+  You should also say Y if you have an OnStream DI-30 tape drive; this
+  will not work with the SCSI protocol, until there is support for the
+  SC-30 and SC-50 versions.
+
+  If you say Y here, the tape drive will be identified at boot time
+  along with other IDE devices, as "hdb" or "hdc", or something
+  similar, and will be mapped to a character device such as "ht0"
+  (check the boot messages with dmesg). Be sure to consult the
+  drivers/ide/ide-tape.c and Documentation/ide.txt files for usage
+  information.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-tape.o.
+
+Include IDE/ATAPI FLOPPY support
+CONFIG_BLK_DEV_IDEFLOPPY
+  If you have an IDE floppy drive which uses the ATAPI protocol,
+  answer Y. ATAPI is a newer protocol used by IDE CDROM/tape/floppy
+  drives, similar to the SCSI protocol. 
+
+  The LS-120 and the IDE/ATAPI Iomega ZIP drive are also supported by
+  this driver. For information about jumper settings and the question
+  of when a ZIP drive uses a partition table, see
+  http://www.win.tue.nl/~aeb/linux/zip/zip-1.html .
+  (ATAPI PD-CD/CDR drives are not supported by this driver; support
+  for PD-CD/CDR drives is available if you answer Y to 
+  "SCSI emulation support", below).
+
+  If you say Y here, the FLOPPY drive will be identified along with
+  other IDE devices, as "hdb" or "hdc", or something similar (check
+  the boot messages with dmesg).
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ide-floppy.o.
+
+SCSI emulation support
+CONFIG_BLK_DEV_IDESCSI
+  This will provide SCSI host adapter emulation for IDE ATAPI devices,
+  and will allow you to use a SCSI device driver instead of a native
+  ATAPI driver.
+
+  This is useful if you have an ATAPI device for which no native
+  driver has been written (for example, an ATAPI PD-CD or CDR drive);
+  you can then use this emulation together with an appropriate SCSI
+  device driver. In order to do this, say Y here and to "SCSI support"
+  and "SCSI generic support", below. You must then provide the kernel
+  command line "hdx=scsi" (try "man bootparam" or see the
+  documentation of your boot loader (lilo or loadlin) about how to
+  pass options to the kernel at boot time) for devices if you want the
+  native EIDE sub-drivers to skip over the native support, so that
+  this SCSI emulation can be used instead. This is required for use of
+  CD-RW's.
+
+  Note that this option does NOT allow you to attach SCSI devices to a
+  box that doesn't have a SCSI host adapter installed.
+
+  If both this SCSI emulation and native ATAPI support are compiled
+  into the kernel, the native support will be used.
+
+ISA-PNP EIDE support
+CONFIG_BLK_DEV_ISAPNP
+  If you have an ISA EIDE card that is PnP (Plug and Play) and
+  requires setup first before scanning for devices, say Y here.
+
+  If unsure, say N.
+
+CMD640 chipset bugfix/support
+CONFIG_BLK_DEV_CMD640
+  The CMD-Technologies CMD640 IDE chip is used on many common 486 and
+  Pentium motherboards, usually in combination with a "Neptune" or
+  "SiS" chipset. Unfortunately, it has a number of rather nasty
+  design flaws that can cause severe data corruption under many common
+  conditions. Say Y here to include code which tries to automatically
+  detect and correct the problems under Linux. This option also
+  enables access to the secondary IDE ports in some CMD640 based
+  systems. 
+
+  This driver will work automatically in PCI based systems (most new
+  systems have PCI slots). But if your system uses VESA local bus
+  (VLB) instead of PCI, you must also supply a kernel boot parameter
+  to enable the CMD640 bugfix/support: "ide0=cmd640_vlb". (Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel.)
+
+  The CMD640 chip is also used on add-in cards by Acculogic, and on
+  the "CSA-6400E PCI to IDE controller" that some people have. For
+  details, read Documentation/ide.txt. 
+
+CMD640 enhanced support
+CONFIG_BLK_DEV_CMD640_ENHANCED
+  This option includes support for setting/autotuning PIO modes and
+  prefetch on CMD640 IDE interfaces. For details, read
+  Documentation/ide.txt. If you have a CMD640 IDE interface and your
+  BIOS does not already do this for you, then say Y here. Otherwise
+  say N.
+
+RZ1000 chipset bugfix/support
+CONFIG_BLK_DEV_RZ1000
+  The PC-Technologies RZ1000 IDE chip is used on many common 486 and
+  Pentium motherboards, usually along with the "Neptune" chipset.
+  Unfortunately, it has a rather nasty design flaw that can cause
+  severe data corruption under many conditions. Say Y here to include
+  code which automatically detects and corrects the problem under
+  Linux. This may slow disk throughput by a few percent, but at least
+  things will operate 100% reliably. 
+
+Generic PCI IDE chipset support
+CONFIG_BLK_DEV_IDEPCI
+  Say Y here for PCI systems which use IDE drive(s).
+  This option helps the IDE driver to automatically detect and
+  configure all PCI-based IDE interfaces in your system.
+  
+Support for sharing PCI IDE interrupts
+CONFIG_IDEPCI_SHARE_IRQ
+  Some ATA/IDE chipsets have hardware support which allows for
+  sharing a single IRQ with other cards. To enable support for
+  this in the ATA/IDE driver, say Y here.
+
+  It is safe to say Y to this question, in most cases.
+  If unsure, say N.
+
+Generic PCI bus-master DMA support
+CONFIG_BLK_DEV_IDEDMA_PCI
+  If your PCI system uses IDE drive(s) (as opposed to SCSI, say) and
+  is capable of bus-master DMA operation (most Pentium PCI systems),
+  you will want to say Y here to reduce CPU overhead. You can then use
+  the "hdparm" utility to enable DMA for drives for which it was not
+  enabled automatically. By default, DMA is not enabled automatically
+  for these drives, but you can change that by saying Y to the
+  following question "Use DMA by default when available". You can get
+  the latest version of the hdparm utility from
+  ftp://metalab.unc.edu/pub/Linux/system/hardware/ .
+
+  Read the comments at the beginning of drivers/ide/ide-dma.c and
+  the file Documentation/ide.txt for more information.
+
+  It is safe to say Y to this question.
+
+Good-Bad DMA Model-Firmware (EXPERIMENTAL)
+CONFIG_IDEDMA_NEW_DRIVE_LISTINGS
+  If you say Y here, the model and firmware revision of your drive
+  will be compared against a blacklist of buggy drives that claim to
+  be (U)DMA capable but aren't. This is a blanket on/off test with no
+  speed limit options.
+
+  Straight GNU GCC 2.7.3/2.8.X compilers are known to be safe;
+  whereas, many versions of EGCS have a problem and miscompile if you
+  say Y here.
+
+  If in doubt, say N.
+
+Boot off-board chipsets first support
+CONFIG_BLK_DEV_OFFBOARD
+  Normally, IDE controllers built into the motherboard (on-board
+  controllers) are assigned to ide0 and ide1 while those on add-in PCI
+  cards (off-board controllers) are relegated to ide2 and ide3.
+  Answering Y here will allow you to reverse the situation, with
+  off-board controllers on ide0/1 and on-board controllers on ide2/3.
+  This can improve the usability of some boot managers such as lilo
+  when booting from a drive on an off-board controller.
+
+  If you say Y here, and you actually want to reverse the device scan
+  order as explained above, you also need to issue the kernel command
+  line option "ide=reverse". (Try "man bootparam" or see the
+  documentation of your boot loader (lilo or loadlin) about how to
+  pass options to the kernel at boot time.)
+
+  Note that, if you do this, the order of the hd* devices will be
+  rearranged which may require modification of fstab and other files.
+
+  If in doubt, say N.
+
+Use DMA by default when available
+CONFIG_IDEDMA_PCI_AUTO
+  Prior to kernel version 2.1.112, Linux used to automatically use
+  DMA for IDE drives and chipsets which support it. Due to concerns
+  about a couple of cases where buggy hardware may have caused damage,
+  the default is now to NOT use DMA automatically. To revert to the
+  previous behaviour, say Y to this question.
+
+  If you suspect your hardware is at all flakey, say N here.
+  Do NOT email the IDE kernel people regarding this issue!
+
+  It is normally safe to answer Y to this question unless your
+  motherboard uses a VIA VP2 chipset, in which case you should say N.
+
+IGNORE word93 Validation BITS
+CONFIG_IDEDMA_IVB
+  Since various rules were applied and created ... et al. as it relates
+  the detection of vaild cable signals.  This is a result of unclear terms
+  in ATA-4 and ATA-5 standards.
+
+  It is normally safe to answer Y; however, the default is N.
+
+Various ATA, Work(s) In Progress (EXPERIMENTAL)
+CONFIG_IDEDMA_PCI_WIP
+  If you enable this you will be able to use and test highly
+  developmental projects. If you say N, this configure script will
+  simply skip those options.
+
+  It is SAFEST to say N to this question.
+
+3ware Hardware ATA-RAID support
+CONFIG_BLK_DEV_3W_XXXX_RAID
+  3ware is the only hardware ATA-Raid product in Linux to date.
+  This card is 2,4, or 8 channel master mode support only.
+  SCSI support required!!!
+
+  http://www.3ware.com/
+
+  Please read the comments at the top of drivers/scsi/3w-xxxx.c  
+
+AEC62XX chipset support
+CONFIG_BLK_DEV_AEC62XX
+  This driver adds up to 4 more EIDE devices sharing a single
+  interrupt. This add-on card is a bootable PCI UDMA controller. In
+  order to get this card to initialize correctly in some cases, you
+  should say Y here, and preferably also to "Use DMA by default when
+  available".
+
+  The ATP850U/UF is an UltraDMA 33 chipset base.
+  The ATP860 is an UltraDMA 66 chipset base.
+  The ATP860M(acintosh) version is an UltraDMA 66 chipset base.
+
+  Please read the comments at the top of drivers/ide/aec62xx.c
+  If you say Y here, then say Y to "Use DMA by default when available" as
+  well.
+
+AEC62XX Tuning support
+CONFIG_AEC62XX_TUNING
+  Please read the comments at the top of drivers/ide/aec62xx.c  
+  If unsure, say N.
+
+ALI M15x3 chipset support
+CONFIG_BLK_DEV_ALI15X3
+  This driver ensures (U)DMA support for ALI 1533, 1543 and 1543C
+  onboard chipsets.  It also tests for Simplex mode and enables
+  normal dual channel support.
+
+  If you say Y here, you also need to say Y to "Use DMA by default
+  when available", above.
+  Please read the comments at the top of drivers/ide/alim15x3.c
+
+  If unsure, say N.
+
+ALI M15x3 WDC support (DANGEROUS)
+CONFIG_WDC_ALI15X3
+  This allows for UltraDMA support for WDC drives that ignore CRC
+  checking. You are a fool for enabling this option, but there have
+  been requests. DO NOT COMPLAIN IF YOUR DRIVE HAS FS CORRUPTION, IF
+  YOU ENABLE THIS! No one will listen, just laugh for ignoring this
+  SERIOUS WARNING.
+
+  Using this option can allow WDC drives to run at ATA-4/5 transfer
+  rates with only an ATA-2 support structure.
+
+  SAY NO!
+
+AMD7409 chipset support
+CONFIG_BLK_DEV_AMD7409
+  This driver ensures (U)DMA support for the AMD756 Viper chipset.
+
+  If you say Y here, you also need to say Y to "Use DMA by default
+  when available", above.
+  Please read the comments at the top of drivers/ide/amd7409.c
+
+  If unsure, say N.
+
+AMD Viper ATA-66 Override support (WIP)
+CONFIG_AMD7409_OVERRIDE
+  This option auto-forces the ata66 flag.
+  This effect can be also invoked by calling "idex=ata66"
+  If unsure, say N.
+
+CMD64X chipset support
+CONFIG_BLK_DEV_CMD64X
+  Say Y here if you have an IDE controller which uses any of these
+  chipsets: CMD643, CMD646, or CMD648.
+
+CY82C693 chipset support
+CONFIG_BLK_DEV_CY82C693
+  This driver adds detection and support for the CY82C693 chipset
+  used on Digital's PC-Alpha 164SX boards.
+
+  If you say Y here, you need to say Y to "Use DMA by default
+  when available" as well.
+
+Cyrix CS5530 MediaGX chipset support
+CONFIG_BLK_DEV_CS5530
+  Include support for UDMA on the Cyrix MediaGX 5530 chipset. This
+  will automatically be detected and configured if found.
+
+  It is safe to say Y to this question.
+
+  People with SCSI-only systems should say N here. If unsure, say Y.
+
+HPT34X chipset support
+CONFIG_BLK_DEV_HPT34X
+  This driver adds up to 4 more EIDE devices sharing a single
+  interrupt. The HPT343 chipset in its current form is a non-bootable
+  controller; the HPT345/HPT363 chipset is a bootable (needs BIOS FIX)
+  PCI UDMA controllers. This driver requires dynamic tuning of the
+  chipset during the ide-probe at boot time. It is reported to support
+  DVD II drives, by the manufacturer.
+
+HPT34X AUTODMA support (WIP)
+CONFIG_HPT34X_AUTODMA
+  This is a dangerous thing to attempt currently! Please read the
+  comments at the top of drivers/ide/hpt34x.c If you say Y here,
+  then say Y to "Use DMA by default when available" as well.
+
+  If unsure, say N.
+
+HPT366 chipset support
+CONFIG_BLK_DEV_HPT366
+  HPT366 is an Ultra DMA chipset for ATA-66.
+  HPT368 is an Ultra DMA chipset for ATA-66 RAID Based.
+  HPT370 is an Ultra DMA chipset for ATA-100.
+ 
+  This driver adds up to 4 more EIDE devices sharing a single
+  interrupt. 
+
+  The HPT366 chipset in its current form is bootable. One solution
+  for this problem are special LILO commands for redirecting the
+  reference to device 0x80. The other solution is to say Y to "Boot
+  off-board chipsets first support" (CONFIG_BLK_DEV_OFFBOARD) unless
+  your mother board has the chipset natively mounted. Regardless one
+  should use the fore mentioned option and call at LILO or include
+  "ide=reverse" in LILO's append-line.
+
+  This driver requires dynamic tuning of the chipset during the
+  ide-probe at boot. It is reported to support DVD II drives, by the
+  manufacturer.
+
+NS87415 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_NS87415
+  This driver adds detection and support for the NS87415 chip
+  (used in SPARC64, among others).
+
+  Please read the comments at the top of drivers/ide/ns87415.c.
+
+OPTi 82C621 enhanced support (EXPERIMENTAL)
+CONFIG_BLK_DEV_OPTI621
+  This is a driver for the OPTi 82C621 EIDE controller.
+  Please read the comments at the top of drivers/ide/opti621.c.
+
+ServerWorks OSB4 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_OSB4
+  This driver adds PIO/DMA support for the Serverworks OSB4 chipset
+
+Intel PIIXn chipsets support
+CONFIG_BLK_DEV_PIIX
+  This driver adds PIO mode setting and tuning for all PIIX IDE
+  controllers by Intel.  Since the BIOS can sometimes improperly tune
+  PIO 0-4 mode settings, this allows dynamic tuning of the chipset
+  via the standard end-user tool 'hdparm'.
+
+  Please read the comments at the top of drivers/ide/piix.c.
+
+  If you say Y here, you should also say Y to "PIIXn Tuning support",
+  below.
+
+  If unsure, say N.
+
+PIIXn Tuning support
+CONFIG_PIIX_TUNING
+  This driver extension adds DMA mode setting and tuning for all PIIX
+  IDE controllers by Intel. Since the BIOS can sometimes improperly
+  set up the device/adapter combination and speed limits, it has
+  become a necessity to back/forward speed devices as needed.
+
+  Case 430HX/440FX PIIX3 need speed limits to reduce UDMA to DMA mode
+  2 if the BIOS can not perform this task at initialization.
+
+  If unsure, say N.
+
+PROMISE PDC20246/PDC20262/PDC20267 support
+CONFIG_BLK_DEV_PDC202XX
+  Promise Ultra33 or PDC20246
+  Promise Ultra66 or PDC20262
+  Promise Ultra100 or PDC20265/PDC20267
+
+  This driver adds up to 4 more EIDE devices sharing a single
+  interrupt. This add-on card is a bootable PCI UDMA controller. Since
+  multiple cards can be installed and there are BIOS ROM problems that
+  happen if the BIOS revisions of all installed cards (three-max) do
+  not match, the driver attempts to do dynamic tuning of the chipset
+  at boot-time for max-speed. Ultra33 BIOS 1.25 or newer is required
+  for more than one card. This card may require that you say Y to
+  "Special UDMA Feature (EXPERIMENTAL)".
+
+  If you say Y here, you need to say Y to "Use DMA by default when
+  available" as well.
+
+  Please read the comments at the top of drivers/ide/pdc202xx.c
+
+  If unsure, say N.
+
+Special UDMA Feature (EXPERIMENTAL)
+CONFIG_PDC202XX_BURST
+  For PDC20246, PDC20262, PDC20265 and PDC20267 Ultra DMA chipsets.
+  Designed originally for PDC20246/Ultra33 that has BIOS setup
+  failures when using 3 or more cards.
+
+  Unknown for PDC20265/PDC20267 Ultra DMA 100.
+
+  Please read the comments at the top of drivers/ide/pdc202xx.c
+
+  If unsure, say N.
+
+SiS5513 chipset support
+CONFIG_BLK_DEV_SIS5513
+  This driver ensures (U)DMA support for SIS5513 chipset based
+  mainboards. SiS620/530 UDMA mode 4, SiS5600/5597 UDMA mode 2, all
+  other DMA mode 2 limited chipsets are unsupported to date.
+
+  If you say Y here, you need to say Y to "Use DMA by default when
+  available" as well.
+
+  Please read the comments at the top of drivers/ide/sis5513.c
+
+SLC90E66 chipset support
+CONFIG_BLK_DEV_SLC90E66
+  This driver ensures (U)DMA support for Victroy66 SouthBridges for
+  SMsC with Intel NorthBridges.  This is an Ultra66 based chipset.
+  The nice thing about it is that you can mix Ultra/DMA/PIO devices
+  and it will handle timing cycles.  Since this is an improved look-a-like
+  to the PIIX4 it should be a nice addition.
+
+  If you say Y here, you need to say Y to "Use DMA by default when
+  available" as well.
+
+  Please read the comments at the top of drivers/ide/slc90e66.c
+
+Winbond SL82c105 support
+CONFIG_BLK_DEV_SL82C105
+  If you have a Winbond SL82c105 IDE controller, say Y here to enable
+  special configuration for this chip. This is common on various CHRP
+  motherboards, but could be used elsewhere. If in doubt, say Y.
+
+Tekram TRM290 chipset support (EXPERIMENTAL)
+CONFIG_BLK_DEV_TRM290
+  This driver adds support for bus master DMA transfers
+  using the Tekram TRM290 PCI IDE chip. Volunteers are
+  needed for further tweaking and development.
+  Please read the comments at the top of drivers/ide/trm290.c.
+
+VIA82CXXX chipset support
+CONFIG_BLK_DEV_VIA82CXXX
+  This allows you to configure your chipset for a better use while
+  running (U)DMA: it will allow you to enable efficiently the second
+  channel dma usage, as it may not be set by BIOS. It allows you to
+  pass a kernel command line at boot time in order to set fifo
+  config. If no command line is provided, it will try to set fifo
+  configuration at its best. It will allow you to get information from
+  /proc/ide/via provided you enabled "proc" support.
+
+  Please read the comments at the top of drivers/ide/via82cxxx.c
+
+  If you say Y here, then say Y to "Use DMA by default when available"
+  as well.
+
+  If unsure, say N.
+
+VIA82CXXX Tuning support (WIP)
+CONFIG_VIA82CXXX_TUNING
+  Please read the comments at the top of drivers/ide/via82cxxx.c
+
+  If unsure, say N.
+
+Other IDE chipset support
+CONFIG_IDE_CHIPSETS
+  Say Y here if you want to include enhanced support for various IDE
+  interface chipsets used on motherboards and add-on cards. You can
+  then pick your particular IDE chip from among the following options.
+  This enhanced support may be necessary for Linux to be able to
+  access the 3rd/4th drives in some systems. It may also enable
+  setting of higher speed I/O rates to improve system performance with
+  these chipsets. Most of these also require special kernel boot
+  parameters to actually turn on the support at runtime; you can find
+  a list of these in the file Documentation/ide.txt.
+  
+  People with SCSI-only systems can say N here. 
+
+Generic 4 drives/port support
+CONFIG_BLK_DEV_4DRIVES
+  Certain older chipsets, including the Tekram 690CD, use a single set
+  of I/O ports at 0x1f0 to control up to four drives, instead of the
+  customary two drives per port. Support for this can be enabled at
+  runtime using the "ide0=four" kernel boot parameter if you say Y
+  here.
+
+ALI M14xx support
+CONFIG_BLK_DEV_ALI14XX
+  This driver is enabled at runtime using the "ide0=ali14xx" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the ALI M1439/1443/1445/1487/1489 chipsets, and permits faster
+  I/O speeds to be set as well. See the files Documentation/ide.txt
+  and drivers/ide/ali14xx.c for more info.
+
+DTC-2278 support
+CONFIG_BLK_DEV_DTC2278
+  This driver is enabled at runtime using the "ide0=dtc2278" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the DTC-2278 card, and permits faster I/O speeds to be set as
+  well. See the Documentation/ide.txt and drivers/ide/dtc2278.c
+  files for more info.
+
+Holtek HT6560B support
+CONFIG_BLK_DEV_HT6560B
+  This driver is enabled at runtime using the "ide0=ht6560b" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the Holtek card, and permits faster I/O speeds to be set as well.
+  See the Documentation/ide.txt and drivers/ide/ht6560b.c files for
+  more info.
+
+PROMISE DC4030 support (EXPERIMENTAL)
+CONFIG_BLK_DEV_PDC4030
+  This driver provides support for the secondary IDE interface and
+  cache of Promise IDE chipsets, e.g. DC4030 and DC5030. This driver
+  is known to incur timeouts/retries during heavy I/O to drives
+  attached to the secondary interface. CDROM and TAPE devices are not
+  supported yet. This driver is enabled at runtime using the
+  "ide0=dc4030" kernel boot parameter. See the Documentation/ide.txt
+  and drivers/ide/pdc4030.c files for more info.
+
+QDI QD6580 support
+CONFIG_BLK_DEV_QD6580
+  This driver is enabled at runtime using the "ide0=qd6580" kernel
+  boot parameter. It permits faster I/O speeds to be set. See the
+  files Documentation/ide.txt and drivers/ide/qd6580.c for more
+  info.
+
+UMC 8672 support
+CONFIG_BLK_DEV_UMC8672
+  This driver is enabled at runtime using the "ide0=umc8672" kernel
+  boot parameter. It enables support for the secondary IDE interface
+  of the UMC-8672, and permits faster I/O speeds to be set as well.
+  See the files Documentation/ide.txt and drivers/ide/umc8672.c for
+  more info.
+
+Amiga builtin Gayle IDE interface support
+CONFIG_BLK_DEV_GAYLE
+  This is the IDE driver for the builtin IDE interface on some Amiga
+  models. It supports both the `A1200 style' (used in A600 and A1200)
+  and `A4000 style' (used in A4000 and A4000T) of the Gayle IDE
+  interface. Say Y if you have such an Amiga model and want to use IDE
+  devices (hard disks, CD-ROM drives, etc.) that are connected to the
+  builtin IDE interface.
+
+Falcon IDE interface support
+CONFIG_BLK_DEV_FALCON_IDE
+  This is the IDE driver for the builtin IDE interface on the Atari
+  Falcon. Say Y if you have a Falcon and want to use IDE devices (hard
+  disks, CD-ROM drives, etc.) that are connected to the builtin IDE
+  interface.
+
+Amiga Buddha/Catweasel IDE interface support (EXPERIMENTAL)
+CONFIG_BLK_DEV_BUDDHA
+  This is the IDE driver for the IDE interfaces on the Buddha and
+  Catweasel expansion boards.  It supports up to two interfaces on the
+  Buddha and three on the Catweasel.
+
+  Say Y if you have a Buddha or Catweasel expansion board and want to
+  use IDE devices (hard disks, CD-ROM drives, etc.) that are connected
+  to one of its IDE interfaces.
+
+Amiga IDE Doubler support (EXPERIMENTAL)
+CONFIG_BLK_DEV_IDEDOUBLER
+  This driver provides support for the so-called `IDE doublers' (made
+  by various manufacturers, e.g. Eyetech) that can be connected to the
+  builtin IDE interface of some Amiga models. Using such an IDE
+  doubler, you can connect up to four instead of two IDE devices on
+  the Amiga's builtin IDE interface.
+
+  Note that the normal Amiga Gayle IDE driver may not work correctly
+  if you have an IDE doubler and don't enable this driver!
+
+  Say Y if you have an IDE doubler.  The driver is enabled at kernel
+  runtime using the "ide=doubler" kernel boot parameter.
+
+Support for PowerMac IDE devices (must also enable IDE)
+CONFIG_BLK_DEV_IDE_PMAC
+  This driver provides support for the built-in IDE controller on most
+  of the recent Apple Power Macintoshes and PowerBooks.
+  If unsure, say Y.
+
+PowerMac IDE DMA support
+CONFIG_BLK_DEV_IDEDMA_PMAC
+  This option allows the driver for the built-in IDE controller on
+  Power Macintoshes and PowerBooks to use DMA (direct memory access)
+  to transfer data to and from memory.  Saying Y is safe and improves
+  performance.
+
+Use DMA by default
+CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
+  This option allows the driver for the built-in IDE controller on
+  Power Macintoshes and PowerBooks to use DMA automatically, without
+  it having to be explicitly enabled.  This option is provided because
+  of concerns about a couple of cases where using DMA on buggy PC
+  hardware may have caused damage.  Saying Y should be safe on all
+  Apple machines.
+
+Macintosh Quadra/Powerbook IDE interface support
+CONFIG_BLK_DEV_MAC_IDE
+  This is the IDE driver for the builtin IDE interface on some m68k
+  Macintosh models. It supports both the `Quadra style' (used in
+  Quadra/ Centris 630 and Performa 588 models) and `Powerbook style'
+  (used in the Powerbook 150 and 190 models) IDE interface.
+
+  Say Y if you have such an Macintosh model and want to use IDE
+  devices (hard disks, CD-ROM drives, etc.) that are connected to the
+  builtin IDE interface.
+
+ICS IDE interface support
+CONFIG_BLK_DEV_IDE_ICSIDE
+  On Acorn systems, say Y here if you wish to use the ICS IDE
+  interface card.  This is not required for ICS partition support.
+  If you are unsure, say N to this.
+
+ICS DMA support
+CONFIG_BLK_DEV_IDEDMA_ICS
+  Say Y here if you want to add DMA (Direct Memory Access) support to
+  the ICS IDE driver.
+
+Use ICS DMA by default
+CONFIG_IDEDMA_ICS_AUTO
+  Prior to kernel version 2.1.112, Linux used to automatically use
+  DMA for IDE drives and chipsets which support it. Due to concerns
+  about a couple of cases where buggy hardware may have caused damage,
+  the default is now to NOT use DMA automatically. To revert to the
+  previous behaviour, say Y to this question.
+
+  If you suspect your hardware is at all flakey, say N here.
+  Do NOT email the IDE kernel people regarding this issue!
+
+XT hard disk support
+CONFIG_BLK_DEV_XD
+  Very old 8 bit hard disk controllers used in the IBM XT computer
+  will be supported if you say Y here. 
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called xd.o. 
+
+  It's pretty unlikely that you have one of these: say N.
+
+PS/2 ESDI hard disk support
+CONFIG_BLK_DEV_PS2
+  Say Y here if you have a PS/2 machine with a MCA bus and an ESDI
+  hard disk.
+  
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ps2esdi.o.
+
+Mylex DAC960/DAC1100 PCI RAID Controller support
+CONFIG_BLK_DEV_DAC960
+  This driver adds support for the Mylex DAC960, AcceleRAID, and
+  eXtremeRAID PCI RAID controllers. See the file
+  Documentation/README.DAC960 for further information about this
+  driver.
+
+  If you want to compile the driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt.  The module will be
+  called DAC960.o. 
+
+Parallel port IDE device support
+CONFIG_PARIDE
+  There are many external CD-ROM and disk devices that connect through
+  your computer's parallel port. Most of them are actually IDE devices
+  using a parallel port IDE adapter. This option enables the PARIDE
+  subsystem which contains drivers for many of these external drives.
+  Read Documentation/paride.txt for more information.
+
+  If you have said Y to the "Parallel-port support" configuration
+  option, you may share a single port between your printer and other
+  parallel port devices. Answer Y to build PARIDE support into your
+  kernel, or M if you would like to build it as a loadable module. If
+  your parallel port support is in a loadable module, you must build
+  PARIDE as a module. If you built PARIDE support into your kernel,
+  you may still build the individual protocol modules and high-level
+  drivers as loadable modules. If you build this support as a module,
+  it will be called paride.o.
+
+  To use the PARIDE support, you must say Y or M here and also to at
+  least one high-level driver (e.g. "Parallel port IDE disks",
+  "Parallel port ATAPI CD-ROMs", "Parallel port ATAPI disks" etc.) and
+  to at least one protocol driver (e.g. "ATEN EH-100 protocol",
+  "MicroSolutions backpack protocol", "DataStor Commuter protocol"
+  etc.).
+
+Parallel port IDE disks
+CONFIG_PARIDE_PD
+  This option enables the high-level driver for IDE-type disk devices 
+  connected through a parallel port. If you chose to build PARIDE 
+  support into your kernel, you may answer Y here to build in the 
+  parallel port IDE driver, otherwise you should answer M to build 
+  it as a loadable module. The module will be called pd.o. You 
+  must also have at least one parallel port protocol driver in your 
+  system. Among the devices supported by this driver are the SyQuest 
+  EZ-135, EZ-230 and SparQ drives, the Avatar Shark and the backpack
+  hard drives from MicroSolutions.
+
+Parallel port ATAPI CD-ROMs
+CONFIG_PARIDE_PCD
+  This option enables the high-level driver for ATAPI CD-ROM devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI CD-ROM driver, otherwise you should answer M to
+  build it as a loadable module. The module will be called pcd.o. You
+  must also have at least one parallel port protocol driver in your
+  system. Among the devices supported by this driver are the
+  MicroSolutions backpack CD-ROM drives and the Freecom Power CD. If
+  you have such a CD-ROM drive, you should also say Y or M to "ISO
+  9660 CDROM file system support" below, because that's the file
+  system used on CDROMs.
+
+Parallel port ATAPI disks
+CONFIG_PARIDE_PF
+  This option enables the high-level driver for ATAPI disk devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pf.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver are the
+  MicroSolutions backpack PD/CD drive and the Imation Superdisk
+  LS-120 drive.
+
+Parallel port ATAPI tapes
+CONFIG_PARIDE_PT
+  This option enables the high-level driver for ATAPI tape devices
+  connected through a parallel port. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  parallel port ATAPI disk driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called pt.o.
+  You must also have at least one parallel port protocol driver in
+  your system. Among the devices supported by this driver is the
+  parallel port version of the HP 5GB drive.
+
+Parallel port generic ATAPI devices
+CONFIG_PARIDE_PG
+  This option enables a special high-level driver for generic ATAPI
+  devices connected through a parallel port. The driver allows user
+  programs, such as cdrecord, to send ATAPI commands directly to a
+  device. 
+
+  If you chose to build PARIDE support into your kernel, you may
+  answer Y here to build in the parallel port generic ATAPI driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called pg.o.
+
+  You must also have at least one parallel port protocol driver in
+  your system.
+
+  This driver implements an API loosely related to the generic SCSI
+  driver. See include/linux/pg.h for details.
+
+  You can obtain the most recent version of cdrecord from
+  ftp://ftp.fokus.gmd.de/pub/unix/cdrecord/ . Versions 1.6.1a3 and
+  later fully support this driver.
+
+ATEN EH-100 protocol
+CONFIG_PARIDE_ATEN
+  This option enables support for the ATEN EH-100 parallel port IDE
+  protocol. This protocol is used in some inexpensive low performance
+  parallel port kits made in Hong Kong. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called aten.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+MicroSolutions backpack protocol
+CONFIG_PARIDE_BPCK
+  This option enables support for the MicroSolutions backpack parallel
+  port IDE protocol. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called bpck.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+DataStor Commuter protocol
+CONFIG_PARIDE_COMM
+  This option enables support for the Commuter parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called comm.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+DataStor EP-2000 protocol
+CONFIG_PARIDE_DSTR
+  This option enables support for the EP-2000 parallel port IDE 
+  protocol from DataStor. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called dstr.o. You must also have
+  a high-level driver for the type of device that you want to support.
+
+Shuttle EPAT/EPEZ protocol
+CONFIG_PARIDE_EPAT
+  This option enables support for the EPAT parallel port IDE protocol.
+  EPAT is a parallel port IDE adapter manufactured by Shuttle
+  Technology and widely used in devices from major vendors such as
+  Hewlett-Packard, SyQuest, Imation and Avatar. If you chose to build
+  PARIDE support into your kernel, you may answer Y here to build in
+  the protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called epat.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+Shuttle EPIA protocol
+CONFIG_PARIDE_EPIA
+  This option enables support for the (obsolete) EPIA parallel port
+  IDE protocol from Shuttle Technology. This adapter can still be
+  found in some no-name kits. If you chose to build PARIDE support
+  into your kernel, you may answer Y here to build in the protocol
+  driver, otherwise you should answer M to build it as a loadable
+  module. The module will be called epia.o. You must also have a
+  high-level driver for the type of device that you want to support.
+
+FIT TD-2000 protocol
+CONFIG_PARIDE_FIT2
+  This option enables support for the TD-2000 parallel port IDE
+  protocol from Fidelity International Technology. This is a simple
+  (low speed) adapter that is used in some portable hard drives. If
+  you chose to build PARIDE support into your kernel, you may answer Y
+  here to build in the protocol driver, otherwise you should answer M
+  to build it as a loadable module. The module will be called ktti.o.
+  You must also have a high-level driver for the type of device that
+  you want to support.
+
+FIT TD-3000 protocol
+CONFIG_PARIDE_FIT3
+  This option enables support for the TD-3000 parallel port IDE
+  protocol from Fidelity International Technology. This protocol is
+  used in newer models of their portable disk, CD-ROM and PD/CD
+  devices. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called fit3.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Freecom IQ ASIC-2 protocol
+CONFIG_PARIDE_FRIQ
+  This option enables support for version 2 of the Freecom IQ parallel
+  port IDE adapter.  This adapter is used by the Maxell Superdisk 
+  drive.  If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called friq.o. You must also have a high-level driver for the type
+  of device that you want to support. 
+
+FreeCom power protocol
+CONFIG_PARIDE_FRPW
+  This option enables support for the Freecom power parallel port IDE
+  protocol. If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called frpw.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+KingByte KBIC-951A/971A protocols
+CONFIG_PARIDE_KBIC
+  This option enables support for the KBIC-951A and KBIC-971A parallel
+  port IDE protocols from KingByte Information Corp. KingByte's
+  adapters appear in many no-name portable disk and CD-ROM products,
+  especially in Europe. If you chose to build PARIDE support into your
+  kernel, you may answer Y here to build in the protocol driver,
+  otherwise you should answer M to build it as a loadable module. The
+  module will be called kbic.o. You must also have a high-level driver
+  for the type of device that you want to support.
+
+KT PHd protocol
+CONFIG_PARIDE_KTTI
+  This option enables support for the "PHd" parallel port IDE protocol
+  from KT Technology. This is a simple (low speed) adapter that is
+  used in some 2.5" portable hard drives. If you chose to build PARIDE
+  support into your kernel, you may answer Y here to build in the
+  protocol driver, otherwise you should answer M to build it as a
+  loadable module. The module will be called ktti.o. You must also
+  have a high-level driver for the type of device that you want to
+  support.
+
+OnSpec 90c20 protocol
+CONFIG_PARIDE_ON20
+  This option enables support for the (obsolete) 90c20 parallel port 
+  IDE protocol from OnSpec (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you 
+  may answer Y here to build in the protocol driver, otherwise you 
+  should answer M to build it as a loadable module. The module will 
+  be called on20.o. You must also have a high-level driver for the 
+  type of device that you want to support.
+
+OnSpec 90c26 protocol
+CONFIG_PARIDE_ON26
+  This option enables support for the 90c26 parallel port IDE protocol
+  from OnSpec Electronics (often marketed under the ValuStore brand
+  name). If you chose to build PARIDE support into your kernel, you
+  may answer Y here to build in the protocol driver, otherwise you
+  should answer M to build it as a loadable module. The module will be
+  called on26.o. You must also have a high-level driver for the type
+  of device that you want to support.
+
+Logical Volume Manager (LVM) support
+CONFIG_BLK_DEV_LVM
+  This driver lets you combine several hard disks, hard disk
+  partitions, multiple devices or even loop devices (for evaluation
+  purposes) into a volume group.  Imagine a volume group as a kind of
+  virtual disk. Logical volumes, which can be thought of as virtual
+  partitions, can be created in the volume group.  You can resize
+  volume groups and logical volumes after creation time, corresponding
+  to new capacity needs.  Logical volumes are accessed as block
+  devices named /dev/VolumeGroupName/LogicalVolumeName.
+
+  For details see Documentation/LVM-HOWTO. You will need supporting
+  user space software; location is in Documentation/Changes.
+
+  If you want to compile this support as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called lvm-mod.o.
+
+Logical Volume Manager /proc file system information
+CONFIG_LVM_PROC_FS
+  If you say Y here, you are able to access overall Logical Volume
+  Manager, Volume Group, Logical and Physical Volume information in
+  /proc/lvm.
+
+  To use this option, you have to check, that the "/proc file system
+  support" (CONFIG_PROC_FS) is enabled too.
+
+Multiple devices driver support
+CONFIG_BLK_DEV_MD
+  This driver lets you combine several hard disk partitions into one
+  logical block device. This can be used to simply append one
+  partition to another one or to combine several redundant hard disks
+  into a RAID1/4/5 device so as to provide protection against hard
+  disk failures. This is called "Software RAID" since the combining of
+  the partitions is done by the kernel. "Hardware RAID" means that the
+  combining is done by a dedicated controller; if you have such a
+  controller, you do not need to say Y here.
+
+  More information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If unsure, say N.
+
+Linear (append) mode
+CONFIG_MD_LINEAR
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called linear mode, i.e. it will combine the hard disk
+  partitions by simply appending one to the other. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called linear.o.
+
+  If unsure, say Y.
+
+RAID-0 (striping) mode
+CONFIG_MD_RAID0
+  If you say Y here, then your multiple devices driver will be able to
+  use the so-called raid0 mode, i.e. it will combine the hard disk
+  partitions into one logical device in such a fashion as to fill them
+  up evenly, one chunk here and one chunk there. This will increase
+  the throughput rate if the partitions reside on distinct disks. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called raid0.o.
+
+  If unsure, say Y.
+
+RAID-1/RAID-5 code (DANGEROUS)
+CONFIG_RAID15_DANGEROUS
+  This new RAID1/RAID5 code has been freshly merged, and has not seen
+  enough testing yet. While there are no known bugs in it, it might
+  destroy your filesystems, eat your data and start World War III.
+  You have been warned.
+
+  If unsure, say N.
+
+RAID-1 (mirroring) mode
+CONFIG_MD_RAID1
+  A RAID-1 set consists of several disk drives which are exact copies
+  of each other. In the event of a mirror failure, the RAID driver
+  will continue to use the operational mirrors in the set, providing
+  an error free MD (multiple device) to the higher levels of the
+  kernel. In a set with N drives, the available space is the capacity
+  of a single drive, and the set protects against a failure of (N - 1)
+  drives. 
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-1 set, say Y. This code is also
+  available as a module called raid1.o ( = code which can be inserted
+  in and removed from the running kernel whenever you want). If you
+  want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+RAID-4/RAID-5 mode
+CONFIG_MD_RAID5
+  A RAID-5 set of N drives with a capacity of C MB per drive provides
+  the capacity of C * (N - 1) MB, and protects against a failure
+  of a single drive. For a given sector (row) number, (N - 1) drives
+  contain data sectors, and one drive contains the parity protection.
+  For a RAID-4 set, the parity blocks are present on a single drive,
+  while a RAID-5 set distributes the parity across the drives in one
+  of the available parity distribution methods.
+
+  Information about Software RAID on Linux is contained in the
+  Software-RAID mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . There you will also
+  learn where to get the supporting user space utilities raidtools.
+
+  If you want to use such a RAID-4/RAID-5 set, say Y. This code is
+  also available as a module called raid5.o ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say Y.
+
+RAID Boot support
+CONFIG_MD_BOOT
+  To boot with an initial raid volume (any type) you can select
+  autodetect, or answer Y here and appropriate options to the kernel
+  at boot time.
+  For lilo and loadlin options see the file Documentation/md.txt.
+
+RAID AutoDetect support
+CONFIG_AUTODETECT_RAID
+  An alternative to "Raid Boot support" is autodetect support.
+  With this selected, any partitons of type 0xFD will be considered for
+  inclusion in a RAID array.  Information in the RAID-superblock on
+  the partition will determine how it is included.
+
+Support for Acer PICA 1 chipset
+CONFIG_ACER_PICA_61
+  This is a machine with a R4400 133/150 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://oss.sgi.com/mips .
+
+Support for Algorithmics P4032 (EXPERIMENTAL)
+CONFIG_ALGOR_P4032
+  This is an evaluation board of the British company Algorithmics. The
+  board uses the R4300 and a R5230 CPUs. For more information about
+  this board see http://www.algor.co.uk .
+
+Support for BAGET MIPS series
+CONFIG_BAGET_MIPS
+  This enables support for the Baget, a Russian embedded system.  For 
+  more details about the Baget see the Linux/MIPS FAQ on 
+  http://oss.sgi.com/mips .
+
+Support for Cobalt Microserver
+CONFIG_COBALT_MICRO_SERVER
+  This enables support for the Cobalt Microserver.  For more information
+  see the Linux/MIPS FAQ on http://oss.sgi.com/mips .
+
+Support for 2800
+CONFIG_COBALT_28
+  This adds support for the Cobalt Microserver 2800.  A kernel with this
+  option selected will only work on the 2800.
+
+Support for DECstations
+CONFIG_DECSTATION
+  This enables support for DEC's MIPS based workstations.  For details
+  see the Linux/MIPS FAQ on http://oss.sgi.com/mips and the 
+  DECstation porting pages on http://decstation.unix-ag.org .
+
+  If you have one of the following DECstation Models you definitely
+  want to choose R4xx0 for the CPU Type:
+
+	DECstation 5000/50
+	DECstation 5000/150
+	DECstation 5000/260
+	DECsystem 5900/260
+
+  otherwise choose R3000.
+
+Support for NEC DDB Vrc-5074
+CONFIG_DDB5074
+  This enables support for the VR5000-based NEC DDB Vrc-5074
+  evaluation board.
+
+Support for Mips Magnum 4000
+CONFIG_MIPS_MAGNUM_4000
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://oss.sgi.com/mips.
+
+Support for Olivetti M700
+CONFIG_OLIVETTI_M700
+  This is a machine with a R4000 100 MHz CPU. To compile a Linux
+  kernel that runs on these, say Y here. For details about Linux on
+  the MIPS architecture, check out the Linux/MIPS FAQ on the WWW at
+  http://oss.sgi.com/mips.
+
+Support for SGI IP22
+CONFIG_SGI_IP22
+  This are the SGI Indy, Challenge S and Indigo2, as well as certain
+  OEM variants like the Tandem CMN B006S. To compile a Linux kernel
+  that runs on these, say Y here.
+
+Support for SGI IP27
+  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
+  workstations.  To compile a Linux kernel that runs on these, say Y
+  here.
+
+IP27 N-Mode
+CONFIG_SGI_SN0_N_MODE
+  The nodes of Origin 200, Origin 2000 and Onyx 2 systems can be
+  configured in either N-Modes which allows for more nodes or M-Mode
+  which allows for more more memory.  Your system is most probably
+  running in M-Mode, so you should say N here.
+
+MIPS JAZZ onboard SONIC Ethernet support
+CONFIG_MIPS_JAZZ_SONIC
+  This is the driver for the onboard card of of MIPS Magnum 4000,
+  Acer PICA, Olivetti M700-10 and a few other identical OEM systems.
+
+MIPS JAZZ FAS216 SCSI support
+CONFIG_JAZZ_ESP
+  This is the driver for the onboard SCSI host adapter of MIPS Magnum
+  4000, Acer PICA, Olivetti M700-10 and a few other identical OEM
+  systems.
+
+PCMCIA SCSI adapter support
+CONFIG_SCSI_PCMCIA
+  Say Y here if you intend to attach a PCMCIA or CardBus card to your
+  computer which acts as a SCSI host adapter. These are credit card
+  size devices often used with laptops.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions PCMCIA SCSI host adapters.
+
+Adaptec AHA152X PCMCIA support
+CONFIG_PCMCIA_AHA152X
+  Say Y here if you intend to attach this type of PCMCIA SCSI host
+  adapter to your computer.
+
+  This driver is also available as a module called aha152x_cs.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Qlogic PCMCIA support
+CONFIG_PCMCIA_QLOGIC
+  Say Y here if you intend to attach this type of PCMCIA SCSI host
+  adapter to your computer.
+
+  This driver is also available as a module called qlogic_cs.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Future Domain PCMCIA support
+CONFIG_PCMCIA_FDOMAIN
+  Say Y here if you intend to attach this type of PCMCIA SCSI host
+  adapter to your computer.
+
+  This driver is also available as a module called fdomain_cs.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Adaptec APA1480 CardBus support
+CONFIG_PCMCIA_APA1480
+  Say Y here if you intend to attach this type of CardBus SCSI host
+  adapter to your computer.
+
+  This driver is also available as a module called apa1480_cb.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+CPU type
+CONFIG_CPU_R3000
+  Please make sure to pick the right CPU type. Linux/MIPS is not
+  designed to be generic, i.e. Kernels compiled for R3000 CPUs will
+  *not* work on R4000 Machines and vice versa.
+  However, since most the supported Machines have an R4000 (or 
+  similar) CPU, R4xx0 might be a safe bet.
+  If the resulting Kernel does not work try to recompile with R3000.
+
+Support for large 64-bit configurations
+CONFIG_MIPS_INSANE_LARGE
+  MIPS R10000 does support a 44 bit / 16TB address space as opposed to
+  previous 64-bit processors which only supported 40 bit / 1TB. If you
+  need processes of more than 1TB virtual address space, say Y here.
+  This will result in additional memory usage, so it is not
+  recommended for normal users.
+
+Generate little endian code
+CONFIG_CPU_LITTLE_ENDIAN
+  Some MIPS machines can be configured for either little or big endian
+  byte order. These modes require different kernels. Say Y if your
+  machine is little endian, N if it's a big endian machine.
+
+Networking support
+CONFIG_NET
+  Unless you really know what you are doing, you should say Y here.
+  The reason is that some programs need kernel networking support even
+  when running on a stand-alone machine that isn't connected to any
+  other computer. If you are upgrading from an older kernel, you
+  should consider updating your networking tools too because changes
+  in the kernel and the tools often go hand in hand. The tools are
+  contained in the package net-tools, the location and version number
+  of which are given in Documentation/Changes.
+
+  For a general introduction to Linux networking, it is highly
+  recommended to read the NET-3-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+Socket filtering
+CONFIG_FILTER
+  The Linux Socket Filter is derived from the Berkeley Packet Filter.
+  If you say Y here, user-space programs can attach a filter to any
+  socket and thereby tell the kernel that it should allow or disallow
+  certain types of data to get through the socket. Linux Socket
+  Filtering works on all socket types except TCP for now. See the text
+  file Documentation/networking/filter.txt for more information.
+  If unsure, say N.
+
+Network packet filtering
+CONFIG_NETFILTER
+  Netfilter is a framework for filtering and mangling network packets
+  that pass through your Linux box.
+
+  The most common use of packet filtering is to run your Linux box as
+  a firewall protecting a local network from the Internet. The type of
+  firewall provided by this kernel support is called a "packet
+  filter", which means that it can reject individual network packets
+  based on type, source, destination etc. The other kind of firewall,
+  a "proxy-based" one, is more secure but more intrusive and more
+  bothersome to set up; it inspects the network traffic much more
+  closely, modifies it and has knowledge about the higher level
+  protocols, which a packet filter lacks. Moreover, proxy-based
+  firewalls often require changes to the programs running on the local
+  clients. Proxy-based firewalls don't need support by the kernel, but
+  they are often combined with a packet filter, which only works if
+  you say Y here.
+
+  You should also say Y here if you intend to use your Linux box as
+  the gateway to the Internet for a local network of machines without
+  globally valid IP addresses. This is called "masquerading": if one
+  of the computers on your local network wants to send something to
+  the outside, your box can "masquerade" as that computer, i.e. it
+  forwards the traffic to the intended outside destination, but
+  modifies the packets to make it look like they came from the
+  firewall box itself. It works both ways: if the outside host
+  replies, the Linux box will silently forward the traffic to the
+  correct local computer. This way, the computers on your local net
+  are completely invisible to the outside world, even though they can
+  reach the outside and can receive replies. It is even possible to
+  run globally visible servers from within a masqueraded local network
+  using a mechanism called portforwarding. Masquerading is also often
+  called NAT (Network Address Translation).
+
+  Another use of Netfilter is in transparent proxying: if a machine on
+  the local network tries to connect to an outside host, your Linux
+  box can transparently forward the traffic to a local server,
+  typically a caching proxy server.
+
+  Various modules exist for netfilter which replace the previous
+  masquerading (ipmasqadm), packet filtering (ipchains), transparent
+  proxying, and portforwarding mechanisms. Please see
+  Documentation/Changes under "iptables" for the location of these
+  packages.
+ 
+  Make sure to say N to "Fast switching" below if you intend to say Y
+  here, as Fast switching currently bypasses netfilter.
+ 
+  Chances are that you should say Y here if you compile a kernel which
+  will run as a router and N for regular hosts. If unsure, say N.
+ 
+Network packet filtering debugging
+CONFIG_NETFILTER_DEBUG
+  You can say Y here if you want to get additional messages useful in
+  debugging the netfilter code. 
+
+IP: connection tracking (required for masq/NAT)
+CONFIG_IP_NF_CONNTRACK
+  Connection tracking keeps a record of what packets have passed
+  through your machine, in order to figure out how they are related
+  into connections.
+
+  This is required to do Masquerading or other kinds of Network
+  Address Translation (except for Fast NAT).  It can also be used to
+  enhance packet filtering (see `Connection state match support'
+  below).
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+FTP protocol support
+CONFIG_IP_NF_FTP
+  Tracking FTP connections is problematic: special helpers are
+  required for tracking them, and doing masquerading and other forms
+  of Network Address Translation on them.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `Y'.
+
+IP: user space queueing via NETLINK (EXPERIMENTAL)
+CONFIG_IP_NF_QUEUE
+  Netfilter has the ability to queue packets to user space: the
+  netlink device can be used to access them using this driver.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+IP: ip tables support (required for filtering/masq/NAT)
+CONFIG_IP_NF_IPTABLES
+  iptables is a general, extensible packet identification framework.
+  The packet filtering and full NAT (masquerading, port forwarding,
+  etc) subsystems now use this: say `Y' or `M' here if you want to use
+  either of those.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+limit match support
+CONFIG_IP_NF_MATCH_LIMIT
+  limit matching allows you to control the rate at which a rule can be
+  matched: mainly useful in combination with the LOG target ("LOG
+  target support", below) and to avoid some Denial of Service attacks.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+MAC address match support
+CONFIG_IP_NF_MATCH_MAC
+  mac matching allows you to match packets based on the source
+  ethernet address of the packet.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+netfilter mark match support
+CONFIG_IP_NF_MATCH_MARK
+  Netfilter mark matching allows you to match packets based on the
+  `nfmark' value in the packet.  This can be set by the MARK target
+  (see below).
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Multiple port match support
+CONFIG_IP_NF_MATCH_MULTIPORT
+  Multiport matching allows you to match TCP or UDP packets based on
+  a series of source or destination ports: normally a rule can only
+  match a single range of ports.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+TOS match support
+CONFIG_IP_NF_MATCH_TOS
+  TOS matching allows you to match packets based on the Type Of
+  Service fields of the IP packet.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Connection state match support
+CONFIG_IP_NF_MATCH_STATE
+  Connection state matching allows you to match packets based on their
+  relationship to a tracked connection (ie. previous packets).  This
+  is a powerful tool for packet classification.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Unclean match support (EXPERIMENTAL)
+CONFIG_IP_NF_MATCH_UNCLEAN
+  Unclean packet matching matches any strange or invalid packets, by
+  looking at a series of fields in the IP, TCP, UDP and ICMP headers.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Owner match support (EXPERIMENTAL)
+CONFIG_IP_NF_MATCH_OWNER
+  Packet owner matching allows you to match locally-generated packets
+  based on who created them: the user, group, process or session.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Packet filtering
+CONFIG_IP_NF_FILTER
+  Packet filtering defines a table `filter', which has a series of
+  rules for simple packet filtering at local input, forwarding and
+  local output.  See the man page for iptables(8).
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+REJECT target support
+CONFIG_IP_NF_TARGET_REJECT
+  The REJECT target allows a filtering rule to specify that an ICMP
+  error should be issued in response to an incoming packet, rather
+  than silently being dropped.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+MIRROR target support (EXPERIMENTAL)
+CONFIG_IP_NF_TARGET_MIRROR
+  The MIRROR target allows a filtering rule to specify that an
+  incoming packet should be bounced back to the sender.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Full NAT
+CONFIG_IP_NF_NAT
+  The Full NAT option allows masquerading, port forwarding and other
+  forms of full Network Address Port Translation.  It is controlled by
+  the `nat' table in iptables: see the man page for iptables(8).
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+MASQUERADE target support
+CONFIG_IP_NF_TARGET_MASQUERADE
+  Masquerading is a special case of NAT: all outgoing connections are
+  changed to seem to come from a particular interface's address, and
+  if the interface goes down, those connections are lost.  This is
+  only useful for dialup accounts with dynamic IP address (ie. your IP
+  address will be different on next dialup).
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+REDIRECT target support
+CONFIG_IP_NF_TARGET_REDIRECT
+  REDIRECT is a special case of NAT: all incoming connections are
+  mapped onto the incoming interface's address, causing the packets to
+  come to the local machine instead of passing through.  This is
+  useful for transparent proxies.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+Packet mangling
+CONFIG_IP_NF_MANGLE
+  This option adds a `mangle' table to iptables: see the man page for
+  iptables(8).  This table is used for various packet alterations
+  which can effect how the packet is routed.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+TOS target support
+CONFIG_IP_NF_TARGET_TOS
+  This option adds a `TOS' target, which allows you to create rules in
+  the `mangle' table which alter the Type Of Service field of an IP
+  packet prior to routing.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+MARK target support
+CONFIG_IP_NF_TARGET_MARK
+  This option adds a `MARK' target, which allows you to create rules
+  in the `mangle' table which alter the netfilter mark (nfmark) field
+  associated with the packet packet prior to routing. This can change
+  the routing method (see `IP: use netfilter MARK value as routing
+  key') and can also be used by other subsystems to change their
+  behavior.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+LOG target support
+CONFIG_IP_NF_TARGET_LOG
+  This option adds a `LOG' target, which allows you to create rules in
+  any iptables table which records the packet header to the syslog.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+ipchains (2.2-style) support
+CONFIG_IP_NF_COMPAT_IPCHAINS
+  This option places ipchains (with masquerading and redirection
+  support) back into the kernel, using the new netfilter
+  infrastructure.  It is not recommended for new installations (see
+  `Packet filtering').  With this enabled, you should be able to use
+  the ipchains tool exactly as in 2.2 kernels.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+ipfwadm (2.0-style) support
+CONFIG_IP_NF_COMPAT_IPFWADM
+  This option places ipfwadm (with masquerading and redirection
+  support) back into the kernel, using the new netfilter
+  infrastructure.  It is not recommended for new installations (see
+  `Packet filtering').  With this enabled, you should be able to use
+  the ipfwadm tool exactly as in 2.0 kernels.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.  If unsure, say `N'.
+
+TCP Explicit Congestion Notification support
+CONFIG_INET_ECN
+  Explicit Congestion Notification (ECN) allows routers to notify
+  clients about network congestion, resulting in fewer dropped packets
+  and increased network performance. This option adds ECN support to the
+  Linux kernel, as well as a sysctl (/proc/sys/net/ipv4/tcp_ecn) which
+  allows ECN support to be disabled at runtime.
+
+  Note that, on the Internet, there are many broken firewalls which
+  refuse connections from ECN-enabled machines, and it may be a while
+  before these firewalls are fixed. Until then, to access a site behind
+  such a firewall (some of which are major sites, at the time of this
+  writing) you will have to disable this option, either by saying N now
+  or by using the sysctl.
+
+  If in doubt, say N.
+
+SYN flood protection
+CONFIG_SYN_COOKIES
+  Normal TCP/IP networking is open to an attack known as "SYN
+  flooding". This denial-of-service attack prevents legitimate remote
+  users from being able to connect to your computer during an ongoing
+  attack and requires very little work from the attacker, who can
+  operate from anywhere on the Internet.
+
+  SYN cookies provide protection against this type of attack. If you
+  say Y here, the TCP/IP stack will use a cryptographic challenge
+  protocol known as "SYN cookies" to enable legitimate users to
+  continue to connect, even when your machine is under attack. There
+  is no need for the legitimate users to change their TCP/IP software;
+  SYN cookies work transparently to them. For technical information
+  about SYN cookies, check out
+  ftp://koobera.math.uic.edu/syncookies.html .
+
+  If you are SYN flooded, the source address reported by the kernel is
+  likely to have been forged by the attacker; it is only reported as
+  an aid in tracing the packets to their actual source and should not
+  be taken as absolute truth.
+
+  SYN cookies may prevent correct error reporting on clients when the
+  server is really overloaded. If this happens frequently better turn
+  them off.
+
+  If you say Y here, note that SYN cookies aren't enabled by default;
+  you can enable them by saying Y to "/proc file system support" and
+  "Sysctl support" below and executing the command
+
+    echo 1 >/proc/sys/net/ipv4/tcp_syncookies 
+
+  at boot time after the /proc file system has been mounted.
+  
+  If unsure, say Y.
+
+Alpha system type
+CONFIG_ALPHA_GENERIC
+  This is the system type of your hardware.  A "generic" kernel will
+  run on any supported Alpha system. However, if you configure a
+  kernel for your specific system, it will be faster and smaller.
+
+  To find out what type of Alpha system you have, you may want to
+  check out the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org . In summary:
+
+  Alcor/Alpha-XLT     AS 600
+  Alpha-XL            XL-233, XL-266
+  AlphaBook1          Alpha laptop
+  Avanti              AS 200, AS 205, AS 250, AS 255, AS 300, AS 400
+  Cabriolet           AlphaPC64, AlphaPCI64
+  DP264               DP264
+  EB164               EB164 21164 evaluation board
+  EB64+               EB64+ 21064 evaluation board
+  EB66                EB66 21066 evaluation board
+  EB66+               EB66+ 21066 evaluation board
+  Jensen              DECpc 150, DEC 2000 model 300, 
+                      DEC 2000 model 500
+  LX164               AlphaPC164-LX
+  Miata               Personal Workstation 433a, 433au, 500a,
+                      500au, 600a, or 600au
+  Mikasa              AS 1000
+  Noname              AXPpci33, UDB (Multia)
+  Noritake            AS 1000A, AS 600A, AS 800
+  PC164               AlphaPC164
+  Rawhide             AS 1200, AS 4000, AS 4100
+  Ruffian             RPX164-2, AlphaPC164-UX, AlphaPC164-BX
+  SX164               AlphaPC164-SX
+  Sable               AS 2000, AS 2100
+  Takara              Takara
+  Titan               Privateer
+  Wildfire            AlphaServer GS 40/80/160/320
+
+  If you don't know what to do, choose "generic".
+
+EV5 CPU daughtercard
+CONFIG_ALPHA_PRIMO
+  Say Y if you have an AS 1000 5/xxx or an AS 1000A 5/xxx.
+
+EV5 CPU(s)
+CONFIG_ALPHA_GAMMA
+  Say Y if you have an AS 2000 5/xxx or an AS 2100 5/xxx.
+
+Using SRM as bootloader
+CONFIG_ALPHA_SRM
+  There are two different types of booting firmware on Alphas: SRM,
+  which is command line driven, and ARC, which uses menus and arrow
+  keys. Details about the Linux/Alpha booting process are contained in
+  the Linux/Alpha FAQ, accessible on the WWW from
+  http://www.alphalinux.org .
+
+  The usual way to load Linux on an Alpha machine is to use MILO
+  (a bootloader that lets you pass command line parameters to the
+  kernel just like lilo does for the x86 architecture) which can be
+  loaded either from ARC or can be installed directly as a permanent
+  firmware replacement from floppy (which requires changing a certain
+  jumper on the motherboard). If you want to do either of these, say N
+  here. If MILO doesn't work on your system (true for Jensen
+  motherboards), you can bypass it altogether and boot Linux directly
+  from an SRM console; say Y here in order to do that. Note that you
+  won't be able to boot from an IDE disk using SRM. 
+
+  If unsure, say N.
+
+Legacy kernel start address
+CONFIG_ALPHA_LEGACY_START_ADDRESS
+  The 2.4 kernel changed the kernel start address from 0x310000
+  to 0x810000 to make room for the Wildfire's larger SRM console.
+
+  If you're using aboot 0.7 or later, the bootloader will examine
+  the ELF headers to determine where to transfer control.  Unfortunately,
+  most older bootloaders -- APB or MILO -- hardcoded the kernel
+  start address rather than examining the ELF headers, and the result
+  is a hard lockup.
+
+  Say Y if you have a broken bootloader.  Say N if you do not, or
+  if you wish to run on Wildfire.
+
+Large VMALLOC support
+CONFIG_ALPHA_LARGE_VMALLOC
+  Process creation and other aspects of virtual memory management
+  can be streamlined if we restrict the kernel to one PGD for all
+  vmalloc allocations.  This equates to about 8GB.
+
+  Under normal circumstances, this is so far and above what is needed
+  as to be laughable.  However, there are certain applications (such
+  as benchmark-grade in-kernel web serving) that can make use of as
+  much vmalloc space as is available.
+
+  Say N unless you know you need gobs and gobs of vmalloc space.
+
+Non-standard serial port support
+CONFIG_SERIAL_NONSTANDARD
+  Say Y here if you have any non-standard serial boards -- boards
+  which aren't supported using the standard "dumb" serial driver.
+  This includes intelligent serial boards such as Cyclades,
+  Digiboards, etc. These are usually used for systems that need many
+  serial ports because they serve many terminals or dial-in
+  connections. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-standard serial boards. 
+
+  Most people can say N here.
+
+Extended dumb serial driver options
+CONFIG_SERIAL_EXTENDED
+  If you wish to use any non-standard features of the standard "dumb"
+  driver, say Y here. This includes HUB6 support, shared serial
+  interrupts, special multiport support, support for more than the
+  four COM 1/2/3/4 boards, etc. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about serial driver options. If unsure, say N.
+
+Support more than 4 serial ports
+CONFIG_SERIAL_MANY_PORTS
+  Say Y here if you have dumb serial boards other than the four
+  standard COM 1/2/3/4 ports. This may happen if you have an AST
+  FourPort, Accent Async, Boca (read the Boca mini-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto ), or other custom
+  serial port hardware which acts similar to standard serial port
+  hardware. If you only use the standard COM 1/2/3/4 ports, you can
+  say N here to save some memory. You can also say Y if you have an
+  "intelligent" multiport card such as Cyclades, Digiboards, etc.
+
+Support for sharing serial interrupts
+CONFIG_SERIAL_SHARE_IRQ
+  Some serial boards have hardware support which allows multiple dumb
+  serial ports on the same board to share a single IRQ. To enable
+  support for this in the serial driver, say Y here.
+
+Auto detect IRQ on standard ports (unsafe)
+CONFIG_SERIAL_DETECT_IRQ
+  Say Y here if you want the kernel to try to guess which IRQ
+  to use for your serial port. 
+
+  This is considered unsafe; it is far better to configure the IRQ in
+  a boot script using the setserial command.
+
+  If unsure, say N.
+
+Support special multiport boards
+CONFIG_SERIAL_MULTIPORT
+  Some multiport serial ports have special ports which are used to
+  signal when there are any serial ports on the board which need
+  servicing. Say Y here to enable the serial driver to take advantage
+  of those special I/O ports.
+
+SGI PROM Console Support
+CONFIG_SGI_PROM_CONSOLE
+  Say Y here if you want to use the PROMs for console I/O.
+
+SGI Zilog85C30 serial support
+CONFIG_SGI_SERIAL
+  If you want to use your SGI's built-in serial ports under Linux,
+  answer Y.
+
+SGI Newport Graphics support (EXPERIMENTAL)
+CONFIG_SGI_NEWPORT_GFX
+  If you have an SGI machine and you want to compile the graphics
+  drivers, say Y here. This will include the code for the
+  /dev/graphics and /dev/gfx drivers into the kernel for supporting
+  virtualized access to your graphics hardware.
+
+SGI Newport Console support
+CONFIG_SGI_NEWPORT_CONSOLE
+  Say Y here if you want the console on the Newport aka XL graphics
+  card of your Indy.  Most people say Y here.
+
+SGI DS1286 RTC support
+CONFIG_SGI_DS1286
+  If you say Y here and create a character special file /dev/rtc with
+  major number 10 and minor number 135 using mknod ("man mknod"), you
+  will get access to the real time clock built into your computer.
+  Every SGI has such a clock built in. It reports status information
+  via the file /proc/rtc and its behaviour is set by various ioctls on
+  /dev/rtc.
+
+Support the Bell Technologies HUB6 card
+CONFIG_HUB6
+  Say Y here to enable support in the dumb serial driver to support
+  the HUB6 card.
+
+PCMCIA serial device support
+CONFIG_PCMCIA_SERIAL_CS
+  Say Y here to enable support for 16-bit PCMCIA serial devices,
+  including serial port cards, modems, and the modem functions of
+  multi-function ethernet/modem cards. (PCMCIA- or PC-cards are
+  credit-card size devices often used with laptops.)
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called serial_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+CardBus serial device support
+CONFIG_PCMCIA_SERIAL_CB
+  Say Y here to enable support for CardBus serial devices, including
+  serial port cards, modems, and the modem functions of multi-function
+  ethernet/modem devices. (CardBus cards are the newer and better 
+  version of PCMCIA- or PC-cards: credit card size devices often 
+  used with laptops.)
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called serial_cb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+/dev/agpgart (AGP Support) (EXPERIMENTAL)
+CONFIG_AGP
+  AGP (Accelerated Graphics Port) is a bus system mainly used to
+  connect graphics cards to the rest of the system. 
+
+  If you have an AGP system and you say Y here, it will be possible to
+  use the AGP features of your 3D rendering video card. This code acts
+  as a sort of "AGP driver" for the motherboard's chipset. The glx
+  module will then be able to program the GART (graphics aperture
+  relocation table) registers with appropriate values to transfer
+  commands to the card.
+
+  If you need more texture memory than you can get with the AGP GART
+  (theoretically up to 256 MB, but in practice usually 64 or 128 MB
+  due to kernel allocation issues), you could use PCI accesses
+  and have up to a couple gigs of texture space.
+
+  Note that this is the only means to have XFree4/GLX use
+  write-combining with MTRR support on the AGP bus. Without it, OpenGL
+  direct rendering will be a lot slower but still faster than PIO.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ , or need to use the 810 Xserver in
+  XFree 3.3.6.
+
+  This driver is available as a module. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. The module
+  will be called agpgart.o.
+
+Intel 440LX/BX/GX/815/840/850 support
+CONFIG_AGP_INTEL
+  This option gives you AGP support for the GLX component of the
+  XFree86 4.x on Intel 440LX/BX/GX, 815, 840 and 850 chipsets.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ .
+
+Intel I810/I810 DC100/I810e support
+CONFIG_AGP_I810
+  This option gives you AGP support for the Xserver on the Intel 810
+  and 815 chipset boards for their on-board integrated graphics. This
+  is required to do any useful video modes with these boards.
+
+VIA chipset support
+CONFIG_AGP_VIA
+  This option gives you AGP support for the GLX component of the
+  XFree86 4.x on VIA MPV3/Apollo Pro chipsets.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ .
+
+AMD Irongate support
+CONFIG_AGP_AMD
+  This option gives you AGP support for the GLX component of the
+  XFree86 4.x on AMD Irongate chipset.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ .
+
+Generic SiS support
+CONFIG_AGP_SIS
+  This option gives you AGP support for the GLX component of the "soon
+  to be released" XFree86 4.x on Silicon Integrated Systems [SiS]
+  chipsets.
+
+  Note that 5591/5592 AGP chipsets are NOT supported.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ .
+
+ALI M1541 support
+CONFIG_AGP_ALI
+  This option gives you AGP support for the GLX component of the
+  XFree86 4.x on the ALi M1541 chipset.
+
+  This chipset can do AGP 1x and 2x, but note that there is an
+  acknowledged incompatibility with Matrox G200 cards. Due to
+  timing issues, this chipset cannot do AGP 2x with the G200.
+  This is a hardware limitation. AGP 1x seems to be fine, though.
+
+  For the moment, you should probably say N, unless you want to test
+  the GLX component for XFree86 3.3.6, which can be downloaded from
+  http://utah-glx.sourceforge.net/ .
+
+PCI support
+CONFIG_PCI
+  Find out whether you have a PCI motherboard. PCI is the name of a
+  bus system, i.e. the way the CPU talks to the other stuff inside
+  your box. Other bus systems are ISA, EISA, Microchannel (MCA) or
+  VESA. If you have PCI, say Y, otherwise N. 
+
+  The PCI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , contains valuable
+  information about which PCI hardware does work under Linux and which
+  doesn't.
+
+PCI support
+CONFIG_PCI_INTEGRATOR
+  Find out whether you have a PCI motherboard. PCI is the name of a
+  bus system, i.e. the way the CPU talks to the other stuff inside
+  your box. Other bus systems are ISA, EISA, Microchannel (MCA) or
+  VESA. If you have PCI, say Y, otherwise N. 
+
+  The PCI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , contains valuable
+  information about which PCI hardware does work under Linux and which
+  doesn't.
+
+QSpan PCI
+CONFIG_PCI_QSPAN
+  Find out whether you have a PCI motherboard. PCI is the name of a
+  bus system, i.e. the way the CPU talks to the other stuff inside
+  your box. Other bus systems are ISA, EISA, Microchannel (MCA) or
+  VESA. If you have PCI, say Y, otherwise N. 
+
+  The PCI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , contains valuable
+  information about which PCI hardware does work under Linux and which
+  doesn't.
+
+PCI access mode
+CONFIG_PCI_GOBIOS
+  On PCI systems, the BIOS can be used to detect the PCI devices and
+  determine their configuration. However, some old PCI motherboards
+  have BIOS bugs and may crash if this is done. Also, some embedded
+  PCI-based systems don't have any BIOS at all. Linux can also try to
+  detect the PCI hardware directly without using the BIOS.
+
+  With this option, you can specify how Linux should detect the PCI
+  devices. If you choose "BIOS", the BIOS will be used, if you choose
+  "Direct", the BIOS won't be used, and if you choose "Any", the
+  kernel will try the direct access method and falls back to the BIOS
+  if that doesn't work. If unsure, go with the default, which is
+  "Any".
+
+PCI device name database
+CONFIG_PCI_NAMES
+  By default, the kernel contains a database of all known PCI device
+  names to make the information in /proc/pci, /proc/ioports and
+  similar files comprehensible to the user. This database increases
+  size of the kernel image by about 80KB, but it gets freed after the
+  system boots up, so it doesn't take up kernel memory. Anyway, if you
+  are building an installation floppy or kernel for an embedded system
+  where kernel image size really matters, you can disable this feature
+  and you'll get device ID numbers instead of names.
+
+  When in doubt, say Y.
+
+MCA support
+CONFIG_MCA
+  MicroChannel Architecture is found in some IBM PS/2 machines and
+  laptops. It is a bus system similar to PCI or ISA. See
+  Documentation/mca.txt (and especially the web page given there)
+  before attempting to build an MCA bus kernel.
+
+EISA support
+CONFIG_EISA
+  The Extended Industry Standard Architecture (EISA) bus was
+  developed as an open alternative to the IBM MicroChannel bus.
+
+  The EISA bus provided some of the features of the IBM MicroChannel
+  bus while maintaining backward compatibility with cards made for
+  the older ISA bus. The EISA bus saw limited use between 1988 and 1995
+  when it was made obsolete by the PCI bus.
+
+  Say Y here if you are building a kernel for an EISA-based machine.
+
+  Otherwise, say N.
+
+SGI Visual Workstation support
+CONFIG_VISWS
+  The SGI Visual Workstation series is an IA32-based workstation
+  based on SGI systems chips with some legacy PC hardware attached.
+  Say Y here to create a kernel to run on the SGI 320 or 540.
+  A kernel compiled for the Visual Workstation will not run on other
+  PC boards and vice versa.
+  See Documentation/sgi-visws.txt for more.
+
+SGI Visual Workstation framebuffer support
+CONFIG_FB_SGIVW
+  SGI Visual Workstation support for framebuffer graphics.
+
+I2O support
+CONFIG_I2O
+  The Intelligent Input/Output (I2O) architecture allows hardware
+  drivers to be split into two parts: an operating system specific
+  module called the OSM and an hardware specific module called the
+  HDM. The OSM can talk to a whole range of HDM's, and ideally the
+  HDM's are not OS dependent. This allows for the same HDM driver to
+  be used under different operating systems if the relevant OSM is in
+  place. In order for this to work, you need to have an I2O interface
+  adapter card in your computer. This card contains a special I/O
+  processor (IOP), thus allowing high speeds since the CPU does not
+  have to deal with I/O.
+
+  If you say Y here, you will get a choice of interface adapter
+  drivers and OSM's with the following questions.
+
+  This support is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. You will get modules called i2o_core.o
+  and i20_config.o. 
+
+  If unsure, say N.
+
+I2O PCI support
+CONFIG_I2O_PCI
+  Say Y for support of PCI bus I2O interface adapters. Currently this
+  is the only variety supported, so you should say Y.
+
+  This support is also available as a module called i2o_pci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O Block OSM
+CONFIG_I2O_BLOCK
+  Include support for the I2O Block OSM. The Block OSM presents disk
+  and other structured block devices to the operating system.
+
+  This support is also available as a module called i2o_block.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O LAN OSM
+CONFIG_I2O_LAN
+  Include support for the LAN OSM. You will also need to include
+  support for token ring or FDDI if you wish to use token ring or FDDI
+  I2O cards with this driver.
+
+  This support is also available as a module called i2o_lan.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O SCSI OSM
+CONFIG_I2O_SCSI
+  Allows direct SCSI access to SCSI devices on a SCSI or FibreChannel
+  I2O controller. You can use both the SCSI and Block OSM together if
+  you wish.
+
+  This support is also available as a module called i2o_scsi.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+I2O /proc support
+CONFIG_I2O_PROC
+  If you say Y here and to "/proc file system support", you will be
+  able to read I2O related information from the virtual directory
+  /proc/i2o.
+
+  This support is also available as a module called i2o_proc.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Plug and Play support
+CONFIG_PNP
+  Plug and Play (PnP) is a standard for peripherals which allows those
+  peripherals to be configured by software, e.g. assign IRQ's or other
+  parameters. No jumpers on the cards are needed, instead the values
+  are provided to the cards from the BIOS, from the operating system,
+  or using a user-space utility.
+
+  Say Y here if you would like Linux to configure your Plug and Play
+  devices. You should then also say Y to "ISA Plug and Play support",
+  below. Alternatively, you can say N here and configure your PnP 
+  devices using the user space utilities contained in the isapnptools
+  package.
+  
+  This support is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+ISA Plug and Play support
+CONFIG_ISAPNP
+  Say Y here if you would like support for ISA Plug and Play devices.
+  Some information is in Documentation/isapnp.txt.
+ 
+  This support is also available as a module called isapnp.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+  If unsure, say Y.
+
+Support for hot-pluggable devices
+CONFIG_HOTPLUG
+  Say Y here if you want to plug devices into your computer while
+  the system is running, and be able to use them quickly.  In many
+  cases, the devices can likewise be unplugged at any time too.
+
+  One well known example of this is PCMCIA- or PC-cards, credit-card
+  size devices such as network cards, modems or hard drives which are
+  plugged into slots found on all modern laptop computers.
+
+  Another example, used on modern desktops as well as laptops, is USB.
+  Enable HOTPLUG with USB and KMOD, and your kernel will automatically
+  call out to a user mode "policy agent" to load modules and set up
+  software needed to use USB devices you plug in.  Get agent software
+  (at http://www.linux-usb.org/policy.html) and install it.
+
+PCMCIA/Cardbus support
+CONFIG_PCMCIA
+  Say Y here if you want to attach PCMCIA- or PC-cards to your Linux
+  computer. These are credit-card size devices such as network cards,
+  modems or hard drives often used with laptops computers. There are
+  actually two varieties of these cards: the older 16 bit PCMCIA cards
+  and the newer 32 bit CardBus cards. If you want to use CardBus
+  cards, you need to say Y here and also to "CardBus support" below.
+
+  To use your PC-cards, you will need supporting software from David 
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for 
+  location). Please also read the PCMCIA-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  When compiled this way, there will be modules called pcmcia_core.o
+  and ds.o.  If you want to compile it as a module, say M here and
+  read Documentation/modules.txt.
+
+CardBus support
+CONFIG_CARDBUS
+  CardBus is a bus mastering architecture for PC-cards, which allows 
+  for 32 bit PC-cards (the original PCMCIA standard specifies only 
+  a 16 bit wide bus). Many newer PC-cards are actually CardBus cards.
+
+  To use your PC-cards, you will need supporting software from David 
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for 
+  location).
+
+  If unsure, say Y.
+
+i82365/Yenta compatible bridge support
+CONFIG_I82365
+  Say Y here to include support for PCMCIA and CardBus host bridges
+  that are register compatible with the Intel i82365 and/or the Yenta
+  specification: this includes virtually all modern PCMCIA bridges.
+  "Bridge" is the name used for the hardware inside your computer that
+  PCMCIA cards are plugged into. If unsure, say Y.
+
+Databook TCIC host bridge support
+CONFIG_TCIC
+  Say Y here to include support for the Databook TCIC family of PCMCIA
+  host bridges. These are only found on a handful of old systems.
+  "Bridge" is the name used for the hardware inside your computer that
+  PCMCIA cards are plugged into. If unsure, say N.
+
+System V IPC
+CONFIG_SYSVIPC
+  Inter Process Communication is a suite of library functions and
+  system calls which let processes (running programs) synchronize and
+  exchange information. It is generally considered to be a good thing,
+  and some programs won't run unless you say Y here. In particular, if
+  you want to run the DOS emulator dosemu under Linux (read the
+  DOSEMU-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto ), you'll need to say Y
+  here.
+  
+  You can find documentation about IPC with "info ipc" and also in
+  section 6.4 of the Linux Programmer's Guide, available from
+  http://www.linuxdoc.org/docs.html#guide .
+
+  Shared memory is now implemented using a new (minimal) virtual file
+  system. To mount it automatically at system startup just add the
+  following line to your /etc/fstab:
+
+  none	/dev/shm	shm	defaults	0 0
+
+  Saying Y here enlarges your kernel by about 18 KB. Just say Y.
+
+BSD Process Accounting
+CONFIG_BSD_PROCESS_ACCT
+  If you say Y here, a user level program will be able to instruct the
+  kernel (via a special system call) to write process accounting
+  information to a file: whenever a process exits, information about
+  that process will be appended to the file by the kernel. The
+  information includes things such as creation time, owning user,
+  command name, memory usage, controlling terminal etc. (the complete
+  list is in the struct acct in include/linux/acct.h). It is up to the
+  user level program to do useful things with this information. This
+  is generally a good idea, so say Y.
+  
+Sysctl support
+CONFIG_SYSCTL
+  The sysctl interface provides a means of dynamically changing
+  certain kernel parameters and variables on the fly without requiring
+  a recompile of the kernel or reboot of the system. The primary
+  interface consists of a system call, but if you say Y to "/proc
+  file system support", a tree of modifiable sysctl entries will be
+  generated beneath the /proc/sys directory. They are explained in the
+  files in Documentation/sysctl/. Note that enabling this option will
+  enlarge the kernel by at least 8 KB.
+
+  As it is generally a good thing, you should say Y here unless
+  building a kernel for install/rescue disks or your system is very
+  limited in memory.
+
+Kernel core (/proc/kcore) format
+CONFIG_KCORE_ELF
+  If you enabled support for /proc file system then the file 
+  /proc/kcore will contain the kernel core image. This can be used 
+  in gdb:
+
+  $ cd /usr/src/linux ; gdb vmlinux /proc/kcore
+
+  You have two choices here: ELF and A.OUT. Selecting ELF will make 
+  /proc/kcore appear in ELF core format as defined by the Executable
+  and Linking Format specification. Selecting A.OUT will choose the
+  old "a.out" format which may be necessary for some old versions
+  of binutils or on some architectures.
+
+  This is especially useful if you have compiled the kernel with the 
+  "-g" option to preserve debugging information. It is mainly used 
+  for examining kernel data structures on the live kernel so if you 
+  don't understand what this means or are not a kernel hacker, just 
+  leave it at its default value ELF.
+
+Kernel support for ELF binaries
+CONFIG_BINFMT_ELF
+  ELF (Executable and Linkable Format) is a format for libraries and
+  executables used across different architectures and operating
+  systems. Saying Y here will enable your kernel to run ELF binaries
+  and enlarge it by about 13 KB. ELF support under Linux has now all
+  but replaced the traditional Linux a.out formats (QMAGIC and ZMAGIC)
+  because it is portable (this does *not* mean that you will be able
+  to run executables from different architectures or operating systems
+  however) and makes building run-time libraries very easy. Many new
+  executables are distributed solely in ELF format. You definitely
+  want to say Y here.
+
+  Information about ELF is contained in the ELF HOWTO available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you find that after upgrading from Linux kernel 1.2 and saying Y
+  here, you still can't run any ELF binaries (they just crash), then
+  you'll have to install the newest ELF runtime libraries, including
+  ld.so (check the file Documentation/Changes for location and latest
+  version).
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called binfmt_elf.o. Saying M or N here is dangerous because some
+  crucial programs on your system might be in ELF format.
+
+Kernel support for A.OUT binaries
+CONFIG_BINFMT_AOUT
+  A.out (Assembler.OUTput) is a set of formats for libraries and
+  executables used in the earliest versions of UNIX. Linux used the
+  a.out formats QMAGIC and ZMAGIC until they were replaced with the
+  ELF format.
+
+  As more and more programs are converted to ELF, the use for a.out
+  will gradually diminish. If you disable this option it will reduce
+  your kernel by one page. This is not much and by itself does not
+  warrant removing support. However its removal is a good idea if you
+  wish to ensure that absolutely none of your programs will use this
+  older executable format. If you don't know what to answer at this
+  point then answer Y. If someone told you "You need a kernel with
+  QMAGIC support" then you'll have to say Y here. You may answer M to
+  compile a.out support as a module and later load the module when you
+  want to use a program or library in a.out format. The module will be
+  called binfmt_aout.o. Saying M or N here is dangerous though,
+  because some crucial programs on your system might still be in A.OUT
+  format.
+
+Kernel support for Linux/Intel ELF binaries
+CONFIG_BINFMT_EM86
+  Say Y here if you want to be able to execute Linux/Intel ELF
+  binaries just like native Alpha binaries on your Alpha machine. For
+  this to work, you need to have the emulator /usr/bin/em86 in place.
+
+  You can get the same functionality by saying N here and saying Y to
+  "Kernel support for MISC binaries". 
+
+  You may answer M to compile the emulation support as a module and
+  later load the module when you want to use a Linux/Intel binary. The
+  module will be called binfmt_em86.o. If unsure, say Y.
+
+Kernel support for MISC binaries
+CONFIG_BINFMT_MISC
+  If you say Y here, it will be possible to plug wrapper-driven binary
+  formats into the kernel. You will like this especially when you use
+  programs that need an interpreter to run like Java, Python or
+  Emacs-Lisp. It's also useful if you often run DOS executables under
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto ). Once you have
+  registered such a binary class with the kernel, you can start one of
+  those programs simply by typing in its name at a shell prompt; Linux
+  will automatically feed it to the correct interpreter.
+
+  You can do other nice things, too. Read the file
+  Documentation/binfmt_misc.txt to learn how to use this feature, and
+  Documentation/java.txt for information about how to include Java
+  support.
+
+  You must say Y to "/proc file system support" (CONFIG_PROC_FS) to
+  use this part of the kernel.
+
+  You may say M here for module support and later load the module when
+  you have use for it; the module is called binfmt_misc.o. If you
+  don't know what to answer at this point, say Y.
+
+Solaris binary emulation (EXPERIMENTAL)
+CONFIG_SOLARIS_EMUL
+  This is experimental code which will enable you to run (many)
+  Solaris binaries on your SPARC Linux machine. 
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called solaris.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Processor family
+CONFIG_M386
+  This is the processor type of your CPU. This information is used for
+  optimizing purposes. In order to compile a kernel that can run on
+  all x86 CPU types (albeit not optimally fast), you can specify
+  "386" here.
+
+  The kernel will not necessarily run on earlier architectures than
+  the one you have chosen, e.g. a Pentium optimized kernel will run on
+  a PPro, but not necessarily on a i486.
+
+  Here are the settings recommended for greatest speed:
+   - "386" for the AMD/Cyrix/Intel 386DX/DXL/SL/SLC/SX, Cyrix/TI
+     486DLC/DLC2, UMC 486SX-S and NexGen Nx586. Only "386" kernels will
+     run on a 386 class machine.
+   - "486" for the AMD/Cyrix/IBM/Intel 486DX/DX2/DX4 or
+     SL/SLC/SLC2/SLC3/SX/SX2 and UMC U5D or U5S.
+   - "586" for generic Pentium CPUs, possibly lacking the TSC 
+     (time stamp counter) register.
+   - "Pentium-Classic" for the Intel Pentium.
+   - "Pentium-MMX" for the Intel Pentium MMX.
+   - "Pentium-Pro" for the Intel Pentium Pro/Celeron/Pentium II.
+   - "Pentium-III" for the Intel Pentium III.
+   - "Pentium-4" for the Intel Pentium 4
+   - "K6" for the AMD K6, K6-II and K6-III (aka K6-3D).
+   - "Athlon" for the AMD Athlon (K7).
+   - "Crusoe" for the Transmeta Crusoe series.
+   - "Winchip-C6" for original IDT Winchip.
+   - "Winchip-2" for IDT Winchip 2.
+   - "Winchip-2A" for IDT Winchips with 3dNow! capabilities.
+
+  If you don't know what to do, choose "386".
+
+VGA text console
+CONFIG_VGA_CONSOLE
+  Saying Y here will allow you to use Linux in text mode through a
+  display that complies with the generic VGA standard. Virtually
+  everyone wants that. 
+
+  The program SVGATextMode can be used to utilize SVGA video cards to
+  their full potential in text mode. Download it from
+  ftp://metalab.unc.edu/pub/Linux/utils/console .
+
+  Say Y.
+
+Video mode selection support
+CONFIG_VIDEO_SELECT
+  This enables support for text mode selection on kernel startup. If
+  you want to take advantage of some high-resolution text mode your
+  card's BIOS offers, but the traditional Linux utilities like
+  SVGATextMode don't, you can say Y here and set the mode using the
+  "vga=" option from your boot loader (lilo or loadlin) or set
+  "vga=ask" which brings up a video mode menu on kernel startup. (Try
+  "man bootparam" or see the documentation of your boot loader about
+  how to pass options to the kernel.)
+
+  Read the file Documentation/svga.txt for more information about the
+  Video mode selection support. If unsure, say N.
+
+Support for frame buffer devices (EXPERIMENTAL)
+CONFIG_FB
+  The frame buffer device provides an abstraction for the graphics
+  hardware. It represents the frame buffer of some video hardware and
+  allows application software to access the graphics hardware through
+  a well-defined interface, so the software doesn't need to know
+  anything about the low-level (hardware register) stuff. 
+
+  Frame buffer devices work identically across the different
+  architectures supported by Linux and make the implementation of
+  application programs easier and more portable; at this point, an X
+  server exists which uses the frame buffer device exclusively.
+  On several non-X86 architectures, the frame buffer device is the
+  only way to use the graphics hardware.
+ 
+  The device is accessed through special device nodes, usually located
+  in the /dev directory, i.e. /dev/fb*.
+
+  You need an utility program called fbset to make full use of frame
+  buffer devices. Please read Documentation/fb/framebuffer.txt and the
+  Framebuffer-HOWTO at
+  http://www.tahallah.demon.co.uk/programming/prog.html for more
+  information.
+
+  Say Y here and to the driver for your graphics board below if you
+  are compiling a kernel for a non-x86 architecture.
+
+  If you are compiling for the x86 architecture, you can say Y if you
+  want to play with it, but it is not essential. Please note that
+  running graphical applications that directly touch the hardware
+  (e.g. an accelerated X server) and that are not frame buffer
+  device-aware may cause unexpected results. If unsure, say N.
+
+Acorn VIDC support
+CONFIG_FB_ACORN
+  This is the frame buffer device driver for the Acorn VIDC graphics
+  hardware found in Acorn RISC PCs and other ARM-based machines.  If
+  unsure, say N.
+
+Amiga native chipset support
+CONFIG_FB_AMIGA
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Amigas.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called amifb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amiga OCS chipset support
+CONFIG_FB_AMIGA_OCS
+  This enables support for the original Agnus and Denise video chips,
+  found in the Amiga 1000 and most A500's and A2000's. If you intend
+  to run Linux on any of these systems, say Y; otherwise say N.
+
+Amiga ECS chipset support
+CONFIG_FB_AMIGA_ECS
+  This enables support for the Enhanced Chip Set, found in later
+  A500's, later A2000's, the A600, the A3000, the A3000T and CDTV. If
+  you intend to run Linux on any of these systems, say Y; otherwise
+  say N.
+
+Amiga AGA chipset support
+CONFIG_FB_AMIGA_AGA
+  This enables support for the Advanced Graphics Architecture (also
+  known as the AGA or AA) Chip Set, found in the A1200, A4000, A4000T
+  and CD32. If you intend to run Linux on any of these systems, say Y;
+  otherwise say N.
+
+Amiga CyberVision support
+CONFIG_FB_CYBER
+  This enables support for the Cybervision 64 graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64 or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the
+  Cybervision 64 3D card, as they use incompatible video chips.
+
+CyberPro 20x0 support
+CONFIG_FB_CYBER2000
+  This enables support for the Integraphics CyberPro 20x0 and 5000
+  VGA chips used in the Rebel.com Netwinder and other machines.
+  Say Y if you have a NetWinder or a graphics card containing this
+  device, otherwise say N.
+
+Amiga CyberVision3D support (EXPERIMENTAL)
+CONFIG_FB_VIRGE
+  This enables support for the Cybervision 64/3D graphics card from
+  Phase5. Please note that its use is not all that intuitive (i.e. if
+  you have any questions, be sure to ask!). Say N unless you have a
+  Cybervision 64/3D or plan to get one before you next recompile the
+  kernel. Please note that this driver DOES NOT support the older
+  Cybervision 64 card, as they use incompatible video chips.
+
+Amiga RetinaZ3 support (EXPERIMENTAL)
+CONFIG_FB_RETINAZ3
+  This enables support for the Retina Z3 graphics card. Say N unless
+  you have a Retina Z3 or plan to get one before you next recompile
+  the kernel.
+
+Cirrus Logic generic driver (EXPERIMENTAL)
+CONFIG_FB_CLGEN
+  This enables support for Cirrus Logic GD542x/543x based boards on
+  Amiga: SD64, Piccolo, Picasso II/II+, Picasso IV, or EGS Spectrum.
+
+  If you have a PCI-based system, this enables support for these
+  chips: GD-543x, GD-544x, GD-5480.
+
+  Please read the file Documentation/fb/clgenfb.txt.
+
+  Say N unless you have such a graphics board or plan to get one
+  before you next recompile the kernel.
+
+Permedia2 support (EXPERIMENTAL)
+CONFIG_FB_PM2
+  Say Y here if this is your graphics board.
+
+Apollo support
+CONFIG_APOLLO
+  Say Y here if you want to run Linux on an MC680x0-based Apollo
+  Domain workstation such as the DN3500.
+
+Apollo 3c505 support
+CONFIG_APOLLO_ELPLUS
+  Say Y or M here if your Apollo has a 3Com 3c505 ISA Ethernet card.
+  If you don't have one made for Apollos, you can use one from a PC,
+  except that your Apollo won't be able to boot from it (because the
+  code in the ROM will be for a PC).
+
+Atari native chipset support
+CONFIG_FB_ATARI
+  This is the frame buffer device driver for the builtin graphics
+  chipset found in Ataris.
+
+Open Firmware frame buffer device support 
+CONFIG_FB_OF
+  Say Y if you want support with Open Firmware for your graphics
+  board.
+
+S3 Trio frame buffer device support 
+CONFIG_FB_S3TRIO
+  If you have a S3 Trio say Y. Say N for S3 Virge. 
+
+3Dfx Banshee/Voodoo3 display support (EXPERIMENTAL)
+CONFIG_FB_3DFX
+  This driver supports graphics boards with the 3Dfx Banshee/Voodoo3
+  chips. Say Y if you have such a graphics board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called tdfxfb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+nVidia Riva support (EXPERIMENTAL)
+CONFIG_FB_RIVA
+  This driver supports graphics boards with the nVidia Riva (aka TNTx)
+  chips.
+  Say Y if you have such a graphics board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called rivafb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+ATI Mach64 display support (EXPERIMENTAL)
+CONFIG_FB_ATY
+  This driver supports graphics boards with the ATI Mach64 chips.
+  Say Y if you have such a graphics board.
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called atyfb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+  
+ATI Rage128 display support (EXPERIMENTAL)
+CONFIG_FB_ATY128
+  This driver supports graphics boards with the ATI Rage128 chips.
+  Say Y if you have such a graphics board and read
+  Documentation/fb/aty128fb.txt. 
+
+  The driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called aty128fb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PowerMac "control" frame buffer device support
+CONFIG_FB_CONTROL
+  This driver supports a frame buffer for the graphics adapter in the
+  Power Macintosh 7300 and others.
+
+PowerMac "platinum" frame buffer device support
+CONFIG_FB_PLATINUM
+  This driver supports a frame buffer for the "platinum" graphics
+  adapter in some Power Macintoshes.
+
+PowerMac "valkyrie" frame buffer device support
+CONFIG_FB_VALKYRIE
+  This driver supports a frame buffer for the "valkyrie" graphics
+  adapter in some Power Macintoshes.
+
+Chips 65550 display support
+CONFIG_FB_CT65550
+  This is the frame buffer device driver for the Chips & Technologies
+  65550 graphics chip in PowerBooks.
+
+TGA frame buffer support
+CONFIG_FB_TGA
+  This is the frame buffer device driver for generic TGA graphic
+  cards. Say Y if you have one of those.
+
+VESA VGA graphics console
+CONFIG_FB_VESA
+  This is the frame buffer device driver for generic VESA 2.0
+  compliant graphic cards. The older VESA 1.2 cards are not supported.
+  You will get a boot time penguin logo at no additional cost. Please
+  read Documentation/fb/vesafb.txt. If unsure, say Y.
+
+VGA 16-color planar support
+CONFIG_FBCON_VGA_PLANES
+  This low level frame buffer console driver enable the kernel to use
+  the 16-color planar modes of the old VGA cards where the bits of
+  each pixel are separated into 4 planes. 
+
+  Only answer Y here if you have a (very old) VGA card that isn't VESA
+  2 compatible.
+
+VGA 16-color graphics console
+CONFIG_FB_VGA16
+  This is the frame buffer device driver for VGA 16 color graphic
+  cards. Say Y if you have such a card.
+
+  This code is also available as a module. If you want to compile it
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called vga16fb.o.
+
+Select other compiled-in fonts
+CONFIG_FBCON_FONTS
+  Say Y here if you would like to use fonts other than the default
+  your frame buffer console usually use.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about foreign fonts.
+
+  If unsure, say N (the default choices are safe).
+
+VGA 8x16 font
+CONFIG_FONT_8x16
+  This is the "high resolution" font for the VGA frame buffer (the one
+  provided by the VGA text console 80x25 mode.
+
+  If unsure, say Y.
+
+Support only 8 pixels wide fonts
+CONFIG_FBCON_FONTWIDTH8_ONLY
+  Answer Y here will make the kernel provide only the 8x8 fonts (these
+  are the less readable).
+
+  If unsure, say N.
+
+Sparc console 8x16 font
+CONFIG_FONT_SUN8x16
+  This is the high resolution console font for Sun machines. Say Y.
+
+Sparc console 12x22 font (not supported by all drivers)
+CONFIG_FONT_SUN12x22
+  This is the high resolution console font for Sun machines with very
+  big letters (like the letters used in the SPARC PROM). If the
+  standard font is unreadable for you, say Y, otherwise say N.
+
+VGA 8x8 font
+CONFIG_FONT_8x8
+  This is the "high resolution" font for the VGA frame buffer (the one
+  provided by the text console 80x50 (and higher) modes). 
+
+  Note that this is a poor quality font. The VGA 8x16 font is quite a
+  lot more readable. 
+
+  Given the resolution provided by the frame buffer device, answer N
+  here is safe.
+
+Backward compatibility mode for Xpmac
+CONFIG_FB_COMPAT_XPMAC
+  If you use the Xpmac X server (common with mklinux), you'll need to
+  say Y here to use X. You should consider changing to XFree86 which
+  includes a server that supports the frame buffer device directly
+  (XF68_FBDev).
+
+HGA monochrome support (EXPERIMENTAL)
+CONFIG_FB_HGA
+  Say Y here if you have a Hercules mono graphics card.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called hgafb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  As this card technology is 15 years old, most people will answer N
+  here.
+
+Matrox unified accelerated driver (EXPERIMENTAL)
+CONFIG_FB_MATROX
+  Say Y here if you have a Matrox Millennium, Matrox Millennium II,
+  Matrox Mystique, Matrox Mystique 220, Matrox Productiva G100, Matrox
+  Mystique G200, Matrox Millennium G200, Matrox Marvel G200 video,
+  Matrox G400 or G450 card in your box. At this time, support for the G100
+  is untested and support for G450 is highly experimental.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called matroxfb.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  You can pass several parameters to the driver at boot time or at
+  module load time. The parameters look like "video=matrox:XXX", where
+  the meaning of XXX can be found at the end of the main source file
+  (drivers/video/matroxfb.c). Please see the file
+  Documentation/fb/matroxfb.txt. 
+
+Matrox Millennium support
+CONFIG_FB_MATROX_MILLENIUM
+  Say Y here if you have a Matrox Millennium or Matrox Millennium II
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 4 bpp packed pixel, 8 bpp packed pixel, 16 bpp
+  packed pixel, 24 bpp packed pixel and 32 bpp packed pixel. You can
+  also use font widths different from 8.
+
+Matrox Mystique support
+CONFIG_FB_MATROX_MYSTIQUE
+  Say Y here if you have a Matrox Mystique or Matrox Mystique 220
+  video card. If you select "Advanced lowlevel driver options" below,
+  you should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp
+  packed pixel and 32 bpp packed pixel. You can also use font widths
+  different from 8.
+
+Matrox G100/G200/G400/G450 support
+CONFIG_FB_MATROX_G100
+  Say Y here if you have a Matrox G100, G200, G400 or G450 based
+  video card. If you select "Advanced lowlevel driver options", you 
+  should check 8 bpp packed pixel, 16 bpp packed pixel, 24 bpp packed 
+  pixel and 32 bpp packed pixel. You can also use font widths 
+  different from 8.
+
+  If you need support for G400 secondary head, you must first say Y to
+  "I2C support" and "I2C bit-banging support" in the character devices
+  section, and then to "Matrox I2C support" and "G400 second head
+  support" here in the framebuffer section.
+
+Matrox I2C support
+CONFIG_FB_MATROX_I2C
+  This drivers creates I2C buses which are needed for accessing the
+  DDC (I2C) bus present on all Matroxes, an I2C bus which
+  interconnects Matrox optional devices, like MGA-TVO on G200 and
+  G400, and the secondary head DDC bus, present on G400 only.
+  
+  You can say Y or M here if you want to experiment with monitor 
+  detection code. You must say Y or M here if you want to use either
+  second head of G400 or MGA-TVO on G200 or G400.
+  
+  If you compile it as module, it will create a module named
+  i2c-matroxfb.o.
+  
+Matrox G400 second head support
+CONFIG_FB_MATROX_MAVEN
+  WARNING !!! This support does not work with G450 !!!
+
+  Say Y or M here if you want to use a secondary head (meaning two
+  monitors in parallel) on G400 or MGA-TVO add-on on G200. Secondary
+  head is not compatible with accelerated XFree 3.3.x SVGA servers -
+  secondary head output is blanked while you are in X. With XFree
+  3.9.17 preview you can use both heads if you use SVGA over fbdev or
+  the fbdev driver on first head and the fbdev driver on second head.
+  
+  If you compile it as module, two modules are created,
+  matroxfb_crtc2.o and matroxfb_maven.o. Matroxfb_maven is needed for
+  both G200 and G400, matroxfb_crtc2 is needed only by G400. You must
+  also load i2c-matroxfb to get it to run.
+  
+  The driver starts in monitor mode and you must use the matroxset
+  tool (available at ftp://platan.vc.cvut.cz/pub/linux/matrox-latest)
+  to switch it to PAL or NTSC or to swap primary and secondary head
+  outputs. Secondary head driver also always start in 640x480
+  resolution, you must use fbset to change it.
+  
+  Also do not forget that second head supports only 16 and 32 bpp
+  packed pixels, so it is a good idea to compile them into the kernel
+  too. You can use only some font widths, as the driver uses generic
+  painting procedures (the secondary head does not use acceleration
+  engine).
+  
+  There is no need for enabling 'Matrox multihead support' if you have
+  only one Matrox card in the box.
+
+Matrox G450 second head support
+CONFIG_FB_MATROX_G450
+  Say Y or M here if you want to use a secondary head (meaning two
+  monitors in parallel) on G450.
+
+  If you compile it as module, two modules are created,
+  matroxfb_crtc2.o and matroxfb_g450.o. Both modules are needed if you
+  want two independent display devices.
+
+  The driver starts in monitor mode and currently does not support
+  output in TV modes. You must use the matroxset tool (available
+  at ftp://platan.vc.cvut.cz/pub/linux/matrox-latest) to swap primary
+  and secondary head outputs. Secondary head driver always start in
+  640x480 resolution and you must use fbset to change it.
+
+  Also do not forget that second head supports only 16 and 32 bpp
+  packed pixels, so it is a good idea to compile them into the kernel
+  too. You can use only some font widths, as the driver uses generic
+  painting procedures (the secondary head does not use acceleration
+  engine).
+
+  There is no need for enabling 'Matrox multihead support' if you have
+  only one Matrox card in the box.
+
+Matrox unified driver multihead support
+CONFIG_FB_MATROX_MULTIHEAD
+  Say Y here if you have more than one (supported) Matrox device in
+  your computer and you want to use all of them for different monitors
+  ("multihead"). If you have only one device, you should say N because
+  the driver compiled with Y is larger and a bit slower, especially on
+  ia32 (ix86).
+
+  If you said M to "Matrox unified accelerated driver" and N here, you
+  will still be able to use several Matrox devices simultaneously:
+  insert several instances of the module matroxfb.o into the kernel
+  with insmod, supplying the parameter "dev=N" where N is 0, 1, etc.
+  for the different Matrox devices. This method is slightly faster but
+  uses 40 KB of kernel memory per Matrox card.
+
+MDA text console (dual-headed)
+CONFIG_MDA_CONSOLE
+  Say Y here if you have an old MDA or monochrome Hercules graphics
+  adapter in your system acting as a second head ( = video card). You
+  will then be able to use two monitors with your Linux system. Do not
+  say Y here if your MDA card is the primary card in your system; the
+  normal VGA driver will handle it.
+  
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want).
+  The module will be called mdacon.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+SBUS and UPA frame buffers
+CONFIG_FB_SBUS
+  Say Y if you want support for SBUS or UPA based frame buffer device.
+
+Creator/Creator3D support
+CONFIG_FB_CREATOR
+  This is the frame buffer device driver for the Creator and Creator3D
+  graphics boards.
+
+CGsix (GX,TurboGX) support
+CONFIG_FB_CGSIX
+  This is the frame buffer device driver for the CGsix (GX, TurboGX)
+  frame buffer.
+
+BWtwo support
+CONFIG_FB_BWTWO
+  This is the frame buffer device driver for the BWtwo frame buffer.
+
+CGthree support
+CONFIG_FB_CGTHREE
+  This is the frame buffer device driver for the CGthree frame buffer.
+
+TCX (SS4/SS5 only) support
+CONFIG_FB_TCX
+  This is the frame buffer device driver for the TCX 24/8bit frame
+  buffer.
+
+Virtual Frame Buffer support (ONLY FOR TESTING!)
+CONFIG_FB_VIRTUAL
+  This is a `virtual' frame buffer device. It operates on a chunk of
+  unswapable kernel memory instead of on the memory of a graphics
+  board. This means you cannot see any output sent to this frame
+  buffer device, while it does consume precious memory. The main use
+  of this frame buffer device is testing and debugging the frame
+  buffer subsystem. Do NOT enable it for normal systems! To protect
+  the innocent, it has to be enabled explicitly at boot time using the
+  kernel option `video=vfb:'.
+
+  This driver is also available as a module ( = code which can be
+  inserted and removed from the running kernel whenever you want). The
+  module will be called vfb.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+ 
+  If unsure, say N.
+
+CONFIG_FB_SA1100
+  This is a framebuffer device for the SA-1100 LCD Controller.
+  See http://www.linux-fbdev.org/ for information on framebuffer
+  devices.
+
+  If you plan to use the LCD display with your SA-1100 system, say
+  Y here.
+
+Advanced low level driver options
+CONFIG_FBCON_ADVANCED
+  The frame buffer console uses character drawing routines that are
+  tailored to the specific organization of pixels in the memory of
+  your graphics hardware. These are called the low level frame buffer
+  console drivers. Note that they are used for text console output
+  only; they are NOT needed for graphical applications.
+
+  If you say N here, the needed low level drivers are automatically
+  enabled, depending on what frame buffer devices you selected above.
+  This is recommended for most users.
+
+  If you say Y here, you have more fine-grained control over which low
+  level drivers are enabled. You can e.g. leave out low level drivers
+  for color depths you do not intend to use for text consoles.
+
+  Low level frame buffer console drivers can be modules ( = code which
+  can be inserted and removed from the running kernel whenever you
+  want). The modules will be called fbcon-*.o. If you want to compile
+  (some of) them as modules, read Documentation/modules.txt.
+  
+  If unsure, say N.
+
+Monochrome support
+CONFIG_FBCON_MFB
+  This is the low level frame buffer console driver for monochrome
+  (2 colors) packed pixels.
+
+2 bpp packed pixels support
+CONFIG_FBCON_CFB2
+  This is the low level frame buffer console driver for 2 bits per
+  pixel (4 colors) packed pixels.
+
+4 bpp packed pixels support
+CONFIG_FBCON_CFB4
+  This is the low level frame buffer console driver for 4 bits per
+  pixel (16 colors) packed pixels.
+
+8 bpp packed pixels support
+CONFIG_FBCON_CFB8
+  This is the low level frame buffer console driver for 8 bits per
+  pixel (256 colors) packed pixels.
+
+16 bpp packed pixels support
+CONFIG_FBCON_CFB16
+  This is the low level frame buffer console driver for 15 or 16 bits
+  per pixel (32K or 64K colors, also known as `hicolor') packed
+  pixels.
+
+24 bpp packed pixels support
+CONFIG_FBCON_CFB24
+  This is the low level frame buffer console driver for 24 bits per
+  pixel (16M colors, also known as `truecolor') packed pixels. It is
+  NOT for `sparse' 32 bits per pixel mode.
+
+32 bpp packed pixels support
+CONFIG_FBCON_CFB32
+  This is the low level frame buffer console driver for 32 bits per
+  pixel (16M colors, also known as `truecolor') sparse packed pixels.
+
+Amiga bitplanes support
+CONFIG_FBCON_AFB
+  This is the low level frame buffer console driver for 1 to 8
+  bitplanes (2 to 256 colors) on Amiga.
+
+Amiga interleaved bitplanes support
+CONFIG_FBCON_ILBM
+  This is the low level frame buffer console driver for 1 to 8
+  interleaved bitplanes (2 to 256 colors) on Amiga.
+
+Atari interleaved bitplanes (2 planes) support
+CONFIG_FBCON_IPLAN2P2
+  This is the low level frame buffer console driver for 2 interleaved
+  bitplanes (4 colors) on Atari.
+
+Atari interleaved bitplanes (4 planes) support
+CONFIG_FBCON_IPLAN2P4
+  This is the low level frame buffer console driver for 4 interleaved
+  bitplanes (16 colors) on Atari.
+
+Atari interleaved bitplanes (8 planes) support
+CONFIG_FBCON_IPLAN2P8
+  This is the low level frame buffer console driver for 8 interleaved
+  bitplanes (256 colors) on Atari.
+
+Mac variable bpp packed pixels support
+CONFIG_FBCON_MAC
+  This is the low level frame buffer console driver for 1/2/4/8/16/32
+  bits per pixel packed pixels on Mac. It supports variable font
+  widths for low resolution screens.
+  
+HGA monochrome support (EXPERIMENTAL)
+CONFIG_FBCON_HGA
+  This is the low level frame buffer console driver for Hercules mono 
+  graphics cards.
+
+VGA characters/attributes support
+CONFIG_FBCON_VGA
+  This is the low level frame buffer console driver for VGA text mode;
+  it is used by frame buffer device drivers that support VGA text
+  mode.
+
+Parallel-port support
+CONFIG_PARPORT
+  If you want to use devices connected to your machine's parallel port
+  (the connector at the computer with 25 holes), e.g. printer, ZIP
+  drive, PLIP link (Parallel Line Internet Protocol is mainly used to
+  create a mini network by connecting the parallel ports of two local
+  machines) etc., then you need to say Y here; please read
+  Documentation/parport.txt and drivers/parport/BUGS-parport.
+
+  For extensive information about drivers for many devices attaching
+  to the parallel port see http://www.torque.net/linux-pp.html on the
+  WWW.
+
+  It is possible to share a single parallel port among several devices
+  and it is safe to compile all the corresponding drivers into the
+  kernel. If you want to compile parallel port support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called parport.o. If you have more than one
+  parallel port and want to specify which port and IRQ to be used by
+  this driver at module load time, take a look at
+  Documentation/parport.txt.
+
+  If unsure, say Y.
+
+PC-style hardware
+CONFIG_PARPORT_PC
+  You should say Y here if you have a PC-style parallel port. All IBM
+  PC compatible computers and some Alphas have PC-style parallel
+  ports. 
+
+  This code is also available as a module. If you want to compile it
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called parport_pc.o.
+  
+  If unsure, say Y.
+
+Use FIFO/DMA if available
+CONFIG_PARPORT_PC_FIFO
+  Many parallel port chipsets provide hardware that can speed up
+  printing. Say Y here if you want to take advantage of that.
+
+  As well as actually having a FIFO, or DMA capability, the kernel
+  will need to know which IRQ the parallel port has. By default,
+  parallel port interrupts will not be used, and so neither will the
+  FIFO. See Documentation/parport.txt to find out how to specify
+  which IRQ/DMA to use.
+
+SuperIO chipset support (EXPERIMENTAL)
+CONFIG_PARPORT_PC_SUPERIO
+  Saying Y here enables some probes for Super-IO chipsets in order to
+  find out things like base addresses, IRQ lines and DMA channels.  It
+  is safe to say N.
+
+Support for PCMCIA management for PC-style ports
+CONFIG_PARPORT_PC_PCMCIA
+  Say Y here if you need PCMCIA support for your PC-style parallel
+  ports. If unsure, say N.
+
+Support foreign hardware
+CONFIG_PARPORT_OTHER
+  Say Y here if you want to be able to load driver modules to support
+  other non-standard types of parallel ports. This causes a
+  performance loss, so most people say N.
+
+Sun Ultra/AX-style hardware 
+CONFIG_PARPORT_AX
+  Say Y here if you need support for the parallel port hardware on Sun
+  Ultra/AX machines. This code is also available as a module (say M),
+  called parport_ax.o. If in doubt, saying N is the safe plan.
+
+Amiga built-in parallel port support
+CONFIG_PARPORT_AMIGA
+  Say Y here if you need support for the parallel port hardware on
+  Amiga machines. This code is also available as a module (say M),
+  called parport_amiga.o. If in doubt, saying N is the safe plan.
+
+Atari built-in parallel port support
+CONFIG_PARPORT_ATARI
+  Say Y here if you need support for the parallel port hardware on
+  Atari machines. This code is also available as a module (say M),
+  called parport_atari.o. If in doubt, saying N is the safe plan.
+
+Multiface 3 parallel port card support
+CONFIG_PARPORT_MFC3
+  Say Y here if you need parallel port support for the MFC3 card.
+  This code is also available as a module (say M), called
+  parport_mfc3.o. If in doubt, saying N is the safe plan.
+
+Support IEEE1284 status readback
+CONFIG_PRINTER_READBACK
+  If you have a device on your parallel port that support this
+  protocol, this option will allow the device to report its status. It
+  is safe to say Y.
+
+IEEE1284 transfer modes
+CONFIG_PARPORT_1284
+  If you have a printer that supports status readback or device ID, or
+  want to use a device that uses enhanced parallel port transfer modes
+  such as EPP and ECP, say Y here to enable advanced IEEE 1284
+  transfer modes. Also say Y if you want device ID information to
+  appear in /proc/sys/dev/parport/*/autoprobe*. It is safe to say N.
+ 
+Enable loadable module support
+CONFIG_MODULES
+  Kernel modules are small pieces of compiled code which can be
+  inserted in or removed from the running kernel, using the programs
+  insmod and rmmod. This is described in the file
+  Documentation/modules.txt, including the fact that you have to say
+  "make modules" in order to compile the modules that you chose during
+  kernel configuration. Modules can be device drivers, file systems,
+  binary executable formats, and so on. If you think that you may want
+  to make use of modules with this kernel in the future, then say Y
+  here. If unsure, say Y.
+
+Set version information on all symbols for modules
+CONFIG_MODVERSIONS
+  Usually, modules have to be recompiled whenever you switch to a new
+  kernel. Saying Y here makes it possible, and safe, to use the
+  same modules even after compiling a new kernel; this requires the
+  program modprobe. All the software needed for module support is in
+  the modutils package (check the file Documentation/Changes for
+  location and latest version). NOTE: if you say Y here but don't
+  have the program genksyms (which is also contained in the above
+  mentioned modutils package), then the building of your kernel will
+  fail. If you are going to use modules that are generated from
+  non-kernel sources, you would benefit from this option. Otherwise
+  it's not that important. So, N ought to be a safe bet.
+
+Kernel module loader support
+CONFIG_KMOD
+  Normally when you have selected some drivers and/or file systems to
+  be created as loadable modules, you also have the responsibility to
+  load the corresponding modules (using the programs insmod or
+  modprobe) before you can use them. If you say Y here however, the
+  kernel will be able to load modules for itself: when a part of the
+  kernel needs a module, it runs modprobe with the appropriate
+  arguments, thereby loading the module if it is available. (This is a
+  replacement for kerneld.) Say Y here and read about configuring it
+  in Documentation/kmod.txt.
+
+ARP daemon support (EXPERIMENTAL)
+CONFIG_ARPD
+  Normally, the kernel maintains an internal cache which maps IP 
+  addresses to hardware addresses on the local network, so that
+  Ethernet/Token Ring/ etc. frames are sent to the proper address on
+  the physical networking layer. For small networks having a few
+  hundred directly connected hosts or less, keeping this address
+  resolution (ARP) cache inside the kernel works well. However,
+  maintaining an internal ARP cache does not work well for very large
+  switched networks, and will use a lot of kernel memory if TCP/IP
+  connections are made to many machines on the network. 
+
+  If you say Y here, the kernel's internal ARP cache will never grow
+  to more than 256 entries (the oldest entries are expired in a LIFO
+  manner) and communication will be attempted with the user space ARP
+  daemon arpd. Arpd then answers the address resolution request either
+  from its own cache or by asking the net.
+
+  This code is experimental and also obsolete. If you want to use it,
+  you need to find a version of the daemon arpd on the net somewhere,
+  and you should also say Y to "Kernel/User network link driver",
+  below. If unsure, say N.
+
+TCP/IP networking
+CONFIG_INET
+  These are the protocols used on the Internet and on most local
+  Ethernets. It is highly recommended to say Y here (this will enlarge
+  your kernel by about 144 KB), since some programs (e.g. the X window
+  system) use TCP/IP even if your machine is not connected to any
+  other computer. You will get the so-called loopback device which
+  allows you to ping yourself (great fun, that!).
+
+  For an excellent introduction to Linux networking, please read the
+  NET-3-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This option is also necessary if you want to use the full power of
+  term (term is a program which gives you almost full Internet
+  connectivity if you have a regular dial up shell account on some
+  Internet connected Unix computer; for more information, read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html ).
+  
+  If you say Y here and also to "/proc file system support" and
+  "Sysctl support" below, you can change various aspects of the
+  behavior of the TCP/IP code by writing to the (virtual) files in
+  /proc/sys/net/ipv4/*; the options are explained in the file
+  Documentation/networking/ip-sysctl.txt.
+
+  Short answer: say Y.
+
+IP: multicasting
+CONFIG_IP_MULTICAST
+  This is code for addressing several networked computers at once,
+  enlarging your kernel by about 2 KB. You need multicasting if you
+  intend to participate in the MBONE, a high bandwidth network on top
+  of the Internet which carries audio and video broadcasts. More
+  information about the MBONE is on the WWW at
+  http://www-itg.lbl.gov/mbone/ . Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. For most people, it's safe
+  to say N.
+
+IP: advanced router
+CONFIG_IP_ADVANCED_ROUTER
+  If you intend to run your Linux box mostly as a router, i.e. as a
+  computer that forwards and redistributes network packets, say Y; you
+  will then be presented with several options that allow more precise
+  control about the routing process.
+
+  The answer to this question won't directly affect the kernel:
+  answering N will just cause this configure script to skip all the
+  questions about advanced routing.
+
+  Note that your box can only act as a router if you enable IP
+  forwarding in your kernel; you can do that by saying Y to "/proc
+  file system support" and "Sysctl support" below and executing the
+  line
+
+    echo "1" > /proc/sys/net/ipv4/ip_forward
+
+  at boot time after the /proc file system has been mounted. 
+
+  If you turn on IP forwarding, you will also get the rp_filter, which
+  automatically rejects incoming packets if the routing table entry
+  for their source address doesn't match the network interface they're
+  arriving on. This has security advantages because it prevents the
+  so-called IP spoofing, however it can pose problems if you use
+  asymmetric routing (packets from you to a host take a different path
+  than packets from that host to you) or if you operate a non-routing
+  host which has several IP addresses on different interfaces. To turn
+  rp_filter off use:
+
+        echo 0 > /proc/sys/net/ipv4/conf/<device>/rp_filter
+  or
+        echo 0 > /proc/sys/net/ipv4/conf/all/rp_filter
+
+  If unsure, say N here.
+
+IP: policy routing
+CONFIG_IP_MULTIPLE_TABLES
+  Normally, a router decides what to do with a received packet based
+  solely on the packet's final destination address. If you say Y here,
+  the Linux router will also be able to take the packet's source
+  address into account. Furthermore, if you also say Y to "IP: use TOS
+  value as routing key" below, the TOS (Type-Of-Service) field of the
+  packet can be used for routing decisions as well. In addition, if
+  you say Y here and to "IP: fast network address translation" below,
+  the router will also be able to modify source and destination
+  addresses of forwarded packets.
+
+  If you are interested in this, please see the preliminary
+  documentation at http://www.compendium.com.ar/policy-routing.txt and
+  ftp://post.tepkom.ru/pub/vol2/Linux/docs/advanced-routing.tex . You
+  will need supporting software from ftp://ftp.inr.ac.ru/ip-routing/
+  
+  If unsure, say N.
+  
+IP: equal cost multipath
+CONFIG_IP_ROUTE_MULTIPATH
+  Normally, the routing tables specify a single action to be taken in
+  a deterministic manner for a given packet. If you say Y here
+  however, it becomes possible to attach several actions to a packet
+  pattern, in effect specifying several alternative paths to travel
+  for those packets. The router considers all these paths to be of
+  equal "cost" and chooses one of them in a non-deterministic fashion
+  if a matching packet arrives.
+
+IP: use TOS value as routing key
+CONFIG_IP_ROUTE_TOS
+  The header of every IP packet carries a TOS (Type Of Service) value
+  with which the packet requests a certain treatment, e.g. low latency
+  (for interactive traffic), high throughput, or high reliability. If
+  you say Y here, you will be able to specify different routes for
+  packets with different TOS values.
+
+IP: use netfilter MARK value as routing key
+CONFIG_IP_ROUTE_FWMARK
+  If you say Y here, you will be able to specify different routes for
+  packets with different mark values (see iptables(8), MARK target).
+
+IP: verbose route monitoring
+CONFIG_IP_ROUTE_VERBOSE
+  If you say Y here, which is recommended, then the kernel will print
+  verbose messages regarding the routing, for example warnings about
+  received packets which look strange and could be evidence of an
+  attack or a misconfigured system somewhere. The information is
+  handled by the klogd daemon which is responsible for kernel messages
+  ("man klogd").
+
+IP: large routing tables
+CONFIG_IP_ROUTE_LARGE_TABLES
+  If you have routing zones that grow to more than about 64 entries,
+  you may want to say Y here to speed up the routing process.
+
+IP: fast network address translation
+CONFIG_IP_ROUTE_NAT
+  If you say Y here, your router will be able to modify source and
+  destination addresses of packets that pass through it, in a manner
+  you specify. General information about Network Address Translation
+  can be gotten from the document
+  http://www.csn.tu-chemnitz.de/~mha/linux-ip-nat/diplom/nat.html
+
+IP: kernel level autoconfiguration
+CONFIG_IP_PNP
+  This enables automatic configuration of IP addresses of devices and
+  of the routing table during kernel boot, based on either information
+  supplied on the kernel command line or by BOOTP or RARP protocols.
+  You need to say Y only for diskless machines requiring network
+  access to boot (in which case you want to say Y to "Root file system
+  on NFS" as well), because all other machines configure the network
+  in their startup scripts.
+
+BOOTP support
+CONFIG_IP_PNP_BOOTP
+  If you want your Linux box to mount its whole root file system (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the BOOTP protocol (a
+  special protocol designed for doing this job), say Y here. In case
+  the boot ROM of your network card was designed for booting Linux and
+  does BOOTP itself, providing all necessary information on the kernel
+  command line, you can say N here. If unsure, say Y. Note that if you
+  want to use BOOTP, a BOOTP server must be operating on your network.
+  Read Documentation/nfsroot.txt for details.
+
+RARP support
+CONFIG_IP_PNP_RARP
+  If you want your Linux box to mount its whole root file system (the
+  one containing the directory /) from some other computer over the
+  net via NFS and you want the IP address of your computer to be
+  discovered automatically at boot time using the RARP protocol (an
+  older protocol which is being obsoleted by BOOTP and DHCP), say Y
+  here. Note that if you want to use RARP, a RARP server must be
+  operating on your network. Read Documentation/nfsroot.txt for
+  details.
+
+IP: tunneling
+CONFIG_NET_IPIP
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  encapsulation of IP within IP, which sounds kind of pointless, but
+  can be useful if you want to make your (or some other) machine
+  appear on a different network than it physically is, or to use
+  mobile-IP facilities (allowing laptops to seamlessly move between
+  networks without changing their IP addresses; check out
+  http://anchor.cs.binghamton.edu/~mobileip/LJ/index.html ). 
+
+  Saying Y to this option will produce two modules ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). Most people won't need this and can say N.
+
+IP: GRE tunnels over IP
+CONFIG_NET_IPGRE
+  Tunneling means encapsulating data of one protocol type within
+  another protocol and sending it over a channel that understands the
+  encapsulating protocol. This particular tunneling driver implements
+  GRE (Generic Routing Encapsulation) and at this time allows
+  encapsulating of IPv4 or IPv6 over existing IPv4 infrastructure.
+  This driver is useful if the other endpoint is a Cisco router: Cisco
+  likes GRE much better than the other Linux tunneling driver ("IP:
+  tunneling" above). In addition, GRE allows multicast redistribution
+  through the tunnel.
+
+IP: broadcast GRE over IP
+CONFIG_NET_IPGRE_BROADCAST
+  One application of GRE/IP is to construct a broadcast WAN (Wide Area
+  Network), which looks like a normal Ethernet LAN (Local Area
+  Network), but can be distributed all over the Internet. If you want
+  to do that, say Y here and to "IP: multicast routing" below.
+
+IP: multicast routing
+CONFIG_IP_MROUTE
+  This is used if you want your machine to act as a router for IP
+  packets that have several destination addresses. It is needed on the
+  MBONE, a high bandwidth network on top of the Internet which carries
+  audio and video broadcasts. In order to do that, you would most
+  likely run the program mrouted. Information about the multicast
+  capabilities of the various network cards is contained in
+  Documentation/networking/multicast.txt. If you haven't heard about
+  it, you don't need it.
+
+IP: PIM-SM version 1 support
+CONFIG_IP_PIMSM_V1
+  Kernel side support for Sparse Mode PIM (Protocol Independent
+  Multicast) version 1. This multicast routing protocol is used widely
+  because Cisco supports it. You need special software to use it
+  (pimd-v1). Please see http://netweb.usc.edu/pim/ for more
+  information about PIM.
+
+  Say Y if you want to use PIM-SM v1. Note that you can say N here if
+  you just want to use Dense Mode PIM.
+
+IP: PIM-SM version 2 support
+CONFIG_IP_PIMSM_V2
+  Kernel side support for Sparse Mode PIM version 2. In order to use
+  this, you need an experimental routing daemon supporting it (pimd or
+  gated-5). This routing protocol is not used widely, so say N unless
+  you want to play with it.
+
+PC/TCP compatibility mode
+CONFIG_INET_PCTCP
+  If you have been having difficulties telnetting to your Linux
+  machine from a DOS system that uses (broken) PC/TCP networking
+  software (all versions up to OnNet 2.0) over your local Ethernet try
+  saying Y here. Everyone else says N. 
+
+  People having problems with NCSA telnet should see the file
+  Documentation/networking/ncsa-telnet.
+
+Path MTU Discovery (normally enabled)
+CONFIG_PATH_MTU_DISCOVERY
+  MTU (maximal transfer unit) is the size of the chunks we send out
+  over the net. "Path MTU Discovery" means that, instead of always
+  sending very small chunks, we start out sending big ones and if we
+  then discover that some host along the way likes its chunks smaller,
+  we adjust to a smaller size. This is good, so most people say Y
+  here.
+
+  However, some DOS software (versions of DOS NCSA telnet and Trumpet
+  Winsock in PPP mode) is broken and won't be able to connect to your
+  Linux machine correctly in all cases (especially through a terminal
+  server) unless you say N here. See
+  Documentation/networking/ncsa-telnet for the location of fixed NCSA
+  telnet clients. If in doubt, say Y.
+
+Disable NAGLE algorithm (normally enabled)
+CONFIG_TCP_NAGLE_OFF
+  The NAGLE algorithm works by requiring an acknowledgment before
+  sending small IP frames (packets). This keeps tiny telnet and
+  rlogin packets from congesting Wide Area Networks. Most people
+  strongly recommend to say N here, thereby leaving NAGLE
+  enabled. Those programs that would benefit from disabling this
+  facility can do it on a per connection basis themselves.
+
+IP: Allow large windows (not recommended if <16 MB of memory)
+CONFIG_SKB_LARGE
+  On high speed, long distance networks the performance limit on
+  networking becomes the amount of data the sending machine can buffer
+  until the other end confirms its reception. (At 45 Mbit/second there
+  are a lot of bits between New York and London ...). If you say Y
+  here, bigger buffers can be used which allows larger amounts of data
+  to be "in flight" at any given time. It also means a user process
+  can require a lot more memory for network buffers and thus this
+  option is best used only on machines with 16 MB of memory or higher.
+  Unless you are using long links with end to end speeds of over 2
+  Mbit a second or satellite links this option will make no difference
+  to performance.
+
+Unix domain sockets
+CONFIG_UNIX
+  If you say Y here, you will include support for Unix domain sockets;
+  sockets are the standard Unix mechanism for establishing and
+  accessing network connections. Many commonly used programs such as
+  the X Window system and syslog use these sockets even if your
+  machine is not connected to any network. Unless you are working on
+  an embedded system or something similar, you therefore definitely
+  want to say Y here.
+
+  However, the socket support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  unix.o. If you try building this as a module and you have said Y to
+  "Kernel module loader support" above, be sure to add 'alias net-pf-1
+  unix' to your /etc/modules.conf file. Note that several important
+  services won't work correctly if you say M here and then neglect to
+  load the module.
+
+  Say Y unless you know what you are doing.
+
+The IPv6 protocol (EXPERIMENTAL)
+CONFIG_IPV6
+  This is experimental support for the next version of the Internet
+  Protocol: IP version 6 (also called IPng "IP next generation").
+  Features of this new protocol include: expanded address space,
+  authentication and privacy, and seamless interoperability with the
+  current version of IP (IP version 4). For general information about
+  IPv6, see http://playground.sun.com/pub/ipng/html/ipng-main.html ;
+  for specific information about IPv6 under Linux read the HOWTO at
+  http://www.bieringer.de/linux/IPv6/ and the file net/ipv6/README in
+  the kernel source.
+
+  If you want to use IPv6, please upgrade to the newest net-tools as
+  given in Documentation/Changes. You will still be able to do regular
+  IPv4 networking as well.
+
+  This protocol support is also available as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). The module will be called ipv6.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+  It is safe to say N here for now.
+
+IPv6: enable EUI-64 token format
+CONFIG_IPV6_EUI64
+  6bone, the network of computers using the IPv6 protocol, is moving
+  to a new aggregatable address format and a new link local address
+  assignment (EUI-64). Say Y if your site has upgraded already, or
+  has started to upgrade.
+
+IPv6: disable provider based addresses
+CONFIG_IPV6_NO_PB
+  Linux tries to operate correctly when your site has moved to EUI-64
+  only partially. Unfortunately, the two address formats (old:
+  "provider based" and new: "aggregatable") are incompatible. Say Y if
+  your site finished the upgrade to EUI-64, and/or you encountered
+  some problems caused by the presence of two link-local addresses on
+  an interface.
+
+IPv6: routing messages via old netlink
+CONFIG_IPV6_NETLINK
+  You can say Y here to receive routing messages from the IPv6 code
+  through the old netlink interface. However, a better option is to
+  say Y to "Kernel/User network link driver" and to "Routing
+  messages" instead.
+  
+Kernel httpd acceleration (EXPERIMENTAL)
+CONFIG_KHTTPD
+  The kernel httpd acceleration daemon (kHTTPd) is a (limited) web
+  server built into the kernel. It is limited since it can only serve
+  files from the file system and cannot deal with executable content
+  such as CGI scripts. Serving files is sped up if you use kHTTPd.
+  If kHTTPd is not able to fulfill a request, it can transparently
+  pass it through to a user space web server such as apache.
+
+  Saying "M" here builds the kHTTPd module; this is NOT enough to have
+  a working kHTTPd. For safety reasons, the module has to be activated
+  by doing a "echo 1 > /proc/sys/net/khttpd/start" after inserting the
+  module.
+
+  Before using this, read the README in net/khttpd !
+
+  The kHTTPd is experimental. Be careful when using it on a production
+  machine. Also note that kHTTPd doesn't support virtual servers yet.
+
+IPX networking
+CONFIG_IPX
+  This is support for the Novell networking protocol, IPX, commonly
+  used for local networks of Windows machines. You need it if you want
+  to access Novell NetWare file or print servers using the Linux
+  Novell client ncpfs (available from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/ ) or from within
+  the Linux DOS emulator DOSEMU (read the DOSEMU-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto ). In order to do the
+  former, you'll also have to say Y to "NCP file system support",
+  below.
+
+  IPX is similar in scope to IP, while SPX, which runs on top of IPX,
+  is similar to TCP. There is also experimental support for SPX in
+  Linux (see "SPX networking", below).
+
+  To turn your Linux box into a fully featured NetWare file server and
+  IPX router, say Y here and fetch either lwared from
+  ftp://metalab.unc.edu/pub/Linux/system/network/daemons/ or mars_nwe
+  from ftp://ftp.gwdg.de/pub/linux/misc/ncpfs . For more information,
+  read the IPX-HOWTO available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html .
+
+  The IPX driver would enlarge your kernel by about 16 KB. This driver
+  is also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module will
+  be called ipx.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. Unless you want to integrate
+  your Linux box with a local Novell network, say N.
+
+IPX: Full internal IPX network
+CONFIG_IPX_INTERN
+  Every IPX network has an address that identifies it. Sometimes it is
+  useful to give an IPX "network" address to your Linux box as well
+  (for example if your box is acting as a file server for different
+  IPX networks: it will then be accessible from everywhere using the
+  same address). The way this is done is to create a virtual internal
+  "network" inside your box and to assign an IPX address to this
+  network. Say Y here if you want to do this; read the IPX-HOWTO at
+  http://www.linuxdoc.org/docs.html#howto for details.
+
+  The full internal IPX network enables you to allocate sockets on
+  different virtual nodes of the internal network. This is done by
+  evaluating the field sipx_node of the socket address given to the
+  bind call. So applications should always initialize the node field
+  to 0 when binding a socket on the primary network. In this case the
+  socket is assigned the default node that has been given to the
+  kernel when the internal network was created. By enabling the full
+  internal IPX network the cross-forwarding of packets targeted at
+  'special' sockets to sockets listening on the primary network is
+  disabled. This might break existing applications, especially RIP/SAP
+  daemons. A RIP/SAP daemon that works well with the full internal net
+  can be found on ftp://ftp.gwdg.de/pub/linux/misc/ncpfs . 
+
+  If you don't know what you are doing, say N.
+
+IPX: SPX networking (EXPERIMENTAL)
+CONFIG_SPX
+  The Sequenced Packet eXchange protocol is a transport layer protocol
+  built on top of IPX. It is used in Novell NetWare systems for
+  client-server applications and is similar to TCP (which runs on top
+  of IP).
+
+  Note that Novell NetWare file sharing does not use SPX; it uses a
+  protocol called NCP, for which separate Linux support is available
+  ("NCP file system support" below for the client side, and the user
+  space programs lwared or mars_nwe for the server side).
+
+  Say Y here if you have use for SPX; read the IPX-HOWTO at
+  http://www.linuxdoc.org/docs.html#howto for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called af_spx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+DECnet networking (EXPERIMENTAL)
+CONFIG_DECNET
+  The DECnet networking protocol was used in many products made by
+  Digital (now Compaq). It provides reliable stream and sequenced
+  packet communications over which run a variety of services similar
+  to those which run over TCP/IP.
+
+  To find some tools to use with the kernel layer support, please
+  look at Patrick Caulfield's web site: 
+  http://linux.dreamtime.org/decnet/
+
+  More detailed documentation is available in the
+  Documentation/networking/decnet.txt file.
+
+  Be sure to say Y to "/proc file system support" and "Sysctl support"
+  below when using DECnet, since you will need sysctl support to aid
+  in configuration at run time.
+
+  The DECnet code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called decnet.o.
+
+DECnet SIOCFIGCONF support
+CONFIG_DECNET_SIOCGIFCONF
+   This option should only be turned on if you are really sure that
+   you know what you are doing. It can break other applications which
+   use this system call and the proper way to get the information
+   provided by this call is to use rtnetlink.
+   
+   If unsure, say N.
+
+DECnet Router Support (EXPERIMENTAL)
+CONFIG_DECNET_ROUTER
+   Add support for turning your DECnet Endnode into a level 1 or 2
+   router. This is an unfinished option for developers only. If you do
+   say Y here, then make sure that you also say Y to "Kernel/User
+   network link driver", "Routing messages" and "Network packet
+   filtering". The first two are required to allow configuration via
+   rtnetlink (currently you need Alexey Kuznetsov's iproute2 package
+   from ftp://ftp.inr.ac.ru). The "Network packet filtering" option
+   will be required for the forthcoming routing daemon to work.
+
+   See Documentation/networking/decnet.txt for more information.
+
+DECnet: use FWMARK value as routing key
+CONFIG_DECNET_ROUTE_FWMARK
+  If you say Y here, you will be able to specify different routes for
+  packets with different FWMARK ("firewalling mark") values
+  (see ipchains(8), "-m" argument).
+
+Appletalk interfaces support
+CONFIG_APPLETALK
+  AppleTalk is the way Apple computers speak to each other on a
+  network. If your Linux box is connected to such a network and you
+  want to join the conversation, say Y.
+
+AppleTalk protocol support
+CONFIG_ATALK
+  AppleTalk is the way Apple computers speak to each other on a
+  network. If your Linux box is connected to such a network and you
+  want to join the conversation, say Y. You will need to use the
+  netatalk package so that your Linux box can act as a print and file
+  server for Macs as well as access AppleTalk printers. Check out
+  http://threepio.hitchcock.org/cgi-bin/faq/netatalk/faq.pl on the WWW
+  for details. EtherTalk is the name used for AppleTalk over Ethernet
+  and the cheaper and slower LocalTalk is AppleTalk over a proprietary
+  Apple network using serial links. EtherTalk and LocalTalk are fully
+  supported by Linux.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html . The
+  NET-3-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , contains valuable
+  information as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called appletalk.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. I hear that
+  the GNU boycott of Apple is over, so even politically correct people
+  are allowed to say Y here.
+
+AppleTalk-IP driver support
+CONFIG_IPDDP
+  This allows IP networking for users who only have AppleTalk
+  networking available. This feature is experimental. With this
+  driver, you can encapsulate IP inside AppleTalk (e.g. if your Linux
+  box is stuck on an AppleTalk only network) or decapsulate (e.g. if
+  you want your Linux box to act as an Internet gateway for a zoo of
+  AppleTalk connected Macs). Please see the file
+  Documentation/networking/ipddp.txt for more information.
+
+  If you say Y here, the AppleTalk-IP support will be compiled into
+  the kernel. In this case, you can either use encapsulation or
+  decapsulation, but not both. With the following two questions, you
+  decide which one you want.
+
+  If you say M here, the AppleTalk-IP support will be compiled as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want, read Documentation/modules.txt).
+  The module is called ipddp.o. In this case, you will be able to use
+  both encapsulation and decapsulation simultaneously, by loading two
+  copies of the module and specifying different values for the module
+  option ipddp_mode. 
+
+IP to AppleTalk-IP Encapsulation support
+CONFIG_IPDDP_ENCAP
+  If you say Y here, the AppleTalk-IP code will be able to encapsulate
+  IP packets inside AppleTalk frames; this is useful if your Linux box
+  is stuck on an AppleTalk network (which hopefully contains a
+  decapsulator somewhere). Please see
+  Documentation/networking/ipddp.txt for more information. If you said
+  Y to "AppleTalk-IP driver support" above and you say Y here, then
+  you cannot say Y to "AppleTalk-IP to IP Decapsulation support",
+  below.
+
+AppleTalk-IP to IP Decapsulation support
+CONFIG_IPDDP_DECAP
+  If you say Y here, the AppleTalk-IP code will be able to decapsulate
+  AppleTalk-IP frames to IP packets; this is useful if you want your
+  Linux box to act as an Internet gateway for an AppleTalk network.
+  Please see Documentation/networking/ipddp.txt for more information.
+  If you said Y to "AppleTalk-IP driver support" above and you say Y
+  here, then you cannot say Y to "IP to AppleTalk-IP Encapsulation
+  support", above.
+
+Apple/Farallon LocalTalk PC card support
+CONFIG_LTPC
+  This allows you to use the AppleTalk PC card to connect to LocalTalk
+  networks. The card is also known as the Farallon PhoneNet PC card.
+  If you are in doubt, this card is the one with the 65C02 chip on it.
+  You also need version 1.3.3 or later of the netatalk package.
+  This driver is experimental, which means that it may not work.
+  See the file Documentation/networking/ltpc.txt.
+
+COPS LocalTalk PC card support
+CONFIG_COPS
+  This allows you to use COPS AppleTalk cards to connect to LocalTalk
+  networks. You also need version 1.3.3 or later of the netatalk
+  package. This driver is experimental, which means that it may not
+  work. This driver will only work if you choose "AppleTalk DDP"
+  networking support, above.
+  Please read the file Documentation/networking/cops.txt. 
+
+Dayna firmware support
+CONFIG_COPS_DAYNA
+  Support COPS compatible cards with Dayna style firmware (Dayna
+  DL2000/ Daynatalk/PC (half length), COPS LT-95, Farallon PhoneNET PC
+  III, Farallon PhoneNET PC II).
+
+Tangent firmware support
+CONFIG_COPS_TANGENT
+  Support COPS compatible cards with Tangent style firmware (Tangent
+  ATB_II, Novell NL-1000, Daystar Digital LT-200.
+
+Amateur Radio support
+CONFIG_HAMRADIO
+  If you want to connect your Linux box to an amateur radio, answer Y
+  here. You want to read http://www.tapr.org/tapr/html/pkthome.html
+  and the HAM-HOWTO and the AX25-HOWTO, both available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about amateur radio.
+
+Amateur Radio AX.25 Level 2
+CONFIG_AX25
+  This is the protocol used for computer communication over amateur
+  radio. It is either used by itself for point-to-point links, or to
+  carry other protocols such as tcp/ip. To use it, you need a device
+  that connects your Linux box to your amateur radio. You can either
+  use a low speed TNC (a Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output) supporting the KISS protocol or
+  one of the various SCC cards that are supported by the generic Z8530
+  or the DMA SCC driver. Another option are the Baycom modem serial
+  and parallel port hacks or the sound card modem (supported by their
+  own drivers). If you say Y here, you also have to say Y to one of
+  those drivers.
+
+  Information about where to get supporting software for Linux amateur
+  radio as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . You might also want to
+  check out the file Documentation/networking/ax25.txt in the kernel
+  source. More information about digital amateur radio in general is
+  on the WWW at http://www.tapr.org/tapr/html/pkthome.html .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ax25.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AX.25 DAMA Slave support
+CONFIG_AX25_DAMA_SLAVE
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other slaves.
+  If you say Y here, your Linux box will act as a DAMA slave; this is
+  transparent in that you don't have to do any special DAMA
+  configuration. (Linux cannot yet act as a DAMA server.) If unsure,
+  say N.
+
+AX.25 DAMA Master support
+CONFIG_AX25_DAMA_MASTER
+  DAMA is a mechanism to prevent collisions when doing AX.25
+  networking. A DAMA server (called "master") accepts incoming traffic
+  from clients (called "slaves") and redistributes it to other
+  slaves. If you say Y here, your Linux box will act as a DAMA server.
+  If unsure, say N.
+
+Amateur Radio NET/ROM
+CONFIG_NETROM
+  NET/ROM is a network layer protocol on top of AX.25 useful for
+  routing.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called netrom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Amateur Radio X.25 PLP (Rose)
+CONFIG_ROSE
+  The Packet Layer Protocol (PLP) is a way to route packets over X.25
+  connections in general and amateur radio AX.25 connections in
+  particular, essentially an alternative to NET/ROM.
+
+  A comprehensive listing of all the software for Linux amateur radio
+  users as well as information about how to configure an AX.25 port is
+  contained in the AX25-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . You also might want to
+  check out the file Documentation/networking/ax25.txt. More
+  information about digital amateur radio in general is on the WWW at
+  http://www.tapr.org/tapr/html/pkthome.html .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rose.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Serial port KISS driver for AX.25
+CONFIG_MKISS
+  KISS is a protocol used for the exchange of data between a computer
+  and a Terminal Node Controller (a small embedded system commonly
+  used for networking over AX.25 amateur radio connections; it
+  connects the computer's serial port with the radio's microphone
+  input and speaker output).
+
+  Although KISS is less advanced than the 6pack protocol, it has
+  the advantage that it is already supported by most modern TNCs
+  without the need for a firmware upgrade.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called mkiss.o.
+
+Serial port 6PACK driver for AX.25
+CONFIG_6PACK
+  6pack is a transmission protocol for the data exchange between your
+  PC and your TNC (the Terminal Node Controller acts as a kind of
+  modem connecting your computer's serial port to your radio's
+  microphone input and speaker output). This protocol can be used as
+  an alternative to KISS for networking over AX.25 amateur radio
+  connections, but it has some extended functionality.
+
+  Note that this driver is still experimental and might cause
+  problems. For details about the features and the usage of the
+  driver, read Documentation/networking/6pack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called 6pack.o.
+
+BPQ Ethernet driver
+CONFIG_BPQETHER
+  AX.25 is the protocol used for computer communication over amateur
+  radio. If you say Y here, you will be able to send and receive AX.25
+  traffic over Ethernet (also called "BPQ AX.25"), which could be
+  useful if some other computer on your local network has a direct
+  amateur radio connection.
+
+High-speed (DMA) SCC driver for AX.25
+CONFIG_DMASCC
+  This is a driver for high-speed SCC boards, i.e. those supporting
+  DMA on one port. You usually use those boards to connect your
+  computer to an amateur radio modem (such as the WA4DSY 56kbps
+  modem), in order to send and receive AX.25 packet radio network
+  traffic.
+
+  Currently, this driver supports Ottawa PI/PI2, Paccomm/Gracilis
+  PackeTwin, and S5SCC/DMA boards. They are detected automatically.
+  If you have one of these cards, say Y here and read the AX25-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver can operate multiple boards simultaneously. If you
+  compile it as a module (by saying M instead of Y), it will be called
+  dmascc.o. If you don't pass any parameter to the driver, all
+  possible I/O addresses are probed. This could irritate other devices
+  that are currently not in use. You may specify the list of addresses
+  to be probed by "dmascc=addr1,addr2,..." (when compiled into the
+  kernel image) or "io=addr1,addr2,..." (when loaded as a module). The
+  network interfaces will be called dmascc0 and dmascc1 for the board
+  detected first, dmascc2 and dmascc3 for the second one, and so on.
+
+  Before you configure each interface with ifconfig, you MUST set
+  certain parameters, such as channel access timing, clock mode, and
+  DMA channel. This is accomplished with a small utility program,
+  dmascc_cfg, available at
+  http://www.nt.tuwien.ac.at/~kkudielk/Linux/ . Please be sure to get
+  at least version 1.27 of dmascc_cfg, as older versions will not
+  work with the current driver.
+
+Z8530 SCC driver for AX.25
+CONFIG_SCC
+  These cards are used to connect your Linux box to an amateur radio
+  in order to communicate with other computers. If you want to use
+  this, read Documentation/networking/z8530drv.txt and the AX25-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto . Also
+  make sure to say Y to "Amateur Radio AX.25 Level 2" support.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called scc.o.
+
+additional delay for PA0HZP OptoSCC compatible boards
+CONFIG_SCC_DELAY
+  Say Y here if you experience problems with the SCC driver not
+  working properly; please read Documentation/networking/z8530drv.txt
+  for details. If unsure, say N.
+
+#support for TRX that feedback the tx signal to rx
+#CONFIG_SCC_TRXECHO
+###
+### Don't know what's going on here.
+###
+#
+
+YAM driver for AX.25
+CONFIG_YAM
+  The YAM is a modem for packet radio which connects to the serial
+  port and includes some of the functions of a Terminal Node
+  Controller. If you have one of those, say Y here.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt.
+
+BAYCOM picpar and par96 driver for AX.25
+CONFIG_BAYCOM_PAR
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the picpar and
+  par96 designs. To configure the driver, use the sethdlc utility
+  available in the standard ax25 utilities package. For information on
+  the modems, see http://www.baycom.de and the file
+  Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM EPP driver for AX.25
+CONFIG_BAYCOM_EPP
+  This is a driver for Baycom style simple amateur radio modems that
+  connect to a parallel interface. The driver supports the EPP
+  designs. To configure the driver, use the sethdlc utility available
+  in the standard ax25 utilities package. For information on the
+  modems, see http://www.baycom.de and the file
+  Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_par.o.
+
+BAYCOM ser12 full duplex driver for AX.25
+CONFIG_BAYCOM_SER_FDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. In addition, it allows the
+  baudrate to be set between 300 and 4800 baud (however not all modems
+  support all baudrates). This is the preferred driver. The next
+  driver, "BAYCOM ser12 half duplex driver for AX.25" is the old
+  driver and still provided in case this driver does not work with
+  your serial interface chip. To configure the driver, use the sethdlc
+  utility available in the standard ax25 utilities package. For
+  information on the modems, see http://www.baycom.de and
+  Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_fdx.o.
+
+BAYCOM ser12 half duplex driver for AX.25
+CONFIG_BAYCOM_SER_HDX
+  This is one of two drivers for Baycom style simple amateur radio
+  modems that connect to a serial interface. The driver supports the
+  ser12 design in full duplex mode. This is the old driver. It is
+  still provided in case your serial interface chip does not work with
+  the full duplex driver. This driver is depreciated. To configure the
+  driver, use the sethdlc utility available in the standard ax25
+  utilities package. For information on the modems, see
+  http://www.baycom.de and Documentation/networking/baycom.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called baycom_ser_hdx.o.
+
+Sound card modem driver for AX.25
+CONFIG_SOUNDMODEM
+  This experimental driver allows a standard Sound Blaster or
+  WindowsSoundSystem compatible sound card to be used as a packet
+  radio modem (NOT as a telephone modem!), to send digital traffic
+  over amateur radio.
+
+  To configure the driver, use the sethdlc, smdiag and smmixer
+  utilities available in the standard ax25 utilities package. For
+  information on how to key the transmitter, see
+  http://www.ife.ee.ethz.ch/~sailer/pcf/ptt_circ/ptt.html and
+  Documentation/networking/soundmodem.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called soundmodem.o.
+
+Sound card modem support for Sound Blaster and compatible cards
+CONFIG_SOUNDMODEM_SBC
+  This option enables the soundmodem driver to use Sound Blaster and
+  compatible cards. If you have a dual mode card (i.e. a WSS cards
+  with a Sound Blaster emulation) you should say N here and Y to
+  "Sound card modem support for WSS and Crystal cards", below, because
+  this usually results in better performance. This option also
+  supports SB16/32/64 in full duplex mode.
+
+Sound card modem support for WSS and Crystal cards
+CONFIG_SOUNDMODEM_WSS
+  This option enables the soundmodem driver to use WindowsSoundSystem
+  compatible cards. These cards feature a codec chip from either
+  Analog Devices (such as AD1848, AD1845, AD1812) or Crystal
+  Semiconductors (such as CS4248, CS423x). This option also supports
+  the WSS full duplex operation which currently works with Crystal
+  CS423x chips. If you don't need full duplex operation, do not enable
+  it to save performance.
+
+Sound card modem support for 1200 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK1200
+  This option enables the soundmodem driver 1200 baud AFSK modem,
+  compatible to popular modems using TCM3105 or AM7911. The
+  demodulator requires about 12% of the CPU power of a Pentium 75 CPU
+  per channel.
+
+Sound card modem support for 2400 baud AFSK modulation (7.3728MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_7
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with a 7.3728MHz
+  crystal. Note that the availability of this driver does _not_ imply
+  that I recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2400 baud AFSK modulation (8MHz crystal)
+CONFIG_SOUNDMODEM_AFSK2400_8
+  This option enables the soundmodem driver 2400 baud AFSK modem,
+  compatible to TCM3105 modems (over-)clocked with an 8MHz crystal.
+  Note that the availability of this driver does _not_ imply that I
+  recommend building such links. It is only here since users
+  especially in eastern Europe have asked me to do so. In fact this
+  modulation scheme has many disadvantages, mainly its incompatibility
+  with many transceiver designs and the fact that the TCM3105 (if
+  used) is operated widely outside its specifications.
+
+Sound card modem support for 2666 baud AFSK modulation
+CONFIG_SOUNDMODEM_AFSK2666
+  This option enables the soundmodem driver 2666 baud AFSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud 8PSK modulation
+CONFIG_SOUNDMODEM_PSK4800
+  This option enables the soundmodem driver 4800 baud 8PSK modem.
+  This modem is experimental, and not compatible to anything
+  else I know of.
+
+Sound card modem support for 4800 baud HAPN-1 modulation
+CONFIG_SOUNDMODEM_HAPN4800
+  This option enables the soundmodem driver 4800 baud HAPN-1
+  compatible modem. This modulation seems to be widely used 'down
+  under' and in the Netherlands. Here, nobody uses it, so I could not
+  test if it works. It is compatible to itself, however :-)
+
+Sound card modem support for 9600 baud FSK G3RUH modulation
+CONFIG_SOUNDMODEM_FSK9600
+  This option enables the soundmodem driver 9600 baud FSK modem,
+  compatible to the G3RUH standard. The demodulator requires about 4%
+  of the CPU power of a Pentium 75 CPU per channel. You can say Y to
+  both 1200 baud AFSK and 9600 baud FSK if you want (but obviously you
+  can only use one protocol at a time, depending on what the other end
+  can understand).
+
+CCITT X.25 Packet Layer (EXPERIMENTAL)
+CONFIG_X25
+  X.25 is a set of standardized network protocols, similar in scope to
+  frame relay; the one physical line from your box to the X.25 network
+  entry point can carry several logical point-to-point connections
+  (called "virtual circuits") to other computers connected to the X.25
+  network. Governments, banks, and other organizations tend to use it
+  to connect to each other or to form Wide Area Networks (WANs). Many
+  countries have public X.25 networks. X.25 consists of two
+  protocols: the higher level Packet Layer Protocol (PLP) (say Y here
+  if you want that) and the lower level data link layer protocol LAPB
+  (say Y to "LAPB Data Link Driver" below if you want that). 
+
+  You can read more about X.25 at http://www.sangoma.com/x25.htm and
+  http://www.cisco.com/univercd/data/doc/software/11_0/rpcg/cx25.htm .
+  Information about X.25 for Linux is contained in the files
+  Documentation/networking/x25.txt and
+  Documentation/networking/x25-iface.txt.
+
+  One connects to an X.25 network either with a dedicated network card
+  using the X.21 protocol (not yet supported by Linux) or one can do
+  X.25 over a standard telephone line using an ordinary modem (say Y
+  to "X.25 async driver" below) or over Ethernet using an ordinary
+  Ethernet card and either the 802.2 LLC protocol (say Y to "802.2
+  LLC" below) or LAPB over Ethernet (say Y to "LAPB Data Link Driver"
+  and "LAPB over Ethernet driver" below). 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25.o. If unsure, say N.
+
+LAPB Data Link Driver (EXPERIMENTAL) 
+CONFIG_LAPB
+  Link Access Procedure, Balanced (LAPB) is the data link layer (i.e.
+  the lower) part of the X.25 protocol. It offers a reliable
+  connection service to exchange data frames with one other host, and
+  it is used to transport higher level protocols (mostly X.25 Packet
+  Layer, the higher part of X.25, but others are possible as well).
+  Usually, LAPB is used with specialized X.21 network cards, but Linux
+  currently supports LAPB only over Ethernet connections. If you want
+  to use LAPB connections over Ethernet, say Y here and to "LAPB over
+  Ethernet driver" below. Read
+  Documentation/networking/lapb-module.txt for technical details.
+
+  If you want to compile this driver as a module though ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called lapb.o. If unsure, say N.
+
+802.2 LLC (EXPERIMENTAL)
+CONFIG_LLC
+  This is a Logical Link Layer protocol used for X.25 connections over
+  Ethernet, using ordinary Ethernet cards. 
+
+
+Frame Diverter (EXPERIMENTAL)
+CONFIG_NET_DIVERT
+  The Frame Diverter allows you to divert packets from the
+  network, that are not aimed at the interface receiving it (in 
+  promisc. mode). Typically, a Linux box setup as an ethernet bridge
+  with the Frames Diverter on, can do some *really* transparent www 
+  caching using a Squid proxy for example.
+
+  This is very usefull when you don't want to change your router's
+  config (or if you simply don't have access to it).
+
+  The other possible usages of diverting Ethernet Frames are numberous:
+   - reroute smtp traffic to another interface
+   - traffic-shape certain network streams
+   - transparently proxy smtp connections
+   - etc...
+
+  For more informations, please refer to:
+    http://www.freshmeat.net/projects/etherdivert
+    http://perso.wanadoo.fr/magpie/EtherDivert.html
+
+  If unsure, say N
+
+802.1d Ethernet Bridging
+CONFIG_BRIDGE
+  If you say Y here, then your Linux box will be able to act as an
+  Ethernet bridge, which means that the different Ethernet segments it
+  is connected to will appear as one Ethernet to the participants.
+  Several such bridges can work together to create even larger
+  networks of Ethernets using the IEEE 802.1 spanning tree algorithm.
+  As this is a standard, Linux bridges will cooperate properly with
+  other third party bridge products. 
+
+  In order to use the ethernet bridge, you'll need the bridge
+  configuration tools; see Documentation/networking/bridge.txt for
+  location. Please read the Bridge mini-HOWTO for more information.
+  
+  Note that if your box acts as a bridge, it probably contains several
+  Ethernet devices, but the kernel is not able to recognize more than
+  one at boot time without help; for details read the Ethernet-HOWTO,
+  available from in http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this code as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called bridge.o.
+
+  If unsure, say N.
+
+Packet socket
+CONFIG_PACKET
+  The Packet protocol is used by applications which communicate
+  directly with network devices without an intermediate network
+  protocol implemented in the kernel, e.g. tcpdump. If you want them
+  to work, choose Y. 
+
+  This driver is also available as a module called af_packet.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt; if you use modprobe or
+  kmod, you may also want to add "alias net-pf-17 af_packet" to 
+  /etc/modules.conf. 
+
+  If unsure, say Y.
+
+Packet socket: mmapped IO
+CONFIG_PACKET_MMAP
+  If you say Y here, the Packet protocol driver will use an IO
+  mechanism that results in faster communication.
+
+  If unsure, say N.
+
+Kernel/User network link driver
+CONFIG_NETLINK
+  This driver allows for two-way communication between the kernel and
+  user processes. It does so by creating a new socket family, PF_NETLINK.
+  Over this socket, the kernel can send and receive datagrams carrying
+  information. It is documented on many systems in netlink(7), a HOWTO is
+  provided as well, for example on
+  http://snafu.freedom.org/linux2.2/docs/netlink-HOWTO.html
+
+  So far, the kernel uses this feature to publish some network related
+  information if you say Y to "Routing messages", below. You also need
+  to say Y here if you want to use arpd, a daemon that helps keep the
+  internal ARP cache (a mapping between IP addresses and hardware
+  addresses on the local network) small. The ethertap device, which
+  lets user space programs read and write raw Ethernet frames, also
+  needs the network link driver.
+
+  If unsure, say Y.
+
+Routing messages
+CONFIG_RTNETLINK
+  If you say Y here, userspace programs can receive some network
+  related routing information over the netlink. 'rtmon', supplied
+  with the iproute2 package (ftp://ftp.inr.ac.ru), can read and
+  interpret this data.  Information sent to the kernel over this link
+  is ignored.
+
+Netlink device emulation
+CONFIG_NETLINK_DEV
+  This option will be removed soon. Any programs that want to use
+  character special nodes like /dev/tap0 or /dev/route (all with major
+  number 36) need this option, and need to be rewritten soon to use
+  the real netlink socket.
+  This is a backward compatibility option, choose Y for now.
+
+Asynchronous Transfer Mode (ATM)
+CONFIG_ATM
+  ATM is a high-speed networking technology for Local Area Networks
+  and Wide Area Networks. It uses a fixed packet size and is
+  connection oriented, allowing for the negotiation of minimum
+  bandwidth requirements.
+  
+  In order to participate in an ATM network, your Linux box needs an
+  ATM networking card. If you have that, say Y here and to the driver
+  of your ATM card below.
+
+  Note that you need a set of user-space programs to actually make use
+  of ATM. See the file Documentation/networking/atm.txt for further
+  details.
+
+Classical IP over ATM
+CONFIG_ATM_CLIP
+  Classical IP over ATM for PVCs and SVCs, supporting InARP and
+  ATMARP. If you want to communication with other IP hosts on your ATM
+  network, you will typically either say Y here or to "LAN Emulation
+  (LANE)" below.
+
+Do NOT send ICMP if no neighbour
+CONFIG_ATM_CLIP_NO_ICMP
+  Normally, an "ICMP host unreachable" message is sent if a neighbour
+  cannot be reached because there is no VC to it in the kernel's
+  ATMARP table. This may cause problems when ATMARP table entries are
+  briefly removed during revalidation. If you say Y here, packets to
+  such neighbours are silently discarded instead.
+
+LAN Emulation (LANE) support
+CONFIG_ATM_LANE
+  LAN Emulation emulates services of existing LANs across an ATM
+  network. Besides operating as a normal ATM end station client, Linux
+  LANE client can also act as an proxy client bridging packets between
+  ELAN and Ethernet segments. You need LANE if you want to try MPOA.
+
+Multi-Protocol Over ATM (MPOA) support
+CONFIG_ATM_MPOA
+  Multi-Protocol Over ATM allows ATM edge devices such as routers,
+  bridges and ATM attached hosts establish direct ATM VCs across
+  subnetwork boundaries. These shortcut connections bypass routers
+  enhancing overall network performance.
+
+ATM over TCP
+CONFIG_ATM_TCP
+  ATM over TCP driver. Useful mainly for development and for
+  experiments. If unsure, say N.
+
+Efficient Networks ENI155P
+CONFIG_ATM_ENI
+  Driver for the Efficient Networks ENI155p series and SMC ATM
+  Power155 155 Mbps ATM adapters. Both, the versions with 512KB and
+  2MB on-board RAM (Efficient calls them "C" and "S", respectively),
+  and the FPGA and the ASIC Tonga versions of the board are supported.
+  The driver works with MMF (-MF or ...F) and UTP-5 (-U5 or ...D)
+  adapters.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called eni.o.
+
+Enable extended debugging
+CONFIG_ATM_ENI_DEBUG
+  Extended debugging records various events and displays that list
+  when an inconsistency is detected. This mechanism is faster than
+  generally using printks, but still has some impact on performance.
+  Note that extended debugging may create certain race conditions
+  itself. Enable this ONLY if you suspect problems with the driver.
+
+Fine-tune burst settings
+CONFIG_ATM_ENI_TUNE_BURST
+  In order to obtain good throughput, the ENI NIC can transfer
+  multiple words of data per PCI bus access cycle. Such a multi-word
+  transfer is called a burst.
+
+  The default settings for the burst sizes are suitable for most PCI
+  chipsets. However, in some cases, large bursts may overrun buffers
+  in the PCI chipset and cause data corruption. In such cases, large
+  bursts must be disabled and only (slower) small bursts can be used.
+  The burst sizes can be set independently in the send (TX) and
+  receive (RX) direction.
+
+  Note that enabling many different burst sizes in the same direction
+  may increase the cost of setting up a transfer such that the
+  resulting throughput is lower than when using only the largest
+  available burst size.
+
+  Also, sometimes larger bursts lead to lower throughput, e.g. on an
+  Intel 440FX board, a drop from 135 Mbps to 103 Mbps was observed
+  when going from 8W to 16W bursts.
+
+Enable 16W TX bursts (discouraged)
+CONFIG_ATM_ENI_BURST_TX_16W
+  Burst sixteen words at once in the send direction. This may work
+  with recent PCI chipsets, but is known to fail with older chipsets.
+
+Enable 8W TX bursts (recommended)
+CONFIG_ATM_ENI_BURST_TX_8W
+  Burst eight words at once in the send direction. This is the default
+  setting.
+
+Enable 4W TX bursts (optional)
+CONFIG_ATM_ENI_BURST_TX_4W
+  Burst four words at once in the send direction. You may want to try
+  this if you have disabled 8W bursts. Enabling 4W if 8W is also set
+  may or may not improve throughput.
+  
+Enable 2W TX bursts (optional)
+CONFIG_ATM_ENI_BURST_TX_2W
+  Burst two words at once in the send direction. You may want to try
+  this if you have disabled 4W and 8W bursts. Enabling 2W if 4W or 8W
+  are also set may or may not improve throughput.
+
+Enable 16W RX bursts (discouraged)
+CONFIG_ATM_ENI_BURST_RX_16W
+  Burst sixteen words at once in the receive direction. This may work
+  with recent PCI chipsets, but is known to fail with older chipsets.
+
+Enable 8W RX bursts (discouraged)
+CONFIG_ATM_ENI_BURST_RX_8W
+  Burst eight words at once in the receive direction. This may work
+  with recent PCI chipsets, but is known to fail with older chipsets,
+  such as the Intel Neptune series.
+
+Enable 4W RX bursts (recommended)
+CONFIG_ATM_ENI_BURST_RX_4W
+  Burst four words at once in the receive direction. This is the
+  default setting. Enabling 4W if 8W is also set may or may not
+  improve throughput.
+
+Enable 2W RX bursts (optional)
+CONFIG_ATM_ENI_BURST_RX_2W
+  Burst two words at once in the receive direction. You may want to
+  try this if you have disabled 4W and 8W bursts. Enabling 2W if 4W or
+  8W are also set may or may not improve throughput.
+
+ZeitNet ZN1221/ZN1225
+CONFIG_ATM_ZATM
+  Driver for the ZeitNet ZN1221 (MMF) and ZN1225 (UTP-5) 155 Mbps ATM
+  adapters.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called zatm.o.
+
+Enable extended debugging
+CONFIG_ATM_ZATM_DEBUG
+  Extended debugging records various events and displays that list
+  when an inconsistency is detected. This mechanism is faster than
+  generally using printks, but still has some impact on performance.
+  Note that extended debugging may create certain race conditions
+  itself. Enable this ONLY if you suspect problems with the driver.
+
+Enable usec resolution timestamps
+CONFIG_ATM_ZATM_EXACT_TS
+  The uPD98401 SAR chip supports a high-resolution timer (approx. 30
+  MHz) that is used for very accurate reception timestamps. Because
+  that timer overflows after 140 seconds, and also to avoid timer
+  drift, time measurements need to be periodically synchronized with
+  the normal system time. Enabling this feature will add some general
+  overhead for timer synchronization and also per-packet overhead for
+  time conversion.
+
+IDT 77201/11 (NICStAR) (ForeRunnerLE)
+CONFIG_ATM_NICSTAR
+  The NICStAR chipset family is used in a large number of ATM NICs for
+  25 and for 155 Mbps, including IDT cards and the Fore ForeRunnerLE
+  series. Say Y if you have one of those.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called nicstar.o.
+
+ForeRunner LE155 PHYsical layer
+CONFIG_ATM_NICSTAR_USE_SUNI
+  Support for the S-UNI and compatible PHYsical layer chips. These are
+  found in most 155Mbps NICStAR based ATM cards, namely in the
+  ForeRunner LE155 cards. This driver provides detection of cable
+  removal and reinsertion and provides some statistics. This driver
+  doesn't have removal capability when compiled as a module, so if you
+  need that capability don't include S-UNI support (it's not needed to
+  make the card work).
+
+ForeRunner LE25 PHYsical layer
+CONFIG_ATM_NICSTAR_USE_IDT77105
+  Support for the PHYsical layer chip in ForeRunner LE25 cards. In
+  addition to cable removal/reinsertion detection, this driver allows
+  you to control the loopback mode of the chip via a dedicated IOCTL.
+  This driver is required for proper handling of temporary carrier
+  loss, so if you have a 25Mbps NICStAR based ATM card you must say Y.
+
+Madge Ambassador (Collage PCI 155 Server)
+CONFIG_ATM_AMBASSADOR
+  This is a driver for ATMizer based ATM card produced by Madge
+  Networks Ltd. Say Y (or M to compile as a module named ambassador.o)
+  here if you have one of these cards.
+
+Enable debugging messages
+CONFIG_ATM_AMBASSADOR_DEBUG
+  Somewhat useful debugging messages are available. The choice of
+  messages is controlled by a bitmap. This may be specified as a
+  module argument (kernel command line argument as well?), changed
+  dynamically using an ioctl (not yet) or changed by sending the
+  string "Dxxxx" to VCI 1023 (where x is a hex digit). See the file
+  drivers/atm/ambassador.h for the meanings of the bits in the mask.
+
+  When active, these messages can have a significant impact on the
+  speed of the driver, and the size of your syslog files! When
+  inactive, they will have only a modest impact on performance.
+
+Madge Horizon [Ultra] (Collage PCI 25 and Collage PCI 155 Client)
+CONFIG_ATM_HORIZON
+  This is a driver for the Horizon chipset ATM adapter cards once
+  produced by Madge Networks Ltd. Say Y (or M to compile as a module
+  named horizon.o) here if you have one of these cards.
+
+Enable debugging messages
+CONFIG_ATM_HORIZON_DEBUG
+  Somewhat useful debugging messages are available. The choice of
+  messages is controlled by a bitmap. This may be specified as a
+  module argument (kernel command line argument as well?), changed
+  dynamically using an ioctl (not yet) or changed by sending the
+  string "Dxxxx" to VCI 1023 (where x is a hex digit). See the file
+  drivers/atm/horizon.h for the meanings of the bits in the mask.
+
+  When active, these messages can have a significant impact on the
+  speed of the driver, and the size of your syslog files! When
+  inactive, they will have only a modest impact on performance.
+
+Interphase ATM PCI x575/x525/x531 
+CONFIG_ATM_IA
+  This is a driver for the Interphase (i)ChipSAR adapter cards
+  which include a variety of variants in term of the size of the 
+  control memory (128K-1KVC, 512K-4KVC), the size of the packet 
+  memory (128K, 512K, 1M), and the PHY type (Single/Multi mode OC3, 
+  UTP155, UTP25, DS3 and E3). Go to:
+  	www.iphase.com/products/ClassSheet.cfm?ClassID=ATM
+  for more info about the cards. Say Y (or M to compile as a module 
+  named iphase.o) here if you have one of these cards.
+
+  See the file Documentation/networking/iphase.txt for further
+  details.
+
+Enable debugging messages
+CONFIG_ATM_IA_DEBUG
+  Somewhat useful debugging messages are available. The choice of
+  messages is controlled by a bitmap. This may be specified as a
+  module argument (kernel command line argument as well?), changed
+  dynamically using an ioctl (Get the debug utility, iadbg, from 
+  ftp.iphase.com/pub/atm/pci). See the file drivers/atm/iphase.h 
+  for the meanings of the bits in the mask.
+
+  When active, these messages can have a significant impact on the
+  speed of the driver, and the size of your syslog files! When
+  inactive, they will have only a modest impact on performance.
+
+Linux telephony support
+CONFIG_PHONE
+  Say Y here if you have a telephony card, which for example allows
+  you to use a regular phone for voice-over-IP applications. 
+
+  Note: this has nothing to do with modems. You do not need to say Y
+  here in order to be able to use a modem under Linux.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called phonedev.o.
+
+Compaq Smart Array support
+CONFIG_BLK_CPQ_CISS_DA
+   This is the driver for Compaq Smart Array controllers.
+   Everyone using these boards should say Y here.
+   See Documentation/cciss.txt for the current list of
+   boards supported by this driver, and for further information
+   on the use of this driver.
+
+QuickNet Internet LineJack/PhoneJack support
+CONFIG_PHONE_IXJ
+  Say M if you have a telephony card manufactured by Quicknet
+  Technologies, Inc.  These include the Internet PhoneJACK and
+  Internet LineJACK Telephony Cards. You will get a module called
+  ixj.o. 
+
+  For the ISA versions of these products, you can configure the
+  cards using the isapnp tools (pnpdump/isapnp) or you can use the
+  isapnp support.  Please read Documentation/telephony/ixj.txt.
+
+  For more information on these cards, see Quicknet's web site at:
+  http://www.quicknet.net/ .
+
+  If you do not have any Quicknet telephony cards, you can safely
+  say N here.
+
+FORE Systems 200E-series
+CONFIG_ATM_FORE200E_MAYBE
+  This is a driver for the FORE Systems 200E-series ATM adapter
+  cards. It simultaneously supports PCA-200E and SBA-200E models
+  on PCI and SBUS hosts. Say Y (or M to compile as a module
+  named fore_200e.o) here if you have one of these ATM adapters.
+ 
+  Note that the driver will actually be compiled only if you
+  additionally enable the support for PCA-200E and/or SBA-200E
+  cards.
+
+  See the file Documentation/networking/fore200e.txt for further
+  details.
+ 
+Enable PCA-200E card support on PCI-based hosts
+CONFIG_ATM_FORE200E_PCA
+  Say Y here if you want your PCA-200E cards to be probed.
+ 
+Use default PCA-200E firmware
+CONFIG_ATM_FORE200E_PCA_DEFAULT_FW
+  Use the default PCA-200E firmware data shipped with the driver.
+ 
+  Normal users do not have to deal with the firmware stuff, so
+  they should say Y here.
+ 
+Pathname of user-supplied binary firmware
+CONFIG_ATM_FORE200E_PCA_FW
+  This defines the pathname of an alternative PCA-200E binary
+  firmware image supplied by the user. This pathname may be
+  absolute or relative to the drivers/atm directory.
+ 
+  The driver comes with an adequate firmware image, so normal users do
+  not have to supply an alternative one. They just say Y to "Use
+  default PCA-200E firmware" instead.
+ 
+Enable SBA-200E card support on SBUS-based hosts
+CONFIG_ATM_FORE200E_SBA
+  Say Y here if you want your SBA-200E cards to be probed.
+ 
+Use default SBA-200E firmware
+CONFIG_ATM_FORE200E_SBA_DEFAULT_FW
+  Use the default SBA-200E firmware data shipped with the driver.
+ 
+  Normal users do not have to deal with the firmware stuff, so
+  they should say Y here.
+ 
+Pathname of user-supplied binary firmware
+CONFIG_ATM_FORE200E_SBA_FW
+  This defines the pathname of an alternative SBA-200E binary
+  firmware image supplied by the user. This pathname may be
+  absolute or relative to the drivers/atm directory.
+ 
+  The driver comes with an adequate firmware image, so normal users do
+  not have to supply an alternative one. They just say Y to "Use
+  default SBA-200E firmware", above.
+ 
+Maximum number of tx retries
+CONFIG_ATM_FORE200E_TX_RETRY
+  Specifies the number of times the driver attempts to transmit
+  a message before giving up, if the transmit queue of the ATM card
+  is transiently saturated.
+ 
+  Saturation of the transmit queue may occur only under extreme
+  conditions, e.g. when a fast host continuously submits very small
+  frames (<64 bytes) or raw AAL0 cells (48 bytes) to the ATM adapter.
+ 
+  Note that under common conditions, it is unlikely that you encounter
+  a saturation of the transmit queue, so the retry mechanism never
+  comes into play.
+
+Debugging level (0-3)
+CONFIG_ATM_FORE200E_DEBUG
+  Specifies the level of debugging messages issued by the driver.
+  The verbosity of the driver increases with the value of this
+  parameter.
+ 
+  When active, these messages can have a significant impact on
+  the performances of the driver, and the size of your syslog files!
+  Keep the debugging level to 0 during normal operations.
+
+SCSI support?
+CONFIG_SCSI
+  If you want to use a SCSI hard disk, SCSI tape drive, SCSI CDROM or
+  any other SCSI device under Linux, say Y and make sure that you know
+  the name of your SCSI host adapter (the card inside your computer
+  that "speaks" the SCSI protocol, also called SCSI controller),
+  because you will be asked for it. 
+
+  You also need to say Y here if you want support for the parallel
+  port version of the 100 MB IOMEGA ZIP drive.
+
+  Please read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . The
+  SCSI-Programming-HOWTO contains information about how to add or
+  remove an SCSI device from a running Linux machine without
+  rebooting.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scsi_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. However, do not compile this as a module if
+  your root file system (the one containing the directory /) is
+  located on a SCSI device.
+
+SCSI disk support
+CONFIG_BLK_DEV_SD
+  If you want to use a SCSI hard disk or the SCSI or parallel port
+  version of the IOMEGA ZIP drive under Linux, say Y and read the
+  SCSI-HOWTO, the Disk-HOWTO and the Multi-Disk-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . This is NOT for SCSI
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sd_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. Do not compile this driver as a module if
+  your root file system (the one containing the directory /) is
+  located on a SCSI disk. In this case, do not compile the driver for
+  your SCSI host adapter (below) as a module either.
+
+Extra SCSI Disks
+CONFIG_SD_EXTRA_DEVS
+  This controls the amount of additional space allocated in tables for
+  drivers that are loaded as modules after the kernel is booted.  In
+  the event that the SCSI core itself was loaded as a module, this
+  value is the number of additional disks that can be loaded after the
+  first host driver is loaded.
+
+  Admittedly this isn't pretty, but there are tons of race conditions
+  involved with resizing the internal arrays on the fly.  Someday this
+  flag will go away, and everything will work automatically.
+
+  If you don't understand what's going on, go with the default.
+
+SCSI tape support
+CONFIG_CHR_DEV_ST
+  If you want to use a SCSI tape drive under Linux, say Y and read the
+  SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , and
+  drivers/scsi/README.st in the kernel source. This is NOT for SCSI
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called st.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+OnStream SC-x0 SCSI tape support
+CONFIG_CHR_DEV_OSST
+  The OnStream SC-x0 SCSI tape drives can not be driven by the 
+  standard st driver, but instead need this special osst driver and 
+  use the  /dev/osstX char device nodes (major 206).
+  Via usb-storage and ide-scsi, you may be able to drive the USB-x0 
+  and DI-x0 drives as well. Note that there is also a second generation
+  of OnStream tape drives (ADR-x0) that supports the standard SCSI-2
+  commands for tapes (QIC-157) and can be driven by the standard
+  driver st.
+  For more information, you may have a look at the SCSI-HOWTO
+  ftp://metalab.unc.edu/pub/Linux/docs/HOWTO  and
+  drivers/scsi/README.osst  in the kernel source. 
+  More info on the OnStream driver may be found on 
+  http://linux1.onstream.nl/test/
+  Please also have a look at the standard st docu, as most of it
+  applies to osst as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called osst.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+SCSI CDROM support
+CONFIG_BLK_DEV_SR
+  If you want to use a SCSI CDROM under Linux, say Y and read the
+  SCSI-HOWTO and the CDROM-HOWTO at
+  http://www.linuxdoc.org/docs.html#howto . Also make sure to say Y
+  or M to "ISO 9660 CDROM file system support" later.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sr_mod.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt .
+
+Extra SCSI CDROMs
+CONFIG_SR_EXTRA_DEVS
+  This controls the amount of additional space allocated in tables for
+  drivers that are loaded as modules after the kernel is booted. In
+  the event that the SCSI core itself was loaded as a module, this
+  value is the number of additional CDROMs that can be loaded after
+  the first host driver is loaded.
+
+  Admittedly this isn't pretty, but there are tons of race conditions
+  involved with resizing the internal arrays on the fly.  Someday this
+  flag will go away, and everything will work automatically.
+
+  If you don't understand what's going on, go with the default.
+
+Enable vendor-specific extensions (for SCSI CDROM)
+CONFIG_BLK_DEV_SR_VENDOR
+  This enables the usage of vendor specific SCSI commands. This is
+  required to support multisession CDs with old NEC/TOSHIBA cdrom
+  drives (and HP Writers). If you have such a drive and get the first
+  session only, try saying Y here; everybody else says N.
+
+SCSI generic support
+CONFIG_CHR_DEV_SG
+  If you want to use SCSI scanners, synthesizers or CD-writers or just
+  about anything having "SCSI" in its name other than hard disks,
+  CDROMs or tapes, say Y here. These won't be supported by the kernel
+  directly, so you need some additional software which knows how to
+  talk to these devices using the SCSI protocol:
+
+  For scanners, look at SANE (http://www.mostang.com/sane). For CD
+  writer software look at cdrecord
+  (http://www.fokus.gmd.de/research/cc/glone/employees/joerg.schilling/private/cdrecord.html)
+  and for burning a "disk at once": cdrdao
+  (http://www.ping.de/sites/daneb/cdrdao.html). Cdparanoia is a high
+  quality digital reader of audio CDs (http://www.xiph.org/paranoia).
+  For other devices, it's possible that you'll have to write the
+  driver software yourself. Please read the file
+  Documentation/scsi-generic.txt for more information.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt and
+  Documentation/scsi.txt. The module will be called sg.o. If unsure,
+  say N.
+
+Debug new queueing code for SCSI
+CONFIG_SCSI_DEBUG_QUEUES
+  This option turns on a lot of additional consistency checking for
+  the new queueing code. This will adversely affect performance, but
+  it is likely that bugs will be caught sooner if this is turned on.
+  This will typically cause the kernel to panic if an error is
+  detected, but it would have probably crashed if the panic weren't
+  there. Comments/questions/problems to linux-scsi mailing list
+  please. See http://www.andante.org/scsi_queue.html for more
+  up-to-date information.
+
+Probe all LUNs on each SCSI device
+CONFIG_SCSI_MULTI_LUN
+  If you have a SCSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, and only one LUN is detected, you
+  can say Y here to force the SCSI driver to probe for multiple LUNs. 
+  A SCSI device with multiple LUNs acts logically like multiple SCSI
+  devices. The vast majority of SCSI devices have only one LUN, and
+  so most people can say N here and should in fact do so, because it
+  is safer.
+
+Verbose SCSI error reporting (kernel size +=12K)
+CONFIG_SCSI_CONSTANTS
+  The error messages regarding your SCSI hardware will be easier to
+  understand if you say Y here; it will enlarge your kernel by about
+  12 KB. If in doubt, say Y.
+
+SCSI logging facility
+CONFIG_SCSI_LOGGING
+  This turns on a logging facility that can be used to debug a number
+  of SCSI related problems. 
+
+  If you say Y here, no logging output will appear by default, but you
+  can enable logging by saying Y to "/proc file system support" and
+  "Sysctl support" below and executing the command
+
+     echo "scsi log token [level]" > /proc/scsi/scsi
+
+  at boot time after the /proc file system has been mounted.
+
+  There are a number of things that can be used for 'token' (you can
+  find them in the source: drivers/scsi/scsi.c), and this allows you
+  to select the types of information you want, and the level allows
+  you to select the level of verbosity. 
+
+  If you say N here, it may be harder to track down some types of SCSI
+  problems. If you say Y here your kernel will be somewhat larger, but
+  there should be no noticeable performance impact as long as you have
+  logging turned off.
+
+AdvanSys SCSI support
+CONFIG_SCSI_ADVANSYS
+  This is a driver for all SCSI host adapters manufactured by
+  AdvanSys. It is documented in the kernel source in
+  drivers/scsi/advansys.c. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called advansys.o.
+
+Adaptec AHA152X/2825 support
+CONFIG_SCSI_AHA152X
+  This is a driver for the AHA-1510, AHA-1520, AHA-1522, and AHA-2825
+  SCSI host adapters. It also works for the AVA-1505, but the IRQ etc.
+  must be manually specified in this case.
+
+  It is explained in section 3.3 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . You might also want to
+  read the file drivers/scsi/README.aha152x.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha152x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AHA1542 support
+CONFIG_SCSI_AHA1542
+  This is support for a SCSI host adapter. It is explained in section
+  3.4 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Note that Trantor was
+  purchased by Adaptec, and some former Trantor products are being
+  sold under the Adaptec name. If it doesn't work out of the box, you
+  may have to change some settings in drivers/scsi/aha1542.h.
+  
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aha1542.o.
+
+Adaptec AHA1740 support
+CONFIG_SCSI_AHA1740
+  This is support for a SCSI host adapter. It is explained in section
+  3.5 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/aha1740.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aha1740.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Adaptec AIC7xxx chipset SCSI controller support
+CONFIG_SCSI_AIC7XXX
+  This driver supports all of Adaptec's PCI based SCSI controllers (not
+  the hardware RAID controllers though) as well as the aic7770 based
+  EISA and VLB SCSI controllers (the 274x and 284x series).  This is
+  an Adaptec sponsored driver written by Justin Gibbs.  It is intended
+  to replace the previous aic7xxx driver maintained by Doug Ledford since
+  Doug is no longer maintaining that driver.
+
+Default number of TCQ commands per device
+CONFIG_AIC7XXX_CMDS_PER_DEVICE
+  Specify the number of commands you would like to allocate per SCSI
+  device when Tagged Command Queueing (TCQ) is enabled on that device.
+
+  This is an upper bound value for the number of tagged transactions
+  to be used for any device.  The aic7xxx driver will automatically
+  vary this number based on device behavior.  For devices with a
+  fixed maximum, the driver will eventually lock to this maximum
+  and display a console message inidicating this value.
+
+  Note: Unless you experience some type of device failure, the default
+	value, no enforced limit, should work for you.
+
+  Default: 253
+
+Initial Bus Reset Settle Delay
+CONFIG_AIC7XXX_RESET_DELAY_MS
+  The number of milliseconds to delay after an initial bus reset.
+  The bus settle delay following all error recovery actions is
+  dictated by the SCSI layer and is not affected by this value.
+
+  Default: 15000 (15 seconds)
+
+Probe for EISA and VL AIC7XXX Adapters
+CONFIG_AIC7XXX_PROBE_EISA_VL
+  The probe for EISA and VL cards may upset some PCI devices
+  that have mapped their registers into the standard EISA
+  "slot space".  If these PCI devices have not yet had a driver
+  attached to reserve their I/O space, the EISA and VL probe
+  may inadvertantly touch the registers of a non-aic7xxx device.
+  If you have an EISA (274X) or VL (2840) controller, you should
+  enable this option or use the "aic7xxx=no_probe:0" module or
+  boot time option.
+  
+  Default: Off
+
+Build Adapter Firmware with Kernel Build
+CONFIG_AIC7XXX_BUILD_FIRMWARE
+  This option should only be enabled if you are modifying the
+  firmware source to the aic7xxx driver and wish to have the
+  generated firmware include files updated during a normal
+  kernel build.  The assembler for the firmware requires
+  lex and yacc or their equivalents, as well as the db v1
+  library.  You may have to install additional packages or
+  modify the assembler make file or the files it includes
+  if your build environment is different than that of the
+  author.
+
+Old Adaptec AIC7xxx chipset SCSI controller support
+CONFIG_SCSI_AIC7XXX_OLD
+  WARNING This driver is an older aic7xxx driver and is no longer under
+  active development.  Adaptec, Inc. is writing a new driver to take the
+  place of this one, and it is recommended that whenever possible, people
+  should use the new Adaptec written driver instead of this one.  This
+  driver will eventually be phased out entirely.
+
+  This is support for the various aic7xxx based Adaptec SCSI
+  controllers. These include the 274x EISA cards; 284x VLB cards;
+  2902, 2910, 293x, 294x, 394x, 3985 and several other PCI and
+  motherboard based SCSI controllers from Adaptec. It does not support
+  the AAA-13x RAID controllers from Adaptec, nor will it likely ever
+  support them. It does not support the 2920 cards from Adaptec that
+  use the Future Domain SCSI controller chip. For those cards, you
+  need the "Future Domain 16xx SCSI support" driver.
+
+  In general, if the controller is based on an Adaptec SCSI controller
+  chip from the aic777x series or the aic78xx series, this driver
+  should work. The only exception is the 7810 which is specifically
+  not supported (that's the RAID controller chip on the AAA-13x
+  cards).
+
+  Note that the AHA2920 SCSI host adapter is *not* supported by this
+  driver; choose "Future Domain 16xx SCSI support" instead if you have
+  one of those.
+
+  Information on the configuration options for this controller can be
+  found by checking the help file for each of the available
+  configuration options. You should read drivers/scsi/aic7xxx_old/README.aic7xxx
+  at a minimum before contacting the maintainer with any questions.
+  The SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , can also be of great
+  help.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aic7xxx_old.o.
+
+Enable or Disable Tagged Command Queueing by default
+CONFIG_AIC7XXX_OLD_TCQ_ON_BY_DEFAULT
+  This option causes the aic7xxx driver to attempt to use Tagged
+  Command Queueing (TCQ) on all devices that claim to support it. 
+
+  TCQ is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Because the device is
+  intelligent, it can optimize its operations (like head positioning)
+  based on its own request queue. Not all devices implement this
+  correctly. 
+
+  If you say Y here, you can still turn off TCQ on troublesome devices
+  with the use of the tag_info boot parameter. See the file
+  drivers/scsi/README.aic7xxx for more information on that and other
+  aic7xxx setup commands. If this option is turned off, you may still
+  enable TCQ on known good devices by use of the tag_info boot
+  parameter.
+
+  If you are unsure about your devices then it is safest to say N
+  here.
+  
+  However, TCQ can increase performance on some hard drives by as much
+  as 50% or more, so it is recommended that if you say N here, you
+  should at least read the README.aic7xxx file so you will know how to
+  enable this option manually should your drives prove to be safe in
+  regards to TCQ.
+
+  Conversely, certain drives are known to lock up or cause bus resets
+  when TCQ is enabled on them. If you have a Western Digital
+  Enterprise SCSI drive for instance, then don't even bother to enable
+  TCQ on it as the drive will become unreliable, and it will actually
+  reduce performance.
+
+Default number of TCQ commands per device
+CONFIG_AIC7XXX_OLD_CMDS_PER_DEVICE
+  Specify the number of commands you would like to allocate per SCSI
+  device when Tagged Command Queueing (TCQ) is enabled on that device.
+
+  Reasonable figures are in the range of 8 to 24 commands per device,
+  but depending on hardware could be increased or decreased from that
+  figure. If the number is too high for any particular device, the
+  driver will automatically compensate usually after only 10 minutes
+  of uptime. It will not hinder performance if some of your devices
+  eventually have their command depth reduced, but is a waste of
+  memory if all of your devices end up reducing this number down to a
+  more reasonable figure.
+  
+  NOTE: Certain very broken drives are known to lock up when given
+  more commands than they like to deal with. Quantum Fireball drives
+  are the most common in this category. For the Quantum Fireball
+  drives it is suggested to use no more than 8 commands per device.
+
+  Default: 8
+
+Collect statistics to report in /proc
+CONFIG_AIC7XXX_OLD_PROC_STATS
+  This option tells the driver to keep track of how many commands have
+  been sent to each particular device and report that information to
+  the user via the /proc/scsi/aic7xxx/n file, where n is the number of
+  the aic7xxx controller you want the information on. This adds a
+  small amount of overhead to each and every SCSI command the aic7xxx
+  driver handles, so if you aren't really interested in this
+  information, it is best to leave it disabled. This will only work if
+  you also say Y to "/proc file system support", below. 
+
+  If unsure, say N.
+
+Adaptec AIC79xx chipset SCSI controller support
+CONFIG_SCSI_AIC79XX
+  This Adaptec developed driver supports Adaptec's PCI-X based U320
+  SCSI controllers.
+
+Default number of TCQ commands per device
+CONFIG_AIC79XX_CMDS_PER_DEVICE
+  Specify the number of commands you would like to allocate per SCSI
+  device when Tagged Command Queueing (TCQ) is enabled on that device.
+
+  This is an upper bound value for the number of tagged transactions
+  to be used for any device.  The aic79xx driver will automatically
+  vary this number based on device behavior.  For devices with a
+  fixed maximum, the driver will eventually lock to this maximum
+  and display a console message inidicating this value.
+
+  Note: Unless you experience some type of device failure, the default
+	value, no enforced limit, should work for you.
+
+  Default: 253
+
+Initial Bus Reset Settle Delay
+CONFIG_AIC79XX_RESET_DELAY_MS
+  The number of milliseconds to delay after an initial bus reset.
+  The bus settle delay following all error recovery actions is
+  dictated by the SCSI layer and is not affected by this value.
+
+  Default: 15000 (15 seconds)
+
+Build Adapter Firmware with Kernel Build
+CONFIG_AIC79XX_BUILD_FIRMWARE
+  This option should only be enabled if you are modifying the
+  firmware source to the aic79xx driver and wish to have the
+  generated firmware include files updated during a normal
+  kernel build.  The assembler for the firmware requires
+  lex and yacc or their equivalents, as well as the db v1
+  library.  You may have to install additional packages or
+  modify the assembler make file or the files it includes
+  if your build environment is different than that of the
+  author.
+
+Enable Read Streaming for All Targets
+CONFIG_AIC79XX_ENABLE_RD_STRM
+  This option enables read streaming on all targets that support
+  the feature.  Although it is intended to boost performance, it
+  may actually degrade performance on devices where the feature is
+  not implemented correctly.
+
+IBM ServeRAID Support
+CONFIG_SCSI_IPS
+  This is support for the IBM ServeRAID hardware RAID controllers.
+  See http://www.developer.ibm.com/welcome/netfinity/serveraid.html
+  for more information.  If this driver does not work correctly
+  without modification please contact the author by email at
+  ipslinux@us.ibm.com.
+
+  You can build this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  but only a single instance may be loaded. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. The
+  module will be called ips.o.
+
+BusLogic SCSI support
+CONFIG_SCSI_BUSLOGIC
+  This is support for BusLogic MultiMaster and FlashPoint SCSI Host
+  Adapters. Consult the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , and the files
+  README.BusLogic and README.FlashPoint in drivers/scsi for more
+  information. If this driver does not work correctly without
+  modification, please contact the author, Leonard N. Zubkoff, by
+  email to lnz@dandelion.com.
+
+  You can also build this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  but only a single instance may be loaded. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. The
+  module will be called BusLogic.o.
+
+Omit BusLogic SCSI FlashPoint support
+CONFIG_SCSI_OMIT_FLASHPOINT
+  This option allows you to omit the FlashPoint support from the
+  BusLogic SCSI driver. The FlashPoint SCCB Manager code is
+  substantial, so users of MultiMaster Host Adapters may wish to omit
+  it.
+
+DMX3191D SCSI support
+CONFIG_SCSI_DMX3191D
+  This is support for Domex DMX3191D SCSI Host Adapters.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dmx3191d.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+DTC3180/3280 SCSI support
+CONFIG_SCSI_DTC3280
+  This is support for DTC 3180/3280 SCSI Host Adapters. Please read
+  the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , and the file
+  drivers/scsi/README.dtc3x80.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dtc.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-DMA [Obsolete] (DPT, NEC, AT&T, SNI, AST, Olivetti, Alphatronix) support
+CONFIG_SCSI_EATA_DMA
+  This is support for the EATA-DMA protocol compliant SCSI Host
+  Adapters like the SmartCache III/IV, SmartRAID controller families
+  and the DPT PM2011B and PM2012B controllers. 
+
+  Note that this driver is obsolete; if you have one of the above SCSI
+  Host Adapters, you should normally say N here and Y to "EATA
+  ISA/EISA/PCI support", below. Please read the SCSI-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eata_dma.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA-PIO (old DPT PM2001, PM2012A) support
+CONFIG_SCSI_EATA_PIO
+  This driver supports all EATA-PIO protocol compliant SCSI Host
+  Adapters like the DPT PM2001 and the PM2012A. EATA-DMA compliant
+  host adapters could also use this driver but are discouraged from
+  doing so, since this driver only supports hard disks and lacks
+  numerous features. You might want to have a look at the SCSI-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto . 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata_pio.o.
+
+UltraStor 14F/34F support
+CONFIG_SCSI_U14_34F
+  This is support for the UltraStor 14F and 34F SCSI-2 host adapters.
+  The source at drivers/scsi/u14-34f.c contains some information about
+  this hardware. If the driver doesn't work out of the box, you may
+  have to change some settings in drivers/scsi/u14-34f.c. Read the
+  SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Note that there is also
+  another driver for the same hardware: "UltraStor SCSI support",
+  below. You should say Y to both only if you want 24F support as
+  well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called u14-34f.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+enable elevator sorting
+CONFIG_SCSI_U14_34F_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_U14_34F_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 8
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 14. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+Future Domain 16xx SCSI/AHA-2920A support
+CONFIG_SCSI_FUTURE_DOMAIN
+  This is support for Future Domain's 16-bit SCSI host adapters
+  (TMC-1660/1680, TMC-1650/1670, TMC-3260, TMC-1610M/MER/MEX) and
+  other adapters based on the Future Domain chipsets (Quantum
+  ISA-200S, ISA-250MG; Adaptec AHA-2920A; and at least one IBM board).
+  It is explained in section 3.7 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  NOTE: Newer Adaptec AHA-2920C boards use the Adaptec AIC-7850 chip
+  and should use the aic7xxx driver ("Adaptec AIC7xxx chipset SCSI
+  controller support"). This Future Domain driver works with the older
+  Adaptec AHA-2920A boards with a Future Domain chip on them.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fdomain.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Future Domain MCS-600/700 SCSI support
+CONFIG_SCSI_FD_MCS
+  This is support for Future Domain MCS 600/700 MCA SCSI adapters.
+  Some PS/2 computers are equipped with IBM Fast SCSI Adapter/A which
+  is identical to the MCS 700 and hence also supported by this driver.
+  This driver also supports the Reply SB16/SCSI card (the SCSI part).
+  It supports multiple adapters in the same system.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fd_mcs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Generic NCR5380/53c400 SCSI support
+CONFIG_SCSI_GENERIC_NCR5380
+  This is the generic NCR family of SCSI controllers, not to be
+  confused with the NCR 53c7 or 8xx controllers. It is explained in
+  section 3.8 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/g_NCR5380.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called g_NCR5380.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Enable NCR53c400 extensions
+CONFIG_SCSI_GENERIC_NCR53C400
+  This enables certain optimizations for the NCR53c400 SCSI cards. You
+  might as well try it out. Note that this driver will only probe for
+  the Trantor T130B in its default configuration; you might have to
+  pass a command line option to the kernel at boot time if it doesn't
+  detect your card. See the file drivers/scsi/README.g_NCR5380 for
+  details.
+
+NCR5380/53c400 mapping method (use Port for T130B)
+CONFIG_SCSI_G_NCR5380_PORT
+  The NCR5380 and NCR53c400 SCSI controllers come in two varieties:
+  port or memory mapped. You should know what you have. The most
+  common card, Trantor T130B, uses port mapped mode.
+
+NCR53c7,8xx SCSI support
+CONFIG_SCSI_NCR53C7xx
+  This is a driver for the 53c7 and 8xx NCR family of SCSI
+  controllers, not to be confused with the NCR 5380 controllers. It is
+  explained in section 3.8 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/53c7,8xx.h. Please read drivers/scsi/README.ncr53c7xx
+  for the available boot time command line options.
+
+  Note: there is another driver for the 53c8xx family of controllers
+  ("NCR53C8XX SCSI support" below). If you want to use them both, you
+  need to say M to both and build them as modules, but only one may be
+  active at a time. If you have a 53c8xx board, it's better to use the
+  other driver.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 53c7,8xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+always negotiate synchronous transfers
+CONFIG_SCSI_NCR53C7xx_sync
+  In general, this is good; however, it is a bit dangerous since there
+  are some broken SCSI devices out there. Take your chances. Safe bet
+  is N.
+
+allow FAST-SCSI [10MHz]
+CONFIG_SCSI_NCR53C7xx_FAST
+  This will enable 10MHz FAST-SCSI transfers with your host
+  adapter. Some systems have problems with that speed, so it's safest
+  to say N here.
+
+allow DISCONNECT
+CONFIG_SCSI_NCR53C7xx_DISCONNECT
+  This enables the disconnect/reconnect feature of the NCR SCSI
+  controller. When you say Y here, a slow SCSI device will not lock
+  the SCSI bus while processing a request, allowing simultaneous use
+  of e.g. a SCSI hard disk and SCSI tape or CD-ROM drive, and
+  providing much better performance when using slow and fast SCSI
+  devices at the same time. Some devices, however, do not operate
+  properly with this option enabled, and will cause your SCSI system
+  to hang, which might cause a system crash. The safe answer
+  therefore is to say N.
+
+NCR53C8XX SCSI support
+CONFIG_SCSI_NCR53C8XX
+  This is the BSD ncr driver adapted to Linux for the NCR53C8XX family
+  of PCI-SCSI controllers. This driver supports parity checking,
+  tagged command queuing and fast synchronous data transfers up to 80
+  MB/s with wide FAST-40 LVD devices and controllers.
+
+  Recent versions of the 53C8XX chips are better supported by the
+  option "SYM53C8XX SCSI support", below.
+
+  Note: there is yet another driver for the 53c8xx family of
+  controllers ("NCR53c7,8xx SCSI support" above). If you want to use
+  them both, you need to say M to both and build them as modules, but
+  only one may be active at a time. If you have a 53c8xx board, you
+  probably do not want to use the "NCR53c7,8xx SCSI support".
+
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+SYM53C8XX SCSI support
+CONFIG_SCSI_SYM53C8XX
+  This driver supports all the features of recent 53C8XX chips (used
+  in PCI SCSI controllers), notably the hardware phase mismatch
+  feature of the SYM53C896.
+
+  Older versions of the 53C8XX chips are not supported by this
+  driver. If your system uses either a 810 rev. < 16, a 815, or a 825
+  rev. < 16 PCI SCSI processor, you must use the generic NCR53C8XX
+  driver ("NCR53C8XX SCSI support" above) or configure both the
+  NCR53C8XX and this SYM53C8XX drivers either as module or linked to
+  the kernel image.
+
+  When both drivers are linked into the kernel, the SYM53C8XX driver
+  is called first at initialization and you can use the 'excl=ioaddr'
+  driver boot option to exclude attachment of adapters by the
+  SYM53C8XX driver. For example, entering
+  'sym53c8xx=excl:0xb400,excl=0xc000' at the lilo prompt prevents
+  adapters at io address 0xb400 and 0xc000 from being attached by the
+  SYM53C8XX driver, thus allowing the NCR53C8XX driver to attach them.
+  The 'excl' option is also supported by the NCR53C8XX driver.
+  
+  Please read drivers/scsi/README.ncr53c8xx for more information.
+
+synchronous data transfers frequency
+CONFIG_SCSI_NCR53C8XX_SYNC
+  The SCSI Parallel Interface-2 Standard defines 5 classes of transfer
+  rates: FAST-5, FAST-10, FAST-20, FAST-40 and FAST-80. The numbers are
+  respectively the maximum data transfer rates in mega-transfers per
+  second for each class. For example, a FAST-20 Wide 16 device is able
+  to transfer data at 20 million 16 bit packets per second for a total
+  rate of 40 MB/s.
+
+  You may specify 0 if you want to only use asynchronous data
+  transfers. This is the safest and slowest option. Otherwise, specify
+  a value between 5 and 80, depending on the capability of your SCSI
+  controller. The higher the number, the faster the data transfer.
+  Note that 80 should normally be ok since the driver decreases the
+  value automatically according to the controller's capabilities.
+
+  Your answer to this question is ignored for controllers with NVRAM,
+  since the driver will get this information from the user set-up. It
+  also can be overridden using a boot setup option, as follows
+  (example): 'ncr53c8xx=sync:12' will allow the driver to negotiate
+  for FAST-20 synchronous data transfer (20 mega-transfers per
+  second).
+
+  The normal answer therefore is not to go with the default but to
+  select the maximum value 80 allowing the driver to use the maximum
+  value supported by each controller. If this causes problems with
+  your SCSI devices, you should come back and decrease the value.
+
+  There is no safe option other than using good cabling, right
+  terminations and SCSI conformant devices.
+
+use normal IO
+CONFIG_SCSI_NCR53C8XX_IOMAPPED
+  If you say Y here, the driver will use normal IO, as opposed to
+  memory mapped IO. Memory mapped IO has less latency than normal IO
+  and works for most Intel-based hardware. Under Linux/Alpha only
+  normal IO is currently supported by the driver and so, this option
+  has no effect on those systems. 
+
+  The normal answer therefore is N; try Y only if you encounter SCSI
+  related problems.
+
+not allow targets to disconnect
+CONFIG_SCSI_NCR53C8XX_NO_DISCONNECT
+  This option is only provided for safety if you suspect some SCSI
+  device of yours to not support properly the target-disconnect
+  feature. In that case, you would say Y here. In general however, to
+  not allow targets to disconnect is not reasonable if there is more
+  than 1 device on a SCSI bus. The normal answer therefore is N.
+
+default tagged command queue depth
+CONFIG_SCSI_NCR53C8XX_DEFAULT_TAGS
+  "Tagged command queuing" is a feature of SCSI-2 which improves
+  performance: the host adapter can send several SCSI commands to a
+  device's queue even if previous commands haven't finished yet.
+  Because the device is intelligent, it can optimize its operations
+  (like head positioning) based on its own request queue. Some SCSI
+  devices don't implement this properly; if you want to disable this
+  feature, enter 0 or 1 here (it doesn't matter which).
+
+  The default value is 8 and should be supported by most hard disks.
+  This value can be overridden from the boot command line using the 
+  'tags' option as follows (example):
+  'ncr53c8xx=tags:4/t2t3q16/t0u2q10' will set default queue depth to
+  4, set queue depth to 16 for target 2 and target 3 on controller 0
+  and set queue depth to 10 for target 0 / lun 2 on controller 1.
+
+  The normal answer therefore is to go with the default 8 and to use 
+  a boot command line option for devices that need to use a different 
+  command queue depth.
+
+  There is no safe option other than using good SCSI devices.
+
+maximum number of queued commands
+CONFIG_SCSI_NCR53C8XX_MAX_TAGS
+  This option allows you to specify the maximum number of commands
+  that can be queued to any device, when tagged command queuing is
+  possible. The default value is 32. Minimum is 2, maximum is 64.
+  Modern hard disks are able to support 64 tags and even more, but 
+  do not seem to be faster when more than 32 tags are being used.
+  
+  So, the normal answer here is to go with the default value 32 unless
+  you are using very large hard disks with large cache (>= 1 MB) that
+  are able to take advantage of more than 32 tagged commands.
+
+  There is no safe option and the default answer is recommended.
+
+assume boards are SYMBIOS compatible (EXPERIMENTAL)
+CONFIG_SCSI_NCR53C8XX_SYMBIOS_COMPAT
+  This option allows you to enable some features depending on GPIO
+  wiring. These General Purpose Input/Output pins can be used for
+  vendor specific features or implementation of the standard SYMBIOS
+  features. Genuine SYMBIOS controllers use GPIO0 in output for
+  controller LED and GPIO3 bit as a flag indicating
+  singled-ended/differential interface. The Tekram DC-390U/F boards
+  uses a different GPIO wiring.
+  
+  Your answer to this question is ignored if all your controllers have
+  NVRAM, since the driver is able to detect the board type from the
+  NVRAM format.
+
+  If all the controllers in your system are genuine SYMBIOS boards or
+  use BIOS and drivers from SYMBIOS, you would want to say Y here,
+  otherwise N. N is the safe answer.
+
+enable profiling statistics gathering
+CONFIG_SCSI_NCR53C8XX_PROFILE
+  This option allows you to enable profiling information gathering.
+  These statistics are not very accurate due to the low frequency 
+  of the kernel clock (100 Hz on i386) and have performance impact 
+  on systems that use very fast devices.
+
+  The normal answer therefore is N.
+
+include support for the NCR PQS/PDS SCSI card
+CONFIG_SCSI_NCR53C8XX_PQS_PDS
+  Say Y here if you have a special SCSI adapter produced by NCR
+  corporation called a PCI Quad SCSI or PCI Dual SCSI. You do not need
+  this if you do not have one of these adapters. However, since this
+  device is detected as a specific PCI device, this option is quite
+  safe.
+
+  The common answer here is N, but answering Y is safe.
+
+IBMMCA SCSI support
+CONFIG_SCSI_IBMMCA
+  This is support for the IBM SCSI adapter found in many of the PS/2
+  series computers. These machines have an MCA bus, so you need to
+  answer Y to "MCA support" as well and read Documentation/mca.txt.
+
+  If the adapter isn't found during boot (a common problem for models
+  56, 57, 76, and 77) you'll need to use the 'ibmmcascsi=<pun>' kernel
+  option, where <pun> is the id of the SCSI subsystem (usually 7, but
+  if that doesn't work check your reference diskette). Owners of model
+  95 with a LED-matrix-display can in addition activate some activity
+  info like under OS/2, but more informative, by setting
+  'ibmmcascsi=display' as an additional kernel parameter. Try "man
+  bootparam" or see the documentation of your boot loader about how to
+  pass options to the kernel.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ibmmca.o.
+
+Standard SCSI-order
+CONFIG_IBMMCA_SCSI_ORDER_STANDARD
+  In the PC-world and in most modern SCSI-BIOS-setups, SCSI-hard disks
+  are assigned to the drive letters, starting with the lowest SCSI-id
+  (physical number -- pun) to be drive C:, as seen from DOS and
+  similar operating systems. When looking into papers describing the
+  ANSI-SCSI-standard, this assignment of drives appears to be wrong.
+  The SCSI-standard follows a hardware-hierarchy which says that id 7
+  has the highest priority and id 0 the lowest. Therefore, the host
+  adapters are still today everywhere placed as SCSI-id 7 by default.
+  In the SCSI-standard, the drive letters express the priority of the
+  disk. C: should be the hard disk, or a partition on it, with the
+  highest priority. This must therefore be the disk with the highest
+  SCSI-id (e.g. 6) and not the one with the lowest! IBM-BIOS kept the
+  original definition of the SCSI-standard as also industrial- and
+  process-control-machines, like VME-CPUs running under realtime-OSs
+  (e.g. LynxOS, OS9) do.
+
+  If you like to run Linux on your MCA-machine with the same
+  assignment of hard disks as seen from e.g. DOS or OS/2 on your
+  machine, which is in addition conformant to the SCSI-standard, you
+  must say Y here. This is also necessary for MCA-Linux users who want
+  to keep downward compatibility to older releases of the
+  IBM-MCA-SCSI-driver (older than driver-release 2.00 and older than
+  June 1997).
+
+  If you like to have the lowest SCSI-id assigned as drive C:, as
+  modern SCSI-BIOSes do, which does not conform to the standard, but
+  is widespread and common in the PC-world of today, you must say N
+  here. If unsure, say Y.
+
+Reset SCSI-devices at boot time
+CONFIG_IBMMCA_SCSI_DEV_RESET
+  By default, SCSI-devices are reset when the machine is powered on.
+  However, some devices exist, like special-control-devices,
+  SCSI-CNC-machines, SCSI-printer or scanners of older type, that do
+  not reset when switched on. If you say Y here, each device connected
+  to your SCSI-bus will be issued a reset-command after it has been
+  probed, while the kernel is booting. This may cause problems with
+  more modern devices, like hard disks, which do not appreciate these
+  reset commands, and can cause your system to hang. So say Y only if
+  you know that one of your older devices needs it; N is the safe
+  answer.
+
+NCR 53C9x MCA support
+CONFIG_SCSI_MCA_53C9X
+  Some Microchannel machines, notably the NCR 35xx line, use a SCSI
+  controller based on the NCR 53C94.  This driver will allow use of
+  the controller on the 3550, and very possibly others.   
+
+  If you want to compile this as a module (= code which can be
+  inserted and removed from the running kernel whenever you want), say
+  M here and read Documentation/modules.txt. The module will be called
+  mca_53c9x.o.
+ 
+Always IN2000 SCSI support
+CONFIG_SCSI_IN2000
+  This is support for an ISA bus SCSI host adapter. You'll find more
+  information in drivers/scsi/in2000.readme. If it doesn't work out of
+  the box, you may have to change the jumpers for IRQ or address
+  selection. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called in2000.o.
+
+Initio 91XXU(W) SCSI support
+CONFIG_SCSI_INITIO
+  This is support for the Initio 91XXU(W) SCSI host adapter. Please
+  read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called initio.o
+
+PAS16 SCSI support
+CONFIG_SCSI_PAS16
+  This is support for a SCSI host adapter. It is explained in section
+  3.10 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/pas16.h.
+  
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pas16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Initio INI-A100U2W SCSI support
+CONFIG_SCSI_INIA100
+  This is support for the Initio INI-A100U2W SCSI host adapter. Please
+  read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be 
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called a100u2w.o
+
+PCI2000 support
+CONFIG_SCSI_PCI2000
+  This is support for the PCI2000I EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module called pci2000.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PCI2220i support
+CONFIG_SCSI_PCI2220I
+  This is support for the PCI2220i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module called pci2220i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PSI240i support
+CONFIG_SCSI_PSI240I
+  This is support for the PSI240i EIDE interface card which acts as a
+  SCSI host adapter. Please read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module called psi240i.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Qlogic FAS SCSI support
+CONFIG_SCSI_QLOGIC_FAS
+  This is a driver for the ISA, VLB, and PCMCIA versions of the Qlogic
+  FastSCSI! cards as well as any other card based on the FASXX chip
+  (including the Control Concepts SCSI/IDE/SIO/PIO/FDC cards).
+
+  This driver does NOT support the PCI versions of these cards. The
+  PCI versions are supported by the Qlogic ISP driver ("Qlogic ISP
+  SCSI support"), below.
+
+  Information about this driver is contained in
+  drivers/scsi/README.qlogicfas. You should also read the SCSI-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfas.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP SCSI support (EXPERIMENTAL)
+CONFIG_SCSI_QLOGIC_ISP
+  This driver works for all QLogic PCI SCSI host adapters (IQ-PCI,
+  IQ-PCI-10, IQ_PCI-D) except for the PCI-basic card. (This latter
+  card is supported by the "AM53/79C974 PCI SCSI" driver). 
+
+  If you say Y here, make sure to choose "BIOS" at the question "PCI
+  access mode".
+
+  Please read the file drivers/scsi/README.qlogicisp. You should also
+  read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicisp.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic ISP FC SCSI support
+CONFIG_SCSI_QLOGIC_FC
+  This is a driver for the QLogic ISP2100 SCSI-FCP host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qlogicfc.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Qlogic QLA 1280 SCSI support
+CONFIG_SCSI_QLOGIC_1280
+  Say Y if you have a QLogic ISP1x80/1x160 SCSI host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called qla1280.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Seagate ST-02 and Future Domain TMC-8xx SCSI support
+CONFIG_SCSI_SEAGATE
+  These are 8-bit SCSI controllers; the ST-01 is also supported by
+  this driver. It is explained in section 3.9 of the SCSI-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto . If it
+  doesn't work out of the box, you may have to change some settings in
+  drivers/scsi/seagate.h.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called seagate.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Trantor T128/T128F/T228 SCSI support
+CONFIG_SCSI_T128
+  This is support for a SCSI host adapter. It is explained in section
+  3.11 of the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/t128.h. Note that Trantor was purchased by Adaptec, and
+  some former Trantor products are being sold under the Adaptec name.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called t128.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UltraStor SCSI support
+CONFIG_SCSI_ULTRASTOR
+  This is support for the UltraStor 14F, 24F and 34F SCSI-2 host
+  adapter family. This driver is explained in section 3.12 of the
+  SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . If it doesn't work out
+  of the box, you may have to change some settings in
+  drivers/scsi/ultrastor.h.
+  
+  Note that there is also another driver for the same hardware:
+  "UltraStor 14F/34F support", above.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ultrastor.o. 
+
+7000FASST SCSI support
+CONFIG_SCSI_7000FASST
+  This driver supports the Western Digital 7000 SCSI host adapter
+  family. Some information is in the source: drivers/scsi/wd7000.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called wd7000.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+ACARD SCSI support
+CONFIG_SCSI_ACARD
+  This driver supports the ACARD 870U/W SCSI host adapter.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called atp870u.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+EATA ISA/EISA/PCI (DPT and generic EATA/DMA-compliant boards) support
+CONFIG_SCSI_EATA
+  This driver supports all EATA/DMA-compliant SCSI host adapters. DPT
+  ISA and all EISA i/o addresses are probed looking for the "EATA"
+  signature. If you chose "BIOS" at the question "PCI access mode",
+  the addresses of all the PCI SCSI controllers reported by the PCI
+  subsystem are probed as well.
+
+  You want to read the start of drivers/scsi/eata.c and the
+  SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that there is also another driver for the same hardware
+  available: "EATA-DMA support". You should say Y to only one of them.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called eata.o.
+
+enable tagged command queuing
+CONFIG_SCSI_EATA_TAGGED_QUEUE
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Most EATA adapters negotiate
+  this feature automatically with the device, even if your answer is
+  N. The safe answer is N.
+        
+enable elevator sorting
+CONFIG_SCSI_EATA_LINKED_COMMANDS
+  This option enables elevator sorting for all probed SCSI disks and 
+  CDROMs. It definitely reduces the average seek distance when doing
+  random seeks, but this does not necessarily result in a noticeable
+  performance improvement: your mileage may vary...
+  The safe answer is N.
+
+maximum number of queued commands
+CONFIG_SCSI_EATA_MAX_TAGS
+  This specifies how many SCSI commands can be maximally queued for
+  each probed SCSI device. You should reduce the default value of 16
+  only if you have disks with buggy or limited tagged command support.
+  Minimum is 2 and maximum is 62. This value is also the window size
+  used by the elevator sorting option above. The effective value used
+  by the driver for each probed SCSI device is reported at boot time.
+
+NCR53c406a SCSI support
+CONFIG_SCSI_NCR53C406A
+  This is support for the NCR53c406a SCSI host adapter. For user
+  configurable parameters, check out drivers/scsi/NCR53c406.c in the
+  kernel source. Also read the SCSI-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called NCR53c406.o.
+
+Symbios Logic sym53c416 support
+CONFIG_SCSI_SYM53C416
+  This is support for the sym53c416 SCSI host adapter, the SCSI
+  adapter that comes with some HP scanners. This driver requires that
+  the sym53c416 is configured first using some sort of pnp
+  configuration program (e.g. isapnp) or by a PnP aware BIOS. If you
+  are using isapnp then you need to compile this driver as a module
+  and then load it using insmod after isapnp has run. The parameters
+  of the configured card(s) should be passed to the driver. The format
+  is:
+
+    insmod sym53c416 sym53c416=<base>,<irq> [sym53c416_1=<base>,<irq>]
+
+  There is support for up to four adapters. If you want to compile
+  this driver as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  sym53c416.o. 
+
+Simple 53c710 SCSI support (Compaq, NCR machines)
+CONFIG_SCSI_SIM710
+  This is a simple driver for NCR53c710 based SCSI host adapters.
+
+  More complex drivers for this chip are available ("NCR53c7,8xx SCSI
+  support", above), but they require that the scsi chip be able to do
+  DMA block moves between memory and on-chip registers, which can
+  cause problems under certain conditions. This driver is designed to
+  avoid these problems and is intended to work with any Intel machines
+  using 53c710 chips, including various Compaq and NCR machines.
+
+  Please read the comments at the top of the file
+  drivers/scsi/sim710.c for more information.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called sim710.o.
+
+Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support
+CONFIG_SCSI_DC390T
+  This driver supports PCI SCSI host adapters based on the Am53C974A
+  chip, e.g. Tekram DC390(T), DawiControl 2974 and some onboard
+  PCscsi/PCnet (Am53/79C974) solutions.
+
+  Documentation can be found in drivers/scsi/README.tmscsim.
+  
+  Note that this driver does NOT support Tekram DC390W/U/F, which are
+  based on NCR/Symbios chips. Use "NCR53C8XX SCSI support" for those.
+  Also note that there is another generic Am53C974 driver,
+  "AM53/79C974 PCI SCSI support" below. You can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called tmscsim.o.
+
+Omit support for other Am53/79C974 based SCSI adapters
+CONFIG_SCSI_DC390T_NOGENSUPP
+  If you say N here, the DC390(T) SCSI driver relies on the DC390
+  EEPROM to get initial values for its settings, such as speed,
+  termination, etc. If it can't find this EEPROM, it will use defaults
+  or the user supplied boot/module parameters. For details on driver
+  configuration see drivers/scsi/README.tmscsim.
+
+  If you say Y here and if no EEPROM is found, the driver gives up and
+  thus only supports Tekram DC390(T) adapters. This can be useful if
+  you have a DC390(T) and another Am53C974 based adapter, which, for
+  some reason, you want to drive with the other AM53C974 driver.
+
+  If unsure, say N.
+
+AM53/79C974 PCI SCSI support
+CONFIG_SCSI_AM53C974
+  This is support for the AM53/79C974 SCSI host adapters. Please read
+  drivers/scsi/README.AM53C974 for details. Also, the SCSI-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto , is for
+  you.
+
+  Note that there is another driver for AM53C974 based adapters:
+  "Tekram DC390(T) and Am53/79C974 (PCscsi) SCSI support", above. You
+  can pick either one.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called AM53C974.o.
+
+AMI MegaRAID support
+CONFIG_SCSI_MEGARAID
+  This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
+  and 467 SCSI host adapters. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called megaraid.o.
+
+GDT SCSI Disk Array Controller support
+CONFIG_SCSI_GDTH
+  This is a driver for all SCSI Disk Array Controllers (EISA/ISA/PCI) 
+  manufactured by ICP vortex. It is documented in the kernel source in
+  drivers/scsi/gdth.c and drivers/scsi/gdth.h. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+IOMEGA parallel port (ppa - older drives)
+CONFIG_SCSI_PPA
+  This driver supports older versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say N here and Y to "IOMEGA parallel port (imm -
+  newer drives)", below.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available from
+  http://www.linuxdoc.org/docs.html#howto . If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called ppa.o. 
+
+IOMEGA parallel port (imm - newer drives)
+CONFIG_SCSI_IMM
+  This driver supports newer versions of IOMEGA's parallel port ZIP
+  drive (a 100 MB removable media device).
+
+  Note that you can say N here if you have the SCSI version of the ZIP
+  drive: it will be supported automatically if you said Y to the
+  generic "SCSI disk support", above.
+
+  If you have the ZIP Plus drive or a more recent parallel port ZIP
+  drive (if the supplied cable with the drive is labeled "AutoDetect")
+  then you should say Y here; if you have an older ZIP drive, say N
+  here and Y to "IOMEGA Parallel Port (ppa - older drives)", above.
+
+  For more information about this driver and how to use it you should
+  read the file drivers/scsi/README.ppa. You should also read the
+  SCSI-HOWTO, which is available from
+  http://www.linuxdoc.org/docs.html#howto . If you use this driver,
+  you will still be able to use the parallel port for other tasks,
+  such as a printer; it is safe to compile both drivers into the
+  kernel.
+
+  This driver is also available as a module which can be inserted in
+  and removed from the running kernel whenever you want. To compile
+  this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called imm.o. 
+
+Force the Iomega ZIP drivers to use EPP-16
+CONFIG_SCSI_IZIP_EPP16
+  EPP (Enhanced Parallel Port) is a standard for parallel ports which
+  allows them to act as expansion buses that can handle up to 64
+  peripheral devices.
+
+  Some parallel port chipsets are slower than their motherboard, and
+  so we have to control the state of the chipset's FIFO queue every
+  now and then to avoid data loss. This will be done if you say Y
+  here.
+  
+  Generally, saying Y is the safe option and slows things down a bit.
+
+Assume slow parallel port control register
+CONFIG_SCSI_IZIP_SLOW_CTR
+  Some parallel ports are known to have excessive delays between
+  changing the parallel port control register and good data being
+  available on the parallel port data/status register. This option
+  forces a small delay (1.0 usec to be exact) after changing the
+  control register to let things settle out. Enabling this option may
+  result in a big drop in performance but some very old parallel ports
+  (found in 386 vintage machines) will not work properly.
+
+  Generally, saying N is fine.
+
+Parallel port SCSI device support
+CONFIG_PPSCSI
+  There are many external CD-ROM and disk devices that connect through
+  your computer's parallel port. Lots of them are actually SCSI
+  devices using a parallel port SCSI adapter. This option enables the
+  ppSCSI subsystem which contains drivers for many of these external
+  drives. You may also want to look at CONFIG_PARIDE (Parallel port
+  IDE device support).
+
+  If you built ppSCSI support into your kernel, you may still build
+  the individual protocol modules and high-level drivers as loadable
+  modules. If you build this support as a module, it will be called
+  ppscsi.o.
+
+  To use the ppSCSI support, you must say Y or M here and also to at
+  least one protocol driver (e.g. "Shuttle EPST adapter", "Iomega VPI0
+  adapter", "Shining ScarSCI adapter" etc.).
+
+Adaptec APA-348 adapter
+CONFIG_PPSCSI_T348
+  This option enables support for the APA-348 adapter from Adaptec
+  (also known as Trantor T348).  If you build this as a module it will
+  be called t348.o.
+
+Adaptec APA-358 adapter
+CONFIG_PPSCSI_T358
+  This option enables support for the APA-358 adapter from Adaptec
+  (also known as Trantor T358).  If you build this as a module it will
+  be called t358.o.
+
+Iomega VPI0 adapter
+CONFIG_PPSCSI_VPI0
+  This option enables support for the Iomega VPI0 adapter found in the
+  original ZIP-100 drives and the Jaz Traveller.  If you build this as
+  a module it will be called vpi0.o.
+
+OnSpec 90c26 adapter
+CONFIG_PPSCSI_ONSCSI
+  This option enables support for the OnSpec 90c26 in its SCSI adapter
+  mode.  If you build this as a module it will be called onscsi.o.
+
+Shining SparSCI adapter
+CONFIG_PPSCSI_SPARCSI
+  This option enables support for the WBS-11A parallel port SCSI
+  adapter.  This adapter has been marketed by LinkSys as the
+  "ParaSCSI+" and by Shining Technologies as the "SparCSI".  If you
+  build this as a module it will be called sparcsi.o.
+
+Shuttle EPSA-2 adapter
+CONFIG_PPSCSI_EPSA2
+  This option enables support for the Shuttle Technologies EPSA2
+  parallel port SCSI adapter.  EPAS2 is a predecessor to the EPST.  If
+  you build this as a module it will be called epsa2.o.
+
+Shuttle EPST adapter
+CONFIG_PPSCSI_EPST
+  This option enables support for the Shuttle Technologies EPST
+  parallel port SCSI adapter.  If you build this as a module is will
+  be called epst.o.
+
+SCSI Debug host simulator. (EXPERIMENTAL)
+CONFIG_SCSI_DEBUG
+  This is a host adapter simulator that can be programmed to simulate
+  a large number of conditions that could occur on a real bus. The
+  advantage is that many hard to reproduce problems can be tested in a
+  controlled environment where there is reduced risk of losing
+  important data. This is primarily of use to people trying to debug
+  the middle and upper layers of the SCSI subsystem. If unsure, say N.
+
+Fibre Channel support and FC4 SCSI support
+CONFIG_FC4
+  Fibre Channel is a high speed serial protocol mainly used to
+  connect large storage devices to the computer; it is compatible with
+  and intended to replace SCSI.
+
+  This is an experimental support for storage arrays connected to your
+  computer using optical fibre cables and the "X3.269-199X Fibre
+  Channel Protocol for SCSI" specification. If you want to use this,
+  you need to say Y here and to "SCSI support" as well as to the
+  drivers for the storage array itself and for the interface adapter
+  such as SOC or SOC+. This subsystem could even serve for IP
+  networking, with some code extensions.
+
+  If unsure, say N.
+
+Sun SOC
+CONFIG_FC4_SOC
+  Serial Optical Channel is an interface card with one or two Fibre
+  Optic ports, each of which can be connected to a disk array. Note
+  that if you have older firmware in the card, you'll need the
+  microcode from the Solaris driver to make it work.
+
+  This support is also available as a module called soc.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Sun SOC+ (aka SOCAL)
+CONFIG_FC4_SOCAL
+  Serial Optical Channel Plus is an interface card with up to two
+  Fibre Optic ports. This card supports FC Arbitrated Loop (usually
+  A5000 or internal FC disks in E[3-6]000 machines through the
+  Interface Board). You'll probably need the microcode from the
+  Solaris driver to make it work.
+
+  This support is also available as a module called socal.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SparcSTORAGE Array 100 and 200 series
+CONFIG_SCSI_PLUTO
+  If you never bought a disk array made by Sun, go with N. 
+
+  This support is also available as a module called pluto.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Sun Enterprise Network Array (A5000 and EX500)
+CONFIG_SCSI_FCAL
+  This driver drives FC-AL disks connected through a Fibre Channel
+  card using the drivers/fc4 layer (currently only SOCAL). The most
+  common is either A5000 array or internal disks in E[3-6]000
+  machines.
+
+  This support is also available as a module called fcal.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt. If unsure, say N.
+
+AcornSCSI support
+CONFIG_SCSI_ACORNSCSI_3
+  This enables support for the Acorn SCSI card (aka30). If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Acorn SCSI tagged queue support
+CONFIG_SCSI_ACORNSCSI_TAGGED_QUEUE
+  Say Y here to enable tagged queuing support on the Acorn SCSI card.
+
+  This is a feature of SCSI-2 which improves performance: the host
+  adapter can send several SCSI commands to a device's queue even if
+  previous commands haven't finished yet. Some SCSI devices don't
+  implement this properly, so the safe answer is N.
+
+Acorn SCSI Synchronous transfers support
+CONFIG_SCSI_ACORNSCSI_SYNC
+  Say Y here to enable synchronous transfer negotiation with all
+  targets on the Acorn SCSI card.
+
+  In general, this improves performance; however some SCSI devices
+  don't implement it properly, so the safe answer is N.
+
+Oak SCSI support
+CONFIG_SCSI_OAK1
+  This enables support for the Oak SCSI card. If you have an Acorn
+  system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI I support
+CONFIG_SCSI_CUMANA_1
+  This enables support for the Cumana SCSI I card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+Cumana SCSI II support (EXPERIMENTAL)
+CONFIG_SCSI_CUMANA_2
+  This enables support for the Cumana SCSI II card. If you have an
+  Acorn system with one of these, say Y. If unsure, say N.
+
+EcoSCSI support
+CONFIG_SCSI_ECOSCSI
+  This enables support for the EcoSCSI card -- a small card that sits
+  in the Econet socket. If you have an Acorn system with one of these,
+  say Y. If unsure, say N.
+
+EESOX SCSI support (EXPERIMENTAL)
+CONFIG_SCSI_EESOXSCSI
+  This enables support for the EESOX SCSI card. If you have an Acorn
+  system with one of these, say Y, otherwise say N.
+
+Powertec SCSI support (EXPERIMENTAL)
+CONFIG_SCSI_POWERTECSCSI
+  This enables support for the Powertec SCSI card on Acorn systems. If
+  you have one of these, say Y. If unsure, say N.
+
+IEEE 1394 (aka FireWire) support
+CONFIG_IEEE1394
+  IEEE 1394 describes a high performance serial bus, which is also
+  known as FireWire(tm) or i.Link(tm) and is used for connecting all
+  sorts of devices (most notably digital video cameras) to your
+  computer.
+
+  If you have FireWire hardware and want to use it, say Y here.  This
+  is the core support only, you will also need to select a driver for
+  your IEEE 1394 adapter.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ieee1394.o.
+
+TI PCILynx IEEE 1394 support
+CONFIG_IEEE1394_PCILYNX
+  Say Y here if you have a IEEE-1394 controller with the Texas
+  Instruments PCILynx chip.  Note: this driver is written for revision
+  2 of this chip and may not work with revision 0.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pcilynx.o.
+
+Use local RAM on PCILynx board
+CONFIG_IEEE1394_PCILYNX_LOCALRAM
+  This option makes the PCILynx driver use local RAM available on some
+  PCILynx setups for Packet Control Lists. Local RAM is random access
+  memory which resides on the PCILynx board as opposed to on your
+  computer's motherboard. Local RAM may speed up command processing
+  because no PCI transfers are necessary during use of the Packet
+  Control Lists.
+  
+  Note that there are no known PCILynx systems providing local RAM
+  except for the evaluation boards by Texas Instruments and that the
+  PCILynx does not reliably report missing RAM. This means that it is
+  dangerous to say Y here if you are not absolutely sure that your
+  board provides 64KB of local RAM.
+
+  If unsure, say N.
+
+Support for non-IEEE1394 local ports
+CONFIG_IEEE1394_PCILYNX_PORTS
+  This option enables driver code to access the RAM, ROM and AUX ports
+  of the PCILynx through character devices in /dev.  If you don't know
+  what this is about then you won't need it.
+  
+  If unsure, say N.
+
+Adaptec AIC-5800 IEEE 1394 support
+CONFIG_IEEE1394_AIC5800
+  Say Y here if you have a IEEE 1394 controller using the Adaptec
+  AIC-5800 chip. All Adaptec host adapters (89xx series) use this
+  chip, as well as miro's DV boards.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called aic5800.o.
+
+OHCI (Open Host Controller Interface) support
+CONFIG_IEEE1394_OHCI1394
+  Say Y here if you have a IEEE 1394 controller based on OHCI.
+  The current driver was only tested with OHCI chipsets made
+  by Texas Instruments. However, most third-party vendors use
+  TI chips.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ohci1394.o.
+
+Raw IEEE 1394 I/O support
+CONFIG_IEEE1394_RAWIO
+  Say Y here if you want support for the raw device. This is generally
+  a good idea, so you should say Y here. The raw device enables
+  direct communication of user programs with the IEEE 1394 bus and
+  thus with the attached peripherals.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called raw1394.o.
+
+Excessive debugging output
+CONFIG_IEEE1394_VERBOSEDEBUG
+  If you say Y here, you will get very verbose debugging logs from the
+  subsystem which includes a dump of the header of every sent and
+  received packet.  This can amount to a high amount of data collected
+  in a very short time which is usually also saved to disk by the
+  system logging daemons.
+
+  Say Y if you really want or need the debugging output, everyone else
+  says N.
+
+Network device support?
+CONFIG_NETDEVICES
+  You can say N here if you don't intend to connect your Linux box to
+  any other computer at all or if all your connections will be over a
+  telephone line with a modem either via UUCP (UUCP is a protocol to
+  forward mail and news between unix hosts over telephone lines; read
+  the UUCP-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto ) or dialing up a shell
+  account or a BBS, even using term (term is a program which gives you
+  almost full Internet connectivity if you have a regular dial up
+  shell account on some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html ).
+
+  You'll have to say Y if your computer contains a network card that
+  you want to use under Linux (make sure you know its name because you
+  will be asked for it and read the Ethernet-HOWTO (especially if you
+  plan to use more than one network card under Linux)) or if you want
+  to use SLIP (Serial Line Internet Protocol is the protocol used to
+  send Internet traffic over telephone lines or null modem cables) or
+  CSLIP (compressed SLIP) or PPP (Point to Point Protocol, a better
+  and newer replacement for SLIP) or PLIP (Parallel Line Internet
+  Protocol is mainly used to create a mini network by connecting the
+  parallel ports of two local machines) or AX.25/KISS (protocol for
+  sending Internet traffic over amateur radio links).
+
+  Make sure to read the NET-3-HOWTO. Eventually, you will have to read
+  Olaf Kirch's excellent and free book "Network Administrator's
+  Guide", to be found in http://www.linuxdoc.org/docs.html#guide . If
+  unsure, say Y.
+
+Dummy net driver support
+CONFIG_DUMMY
+  This is essentially a bit-bucket device (i.e. traffic you send to
+  this device is consigned into oblivion) with a configurable IP
+  address. It is most commonly used in order to make your currently
+  inactive SLIP address seem like a real address for local programs.
+  If you use SLIP or PPP, you might want to say Y here. Since this
+  thing often comes in handy, the default is Y. It won't enlarge your
+  kernel either. What a deal. Read about it in the Network
+  Administrator's Guide, available from
+  http://www.linuxdoc.org/docs.html#guide .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called dummy.o. If you want to use more than one dummy device at a
+  time, you need to compile this driver as a module. Instead of
+  'dummy', the devices will then be called 'dummy0', 'dummy1' etc.
+
+Bonding driver support
+CONFIG_BONDING
+  Say 'Y' or 'M' if you wish to be able to 'bond' multiple Ethernet
+  Channels together. This is called 'Etherchannel' by Cisco,
+  'Trunking' by Sun, and 'Bonding' in Linux.
+
+  If you have two ethernet connections to some other computer, you can
+  make them behave like one double speed connection using this driver.
+  Naturally, this has to be supported at the other end as well, either
+  with a similar Bonding Linux driver, a Cisco 5500 switch or a
+  SunTrunking SunSoft driver.
+
+  This is similar to the EQL driver, but it merges Ethernet segments
+  instead of serial lines.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called bonding.o.
+
+SLIP (serial line) support
+CONFIG_SLIP
+  Say Y if you intend to use SLIP or CSLIP (compressed SLIP) to
+  connect to your Internet service provider or to connect to some
+  other local Unix box or if you want to configure your Linux box as a
+  Slip/CSlip server for other people to dial in. SLIP (Serial Line
+  Internet Protocol) is a protocol used to send Internet traffic over
+  serial connections such as telephone lines or null modem cables;
+  nowadays, the protocol PPP is more commonly used for this same
+  purpose.
+
+  Normally, your access provider has to support SLIP in order for you
+  to be able to use it, but there is now a SLIP emulator called SLiRP
+  around (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ) which
+  allows you to use SLIP over a regular dial up shell connection. If
+  you plan to use SLiRP, make sure to say Y to CSLIP, below. The
+  NET-3-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , explains how to
+  configure SLIP. Note that you don't need this option if you just
+  want to run term (term is a program which gives you almost full
+  Internet connectivity if you have a regular dial up shell account on
+  some Internet connected Unix computer. Read
+  http://www.bart.nl/~patrickr/term-howto/Term-HOWTO.html ). SLIP
+  support will enlarge your kernel by about 4 KB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  slip.o.
+
+CSLIP compressed headers
+CONFIG_SLIP_COMPRESSED
+  This protocol is faster than SLIP because it uses compression on the
+  TCP/IP headers (not on the data itself), but it has to be supported
+  on both ends. Ask your access provider if you are not sure and
+  answer Y, just in case. You will still be able to use plain SLIP. If
+  you plan to use SLiRP, the SLIP emulator (available from
+  ftp://metalab.unc.edu/pub/Linux/system/network/serial/ ) which
+  allows you to use SLIP over a regular dial up shell connection, you
+  definitely want to say Y here. The NET-3-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , explains how to configure
+  CSLIP. This won't enlarge your kernel.
+
+Keepalive and linefill
+CONFIG_SLIP_SMART
+  Adds additional capabilities to the SLIP driver to support the
+  RELCOM line fill and keepalive monitoring. Ideal on poor quality
+  analogue lines.
+
+Six bit SLIP encapsulation
+CONFIG_SLIP_MODE_SLIP6
+  Just occasionally you may need to run IP over hostile serial
+  networks that don't pass all control characters or are only seven
+  bit. Saying Y here adds an extra mode you can use with SLIP:
+  "slip6". In this mode, SLIP will only send normal ASCII symbols over
+  the serial device. Naturally, this has to be supported at the other
+  end of the link as well. It's good enough, for example, to run IP
+  over the async ports of a Camtec JNT Pad. If unsure, say N.
+
+PPP (point-to-point protocol) support
+CONFIG_PPP
+  PPP (Point to Point Protocol) is a newer and better SLIP. It serves
+  the same purpose: sending Internet traffic over telephone (and other
+  serial) lines. Ask your access provider if they support it, because
+  otherwise you can't use it; most internet access providers these
+  days support PPP rather than SLIP.
+
+  To use PPP, you need an additional program called pppd as described
+  in Documentation/networking/ppp.txt and in the PPP-HOWTO, available
+  at http://www.linuxdoc.org/docs.html#howto . If you upgrade
+  from an older kernel, you might need to upgrade pppd as well. The
+  PPP option enlarges your kernel by about 16 KB.
+
+  There are actually two versions of PPP: the traditional PPP for
+  asynchronous lines, such as regular analog phone lines, and
+  synchronous PPP which can be used over digital ISDN lines for
+  example. If you want to use PPP over phone lines or other
+  asynchronous serial lines, you need to say Y (or M) here and also to
+  the next option, "PPP support for async serial ports". For PPP over
+  synchronous lines, you should say Y (or M) here and to "Support
+  synchronous PPP", below.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you said Y to "Version information on all symbols" above, then
+  you cannot compile the PPP driver into the kernel; you can then only
+  compile it as a module. The module will be called ppp_generic.o. If
+  you want to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+PPP multilink support (EXPERIMENTAL)
+CONFIG_PPP_MULTILINK
+  PPP multilink is a protocol (defined in RFC 1990) which allows you
+  to combine several (logical or physical) lines into one logical PPP
+  connection, so that you can utilize your full bandwidth.
+
+  This has to be supported at the other end as well and you need a
+  version of the pppd daemon which understands the multilink protocol.
+
+  If unsure, say N.
+
+PPP support for async serial ports
+CONFIG_PPP_ASYNC
+  Say Y (or M) here if you want to be able to use PPP over standard
+  asynchronous serial ports, such as COM1 or COM2 on a PC.  If you use
+  a modem (not a synchronous or ISDN modem) to contact your ISP, you
+  need this option.
+
+  This code is also available as a module (code which can be inserted
+  into and removed from the running kernel).  If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+  If unsure, say Y.
+
+PPP support for sync tty ports
+CONFIG_PPP_SYNC_TTY
+  Say Y (or M) here if you want to be able to use PPP over synchronous
+  (HDLC) tty devices, such as the SyncLink adapter. These devices
+  are often used for high-speed leased lines like T1/E1.
+
+  This code is also available as a module (code which can be inserted
+  into and removed from the running kernel).  If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+PPP Deflate compression
+CONFIG_PPP_DEFLATE
+  Support for the Deflate compression method for PPP, which uses the
+  Deflate algorithm (the same algorithm that gzip uses) to compress
+  each PPP packet before it is sent over the wire. The machine at the
+  other end of the PPP link (usually your ISP) has to support the
+  Deflate compression method as well for this to be useful. Even if
+  they don't support it, it is safe to say Y here.
+
+  This code is also available as a module (code which can be inserted
+  into and removed from the running kernel).  If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+PPP BSD-Compress compression
+CONFIG_PPP_BSDCOMP
+  Support for the BSD-Compress compression method for PPP, which uses
+  the LZW compression method to compress each PPP packet before it is
+  sent over the wire. The machine at the other end of the PPP link
+  (usually your ISP) has to support the BSD-Compress compression
+  method as well for this to be useful. Even if they don't support it,
+  it is safe to say Y here.
+
+  The PPP Deflate compression method ("PPP Deflate compression",
+  above) is preferable to BSD-Compress, because it compresses better
+  and is patent-free.
+
+  Note that the BSD compression code will always be compiled as a
+  module; it is called bsd_comp.o and will show up in the directory
+  modules once you have said "make modules". If unsure, say N.
+
+PPP over Ethernet (EXPERIMENTAL)
+CONFIG_PPPOE
+  Support for PPP over Ethernet.
+
+  This driver requires a specially patched pppd daemon.  The patch to
+  pppd, along with binaries of a patched pppd package can be found at:
+  http://www.math.uwaterloo.ca/~mostrows
+ 
+Wireless LAN (non-hamradio)
+CONFIG_NET_RADIO
+  Support for wireless LANs and everything having to do with radio,
+  but not with amateur radio or FM broadcasting.
+
+  Saying Y here also enables the Wireless Extensions (creates
+  /proc/net/wireless and enables ifconfig access). The Wireless
+  Extension is a generic API allowing a driver to expose to the user
+  space configuration and statistics specific to common Wireless LANs.
+  The beauty of it is that a single set of tool can support all the
+  variations of Wireless LANs, regardless of their type (as long as
+  the driver supports Wireless Extension). Another advantage is that
+  these parameters may be changed on the fly without restarting the
+  driver (or Linux). If you wish to use Wireless Extensions with
+  wireless PCMCIA (PC-) cards, you need to say Y here; you can fetch
+  the tools from
+  http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html .
+
+  Some user-level drivers for scarab devices which don't require
+  special kernel support are available from
+  ftp://shadow.cabi.net/pub/Linux .
+
+STRIP (Metricom Starmode radio IP)
+CONFIG_STRIP
+  Say Y if you have a Metricom radio and intend to use Starmode Radio
+  IP. STRIP is a radio protocol developed for the MosquitoNet project
+  (on the WWW at http://mosquitonet.stanford.edu/ ) to send Internet
+  traffic using Metricom radios. Metricom radios are small, battery
+  powered, 100kbit/sec packet radio transceivers, about the size and
+  weight of a cellular telephone. (You may also have heard them called
+  "Metricom modems" but we avoid the term "modem" because it misleads
+  many people into thinking that you can plug a Metricom modem into a
+  phone line and use it as a modem.)
+
+  You can use STRIP on any Linux machine with a serial port, although
+  it is obviously most useful for people with laptop computers. If you
+  think you might get a Metricom radio in the future, there is no harm
+  in saying Y to STRIP now, except that it makes the kernel a bit
+  bigger. 
+
+  You can also compile this as a module ( = code which can be inserted
+  in and removed from the running kernel whenever you want), say M
+  here and read Documentation/modules.txt. The module will be called
+  strip.o.
+
+AT&T WaveLAN & DEC RoamAbout DS support
+CONFIG_WAVELAN
+  The Lucent WaveLAN (formerly NCR and AT&T; or DEC RoamAbout DS) is
+  a Radio LAN (wireless Ethernet-like Local Area Network) using the
+  radio frequencies 900 MHz and 2.4 GHz.
+  
+  This driver support the ISA version of the WaveLAN card. A separate
+  driver for the PCMCIA (PC-card) hardware is available in David
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for
+  location).
+
+  If you want to use an ISA WaveLAN card under Linux, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Some more specific
+  information is contained in Documentation/networking/wavelan.txt and
+  in the source code drivers/net/wavelan.p.h.
+
+  You will also need the wireless tools package available from
+  http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html .
+  Please read the man pages contained therein.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wavelan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Aironet Arlan 655 & IC2200 DS support
+CONFIG_ARLAN
+  Aironet makes Arlan, a class of wireless LAN adapters. These use the
+  www.Telxon.com chip, which is also used on several similar cards.
+  This driver is tested on the 655 and IC2200 series cards. Look at
+  http://www.ylenurme.ee/~elmer/655/ for the latest information.
+  
+  The driver is built as two modules, arlan and arlan-proc. The latter
+  is the /proc interface and is not needed most of time.
+  
+  On some computers the card ends up in non-valid state after some
+  time. Use a ping-reset script to clear it.
+
+Aironet 4500/4800 series adapters
+CONFIG_AIRONET4500
+  www.aironet.com (recently bought by Cisco) makes these 802.11 DS
+  adapters.  Driver by Elmer Joandi (elmer@ylenurme.ee).
+
+  Say Y here if you have such an adapter, and then say Y below to 
+  the option that applies to your particular type of card (PCI, ISA, 
+  or PCMCIA).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aironet4500_core.o. If you want to 
+  compile it as a module, say M here and read 
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+  quick config parameters: 
+	SSID=tsunami - "The Password"
+	adhoc=1  	there are no Access Points around
+	master=1 	Adhoc master (the one who creates network 
+                        sync)
+	slave=1		Adhoc slave (btw, it is still forming own net 
+			sometimes, and has problems with firmware...
+			change IbssJoinNetTimeout from /proc...)
+	channel=1..? 	meaningful in adhoc mode
+  
+  If you have problems with screwing up card, both_bap_lock=1 is a
+  conservative value (performance hit 15%).
+
+  All other parameters can be set via the proc interface.
+
+Aironet 4500/4800 ISA/PCI/PNP/365 support
+CONFIG_AIRONET4500_NONCS
+  If you have an ISA, PCI or PCMCIA Aironet 4500/4800 wireless LAN 
+  card, say Y here, and then also to the options below that apply 
+  to you.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aironet4500_card.o. If you want to 
+  compile it as a module, say M here and read 
+  Documentation/modules.txt
+
+Aironet 4500/4800 PNP support
+CONFIG_AIRONET4500_PNP
+  If you have an ISA Aironet 4500/4800 card which you want to use in 
+  PNP (Plug and Play) mode, say Y here. This is the recommended mode
+  for ISA cards. Remember however to enable the PNP jumper on the
+  board if you say Y here.
+
+Aironet 4500/4800 PCI support
+CONFIG_AIRONET4500_PCI
+  If you have an PCI Aironet 4500/4800 card, say Y here.
+
+Aironet 4500/4800 ISA broken support (EXPERIMENTAL)
+CONFIG_AIRONET4500_ISA
+  If you have an ISA Aironet 4500/4800 card which you want to run in
+  non-PNP mode, say Y here. This is not recommended and does not work
+  correctly at this point. Say N.
+
+Aironet 4500/4800 I365 broken support (EXPERIMENTAL)
+CONFIG_AIRONET4500_I365
+  If you have a PCMCIA Aironet 4500/4800 card which you want to use 
+  without the standard PCMCIA cardservices provided by the pcmcia-cs 
+  package, say Y here. This is not recommended, so say N.
+
+Aironet 4500/4800 PCMCIA support
+CONFIG_AIRONET4500_CS
+  Say Y here if you have a PCMCIA Aironet 4500/4800 card which you 
+  want to use with the standard PCMCIA cardservices provided by the
+  pcmcia-cs package.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aironet4500_cs.o. If you want to 
+  compile it as a module, say M here and read 
+  Documentation/modules.txt.
+	
+Aironet 4500/4800 PROC interface
+CONFIG_AIRONET4500_PROC
+  If you say Y here (and to the "/proc file system" below), you will 
+  be able to configure your Aironet card via the 
+  /proc/sys/aironet4500 interface.
+
+  Additional info: look in drivers/net/aironet4500_rids.c.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aironet4500_proc.o. If you want to 
+  compile it as a module, say M here and read 
+  Documentation/modules.txt.
+
+  NOTE: the proc interface uses a lot of memory, so it is recommended
+        to compile it as a module and remove the module after 
+        configuration.
+
+LAPB over Ethernet driver
+CONFIG_LAPBETHER
+  This is a driver for a pseudo device (typically called /dev/lapb0)
+  which allows you to open an LAPB point-to-point connection to some
+  other computer on your Ethernet network. In order to do this, you
+  need to say Y or M to the driver for your Ethernet card as well as
+  to "LAPB Data Link Driver". 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called lapbether.o. If unsure, say N.
+
+X.25 async driver
+CONFIG_X25_ASY
+  This is a driver for sending and receiving X.25 frames over regular
+  asynchronous serial lines such as telephone lines equipped with
+  ordinary modems. Experts should note that this driver doesn't
+  currently comply with the asynchronous HDLS framing protocols in
+  CCITT recommendation X.25. 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called x25_asy.o. If unsure, say N.
+
+PCMCIA network device support
+CONFIG_NET_PCMCIA
+  Say Y if you would like to include support for any PCMCIA or CardBus
+  network adapters, then say Y to the driver for your particular card
+  below. PCMCIA- or PC-cards are credit-card size devices often used
+  with laptops computers; CardBus is the newer and faster version of
+  PCMCIA. 
+
+  To use your PC-cards, you will need supporting software from David
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for
+  location). You also want to check out the PCMCIA-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  If unsure, say N.
+
+3Com 3c589 PCMCIA support
+CONFIG_PCMCIA_3C589
+  Say Y here if you intend to attach a 3Com 3c589 or compatible PCMCIA
+  (PC-card) Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c589_cs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+3Com 3c574 PCMCIA support
+CONFIG_PCMCIA_3C574
+  Say Y here if you intend to attach a 3Com 3c574 or compatible PCMCIA
+  (PC-card) Fast Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c574_cs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Fujitsu FMV-J18x PCMCIA support
+CONFIG_PCMCIA_FMVJ18X
+  Say Y here if you intend to attach a Fujitsu FMV-J18x or compatible
+  PCMCIA (PC-card) Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fmvj18x_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+NE2000 compatible PCMCIA support
+CONFIG_PCMCIA_PCNET
+  Say Y here if you intend to attach an NE2000 compatible PCMCIA
+  (PC-card) Ethernet or Fast Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pcnet_cs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+New Media PCMCIA support
+CONFIG_PCMCIA_NMCLAN
+  Say Y here if you intend to attach a New Media Ethernet or LiveWire
+  PCMCIA (PC-card) Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called nmclan_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+SMC 91Cxx PCMCIA support
+CONFIG_PCMCIA_SMC91C92
+  Say Y here if you intend to attach an SMC 91Cxx compatible PCMCIA
+  (PC-card) Ethernet or Fast Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc91c92_cs.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. If
+  unsure, say N.
+
+Xircom 16-bit PCMCIA support
+CONFIG_PCMCIA_XIRC2PS
+  Say Y here if you intend to attach a Xircom 16-bit PCMCIA
+  (PC-card) Ethernet or Fast Ethernet card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called xirc2ps_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+COM20020 ARCnet PCMCIA support
+CONFIG_ARCNET_COM20020_CS
+  Say Y here if you intend to attach this type of ARCnet PCMCIA card
+  to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com20020_cs.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt. If
+  unsure, say N.
+
+IBM PCMCIA Token Ring adapter support
+CONFIG_PCMCIA_IBMTR
+  Say Y here if you intend to attach this type of Token Ring PCMCIA
+  card to your computer. You then also need to say Y to "Token Ring
+  driver support". 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmtr_cs.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Xircom Tulip-like CardBus support
+CONFIG_PCMCIA_XIRTULIP
+  This driver is for the Digital "Tulip" Ethernet CardBus adapters.
+  It should work with most DEC 21*4*-based chips/ethercards, as well
+  as with work-alike chips from Lite-On (PNIC) and Macronix (MXIC) and
+  ASIX.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called xircom_tulip_cb.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. If
+  unsure, say N.
+
+Pcmcia Wireless LAN
+CONFIG_NET_PCMCIA_RADIO
+  Say Y here if you would like to use a PCMCIA (PC-card) device to
+  connect to a wireless local area network. Then say Y to the driver
+  for your particular card below.
+
+  To use your PC-cards, you will need supporting software from David
+  Hinds' pcmcia-cs package (see the file Documentation/Changes for
+  location). You also want to check out the PCMCIA-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+Aviator/Raytheon 2.4MHz wireless support
+CONFIG_PCMCIA_RAYCS
+  Say Y here if you intend to attach an Aviator/Raytheon PCMCIA
+  (PC-card) wireless Ethernet networking card to your computer.
+  Please read the file Documentation/networking/ray_cs.txt for
+  details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ray_cs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Xircom Netwave AirSurfer wireless support
+CONFIG_PCMCIA_NETWAVE
+  Say Y here if you intend to attach this type of PCMCIA (PC-card)
+  wireless Ethernet networking card to your computer.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called netwave_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+AT&T/Lucent Wavelan wireless support
+CONFIG_PCMCIA_WAVELAN
+  Say Y here if you intend to attach an AT&T/Lucent Wavelan PCMCIA
+  (PC-card) wireless Ethernet networking card to your computer.  This
+  driver is for the non-IEEE-802.11 Wavelan cards.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wavelan_cs.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+PLIP (parallel port) support
+CONFIG_PLIP
+  PLIP (Parallel Line Internet Protocol) is used to create a
+  reasonably fast mini network consisting of two (or, rarely, more)
+  local machines. A PLIP link from a Linux box is a popular means to
+  install a Linux distribution on a machine which doesn't have a CDROM
+  drive (a minimal system has to be transferred with floppies first).
+  The kernels on both machines need to have this PLIP option enabled
+  for this to work.
+
+  The PLIP driver has two modes, mode 0 and mode 1. The parallel ports
+  (the connectors at the computers with 25 holes) are connected with
+  "null printer" or "Turbo Laplink" cables which can transmit 4 bits
+  at a time (mode 0) or with special PLIP cables, to be used on
+  bidirectional parallel ports only, which can transmit 8 bits at a
+  time (mode 1); you can find the wiring of these cables in
+  Documentation/networking/PLIP.txt. The cables can be up to 15m long.
+  Mode 0 works also if one of the machines runs DOS/Windows and has
+  some PLIP software installed, e.g. the Crynwr PLIP packet driver
+  (http://oak.oakland.edu/simtel.net/msdos/pktdrvr-pre.html ) and
+  winsock or NCSA's telnet.
+
+  If you want to use PLIP, say Y and read the PLIP mini-HOWTO as well
+  as the NET-3-HOWTO, both available from
+  http://www.linuxdoc.org/docs.html#howto . Note that the PLIP
+  protocol has been changed and this PLIP driver won't work together
+  with the PLIP support in Linux versions 1.0.x. This option enlarges
+  your kernel by about 8 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  plip.o. If unsure, say Y or M, in case you buy a laptop later.
+
+EQL (serial line load balancing) support
+CONFIG_EQUALIZER
+  If you have two serial connections to some other computer (this
+  usually requires two modems and two telephone lines) and you use
+  SLIP (the protocol for sending Internet traffic over telephone
+  lines) or PPP (a better SLIP) on them, you can make them behave like
+  one double speed connection using this driver. Naturally, this has
+  to be supported at the other end as well, either with a similar EQL
+  Linux driver or with a Livingston Portmaster 2e. 
+
+  Say Y if you want this and read Documentation/networking/eql.txt.
+  You may also want to read section 6.2 of the NET-3-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eql.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Universal TUN/TAP device driver.
+CONFIG_TUN
+  TUN/TAP provides packet reception and transmission for user space programs.
+  It can be viewed as a simple Point-to-Point or Ethernet device, which
+  instead of receiving packets from a physical media, receives them from
+  user space program and instead of sending packets via physical media
+  writes them to the user space program.
+
+  When a program opens /dev/net/tun, driver creates and registers 
+  corresponding net device tunX or tapX. After a program closed above 
+  devices, driver will automatically delete tunXX or tapXX device and all 
+  routes corresponding to it.
+
+  Please read Documentation/networking/tuntap.txt for more information.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tun.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If you don't know what to use this for, you don't need it.
+
+Ethertap network tap (OBSOLETE)
+CONFIG_ETHERTAP
+  If you say Y here (and have said Y to "Kernel/User network link
+  driver", above) and create a character special file /dev/tap0 with
+  major number 36 and minor number 16 using mknod ("man mknod"), you
+  will be able to have a user space program read and write raw
+  Ethernet frames from/to that special file. tap0 can be configured
+  with ifconfig and route like any other Ethernet device but it is not
+  connected to any physical LAN; everything written by the user to
+  /dev/tap0 is treated by the kernel as if it had come in from a LAN
+  to the device tap0; everything the kernel wants to send out over the
+  device tap0 can instead be read by the user from /dev/tap0: the user
+  mode program replaces the LAN that would be attached to an ordinary
+  Ethernet device. Please read the file
+  Documentation/networking/ethertap.txt for more information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ethertap.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. 
+
+  If you don't know what to use this for, you don't need it.
+
+Sealevel Systems 4021 support
+CONFIG_SEALEVEL_4021
+  This is a driver for the Sealevel Systems ACB 56 serial I/O adapter.
+  
+  This driver can only be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to do that, say M here. The module will be called
+  sealevel.o.
+
+SyncLink HDLC/SYNCPPP support
+CONFIG_SYNCLINK_SYNCPPP
+  Enables HDLC/SYNCPPP support for the SyncLink WAN driver.
+  Normally the SyncLink WAN driver works with the main PPP
+  driver (ppp.c) and pppd program. HDLC/SYNCPPP support allows use
+  of the Cisco HDLC/PPP driver (syncppp.c).
+  The SyncLink WAN driver (in character devices) must also be enabled.
+
+Frame Relay (DLCI) support
+CONFIG_DLCI
+  This is support for the frame relay protocol; frame relay is a fast
+  low-cost way to connect to a remote Internet access provider or to
+  form a private wide area network. The one physical line from your
+  box to the local "switch" (i.e. the entry point to the frame relay
+  network, usually at the phone company) can carry several logical
+  point-to-point connections to other computers connected to the frame
+  relay network. For a general explanation of the protocol, check out
+  http://www.frforum.com/ on the WWW. To use frame relay, you need
+  supporting hardware (called FRAD) and certain programs from the
+  net-tools package as explained in
+  Documentation/networking/framerelay.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dlci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Max open DLCI
+CONFIG_DLCI_COUNT
+  This is the maximal number of logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) that
+  the driver can handle. The default is probably fine.
+
+Max DLCI per device
+CONFIG_DLCI_MAX
+  You can specify here how many logical point-to-point frame relay
+  connections (the identifiers of which are called DCLIs) should be
+  handled by each of your hardware frame relay access devices. Go with
+  the default.
+
+Sangoma S502A FRAD support
+CONFIG_SDLA
+  Say Y here if you need a driver for the Sangoma S502A, S502E, and
+  S508 Frame Relay Access Devices. These are multi-protocol cards, but
+  only frame relay is supported by the driver at this time. Please
+  read Documentation/framerelay.txt. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sdla.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Acorn Econet/AUN protocols (EXPERIMENTAL)
+CONFIG_ECONET
+  Econet is a fairly old and slow networking protocol mainly used by
+  Acorn computers to access file and print servers. It uses native
+  Econet network cards. AUN is an implementation of the higher level
+  parts of Econet that runs over ordinary Ethernet connections, on
+  top of the UDP packet protocol, which in turn runs on top of the
+  Internet protocol IP.
+
+  If you say Y here, you can choose with the next two options whether
+  to send Econet/AUN traffic over a UDP Ethernet connection or over
+  a native Econet network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called econet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+AUN over UDP
+CONFIG_ECONET_AUNUDP
+  Say Y here if you want to send Econet/AUN traffic over a UDP
+  connection (UDP is a packet based protocol that runs on top of the
+  Internet protocol IP) using an ordinary Ethernet network card.
+
+Native Econet
+CONFIG_ECONET_NATIVE
+  Say Y here if you have a native Econet network card installed in
+  your computer.
+
+WAN Router
+CONFIG_WAN_ROUTER
+  Wide Area Networks (WANs), such as X.25, frame relay and leased
+  lines, are used to interconnect Local Area Networks (LANs) over vast
+  distances with data transfer rates significantly higher than those
+  achievable with commonly used asynchronous modem connections.
+  Usually, a quite expensive external device called a `WAN router' is
+  needed to connect to a WAN.
+
+  As an alternative, WAN routing can be built into the Linux kernel.
+  With relatively inexpensive WAN interface cards available on the
+  market, a perfectly usable router can be built for less than half
+  the price of an external router. If you have one of those cards and
+  wish to use your Linux box as a WAN router, say Y here and also to
+  the WAN driver for your card, below. You will then need the
+  wan-tools package which is available from ftp://ftp.sangoma.com .
+  Read Documentation/networking/wan-router.txt for more information.
+
+  The WAN routing support is also available as a module called
+  wanrouter.o ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Fast switching (read help!)
+CONFIG_NET_FASTROUTE
+  Saying Y here enables direct NIC-to-NIC (NIC = Network Interface
+  Card) data transfers on the local network, which is fast.
+
+  IMPORTANT NOTE: This option is NOT COMPATIBLE with "Network packet
+  filtering" (CONFIG_NETFILTER). Say N here if you say Y there.
+
+  However, it will work with all options in the "IP: advanced router"
+  section (except for "IP: use TOS value as routing key" and
+  "IP: use FWMARK value as routing key").
+
+  At the moment, few devices support fast switching (tulip is one of
+  them, a modified 8390 driver can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz ).
+
+  If unsure, say N.
+
+Forwarding between high speed interfaces
+CONFIG_NET_HW_FLOWCONTROL
+  This option enables NIC (Network Interface Card) hardware throttling
+  during periods of extremal congestion. At the moment only a couple
+  of device drivers support it (really only one -- tulip, a modified
+  8390 driver can be found at
+  ftp://ftp.inr.ac.ru/ip-routing/fastroute/fastroute-8390.tar.gz ). 
+
+  Really, this option is applicable to any machine attached to a fast
+  enough network, and even a 10 Mb NIC is able to kill a not very slow
+  box, such as a 120MHz Pentium.
+
+  However, do not say Y here if you did not experience any serious
+  problems.
+
+QoS and/or fair queueing
+CONFIG_NET_SCHED
+  When the kernel has several packets to send out over a network
+  device, it has to decide which ones to send first, which ones to
+  delay, and which ones to drop. This is the job of the packet
+  scheduler, and several different algorithms for how to do this
+  "fairly" have been proposed.
+
+  If you say N here, you will get the standard packet scheduler, which
+  is a FIFO (first come, first served). If you say Y here, you will be
+  able to choose from among several alternative algorithms which can
+  then be attached to different network devices. This is useful for
+  example if some of your network devices are real time devices that
+  need a certain minimum data flow rate, or if you need to limit the
+  maximum data flow rate for traffic which matches specified criteria.
+  This code is considered to be experimental.
+
+  To administer these schedulers, you'll need the user-level utilities
+  from the package iproute2+tc at ftp://ftp.inr.ac.ru/ip-routing/ .
+  That package also contains some documentation; for more, check out
+  http://snafu.freedom.org/linux2.2/iproute-notes.html .
+
+  This Quality of Service (QoS) support will enable you to use
+  Differentiated Services (diffserv) and Resource Reservation Protocol
+  (RSVP) on your Linux router if you also say Y to "QoS support",
+  "Packet classifier API" and to some classifiers below. Documentation
+  and software is at http://icawww1.epfl.ch/linux-diffserv/ .
+
+  If you say Y here and to "/proc file system" below, you will be able
+  to read status information about packet schedulers from the file
+  /proc/net/psched.
+  
+  The available schedulers are listed in the following questions; you
+  can say Y to as many as you like. If unsure, say N now.
+
+CBQ packet scheduler
+CONFIG_NET_SCH_CBQ
+  Say Y here if you want to use the Class-Based Queueing (CBQ) packet
+  scheduling algorithm for some of your network devices. This
+  algorithm classifies the waiting packets into a tree-like hierarchy
+  of classes; the leaves of this tree are in turn scheduled by
+  separate algorithms (called "disciplines" in this context).
+
+  See the top of net/sched/sch_cbq.c for references about the CBQ
+  algorithm.
+  
+  CBQ is a commonly used scheduler, so if you're unsure, you should
+  say Y here. Then say Y to all the queueing algorithms below that you
+  want to use as CBQ disciplines. Then say Y to "Packet classifier
+  API" and say Y to all the classifiers you want to use; a classifier
+  is a routine that allows you to sort your outgoing traffic into
+  classes based on a certain criterion.
+
+  This code is also available as a module called sch_cbq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+CSZ packet scheduler
+CONFIG_NET_SCH_CSZ
+  Say Y here if you want to use the Clark-Shenker-Zhang (CSZ) packet
+  scheduling algorithm for some of your network devices. At the
+  moment, this is the only algorithm that can guarantee service for
+  real-time applications (see the top of net/sched/sch_csz.c for
+  details and references about the algorithm). 
+  
+  Note: this scheduler is currently broken.
+
+  This code is also available as a module called sch_csz.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+#ATM pseudo-scheduler
+#CONFIG_NET_SCH_ATM
+#
+# ???
+#
+  
+The simplest PRIO pseudo scheduler
+CONFIG_NET_SCH_PRIO
+  Say Y here if you want to use an n-band priority queue packet
+  "scheduler" for some of your network devices or as a leaf discipline
+  for the CBQ scheduling algorithm. If unsure, say Y.
+
+  This code is also available as a module called sch_prio.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+RED queue
+CONFIG_NET_SCH_RED
+  Say Y here if you want to use the Random Early Detection (RED)
+  packet scheduling algorithm for some of your network devices (see
+  the top of net/sched/sch_red.c for details and references about the
+  algorithm).
+
+  This code is also available as a module called sch_red.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SFQ queue
+CONFIG_NET_SCH_SFQ
+  Say Y here if you want to use the Stochastic Fairness Queueing (SFQ)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_sfq.c for details and references about the SFQ
+  algorithm). 
+
+  This code is also available as a module called sch_sfq.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TEQL queue
+CONFIG_NET_SCH_TEQL
+  Say Y here if you want to use the True Link Equalizer (TLE) packet
+  scheduling algorithm for some of your network devices or as a leaf
+  discipline for the CBQ scheduling algorithm. This queueing
+  discipline allows the combination of several physical devices into
+  one virtual device. (see the top of net/sched/sch_teql.c for
+  details).
+
+  This code is also available as a module called sch_teql.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+TBF queue
+CONFIG_NET_SCH_TBF
+  Say Y here if you want to use the Simple Token Bucket Filter (TBF)
+  packet scheduling algorithm for some of your network devices or as a
+  leaf discipline for the CBQ scheduling algorithm (see the top of
+  net/sched/sch_tbf.c for a description of the TBF algorithm). 
+
+  This code is also available as a module called sch_tbf.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+### Add these
+#+tristate '  GRED queue' CONFIG_NET_SCH_GRED
+#+tristate '  Diffserv field marker' CONFIG_NET_SCH_DSMARK
+#+tristate '  Ingress Qdisc' CONFIG_NET_SCH_INGRESS
+
+QoS support
+CONFIG_NET_QOS
+  Say Y here if you want to include Quality Of Service scheduling
+  features, which means that you will be able to request certain
+  rate-of-flow limits for your network devices.
+
+  This Quality of Service (QoS) support will enable you to use
+  Differentiated Services (diffserv) and Resource Reservation Protocol
+  (RSVP) on your Linux router if you also say Y to "Packet classifier
+  API" and to some classifiers below. Documentation and software is at
+  http://icawww1.epfl.ch/linux-diffserv/ .
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about QoS support.
+
+Rate estimator
+CONFIG_NET_ESTIMATOR
+  In order for Quality of Service scheduling to work, the current
+  rate-of-flow for a network device has to be estimated; if you say Y
+  here, the kernel will do just that.
+
+Packet classifier API
+CONFIG_NET_CLS
+  The CBQ scheduling algorithm requires that network packets which are
+  scheduled to be sent out over a network device be classified
+  according to some criterion. If you say Y here, you will get a
+  choice of several different packet classifiers with the following
+  questions.
+
+  This will enable you to use Differentiated Services (diffserv) and
+  Resource Reservation Protocol (RSVP) on your Linux router.
+  Documentation and software is at
+  http://icawww1.epfl.ch/linux-diffserv/ .
+
+### Add
+#tristate '    TC index classifier' CONFIG_NET_CLS_TCINDEX
+
+Routing tables based classifier
+CONFIG_NET_CLS_ROUTE4
+  If you say Y here, you will be able to classify outgoing packets
+  according to the route table entry they matched. If unsure, say Y.
+
+  This code is also available as a module called cls_route.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Firewall based classifier
+CONFIG_NET_CLS_FW
+  If you say Y here, you will be able to classify outgoing packets
+  according to firewall criteria you specified.
+
+  This code is also available as a module called cls_fw.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+U32 classifier
+CONFIG_NET_CLS_U32
+  If you say Y here, you will be able to classify outgoing packets
+  according to their destination address. If unsure, say Y.
+
+  This code is also available as a module called cls_u32.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt
+
+Special RSVP classifier
+CONFIG_NET_CLS_RSVP
+  The Resource Reservation Protocol (RSVP) permits end systems to
+  request a minimum and maximum data flow rate for a connection; this
+  is important for real time data such as streaming sound or video.
+
+  Say Y here if you want to be able to classify outgoing packets based
+  on their RSVP requests.
+
+  This code is also available as a module called cls_rsvp.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt
+
+Special RSVP classifier for IPv6
+CONFIG_NET_CLS_RSVP6
+  The Resource Reservation Protocol (RSVP) permits end systems to
+  request a minimum and maximum data flow rate for a connection; this
+  is important for real time data such as streaming sound or video.
+
+  Say Y here if you want to be able to classify outgoing packets based
+  on their RSVP requests and you are using the new Internet Protocol
+  IPv6 as opposed to the older and more common IPv4.
+
+  This code is also available as a module called cls_rsvp6.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt
+
+#
+# Traffic policing (needed for in/egress)
+# CONFIG_NET_CLS_POLICE
+###
+### Some expert please fill these in
+###
+
+Network code profiler
+CONFIG_NET_PROFILE
+  If you say Y here and to "/proc file system support" below, some
+  obscure and undocumented information about the network code's
+  performance will be written to /proc/net/profile. If you don't know
+  what it is about, you don't need it: say N.
+
+Wan interfaces support
+CONFIG_WAN
+  Wide Area Networks (WANs), such as X.25, frame relay and leased
+  lines, are used to interconnect Local Area Networks (LANs) over vast
+  distances with data transfer rates significantly higher than those
+  achievable with commonly used asynchronous modem connections.
+  Usually, a quite expensive external device called a `WAN router' is
+  needed to connect to a WAN.
+
+  As an alternative, a relatively inexpensive WAN interface card can
+  allow your Linux box to directly connect to a WAN. If you have one
+  of those cards and wish to use it under Linux, say Y here and also
+  to the WAN driver for your card, below.
+
+  If unsure, say N.
+
+Comtrol Hostess SV-11 support
+CONFIG_HOSTESS_SV11
+  This is a network card for low speed synchronous serial links, at
+  up to 256Kbps. It supports both PPP and Cisco HDLC.
+  
+  At this point, the driver can only be compiled as a module.
+
+COSA/SRP sync serial boards support
+CONFIG_COSA
+  This is a driver for COSA and SRP synchronous serial boards. These
+  boards allow to connect synchronous serial devices (for example
+  base-band modems, or any other device with the X.21, V.24, V.35 or
+  V.36 interface) to your Linux box. The cards can work as the
+  character device, synchronous PPP network device, or the Cisco HDLC
+  network device.
+
+  To actually use the COSA or SRP board, you will need user-space
+  utilities for downloading the firmware to the cards and to set them
+  up. Look at the http://www.fi.muni.cz/~kas/cosa/ for more
+  information about the cards (including the pointer to the user-space
+  utilities). You can also read the comment at the top of the
+  drivers/net/cosa.c for details about the cards and the driver
+  itself.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cosa.o. For general information about
+  modules read Documentation/modules.txt.
+
+Lan Media sync serial boards support
+CONFIG_LANMEDIA
+  This is a driver for the following Lan Media family of serial boards.
+ 
+  LMC 1000 board allows you to connect synchronous serial devices (for
+  example base-band modems, or any other device with the X.21, V.24,
+  V.35 or V.36 interface) to your Linux box.
+ 
+  LMC 1200 with on board DSU board allows you to connect your Linux
+  box dirrectly to a T1 or E1 circuit.
+ 
+  LMC 5200 board provides a HSSI interface capable of runnig up to
+  52 mbits per second.
+ 
+  LMC 5245 board connects directly to a T3 circuit saving the
+  additional external hardware.
+ 
+  To change setting such as syncPPP vs cisco HDLC or clock source you
+  will need lmcctl.  It it available at ftp.lanmedia.com.
+ 
+  This code is also available as a module called lmc.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Fibre Channel driver support
+CONFIG_NET_FC
+  Fibre Channel is a high speed serial protocol mainly used to connect
+  large storage devices to the computer; it is compatible with and
+  intended to replace SCSI. 
+
+  If you intend to use Fibre Channel, you need to have a Fibre channel
+  adaptor card in your computer; say Y here and to the driver for your
+  adaptor below. You also should have said Y to "SCSI support" and
+  "SCSI generic support".
+
+Interphase 5526 Tachyon chipset based adaptor support
+CONFIG_IPHASE5526
+  Say Y here if you have a Fibre Channel adaptor of this kind.
+
+  The driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called iph5526.o. For general information about
+  modules read Documentation/modules.txt.
+  
+Red Creek Hardware VPN (EXPERIMENTAL)
+CONFIG_RCPCI
+  This is a driver for hardware which provides a Virtual Private
+  Network (VPN). Say Y if you have it.
+
+  This code is also available as a module called rcpci.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+  
+SBNI12-xx support
+CONFIG_SBNI
+  This is a driver for ISA SBNI12-xx cards which are low cost
+  alternatives to leased line modems. Say Y if you want to insert
+  the driver into the kernel or say M to compile it as a module (the
+  module will be called sbni.o). 
+  
+  You can find more information and last versions of drivers and 
+  utilities at http://www.granch.ru . If you have any question you
+  can send email to sbni@granch.ru.
+  
+  Say N if unsure.
+
+WAN router drivers
+CONFIG_WAN_ROUTER_DRIVERS
+  If you have a WAN interface card and you want your Linux box to act
+  as a WAN router, thereby connecting you Local Area Network to the
+  outside world over the WAN connection, say Y here and then to the
+  driver for your card below. In addition, you need to say Y to "Wan
+  Router".
+
+  You will need the wan-tools package which is available from
+  ftp://ftp.sangoma.com . Read Documentation/networking/wan-router.txt
+  for more information.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about WAN router drivers. If unsure, say N.
+
+Sangoma WANPIPE(tm) multiprotocol cards
+CONFIG_VENDOR_SANGOMA
+  WANPIPE from Sangoma Technologies Inc. (http://www.sangoma.com ) is
+  a family of intelligent multiprotocol WAN adapters with data
+  transfer rates up to T1 (1.544 Mbps). They are also known as
+  Synchronous Data Link Adapters (SDLA) and designated S502E(A), S503
+  or S508. These cards support the X.25, Frame Relay, and PPP
+  protocols. If you have one or more of these cards, say Y to this
+  option; you may then also want to read the file
+  Documentation/networking/wanpipe.txt. The next questions will ask
+  you about the protocols you want the driver to support.
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wanpipe.o. For general information about
+  modules read Documentation/modules.txt.
+
+Maximum number of cards
+CONFIG_WANPIPE_CARDS
+  Enter number of WANPIPE adapters installed in your machine. The
+  driver can support up to 8 cards. You may enter more than you
+  actually have if you plan to add more cards in the future without
+  re-compiling the driver, but remember that in this case you'll waste
+  some kernel memory (about 1K per card).
+
+WANPIPE Cisco HDLC support
+CONFIG_WANPIPE_CHDLC
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a connection which uses the synchronous Cisco HDLC (High-level
+  Data Link Control) protocol. This protocol is often used on
+  high-speed leased lines like T1/E1.
+
+WANPIPE X.25 support
+CONFIG_WANPIPE_X25
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to an X.25 network. You should then also have said Y to "CCITT X.25
+  Packet Layer" and "LAPB Data Link Driver", above. If you say N, the
+  X.25 support will not be included in the driver (saves about 16 KB
+  of kernel memory).
+
+WANPIPE Frame Relay support
+CONFIG_WANPIPE_FR
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a frame relay network. You should then also have said Y to "Frame
+  Relay (DLCI) support", above. If you say N, the frame relay
+  support will not be included in the driver (saves about 16 KB of
+  kernel memory).
+
+WANPIPE PPP support
+CONFIG_WANPIPE_PPP
+  Say Y to this option if you are planning to connect a WANPIPE card
+  to a leased line using Point-to-Point protocol (PPP). You should
+  then also have said Y to "PPP (point-to-point) support", above. If
+  you say N, the PPP support will not be included in the driver (saves
+  about 16 KB of kernel memory).
+
+MultiGate/COMX support
+CONFIG_COMX
+  Say Y if you want to use any board from the MultiGate (COMX) family.
+  These boards are synchronous serial adapters for the PC,
+  manufactured by ITConsult-Pro Co, Hungary.
+
+  Read linux/Documentation/networking/comx.txt for help on configuring
+  and using COMX interfaces. Further info on these cards can be found
+  at http://www.itc.hu or <info@itc.hu>.
+
+  You must say Y to "/proc file system support" (CONFIG_PROC_FS) to
+  use this driver.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx.o.
+
+COMX/CMX/HiCOMX board support
+CONFIG_COMX_HW_COMX
+  Hardware driver for the 'CMX', 'COMX' and 'HiCOMX' boards from the
+  MultiGate family. Say Y if you have one of these. 
+
+  You will need additional firmware to use these cards, which are
+  downloadable from ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called comx-hw-comx.o.
+
+LoCOMX board support
+CONFIG_COMX_HW_LOCOMX
+  Hardware driver for the 'LoCOMX' board from the MultiGate family.
+  Say Y if you have a board like this.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called
+  comx-hw-locomx.o.
+
+MixCOM board support
+CONFIG_COMX_HW_MIXCOM
+  Hardware driver for the 'MixCOM' board from the MultiGate family.
+  Say Y if you have a board like this.
+
+  If you want to use the watchdog device on this card, you should
+  select it in the Watchdog Cards section of the Character Devices
+  configuration. The ISDN interface of this card is Teles 16.3
+  compatible, you should enable it in the ISDN configuration menu. The
+  driver for the flash ROM of this card is available separately on
+  ftp://ftp.itc.hu/.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called
+  comx-hw-mixcom.o.
+
+i810 TCO support
+CONFIG_I810_TCO
+  Hardware driver for the TCO timer built into the Intel i810 and i815
+  chipset family. The TCO (Total Cost of Ownership) timer is a watchdog
+  timer that will reboot the machine after it's second expiration. The
+  expiration time can be configured by commandline argument
+  "i810_margin=<n>" where <n> is the counter initial value. It is
+  decremented every 0.6 secs, the default is 50 which gives a timeout
+  of 30 seconds and one minute until reset.
+
+  On some motherboards the driver may fail to reset the chipset's
+  NO_REBOOT flag which prevents the watchdog from rebooting the machine.
+  If this is the case you will get a kernel message like
+  "i810tco init: failed to reset NO_REBOOT flag".
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called
+  i810-tco.o.
+  
+MultiGate Cisco-HDLC and synchronous PPP protocol support
+CONFIG_COMX_PROTO_PPP
+  Cisco-HDLC and synchronous PPP protocol driver for all MultiGate
+  boards. Say Y if you want to use either protocol on your MultiGate
+  boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called 
+  comx-proto-ppp.o.
+
+MultiGate LAPB protocol support
+CONFIG_COMX_PROTO_LAPB
+  LAPB protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called
+  comx-proto-lapb.o.
+
+MultiGate Frame Relay protocol support
+CONFIG_COMX_PROTO_FR
+  Frame Relay protocol driver for all MultiGate boards. Say Y if you 
+  want to use this protocol on your MultiGate boards.
+
+  If you want to compile this as a module, say M and read
+  Documentation/modules.txt. The module will be called
+  comx-proto-fr.o.
+
+Cyclom 2X(tm) multiprotocol cards (EXPERIMENTAL)
+CONFIG_CYCLADES_SYNC
+  Cyclom 2X from Cyclades Corporation (http://www.cyclades.com and
+  http://www.cyclades.com.br) is an intelligent multiprotocol WAN
+  adapter with data transfer rates up to 512 Kbps. These cards support
+  the X.25 and SNA related protocols. If you have one or more of these
+  cards, say Y to this option. The next questions will ask you about
+  the protocols you want the driver to support (for now only X.25 is
+  supported).
+
+  While no documentation is available at this time please grab the
+  wanconfig tarball in http://www.conectiva.com.br/~acme/cycsyn-devel
+  (with minor changes to make it compile with the current wanrouter
+  include files; efforts are being made to use the original package
+  available at ftp://ftp.sangoma.com ).
+
+  Feel free to contact me or the cycsyn-devel mailing list at
+  acme@conectiva.com.br and cycsyn-devel@bazar.conectiva.com.br for
+  additional details, I hope to have documentation available as soon
+  as possible. (Cyclades Brazil is writing the Documentation).
+
+  The driver will be compiled as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cyclomx.o. For general information about
+  modules read Documentation/modules.txt.
+
+Cyclom 2X X.25 support
+CONFIG_CYCLOMX_X25
+  Say Y to this option if you are planning to connect a Cyclom 2X card
+  to an X.25 network. 
+
+  If you say N, the X.25 support will not be included in the driver
+  (saves about 11 KB of kernel memory).
+
+Ethernet (10 or 100Mbit)
+CONFIG_NET_ETHERNET
+  Ethernet (also called IEEE 802.3 or ISO 8802-2) is the most common
+  type of Local Area Network (LAN) in universities and companies.
+
+  Common varieties of Ethernet are: 10BASE-2 or Thinnet (10 Mbps over
+  coaxial cable, linking computers in a chain), 10BASE-T or twisted
+  pair (10 Mbps over twisted pair cable, linking computers to central
+  hubs), 10BASE-F (10 Mbps over optical fiber links, using hubs),
+  100BASE-TX (100 Mbps over two twisted pair cables, using hubs),
+  100BASE-T4 (100 Mbps over 4 standard voice-grade twisted pair
+  cables, using hubs), 100BASE-FX (100 Mbps over optical fiber links)
+  [the 100BASE varieties are also known as Fast Ethernet], and Gigabit
+  Ethernet (1 Gbps over optical fiber or short copper links).
+
+  If your Linux machine will be connected to an Ethernet and you have
+  an Ethernet network interface card (NIC) installed in your computer,
+  say Y here and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . You will then also have
+  to say Y to the driver for your particular NIC.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Ethernet network cards. If unsure, say N.
+
+Western Digital/SMC cards
+CONFIG_NET_VENDOR_SMC
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about Western Digital cards. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+WD80*3 support
+CONFIG_WD80x3
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra MCA support
+CONFIG_ULTRAMCA
+  If you have a network (Ethernet) card of this type and are running
+  an MCA based system (PS/2), say Y and read the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-mca.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC Ultra support
+CONFIG_ULTRA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+  
+  Important: There have been many reports that, with some motherboards
+  mixing an SMC Ultra and an Adaptec AHA154x SCSI card (or compatible,
+  such as some BusLogic models) causes corruption problems with many
+  operating systems. The Linux smc-ultra driver has a work-around for
+  this but keep it in mind if you have such a SCSI card and have
+  problems.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+SMC Ultra32 EISA support
+CONFIG_ULTRA32
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called smc-ultra32.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt as well
+  as Documentation/networking/net-modules.txt.
+
+SMC 9194 Support
+CONFIG_SMC9194
+  This is support for the SMC9xxx based Ethernet cards. Choose this
+  option if you have a DELL laptop with the docking station, or
+  another SMC9192/9194 based chipset. Say Y if you want it compiled
+  into the kernel, and read the file
+  Documentation/networking/smc9.txt and the Ethernet-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called smc9194.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+PCI NE2000 support
+CONFIG_NE2K_PCI
+  This driver is for NE2000 compatible PCI cards. It will not work
+  with ISA NE2000 cards (they have their own driver, "NE2000/NE1000
+  support" below). If you have a PCI NE2000 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver also works for the following NE2000 clone cards:
+    RealTek RTL-8029  Winbond 89C940  Compex RL2000  KTI ET32P2
+    NetVin NV5000SC   Via 86C926      SureCom NE34   Winbond
+    Holtek HT80232    Holtek HT80229
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2k-pci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan (Micom) NI cards
+CONFIG_NET_VENDOR_RACAL
+  If you have a network (Ethernet) card belonging to this class, such
+  as the NI5010, NI5210 or NI6210, say Y and read the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about NI cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+NI5010 support (EXPERIMENTAL)
+CONFIG_NI5010
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Note that this is still
+  experimental code.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni5010.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI5210 support
+CONFIG_NI52
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni52.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+NI6510 support
+CONFIG_NI65
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ni65.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+RealTek 8129 (not 8019/8029/8139!) support (EXPERIMENTAL)
+CONFIG_RTL8129
+  This is NOT for RTL-8139 cards.  Instead, select the 8139too driver
+  (CONFIG_8139TOO).
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the RTL8129 chip. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note: the 8029 is a NE2000 PCI clone, you can use the NE2K-PCI driver.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called rtl8129.o.
+
+RealTek RTL-8139 PCI Fast Ethernet Adapter support
+CONFIG_8139TOO
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the RTL8139 chips. If you have one of those, say Y and read
+  Documentation/networking/8139too.txt as well as the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called 8139too.o.
+
+SiS 900 PCI Fast Ethernet Adapter support
+CONFIG_SIS900
+  This is a driver for the Fast Ethernet PCI network cards based on
+  the SiS 900 and SiS 7016 chips. The SiS 900 core is also embedded in
+  SiS 630 and SiS 540 chipsets. If you have one of those, say Y and
+  read the Ethernet-HOWTO, available at
+  http://www.linuxdoc.org/docs.html#howto . Please read
+  Documentation/networking/sis900.txt and comments at the beginning of
+  drivers/net/sis900.c for more information.
+
+  This driver also supports AMD 79C901 HomePNA so that you can use
+  your phone line as a network cable.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called sis900.o.
+
+Packet Engines Yellowfin Gigabit-NIC support
+CONFIG_YELLOWFIN
+  Say Y here if you have a Packet Engines G-NIC PCI Gigabit Ethernet
+  adapter. This adapter is used by the Beowulf Linux cluster project.
+  See http://cesdis.gsfc.nasa.gov/linux/drivers/yellowfin.html for
+  more information about this driver in particular and Beowulf in
+  general.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called yellowfin.o.
+
+General Instruments Surfboard 1000
+CONFIG_NET_SB1000
+  This is a driver for the General Instrument (also known as
+  NextLevel) SURFboard 1000 internal
+  cable modem. This is an ISA card which is used by a number of cable
+  TV companies to provide cable modem access. It's a one-way
+  downstream-only cable modem, meaning that your upstream net link is
+  provided by your regular phone modem.
+
+  At present this driver only compiles as a module, so say M here if
+  you have this card. The module will be called sb1000.o. Then read
+  Documentation/networking/README.sb1000 for information on how to use
+  this module, as it needs special ppp scripts for establishing a
+  connection. Further documentation and the necessary scripts can be
+  found at:
+
+  http://www.jacksonville.net/~fventuri/
+  http://home.adelphia.net/~siglercm/sb1000.html
+  http://linuxpower.cx/~cable/
+
+  If you don't have this card, of course say N.
+
+Adaptec Starfire support (EXPERIMENTAL)
+CONFIG_ADAPTEC_STARFIRE
+  Say Y here if you have an Adaptec Starfire (or DuraLAN) PCI network
+  adapter. The DuraLAN chip is used on the 64 bit PCI boards from
+  Adaptec e.g. the ANA-6922A. The older 32 bit boards use the tulip
+  driver.
+  
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called starfile.o.
+  
+Alteon AceNIC/3Com 3C985/NetGear GA620 Gigabit support
+CONFIG_ACENIC
+  Say Y here if you have an Alteon AceNIC, 3Com 3C985(B), NetGear
+  GA620, SGI Gigabit or Farallon PN9000-SX PCI Gigabit Ethernet
+  adapter. The driver allows for using the Jumbo Frame option (9000
+  bytes/frame) however it requires that your switches can handle this
+  as well. To enable Jumbo Frames, add `mtu 9000' to your ifconfig
+  line.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called acenic.o.
+
+Omit support for older Tigon I based AceNICs
+CONFIG_ACENIC_OMIT_TIGON_I
+  Say Y here if you only have Tigon II based AceNICs and want to leave
+  out support for the older Tigon I based cards which are no longer
+  being sold (ie. the original Alteon AceNIC and 3Com 3C985 (non B
+  version)). This will reduce the size of the driver object by
+  app. 100KB. If you are not sure whether your card is a Tigon I or a
+  Tigon II, say N here.
+
+  The safe and default value for this is N.
+
+SysKonnect SK-98xx support
+CONFIG_SK98LIN
+  Say Y here if you have a SysKonnect SK-98xx Gigabit Ethernet Server
+  Adapter. The following adapters are supported by this driver:
+  - SK-9841 (single link 1000Base-LX)
+  - SK-9842 (dual link   1000Base-LX)
+  - SK-9843 (single link 1000Base-SX)
+  - SK-9844 (dual link   1000Base-SX)
+  - SK-9821 (single link 1000Base-T)
+  - SK-9822 (dual link   1000Base-T)
+  - SK-9861 (single link Volition connector)
+  - SK-9862 (dual link   Volition connector)
+  The driver also supports the following adapters from Allied Telesyn:
+  - AT2970...
+
+  The dual link adapters support a link-failover feature.
+  Read Documentation/networking/sk98lin.txt for information about
+  optional driver parameters.
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called sk98lin.o.
+
+MyriCOM Gigabit Ethernet support
+CONFIG_MYRI_SBUS
+  This driver supports MyriCOM Sbus gigabit ethernet cards.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called myri_sbus.o.
+
+AMD LANCE and PCnet (AT1500 and NE2100) support
+CONFIG_LANCE
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Some LinkSys cards are
+  of this type.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called lance.o.
+
+SGI IOC3 Ethernet
+CONFIG_SGI_IOC3_ETH
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+3COM cards
+CONFIG_NET_VENDOR_3COM
+  If you have a network (Ethernet) card belonging to this class, say Y
+  and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about 3COM cards. If you say Y, you will be asked for
+  your specific card in the following questions.
+
+3c501 support
+CONFIG_EL1
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Also, consider buying a
+  new card, since the 3c501 is slow, broken, and obsolete: you will
+  have problems. Some people suggest to ping ("man ping") a nearby
+  machine every minute ("man cron") when using this card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c501.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c503 support
+CONFIG_EL2
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c503.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c505 support
+CONFIG_ELPLUS
+  Information about this network (Ethernet) card can be found in
+  Documentation/networking/3c505.txt. If you have a card of this type,
+  say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c505.o.
+
+3c507 support (EXPERIMENTAL)
+CONFIG_EL16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c507.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c523 support 
+CONFIG_ELMC
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c523.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c527 support
+CONFIG_ELMC_II
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called 3c527.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+3c509/3c579 support
+CONFIG_EL3
+  If you have a network (Ethernet) card belonging to the 3Com
+  EtherLinkIII series, say Y and read the Ethernet-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  If your card is not working you may need to use the DOS
+  setup disk to disable Plug & Play mode, and to select the default
+  media type.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c509.o. 
+
+3c515 ISA Fast EtherLink
+CONFIG_3C515
+  If you have a 3Com ISA EtherLink XL "Corkscrew" 3c515 Fast Ethernet
+  network card, say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  3c515.o.
+
+3c59x/3c90x/3c575_Cardbus series "Vortex/Boomerang/Cyclone" support
+CONFIG_VORTEX
+  This option enables driver support for a large number of 10mbps and
+  10/100mbps EISA, PCI and PCMCIA 3Com network cards:
+
+  "Vortex"    (Fast EtherLink 3c590/3c592/3c595/3c597) EISA and PCI
+  "Boomerang" (EtherLink XL 3c900 or 3c905)            PCI
+  "Cyclone"   (3c540/3c900/3c905/3c980/3c575/3c656)    PCI and Cardbus
+  "Tornado"   (3c905)                                  PCI
+  "Hurricane" (3c555/3cSOHO)                           PCI
+
+  If you have such a card, say Y and read the Ethernet-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto . More specific
+  information is in Documentation/networking/vortex.txt and in the
+  comments at the beginning of drivers/net/3c59x.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Other ISA cards
+CONFIG_NET_ISA
+  If your network (Ethernet) card hasn't been mentioned yet and its
+  bus system (that's the way the cards talks to the other components
+  of your computer) is ISA (as opposed to EISA, VLB or PCI), say Y.
+  Make sure you know the name of your card. Read the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto . 
+
+  If unsure, say Y.
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the remaining ISA network card questions. If you say Y, you will be
+  asked for your specific card in the following questions.
+
+Generic ARCnet support
+CONFIG_ARCNET
+  If you have a network card of this type, say Y and check out the
+  (arguably) beautiful poetry in Documentation/networking/arcnet.txt.
+
+  You need both this driver, and the driver for the particular ARCnet
+  chipset of your card. If you don't know, then it's probably a
+  COM90xx type card, so say Y (or M) to "ARCnet COM90xx chipset
+  support" below.
+
+  You might also want to have a look at the Ethernet-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto (even though ARCnet
+  is not really Ethernet).
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called arcnet.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Enable arc0e (ARCnet "ether-encap" packet format)
+CONFIG_ARCNET_ETH
+  This allows you to use "Ethernet encapsulation" with your ARCnet
+  card via the virtual arc0e device. You only need arc0e if you want
+  to talk to nonstandard ARCnet software, specifically,
+  DOS/Windows-style "NDIS" drivers. You do not need to say Y here to
+  communicate with industry-standard RFC1201 implementations, like the
+  arcether.com packet driver or most DOS/Windows ODI drivers. RFC1201
+  is included automatically as the arc0 device. Please read the
+  ARCnet documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+Enable old ARCNet packet format (RFC 1051)
+CONFIG_ARCNET_1051
+  This allows you to use RFC1051 with your ARCnet card via the virtual
+  arc0s device. You only need arc0s if you want to talk to ARCnet
+  software complying with the "old" standard, specifically, the DOS
+  arcnet.com packet driver, Amigas running AmiTCP, and some variants
+  of NetBSD. You do not need to say Y here to communicate with
+  industry-standard RFC1201 implementations, like the arcether.com
+  packet driver or most DOS/Windows ODI drivers. RFC1201 is included
+  automatically as the arc0 device. Please read the ARCnet
+  documentation in Documentation/networking/arcnet.txt for more
+  information about using arc0e and arc0s.
+
+ARCnet COM90xx (normal) chipset driver
+CONFIG_ARCNET_COM90xx
+  This is the chipset driver for the standard COM90xx cards. If you
+  have always used the old ARCnet driver without knowing what type of
+  card you had, this is probably the one for you. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (IO mapped) chipset driver
+CONFIG_ARCNET_COM90xxIO
+  This is the chipset driver for the COM90xx cards, using them in
+  IO-mapped mode instead of memory-mapped mode. This is slower than
+  the normal driver. Only use it if your card doesn't support shared
+  memory. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com90io.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+ARCnet COM90xx (RIM I) chipset driver
+CONFIG_ARCNET_RIM_I
+  This is yet another chipset driver for the COM90xx cards, but this
+  time only using memory-mapped mode, and no IO ports at all. This
+  driver is completely untested, so if you have one of these cards,
+  please mail dwmw2@infradead.org, especially if it works!
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called arc-rimi.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt as
+  well as Documentation/networking/net-modules.txt.
+
+ARCnet COM20020 chipset driver
+CONFIG_ARCNET_COM20020
+  This is the driver for the new COM20020 chipset. It supports such
+  things as promiscuous mode, so packet sniffing is possible, and
+  extra diagnostic information. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called com20020.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Cabletron E21xx support
+CONFIG_E2100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called e2100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+CS89x0 support
+CONFIG_CS89x0
+  Support for CS89x0 chipset based Ethernet cards. If you have a
+  network (Ethernet) card of this type, say Y and read the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto as well as
+  Documentation/networking/cs89x0.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  cs89x.o.
+
+DEPCA support
+CONFIG_DEPCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto as well as
+  drivers/net/depca.c.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  depca.o.
+
+EtherWorks 3 support
+CONFIG_EWRK3
+  This driver supports the DE203, DE204 and DE205 network (Ethernet)
+  cards. If this is for you, say Y and read
+  Documentation/networking/ewrk3.txt in the kernel source as well as
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  ewrk3.o.
+
+SEEQ8005 support
+CONFIG_SEEQ8005
+  This is a driver for the SEEQ 8005 network (Ethernet) card. If this
+  is for you, read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  ewrk3.o.
+
+AT1700/1720 support
+CONFIG_AT1700
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  at1700.o.
+
+FMV-181/182/183/184 support
+CONFIG_FMV18X
+  If you have a Fujitsu FMV-181/182/183/184 network (Ethernet) card,
+  say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you use an FMV-183 or FMV-184 and it is not working, you may need
+  to disable Plug & Play mode of the card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called fmv18x.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. 
+
+EtherExpress PRO support
+CONFIG_EEXPRESS_PRO
+  If you have a network (Ethernet) card of this type, say Y. This
+  driver supports intel i82595{FX,TX} based boards. Note however 
+  that the EtherExpress PRO/100 Ethernet card has its own separate
+  driver. Please read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress support
+CONFIG_EEXPRESS
+  If you have an EtherExpress16 network (Ethernet) card, say Y and
+  read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Note that the Intel
+  EtherExpress16 card used to be regarded as a very poor choice
+  because the driver was very unreliable. We now have a new driver
+  that should do better.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  eexpress.o.
+
+Packet Engines Hamachi GNIC-II support
+CONFIG_HAMACHI
+  If you have a Gigabit Ethernet card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  hamachi.o.
+
+HP PCLAN+ (27247B and 27252A) support
+CONFIG_HPLAN_PLUS
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp-plus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP PCLAN (27245 and other 27xxx series) support
+CONFIG_HPLAN
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hp.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+HP 10/100VG PCLAN (ISA, EISA, PCI) support
+CONFIG_HP100
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  hp100.o.
+
+NE2000/NE1000 support
+CONFIG_NE2000
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Many Ethernet cards
+  without a specific driver are compatible with NE2000.
+
+  If you have a PCI NE2000 card however, say N here and Y to "PCI
+  NE2000 support", above. If you have a NE2000 card and are running on
+  an MCA system (a bus system used on some IBM PS/2 computers and
+  laptops), say N here and Y to "NE/2 (ne2000 MCA version) support",
+  below.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+National Semiconductor DP83810 series PCI Ethernet support
+CONFIG_NATSEMI
+  This driver is for the National Semiconductor DP83810 series,
+  including the 83815 chip.
+  More specific information and updates are available from 
+  http://www.scyld.com/network/natsemi.html
+
+SK_G16 support
+CONFIG_SK_G16
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+NE/2 (ne2000 MCA version) support
+CONFIG_NE2_MCA
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne2.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SKnet MCA support
+CONFIG_SKMC
+  These are Micro Channel ethernet adapters. You need to say Y to "MCA
+  support" in order to use this driver. Supported cards are the SKnet
+  Junior MC2 and the SKnet MC2(+). The driver automatically
+  distinguishes between the two cards. Note that using multiple boards
+  of different type hasn't been tested with this driver. Say Y if you
+  have one of these ethernet adapters.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called sk_mca.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+IBM LAN Adapter/A support
+CONFIG_IBMLANA
+  This is a Micro Channel ethernet adapter.  You need to set CONFIG_MCA
+  to use this driver.  It is both available as an in-kernel driver and
+  as a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. If you plan to use more than
+  one network card under linux, read the Multiple-Ethernet-mini-HOWTO,
+  available from sunsite.unc.edu:/pub/Linux/docs/HOWTO/mini.  The only
+  currently supported card is the IBM LAN Adapter/A for Ethernet.  It will
+  both support 16K and 32K memory windows, however a 32K window gives
+  a better security against packet losses.  Usage of multiple boards with
+  this driver should be possible, but has not been tested up to now due
+  to lack of hardware.
+
+EISA, VLB, PCI and on board controllers
+CONFIG_NET_PCI
+  This is another class of network cards which attach directly to the
+  bus. If you have one of those, say Y and read the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network cards. If you say Y, you
+  will be asked for your specific card in the following questions. If
+  you are unsure, say Y.
+
+AMD PCnet32 (VLB and PCI) support
+CONFIG_PCNET32
+  If you have a PCnet32 or PCnetPCI based network (Ethernet) card,
+  answer Y here and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pcnet32.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Ansel Communications EISA 3200 support
+CONFIG_AC3200
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ac3200.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Mylex EISA LNE390A/LNE390B support (EXPERIMENTAL)
+CONFIG_LNE390
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lne390.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Novell/Eagle/Microdyne NE3210 EISA support
+CONFIG_NE3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Note that this driver
+  will NOT WORK for NE3200 cards as they are completely different.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ne3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Apricot Xen-II on board Ethernet
+CONFIG_APRICOT
+  If you have a network (Ethernet) controller of this type, say Y and
+  read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt. The module will be called
+  apricot.o.
+
+Generic DECchip & DIGITAL EtherWORKS PCI/EISA
+CONFIG_DE4X5
+  This is support for the DIGITAL series of PCI/EISA Ethernet cards.
+  These include the DE425, DE434, DE435, DE450 and DE500 models. If
+  you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . More specific
+  information is contained in Documentation/networking/de4x5.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called de4x5.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+DECchip Tulip (dc21x4x) PCI support
+CONFIG_TULIP
+  This driver is developed for the SMC EtherPower series Ethernet
+  cards and also works with cards based on the DECchip
+  21040/21041/21140 (Tulip series) chips. Some LinkSys PCI cards are
+  of this type. (If your card is NOT SMC EtherPower 10/100 PCI
+  (smc9332dst), you can also try the driver for "Generic DECchip"
+  cards, above. However, most people with a network card of this type
+  will say Y here.) Do read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . More specific
+  information is contained in Documentation/networking/tulip.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tulip.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Digi Intl. RightSwitch support
+CONFIG_DGRS
+  This is support for the Digi International RightSwitch series of
+  PCI/EISA Ethernet switch cards. These include the SE-4 and the SE-6
+  models. If you have a network card of this type, say Y and read the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . More specific
+  information is contained in Documentation/networking/dgrs.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dgrs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+EtherExpress PRO/100 support
+CONFIG_EEPRO100
+  If you have an Intel EtherExpress PRO/100 PCI network (Ethernet)
+  card, say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eepro100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Enable Power Management (EXPERIMENTAL)
+CONFIG_EEPRO100_PM
+  Many Intel EtherExpress PRO/100 PCI network cards are capable
+  of providing power management capabilities.  To make use of these
+  capabilities, say Y.
+
+  WARNING:  This option is intended for kernel developers and testers.
+  It is still very experimental, with some people reporting complete
+  lockups.
+
+  It is recommended to say N here.
+
+ICL EtherTeam 16i/32 support (EXPERIMENTAL)
+CONFIG_ETH16I
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called eth16i.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+TI ThunderLAN support (EXPERIMENTAL)
+CONFIG_TLAN
+  If you have a PCI Ethernet network card based on the ThunderLAN chip
+  which is supported by this driver, say Y and read the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Devices currently supported by this driver are Compaq Netelligent,
+  Compaq NetFlex and Olicom cards. Please read the file
+  Documentation/networking/tlan.txt for more details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tlan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+  Please email feedback to  torben.mathiasen@compaq.com.
+
+VIA Rhine support
+CONFIG_VIA_RHINE
+  If you have a VIA "rhine" based network card (Rhine-I (3043) or
+  Rhine-2 (VT86c100A)), say Y here.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called via-rhine.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+PCI DM9102(A)/DM9132/DM9801 support 
+CONFIG_DM9102
+  This driver is for DM9102(A)/DM9132/DM9801 compatible PCI cards from
+  Davicom ( http://www.davicom.com.tw ). If you have such a network
+  (Ethernet) card, say Y. Some information is contained in the file 
+  Documentation/networking/dmfe.txt.
+ 
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dmfe.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+Racal-Interlan EISA ES3210 support (EXPERIMENTAL)
+CONFIG_ES3210
+  If you have a network (Ethernet) card of this type, say Y and read
+  the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called es3210.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt as well as
+  Documentation/networking/net-modules.txt.
+
+SMC EtherPower II
+CONFIG_EPIC100
+  This driver is for the SMC EtherPower II 9432 PCI Ethernet NIC,
+  which is based on the SMC83c17x (EPIC/100).
+  More specific information and updates are available from
+  http://www.scyld.com/network/epic100.html
+
+SGI Seeq ethernet controller support
+CONFIG_SGISEEQ
+  Say Y here if you have an Seeq based Ethernet network card. This is
+  used in many Silicon Graphics machines.
+
+Sundance "Alta" PCI Ethernet support
+CONFIG_SUNDANCE
+  This driver is for the Sundance "Alta" chip.
+  More specific information and updates are available from
+  http://www.scyld.com/network/sundance.html
+
+Winbond W89c840 PCI Ethernet support
+CONFIG_WINBOND_840
+  This driver is for the Winbond W89c840 chip.  It also works with
+  the TX9882 chip on the Compex RL100-ATX board.
+  More specific information and updates are available from
+  http://www.scyld.com/network/drivers.html
+
+Zenith Z-Note support (EXPERIMENTAL)
+CONFIG_ZNET
+  The Zenith Z-Note notebook computer has a built-in network
+  (Ethernet) card, and this is the Linux driver for it. Note that the
+  IBM Thinkpad 300 is compatible with the Z-Note and is also supported
+  by this driver. Read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+Pocket and portable adapters
+CONFIG_NET_POCKET
+  Cute little network (Ethernet) devices which attach to the parallel
+  port ("pocket adapters"), commonly used with laptops. If you have
+  one of those, say Y and read the Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to plug a network (or some other) card into the PCMCIA
+  (or PC-card) slot of your laptop instead (PCMCIA is the standard for
+  credit card size extension cards used by all modern laptops), you
+  need the pcmcia-cs package (location contained in the file
+  Documentation/Changes) and you can say N here.
+
+  Laptop users should read the Linux Laptop home page at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about this class of network devices. If you say Y, you
+  will be asked for your specific device in the following questions.
+
+AT-LAN-TEC/RealTek pocket adapter support
+CONFIG_ATP
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read drivers/net/atp.c as well as the Ethernet-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto , if you
+  want to use this. If you intend to use this driver, you should have
+  said N to the "Parallel printer support", because the two drivers
+  don't like each other.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called atp.o.
+
+D-Link DE600 pocket adapter support
+CONFIG_DE600
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , if you want to use
+  this. It is possible to have several devices share a single parallel
+  port and it is safe to compile the corresponding drivers into the
+  kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de600.o.
+
+D-Link DE620 pocket adapter support
+CONFIG_DE620
+  This is a network (Ethernet) device which attaches to your parallel
+  port. Read Documentation/networking/DLINK.txt as well as the
+  Ethernet-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , if you want to use
+  this. It is possible to have several devices share a single parallel
+  port and it is safe to compile the corresponding drivers into the
+  kernel.
+
+  If you want to compile this driver as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called de620.o.
+
+Token Ring driver support
+CONFIG_TR
+  Token Ring is IBM's way of communication on a local network; the
+  rest of the world uses Ethernet. To participate on a Token Ring
+  network, you need a special Token ring network card. If you are
+  connected to such a Token Ring network and want to use your Token
+  Ring card under Linux, say Y here and to the driver for your
+  particular card below and read the Token-Ring mini-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto . Most people can
+  say N here.
+
+IBM Tropic chipset based adapter support
+CONFIG_IBMTR
+  This is support for all IBM Token Ring cards that don't use DMA. If
+  you have such a beast, say Y and read the Token-Ring mini-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  Warning: this driver will almost definitely fail if more than one
+  active Token Ring card is present. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmtr.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IBM Olympic chipset PCI adapter support
+CONFIG_IBMOL
+  This is support for all non-Lanstreamer IBM PCI Token Ring Cards. 
+  Specifically this is all IBM PCI, PCI Wake On Lan, PCI II, PCI II
+  Wake On Lan, and PCI 100/16/4 adapters.
+
+  If you have such an adapter, say Y and read the Token-Ring
+  mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called olympic.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+  Also read the file Documentation/networking/olympic.txt or check the
+  Linux Token Ring Project site for the latest information at
+  http://www.linuxtr.net .
+
+IBM Lanstreamer chipset PCI adapter support
+CONFIG_IBMLS
+  This is support for IBM Lanstreamer PCI Token Ring Cards.
+
+  If you have such an adapter, say Y and read the Token-Ring
+  mini-HOWTO available via FTP (user:anonymous) from
+  ftp://metalab.unc/edu/pub/Linux/docs/HOWTO.
+
+  This driver is also available as a modules ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The modules will be called lanstreamer.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Generic TMS380 Token Ring ISA/PCI/MCA/EISA adapter support
+CONFIG_TMS380TR
+  This driver provides generic support for token ring adapters
+  based on the Texas Instruments TMS380 series chipsets.  This
+  includes the SysKonnect TR4/16(+) ISA (SK-4190), SysKonnect
+  TR4/16(+) PCI (SK-4590), SysKonnect TR4/16 PCI (SK-4591),
+  Compaq 4/16 PCI, Thomas-Conrad TC4048 4/16 PCI, and several
+  Madge adapters.  If you say Y here, you will be asked to select
+  which cards to support below.  If you're using modules, each
+  class of card will be supported by a separate module.
+
+  If you have such an adapter and would like to use it, say Y and
+  read the Token-Ring mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Also read the file Documentation/networking/tms380tr.txt or
+  check http://www.auk.cx/tms380tr/ .
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called tms380tr.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Generic TMS380 PCI support
+CONFIG_TMSPCI
+  This tms380 module supports generic TMS380-based PCI cards.
+
+  These cards are known to work:
+     - Compaq 4/16 TR PCI
+     - SysKonnect TR4/16 PCI (SK-4590/SK-4591)
+     - Thomas-Conrad TC4048 PCI 4/16
+     - 3Com Token Link Velocity
+
+  This driver is available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called tmspci.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Madge Smart 16/4 PCI Mk2 support
+CONFIG_ABYSS
+  This tms380 module supports the Madge Smart 16/4 PCI Mk2 
+  cards (51-02).
+
+  This driver is available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called abyss.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Madge Smart 16/4 Ringode MicroChannel 
+CONFIG_MADGEMC
+  This tms380 module supports the Madge Smart 16/4 MC16 and MC32
+  MicroChannel adapters.
+
+  This driver is available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called madgemc.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+SMC ISA TokenRing adapter support
+CONFIG_SMCTR
+  This is support for the ISA and MCA SMC Token Ring cards,
+  specifically SMC TokenCard Elite (8115T) and SMC TokenCard Elite/A
+  (8115T/A) adapters.
+
+  If you have such an adapter and would like to use it, say Y or M and
+  read the Token-Ring mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto and the file
+  Documentation/networking/smctr.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will will be called smctr.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Sun Happy Meal 10/100baseT support
+CONFIG_HAPPYMEAL
+  This driver supports the "hme" interface present on most Ultra
+  systems and as an option on older Sbus systems. This driver supports
+  both PCI and Sbus devices. This driver also supports the "qfe" quad
+  100baseT device available in both PCI and Sbus configurations.
+
+  This support is also available as a module called sunhme.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Sun Lance support
+CONFIG_SUNLANCE
+  This driver supports the "le" interface present on all 32-bit Sparc
+  systems, on some older Ultra systems and as an Sbus option.
+
+  This support is also available as a module called sunlance.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Sun BigMAC 10/100baseT support (EXPERIMENTAL)
+CONFIG_SUNBMAC
+  This driver supports the "be" interface available as an Sbus option.
+  This is Sun's older 100baseT ethernet device.
+
+  This support is also available as a module called sunbmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Sun QuadEthernet support
+CONFIG_SUNQE
+  This driver supports the "qe" 10baseT ethernet device, available as
+  an Sbus option. Note that this is not the same as Quad FastEthernet
+  "qfe" which is supported by the Happy Meal driver instead.
+
+  This support is also available as a module called sunqe.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Traffic Shaper (EXPERIMENTAL)
+CONFIG_SHAPER
+  The traffic shaper is a virtual network device that allows you to
+  limit the rate of outgoing data flow over some other network device.
+  The traffic that you want to slow down can then be routed through
+  these virtual devices. See Documentation/networking/shaper.txt for
+  more information.
+
+  An alternative to this traffic shaper is the experimental
+  Class-Based Queueing (CBQ) scheduling support which you get if you
+  say Y to "QoS and/or fair queueing" above.
+
+  To set up and configure shaper devices, you need the shapecfg
+  program, available from ftp://shadow.cabi.net/pub/Linux in the
+  shaper package.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called shaper.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+FDDI driver support
+CONFIG_FDDI
+  Fiber Distributed Data Interface is a high speed local area network
+  design; essentially a replacement for high speed Ethernet. FDDI can
+  run over copper or fiber. If you are connected to such a network and
+  want a driver for the FDDI card in your computer, say Y here (and
+  then also Y to the driver for your FDDI card, below). Most people
+  will say N.
+
+Digital DEFEA and DEFPA adapter support
+CONFIG_DEFXX
+  This is support for the DIGITAL series of EISA (DEFEA) and PCI
+  (DEFPA) controllers which can connect you to a local FDDI network.
+
+SysKonnect FDDI PCI support
+CONFIG_SKFP
+  Say Y here if you have a SysKonnect FDDI PCI adapter.
+  The following adapters are supported by this driver:
+  - SK-5521 (SK-NET FDDI-UP)
+  - SK-5522 (SK-NET FDDI-UP DAS)
+  - SK-5541 (SK-NET FDDI-FP)
+  - SK-5543 (SK-NET FDDI-LP)
+  - SK-5544 (SK-NET FDDI-LP DAS)
+  - SK-5821 (SK-NET FDDI-UP64)
+  - SK-5822 (SK-NET FDDI-UP64 DAS)
+  - SK-5841 (SK-NET FDDI-FP64)
+  - SK-5843 (SK-NET FDDI-LP64)
+  - SK-5844 (SK-NET FDDI-LP64 DAS)
+  - Netelligent 100 FDDI DAS Fibre SC
+  - Netelligent 100 FDDI SAS Fibre SC
+  - Netelligent 100 FDDI DAS UTP
+  - Netelligent 100 FDDI SAS UTP
+  - Netelligent 100 FDDI SAS Fibre MIC
+  
+  Read Documentation/networking/skfp.txt for information about
+  the driver.
+
+  Questions concerning this driver can be addressed to:
+    linux@syskonnect.de
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called skfp.o.
+
+HIgh Performance Parallel Interface support (EXPERIMENTAL)
+CONFIG_HIPPI
+  HIgh Performance Parallel Interface (HIPPI) is a 800Mbit/sec and
+  1600Mbit/sec dual-simplex switched or point-to-point network. HIPPI
+  can run over copper (25m) or fiber (300m on multi-mode or 10km on
+  single-mode). HIPPI networks are commonly used for clusters and to
+  connect to super computers. If you are connected to a HIPPI network
+  and have a HIPPI network card in your computer that you want to use
+  under Linux, say Y here (you must also remember to enable the driver
+  for your HIPPI card below). Most people will say N here.
+  
+Essential RoadRunner HIPPI PCI adapter support
+CONFIG_ROADRUNNER
+  Say Y here if this is your PCI HIPPI network card.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rrunner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If unsure,
+  say N.
+
+Use large TX/RX rings
+CONFIG_ROADRUNNER_LARGE_RINGS
+  If you say Y here, the RoadRunner driver will preallocate up to 2 MB
+  of additional memory to allow for fastest operation, both for
+  transmitting and receiving. This memory cannot be used by any other
+  kernel code or by user space programs. Say Y here only if you have
+  the memory.
+
+Acorn Ether1 card
+CONFIG_ARM_ETHER1
+  If you have an Acorn system with one of these (AKA25) network cards,
+  you should say Y to this option if you wish to use it with Linux.
+
+Acorn/ANT Ether3 card
+CONFIG_ARM_ETHER3
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+I Cubed EtherH card
+CONFIG_ARM_ETHERH
+  If you have an Acorn system with one of these network cards, you
+  should say Y to this option if you wish to use it with Linux.
+
+EBSA-110 Ethernet interface
+CONFIG_ARM_AM79C961A
+  If you wish to compile a kernel for the EBSA-110, then you should
+  always answer Y to this.
+
+Support CDROM drives that are not SCSI or IDE/ATAPI
+CONFIG_CD_NO_IDESCSI
+  If you have a CDROM drive that is neither SCSI nor IDE/ATAPI, say Y
+  here, otherwise N. Read the CDROM-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that the answer to this question doesn't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these CDROM drives. If you are unsure what you
+  have, say Y and find out whether you have one of the following
+  drives. 
+
+  For each of these drivers, a file Documentation/cdrom/<driver_name>
+  exists. Especially in cases where you do not know exactly which kind
+  of drive you have you should read there. Most of these drivers use a
+  file drivers/cdrom/<driver_name>.h where you can define your
+  interface parameters and switch some internal goodies. 
+
+  All these CDROM drivers are also usable as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile them as module, say M instead of Y and
+  read Documentation/modules.txt. 
+
+  If you want to use any of these CDROM drivers, you also have to
+  answer Y or M to "ISO 9660 CDROM file system support" below (this
+  answer will get "defaulted" for you if you enable any of the Linux
+  CDROM drivers).
+
+Sony CDU31A/CDU33A CDROM support
+CONFIG_CDU31A
+  These CDROM drives have a spring-pop-out caddyless drawer, and a
+  rectangular green LED centered beneath it. NOTE: these CDROM drives
+  will not be auto detected by the kernel at boot time; you have to
+  provide the interface address as an option to the kernel at boot
+  time as described in Documentation/cdrom/cdu31a or fill in your
+  parameters into drivers/cdrom/cdu31a.c. Try "man bootparam" or
+  see the documentation of your boot loader (lilo or loadlin) about
+  how to pass options to the kernel.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cdu31a.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Standard Mitsumi [no XA/Multisession] CDROM support
+CONFIG_MCD
+  This is the older of the two drivers for the older Mitsumi models
+  LU-005, FX-001 and FX-001D. This is not the right driver for the
+  FX-001DE and the triple or quad speed models (all these are
+  IDE/ATAPI models). Please also the file Documentation/cdrom/mcd.
+
+  With the old LU-005 model, the whole drive chassis slides out for cd
+  insertion. The FX-xxx models use a motorized tray type mechanism.
+  Note that this driver does not support XA or MultiSession CDs
+  (PhotoCDs). There is a new driver (next question) which can do
+  this. If you want that one, say N here.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+IRQ channel for Mitsumi CD-ROM
+CONFIG_MCD_IRQ
+  This allows you to specify the default value of the IRQ used by the
+  driver. This setting can be overridden by passing the "mcd="
+  parameter to the kernel at boot time (or at module load time if you
+  said M to "Standard Mitsumi CDROM support").
+
+I/O base address for Mitsumi CD-ROM
+CONFIG_MCD_BASE
+  This allows you to specify the default value of the I/O base address
+  used by the driver. This setting can be overridden by passing the
+  "mcd=" parameter to the kernel at boot time (or at module load time
+  if you said M to "Standard Mitsumi CDROM support").
+
+Mitsumi [XA/MultiSession] support
+CONFIG_MCDX
+  Use this driver if you want to be able to read XA or MultiSession
+  CDs (PhotoCDs) as well as ordinary CDs with your Mitsumi LU-005,
+  FX-001 or FX-001D CDROM drive. In addition, this driver uses much
+  less kernel memory than the old one, if that is a concern. This
+  driver is able to support more than one drive, but each drive needs
+  a separate interface card. Please read the file
+  Documentation/cdrom/mcdx.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mcdx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic/Creative, Longshine, TEAC CDROM support
+CONFIG_SBPCD
+  This driver supports most of the drives which use the Panasonic or
+  Sound Blaster interface. Please read the file
+  Documentation/cdrom/sbpcd.
+
+  The Matsushita CR-521, CR-522, CR-523, CR-562, CR-563 drives
+  (sometimes labeled "Creative"), the Creative Labs CD200, the
+  Longshine LCS-7260, the "IBM External ISA CDROM" (in fact a CR-56x
+  model), the TEAC CD-55A fall under this category. Some other
+  "electrically compatible" drives (Vertos, Genoa, some Funai models)
+  are currently not supported; for the Sanyo H94A drive currently a
+  separate driver (asked later) is responsible. Most drives have a
+  uniquely shaped faceplate, with a caddyless motorized drawer, but
+  without external brand markings. The older CR-52x drives have a
+  caddy and manual loading/eject, but still no external markings. The
+  driver is able to do an extended auto-probing for interface
+  addresses and drive types; this can help to find facts in cases you
+  are not sure, but can consume some time during the boot process if
+  none of the supported drives gets found. Once your drive got found,
+  you should enter the reported parameters into drivers/cdrom/sbpcd.h
+  and set "DISTRIBUTION 0" there.
+
+  This driver can support up to four CDROM controller cards, and each
+  card can support up to four CDROM drives; if you say Y here, you
+  will be asked how many controller cards you have. If compiled as a
+  module, only one controller card (but with up to four drives) is
+  usable.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sbpcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Matsushita/Panasonic, ... second CDROM controller support
+CONFIG_SBPCD2
+  Say Y here only if you have two CDROM controller cards of this type
+  (usually only if you have more than four drives). You should enter
+  the parameters for the second, third and fourth interface card into
+  include/linux/sbpcd.h before compiling the new kernel. Read
+  the file Documentation/cdrom/sbpcd.
+
+Aztech/Orchid/Okano/Wearnes/TXC/CyDROM CDROM support
+CONFIG_AZTCD
+  This is your driver if you have an Aztech CDA268-01A, Orchid
+  CD-3110, Okano or Wearnes CDD110, Conrad TXC, or CyCDROM CR520 or
+  CR540 CDROM drive. This driver -- just like all these CDROM drivers
+  -- is NOT for CDROM drives with IDE/ATAPI interfaces, such as Aztech
+  CDA269-031SE. Please read the file Documentation/cdrom/aztcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called aztcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sony CDU535 CDROM support
+CONFIG_CDU535
+  This is the driver for the older Sony CDU-535 and CDU-531 CDROM
+  drives. Please read the file Documentation/cdrom/sonycd535.
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sonycd535.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Goldstar R420 CDROM support
+CONFIG_GSCD
+  If this is your CDROM drive, say Y here. As described in the file
+  Documentation/cdrom/gscd, you might have to change a setting
+  in the file drivers/cdrom/gscd.h before compiling the
+  kernel. Please read the file Documentation/cdrom/gscd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called gscd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Philips/LMS CM206 CDROM support
+CONFIG_CM206
+  If you have a Philips/LMS CDROM drive cm206 in combination with a
+  cm260 host adapter card, say Y here. Please also read the file
+  Documentation/cdrom/cm206. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cm206.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Optics Storage DOLPHIN 8000AT CDROM support
+CONFIG_OPTCD
+  This is the driver for the 'DOLPHIN' drive with a 34-pin Sony
+  compatible interface. It also works with the Lasermate CR328A. If
+  you have one of those, say Y. This driver does not work for the
+  Optics Storage 8001 drive; use the IDE-ATAPI CDROM driver for that
+  one. Please read the file Documentation/cdrom/optcd. 
+
+  If you say Y here, you should also say Y or M to "ISO 9660 CDROM
+  file system support" below, because that's the file system used on
+  CDROMs. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called optcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Sanyo CDR-H94A CDROM support
+CONFIG_SJCD
+  If this is your CDROM drive, say Y here and read the file
+  Documentation/cdrom/sjcd. You should then also say Y or M to
+  "ISO 9660 CDROM file system support" below, because that's the
+  file system used on CDROMs.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sjcd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+ISP16/MAD16/Mozart soft configurable cdrom interface support
+CONFIG_ISP16_CDI
+  These are sound cards with built-in cdrom interfaces using the OPTi
+  82C928 or 82C929 chips. Say Y here to have them detected and
+  possibly configured at boot time. In addition, You'll have to say Y
+  to a driver for the particular cdrom drive you have attached to the
+  card. Read Documentation/cdrom/isp16 for details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called isp16.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Quota support
+CONFIG_QUOTA
+  If you say Y here, you will be able to set per user limits for disk
+  usage (also called disk quotas). Currently, it works only for the
+  ext2 file system. You need additional software in order to use quota
+  support; for details, read the Quota mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . Probably the quota
+  support is only useful for multi user systems. If unsure, say N.
+
+Memory Technology Device (MTD) support
+CONFIG_MTD
+  Memory Technology Devices are flash, RAM and similar chips, often
+  used for solid state filesystems on embedded devices. This option
+  will provide the generic support for MTD drivers to register
+  themselves with the kernel and for potential users of MTD devices
+  to enumerate the devices which are present and obtain a handle on
+  them. It will also allow you to select individual drivers for 
+  particular hardware and users of MTD device. If unsure, say N.
+
+M-Systems Disk-On-Chip 1000 support
+CONFIG_MTD_DOC1000
+  This provides an MTD device driver for the M-Systems DiskOnChip
+  1000 devices, which are obsolete so you probably want to say 'N'.
+
+M-Systems Disk-On-Chip 2000 support
+CONFIG_MTD_DOC2000
+  This provides an MTD device driver for the M-Systems DiskOnChip
+  2000 devices. If you use this, you probably also want the NFTL
+  'NAND Flash Translation Layer' below, which is used to emulate
+  a block device by using a kind of filesystem on the flash chips.
+
+M-Systems Disk-On-Chip Millennium support
+CONFIG_MTD_DOC2001
+  This provides an MTD device driver for the M-Systems DiskOnChip
+  Millennium devices. If you use this, you probably also want the
+  NFTL 'NAND Flash Translation Layer' below, which is used to emulate
+  a block device by using a kind of filesystem on the flash chips.
+
+Use extra onboard system memory as MTD device
+CONFIG_MTD_SLRAM
+  If your CPU cannot cache all of the physical memory in your machine,
+  you can still use it for storage or swap by using this driver to
+  present it to the system as a Memory Technology Device.
+
+Ramix PMC551 PCI Mezzanine ram card support
+CONFIG_MTD_PMC551
+  This provides an MTD device driver for the Ramix PMC551 RAM card.
+  If you have one, you probably want to enable this.
+
+PMC551 256M DRAM Bugfix.
+CONFIG_MTD_PMC551_BUGFIX
+  Some PMC551 boards hacve invalid column and row mux values. This 
+  option will fix them, but will break other memory configurations.
+
+Debugging RAM test driver
+CONFIG_MTD_MTDRAM
+  This enables a test MTD device driver which uses vmalloc() to 
+  provide storage. You probably want to say 'N' unless you're 
+  testing stuff, or unless you want to use it in place of a ramdisk
+  when I've eventually got round to making the CONFIG_BLK_DEV option
+  and you've turned it off.
+
+Common Flash Interface (CFI) support
+CONFIG_MTD_CFI
+  Intel's Common Flash Interface specification provides a universal
+  method for probing the capabilities of flash devices. If you wish
+  to support any device which uses CFI-compliant devices, you need
+  to enable this option.
+
+CFI support for Intel/Sharp Extended Command Set chips
+CONFIG_MTD_CFI_INTELEXT
+  The Common Flash Interface defines a number of different command
+  sets which a CFI-compliant chip may claim to implement. This code
+  provides support for one of those command sets, used on Intel
+  Strataflash and other parts.
+
+Flash chip mapping in physical memory
+CONFIG_MTD_PHYSMAP
+  This provides a 'mapping' driver which allows the CFI probe and
+  command set driver code to communicate with flash chips which 
+  are mapped physically into the CPU's memory. You will need to
+  configure the physical address and size of the flash chips on
+  your particular board.
+
+Physical start location of flash chip mapping
+CONFIG_MTD_PHYSMAP_START
+  This is the physical memory location at which the flash chips
+  are mapped on your particular target board. Refer to the 
+  memory map which should hopefully be in the documentation for
+  your board.
+
+Physical length of flash chip mapping
+CONFIG_MTD_PHYSMAP_LEN
+  This is the total length of the mapping of the flash chips on
+  your particular board. If there is space, or aliases, in the 
+  physical memory map between the chips, this could be larger
+  than the total amount of flash present. Refer to the memory
+  map which should hopefully be in the documentation for your
+  board. 
+
+Flash chip mapping on Mixcom piggyback card
+CONFIG_MTD_MIXMEM
+  This supports the paging arrangement for access to flash chips
+  on the Mixcom piggyback card, allowing the flash chip drivers 
+  to get on with their job of driving the flash chips without 
+  having to know about the paging. If you have one of these boards,
+  you probably want to enable this mapping driver.
+
+Flash chip mapping on Nora
+CONFIG_MTD_NORA
+  If you had to ask, you don't have one. Say 'N'.
+
+Flash chip mapping on Octagon 5066 SBC
+CONFIG_MTD_OCTAGON
+  This provides a 'mapping' driver which supports the way in which
+  the flash chips are connected in the Octagon-5066 Single Board
+  Computer. You will also need to complete and enable the driver
+  for JEDEC flash chips.
+
+Flash chip mapping on RPXlite PPC board
+CONFIG_MTD_RPXLITE
+  The RPXLite PowerPC board has CFI-compliant chips mapped in 
+  a strange sparse mapping. This 'mapping' driver supports that
+  arrangement, allowing the CFI probe and command set driver code
+  to communicate with the chips on the RPXLite board.
+
+Flash chip mapping on Tempustech VMAX SBC301
+CONFIG_MTD_VMAX
+  This provides a 'mapping' driver which supports the way in which
+  the flash chips are connected in the Tempustech VMAX SBC301 Single
+  Board Computer. You will also need to complete and enable the driver
+  for JEDEC flash chips.
+
+Direct chardevice access to MTD devices
+CONFIG_MTD_CHAR
+  This provides a character device for each MTD device present in
+  the system, allowing the user to read and write directly to the
+  memory chips, and also use ioctl() to obtain information about
+  the device, or to erase parts of it.
+
+Pseudo-blockdevice access to MTD devices
+CONFIG_MTD_BLOCK
+  Although flash chips have an erase size too large to useful as
+  block devices, it is possible to use MTD devices which are based
+  on RAM chips in this manner. This blockdevice user of MTD devices
+  performs that function. At the moment, it is also required for 
+  the Journalling Flash File System to obtain a handle on the MTD 
+  device when it's mounted - although the JFFS doesn't actually use
+  any of the functions of the mtdblock device.
+
+  Later, it may be extended to perform read/erase/modify/write cycles
+  on flash chips to emulate a smaller block size. Needless to say,
+  this is very unsafe, but could be useful for filesystems which are
+  almost never written to.
+
+FTL (Flash Translation Layer) support
+CONFIG_FTL
+  This provides support for the original Flash Translation Layer which
+  is part of the PCMCIA specification. It uses a kind of pseudo-
+  filesystem on a flash device to emulate a block device with 512-byte
+  sectors, on top of which you put a 'normal' filesystem. You may find
+  that the algorithms used in this code are patented unless you live
+  in the Free World where software patents aren't legal - in the USA
+  you are only permitted to use this on PCMCIA hardware, although 
+  under the terms of the GPL you're obviously permitted to copy,
+  modify and distribute the code as you wish. Just not use it.
+
+NFTL (NAND Flash Translation Layer) support
+CONFIG_NFTL
+  This provides support for the NAND Flash Translation Layer which is
+  used on M-Systems' DiskOnChip devices. It uses a kind of pseudo-
+  filesystem on a flash device to emulate a block device with 512-byte
+  sectors, on top of which you put a 'normal' filesystem. You may find
+  that the algorithms used in this code are patented unless you live
+  in the Free World where software patents aren't legal - in the USA
+  you are only permitted to use this on DiskOnChip hardware, although 
+  under the terms of the GPL you're obviously permitted to copy,
+  modify and distribute the code as you wish. Just not use it.
+
+Write support for NFTL (EXPERIMENTAL)
+CONFIG_NFTL_RW
+  If you're lucky, this will actually work. Don't whinge if it doesn't.
+  Contact dwmw2@infradead.org if you want to help to make it more 
+  reliable.
+
+Support for USB
+CONFIG_USB
+  Universal Serial Bus (USB) is a specification for a serial bus
+  subsystem which offers higher speeds and more features than the
+  traditional PC serial port. The bus supplies power to peripherals
+  and allows for hot swapping. Up to 127 USB peripherals can be
+  connected to a single USB port in a tree structure. The USB port is
+  the root of the tree, the peripherals are the leaves and the inner
+  nodes are special USB devices called hubs. Many newer PC's have USB
+  ports and newer peripherals such as scanners, keyboards, mice,
+  modems, and printers support the USB protocol and can be connected
+  to the PC via those ports.
+
+  Say Y here if your computer has a USB port and you want to use USB
+  devices. You then need to say Y to at least one of "UHCI support" or
+  "OHCI support" below (the type of interface that the USB hardware in
+  your computer provides to the operating system) and then choose from
+  among the drivers for USB peripherals. You may want to check out the
+  information provided in Documentation/usb/ and especially the links
+  given in Documentation/usb/usb-help.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbcore.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB verbose debug messages
+CONFIG_USB_DEBUG
+  Say Y here if you want the USB core & hub drivers to produce a bunch
+  of debug messages to the system log. Select this if you are having a
+  problem with USB support and want to see more of what is going on.
+
+UHCI (intel PIIX4, VIA, ...) support?
+CONFIG_USB_UHCI
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133).
+
+  Currently there exist two drivers for UHCI host controllers: this
+  one and the so-called JE driver, which you can get from 
+  "UHCI alternate (JE) support", below. You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI (intel PIIX4, VIA, ...) alternate (JE) support?
+CONFIG_USB_UHCI_ALT
+  The Universal Host Controller Interface is a standard by Intel for
+  accessing the USB hardware in the PC (which is also called the USB
+  host controller). If your USB host controller conforms to this
+  standard, you may want to say Y, but see below. All recent boards
+  with Intel PCI chipsets (like intel 430TX, 440FX, 440LX, 440BX,
+  i810, i820) conform to this standard. Also all VIA PCI chipsets
+  (like VIA VP2, VP3, MVP3, Apollo Pro, Apollo Pro II or Apollo Pro
+  133). If unsure, say Y.
+
+  Currently there exist two drivers for UHCI host controllers: this
+  so-called JE driver, and the one you get from "UHCI support", above.
+  You need only one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uhci.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+UHCI unlink optimizations (EXPERIMENTAL)
+CONFIG_USB_UHCI_ALT_UNLINK_OPTIMIZE
+  This option currently does nothing. You may say Y or N.
+
+OHCI (Compaq, iMacs, OPTi, SiS, ALi, ...) support
+CONFIG_USB_OHCI
+  The Open Host Controller Interface is a standard by
+  Compaq/Microsoft/National for accessing the USB PC hardware (also
+  called USB host controller). If your USB host controller conforms to
+  this standard, say Y. The USB host controllers on most non-Intel
+  architectures and on several x86 compatibles with non-Intel chipsets
+  -- like SiS (aktual 610, 610 and so on) or ALi (ALi IV, ALi V,
+  Aladdin Pro..) -- conform to this standard.
+
+  You may want to read the file Documentation/usb/ohci.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-ohci.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Human Interface Device (full HID) support
+CONFIG_USB_HID
+  Say Y here if you want full HID support to connect keyboards,
+  mice, joysticks, graphic tablets, or any other HID based devices
+  to your computer via USB. You can't use this driver and the
+  HIDBP (Boot Protocol) keyboard and mouse drivers at the same time.
+  More information is available: Documentation/usb/input.txt.
+
+  If unsure, say Y.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called hid.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB HIDBP Keyboard (basic) support
+CONFIG_USB_KBD
+  Say Y here if you don't want to use the generic HID driver for your
+  USB keyboard and prefer to use the keyboard in its limited Boot
+  Protocol mode instead. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbkbd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+USB HIDBP Mouse (basic) support
+CONFIG_USB_MOUSE
+  Say Y here if you don't want to use the generic HID driver for your
+  USB mouse and prefer to use the mouse in its limited Boot Protocol
+  mode instead. This driver is much smaller than the HID one.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbmouse.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+  If unsure, say N.
+
+Wacom Intuos/Graphire tablet support
+CONFIG_USB_WACOM
+  Say Y here if you want to use the USB version of the Wacom Intuos
+  or Graphire tablet. Make sure to say Y to "Mouse support"
+  (CONFIG_INPUT_MOUSEDEV) and/or "Event interface support"
+  (CONFIG_INPUT_EVDEV) as well.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wacom.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Logitech WingMan Force joystick support
+CONFIG_USB_WMFORCE
+  Say Y here if you want to use the Logitech WingMan Force with Linux
+  on the USB port. No force-feedback support yet, but other than that
+  it should work like a normal joystick.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called wmforce.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Use input layer for ADB devices
+CONFIG_INPUT_ADBHID
+  Say Y here if you want to have ADB (Apple Desktop Bus) HID devices
+  such as keyboards, mice, joysticks, or graphic tablets handled by the
+  input layer.  If you say Y here, make sure to say Y to the
+  corresponding drivers "Keyboard support" (CONFIG_INPUT_KEYBDEV),
+  "Mouse Support" (CONFIG_INPUT_MOUSEDEV) and "Event interface support"
+  (CONFIG_INPUT_EVDEV) as well.
+
+  If you say N here, you still have the option of using the old ADB
+  keyboard and mouse drivers.
+
+  If unsure, say Y.
+
+Keyboard support
+CONFIG_INPUT_KEYBDEV
+  Say Y here if you want your USB HID keyboard (or an ADB keyboard
+  handled by the input layer) to be able to serve as a system keyboard.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keybdev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Mouse support
+CONFIG_INPUT_MOUSEDEV
+  Say Y here if you want your USB HID mouse (or ADB mouse handled by
+  the input layer) to be accessible as char devices 13:32+ -
+  /dev/input/mouseX and 13:63 - /dev/input/mice as an emulated ImPS/2
+  mouse.  That way, all user space programs will be able to use your
+  mouse.
+  
+  If unsure, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mousedev.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Horizontal screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_X
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Vertical screen resolution
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y
+  If you're using a digitizer, or a graphic tablet, and want to use
+  it as a mouse then the mousedev driver needs to know the X window
+  screen resolution you are using to correctly scale the data. If
+  you're not using a digitizer, this value is ignored.
+
+Joystick support
+CONFIG_INPUT_JOYDEV
+  Say Y here if you want your USB HID joystick or gamepad to be
+  accessible as char device 13:0+ - /dev/input/jsX device. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called joydev.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Event interface support
+CONFIG_INPUT_EVDEV
+  Say Y here if you want your USB or ADB HID device events be accessible
+  under char device 13:64+ - /dev/input/eventX in a generic way.
+  This is the future ...
+
+USB Scanner support
+CONFIG_USB_SCANNER
+  Say Y here if you want to connect a USB scanner to your computer's
+  USB port. Please read Documentation/usb/scanner.txt and
+  Documentation/usb/scanner-hp-sane.txt for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called scanner.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+USB Audio support
+CONFIG_USB_AUDIO
+  Say Y here if you want to connect UAB audio equipment such as
+  speakers to your computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called audio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Modem (CDC ACM) support
+CONFIG_USB_ACM
+  This driver supports USB modems and ISDN adapters which support the
+  Communication Device Class Abstract Control Model interface.
+  Please read Documentation/usb/acm.txt for details.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acm.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Serial converter support
+CONFIG_USB_SERIAL
+  Say Y here if you have a USB device that provides normal serial
+  ports, and you want to connect it to your USB bus. Supported devices
+  are the Tech WhiteHEAT multi-port USB to serial converter, and the
+  FTDI or Keyspan single port USB to serial converter Handspring
+  Visor. In addition to saying Y here, you need to say Y to the driver
+  for your specific hardware below. Some other devices may also be
+  used if you say Y to "USB Generic Serial Driver", below.
+
+  Please read Documentation/usb/usb-serial.txt for more information.
+  
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usbserial.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Generic Serial Driver
+CONFIG_USB_SERIAL_GENERIC
+  Say Y here if you want to use the generic USB serial driver. Please
+  read Documentation/usb/usb-serial.txt for more information on using
+  this driver. It is recommended that the "USB Serial converter
+  support" be compiled as a module for this driver to be used
+  properly.
+
+USB ConnectTech WhiteHEAT Serial Driver
+CONFIG_USB_SERIAL_WHITEHEAT
+  Say Y here if you want to use a ConnectTech WhiteHEAT 4 port
+  USB to serial converter device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called whiteheat.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Handspring Visor Driver
+CONFIG_USB_SERIAL_VISOR
+  Say Y here if you want to connect to your HandSpring Visor through
+  its USB docking station. See http://usbvisor.sourceforge.net for
+  more information on using this driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called visor.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Belkin and Paracom Single Port Serial Driver
+CONFIG_USB_SERIAL_BELKIN
+  Say Y here if you want to use a Belkin USB Serial single port
+  adaptor (F5U103 is one of the model numbers) or the Peracom single
+  port USB to serial adapter.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called belkin_sa.o.  If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+USB FTDI Single Port Serial Driver
+CONFIG_USB_SERIAL_FTDI_SIO
+  Say Y here if you want to use a FTDI SIO single port USB to serial
+  converter device. The implementation I have is called the USC-1000.
+
+  See http://reality.sgi.com/bryder_wellington/ftdi_sio for more
+  information on this driver and the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ftdi_sio.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan PDA Single Port Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN_PDA
+  Say Y here if you want to use a Keyspan PDA single port USB to
+  serial converter device.  This driver makes use of firmware
+  developed from scratch by Brian Warner.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan_pda.o. If you want to compile it 
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-xxx Serial Driver
+CONFIG_USB_SERIAL_KEYSPAN
+  Say Y here if you want to use Keyspan USB to serial converter
+  devices.  This driver makes use of Keyspan's official firmware
+  and was developed with their support.  You must also include
+  firmware to support your particular device(s). 
+
+  See http://www.linuxcare.com.au/hugh/keyspan.html for 
+  more information.
+ 
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called keyspan.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Keyspan USA-28 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28
+  Say Y here to include firmware for the USA-28 converter.
+
+USB Keyspan USA-28X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA28X
+  Say Y here to include firmware for the USA-28X converter.
+
+USB Keyspan USA-19 Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19
+  Say Y here to include firmware for the USA-19 converter.
+
+USB Keyspan USA-18X Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA18X
+  Say Y here to include firmware for the USA-18X converter.
+
+USB Keyspan USA-19W Firmware
+CONFIG_USB_SERIAL_KEYSPAN_USA19W
+  Say Y here to include firmware for the USA-19W converter.
+
+USB ZyXEL omni.net LCD Plus Driver
+CONFIG_USB_SERIAL_OMNINET
+  Say Y here if you want to use a ZyXEL omni.net LCD ISDN TA.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called omninet.o. If you want to compile it as a 
+  module, say M here and read Documentation/modules.txt.
+
+USB Digi International AccelePort USB Serial Driver
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT
+  Say Y here if you want to use Digi AccelePort USB 2 or 4 devices,
+  2 port (plus parallel port) and 4 port USB serial converters.  The
+  parallel port on the USB 2 appears as a third serial port on Linux.
+  The Digi Acceleport USB 8 is not yet supported by this driver.
+
+  This driver works under SMP with the usb-uhci driver.  It does not
+  work under SMP with the uhci driver.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called digi_acceleport.o. If you want to compile 
+  it as a module, say M here and read Documentation/modules.txt.
+
+USB Empeg empeg-car Mark I/II Driver
+CONFIG_USB_SERIAL_EMPEG
+  Say Y here if you want to connect to your Empeg empeg-car Mark I/II
+  mp3 player via USB.  The driver uses a single ttyUSB{0,1,2,...}
+  device node.  See Documentation/usb/usb-serial.txt for more
+  tidbits of information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called empeg.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB MCT Single Port Serial Driver
+CONFIG_USB_SERIAL_MCT_U232
+  Say Y here if you want to use a USB Serial single port adapter from
+  Magic Control Technology Corp. (U232 is one of the model numbers).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mct_u232.o.  If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+USB Serial Converter verbose debug
+CONFIG_USB_SERIAL_DEBUG
+  Say Y here if you want verbose debug messages from the USB Serial
+  Converter. 
+
+USB Printer support
+CONFIG_USB_PRINTER
+  Say Y here if you want to connect a USB printer to your computer's
+  USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called printer.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB IBM (Xirlink) C-It Camera support
+CONFIG_USB_IBMCAM
+  Say Y here if you want to connect a IBM "C-It" camera, also known as
+  "Xirlink PC Camera" to your computer's USB port. For more
+  information, read Documentation/usb/ibmcam.txt.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ibmcam.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. This camera
+  has several configuration options which can be specified when you
+  load the module. Read Documentation/usb/ibmcam.txt to learn more.
+
+USB OV511 Camera support
+CONFIG_USB_OV511
+  Say Y here if you want to connect this type of camera to your
+  computer's USB port. See Documentation/usb/ov511.txt for more
+  information and for a list of supported cameras.
+  
+  This driver uses the Video For Linux API. You must say Y or M to
+  "Video For Linux" (under Character Devices) to use this driver.
+  Information on this API and pointers to "v4l" programs may be found
+  on the WWW at http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ov511.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB ADMtek Pegasus-based ethernet device support
+CONFIG_USB_PEGASUS
+  Say Y if you want to use your USB ethernet device. Supported
+  cards until now are:
+    ADMtek AN986 Pegasus (eval. board)
+    ADMtek ADM8511 Pegasus II (eval. board)
+    Accton 10/100
+    Billington USB-100
+    Corega FEter USB-TX
+    MELCO/BUFFALO LUA-TX
+    D-Link DSB-650TX, DSB-650TX-PNA, DSB-650, DU-E10, DU-E100
+    Linksys USB100TX, USB10TX
+    LANEED Ethernet LD-USB/TX
+    SMC 202
+    SOHOware NUB Ethernet
+    
+  Any Pegasus II based board also are supported.
+  If you have devices with vendor IDs other than noted above
+  you should add them in the driver code and send a message
+  to me (petkan@dce.bg) for update.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pegasus.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Kodak DC-2xx Camera support
+CONFIG_USB_DC2XX
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port.  See Documentation/usb/dc2xx.txt for more
+  information; some non-Kodak cameras may also work with this
+  driver, given application support (such as www.gPhoto.org).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dc2xx.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mustek MDC800 Digital Camera Support
+CONFIG_USB_MDC800
+  Say Y here if you want to connect this type of still camera to
+  your computer's USB port. This driver can be used with gphoto 0.4.3
+  and higher (look at http://www.gphoto.org ).
+  To use it create a device node with "mknod /dev/mustek c 180 32" and
+  configure it in your software.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mdc800.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage support
+CONFIG_USB_STORAGE
+  Say Y here if you want to connect USB mass storage devices to your
+  computer's USB port.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called usb-storage.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+USB Mass Storage verbose debug
+CONFIG_USB_STORAGE_DEBUG
+  Say Y here in order to have the USB Mass Storage code generate
+  verbose debugging messages.
+
+USS720 parport driver
+CONFIG_USB_USS720
+  This driver is for USB parallel port adapters that use the Lucent
+  Technologies USS-720 chip. These cables are plugged into your USB
+  port and provide USB compatibility to peripherals designed with
+  parallel port interfaces.
+  
+  The chip has two modes: automatic mode and manual mode. In automatic
+  mode, it looks to the computer like a standard USB printer. Only
+  printers may be connected to the USS-720 in this mode. The generic
+  USB printer driver ("USB Printer support", above) may be used in
+  that mode, and you can say N here if you want to use the chip only
+  in this mode.
+
+  Manual mode is not limited to printers, any parallel port
+  device should work. This driver utilizes manual mode.
+  Note however that some operations are three orders of magnitude
+  slower than on a PCI/ISA Parallel Port, so timing critical
+  applications might not work.
+
+  Say Y here if you own an USS-720 USB->Parport cable and intend to
+  connect anything other than a printer to it.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called uss720.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+  
+USB device file system
+CONFIG_USB_DEVICEFS
+  If you say Y here (and to "/proc file system support" below), you
+  will get a file /proc/usb/devices which lists the devices currently
+  connected to your USB busses, a file /proc/usb/drivers which lists
+  the USB kernel client drivers currently loaded, and for every
+  connected device a file named "/proc/usb/xxx/yyy", where xxx is the
+  bus number and yyy the device number; the latter files can be used
+  by user space programs to talk directly to the device. These files
+  are "virtual", meaning they are generated on the fly and not stored
+  on the hard drive.
+  
+  For the format of the /proc/usb/ files, please read
+  Documentation/usb/proc_usb_info.txt. 
+
+  Please note that this code is completely unrelated to devfs, the
+  "/dev file system support".
+
+  Most users want to say Y here.
+
+USB Bandwidth allocation
+CONFIG_USB_BANDWIDTH
+  If you say Y here, the USB subsystem enforces USB bandwidth
+  allocation and will prevent some device opens from succeeding
+  if they would cause USB bandwidth usage to go above 90% of
+  the bus bandwidth.
+
+  If you say N here, these conditions will cause warning messages
+  about USB bandwidth usage to be logged and some devices or
+  drivers may not work correctly.
+
+DABUSB driver
+CONFIG_USB_DABUSB
+  A Digital Audio Broadcasting (DAB) Receiver for USB and Linux
+  brought to you by the DAB-Team (http://dab.in.tum.de). This driver
+  can be taken as an example for URB-based bulk, control, and
+  isochronous transactions. URB's are explained in
+  Documentation/usb/URB.txt.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dabusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+PLUSB driver
+CONFIG_USB_PLUSB
+  A driver for the Prolific PL-2302 USB-to-USB network device. This
+  'USB cable' connects two hosts via a point-to-point network with
+  bandwidth of 5 Mbit/s. Configure this driver after connecting the
+  USB cable via ifconfig plusb0 10.0.0.1 pointopoint 10.0.0.2 (and
+  vice versa on the other host).
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called plusb.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+USB Diamond Rio500 support
+CONFIG_USB_RIO500
+  Say Y here if you want to connect a USB Rio500 mp3 player to your
+  computer's USB port. Please read Documentation/usb/rio.txt
+  for more information.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called rio500.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+D-Link DSB-R100 FM radio support
+CONFIG_USB_DSBR
+  Say Y here if you want to connect this type of radio to your
+  computer's USB port. Note that the audio is not digital, and
+  you must connect the line out connector to a sound card or a
+  set of speakers.
+
+  This driver uses the Video For Linux API.  You must enable
+  (Y or M in config) Video For Linux (under Character Devices)
+  to use this driver.  Information on this API and pointers to
+  "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called dsbr100.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Microtek USB scanner support
+CONFIG_USB_MICROTEK
+  Say Y here if you want support for the Microtek X6USB and possibly
+  some other scanners by that vendor. The scanner will appear as a
+  scsi generic device to the rest of the system.
+  A patched version of SANE is necessary to use the
+  scanner. It's available at 
+  http://fachschaft.cup.uni-muenchen.de/~neukum/scanner.html
+  This driver can be compiled as a module.
+
+USB Bluetooth support
+CONFIG_USB_BLUETOOTH
+  Say Y here if you want to connect a USB Bluetooth device to your
+  computer's USB port. You will need the Bluetooth stack (available
+  at http://developer.axis.com/software/index.shtml) to fully use
+  the device.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called bluetooth.o. If you want to compile it as 
+  a module, say M here and read Documentation/modules.txt.
+  
+Minix fs support
+CONFIG_MINIX_FS
+  Minix is a simple operating system used in many classes about OS's.
+  The minix file system (method to organize files on a hard disk
+  partition or a floppy disk) was the original file system for Linux,
+  but has been superseded by the second extended file system ext2fs.
+  You don't want to use the minix file system on your hard disk
+  because of certain built-in restrictions, but it is sometimes found
+  on older Linux floppy disks. This option will enlarge your kernel by
+  about 28 KB. If unsure, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called minix.o. Note that the file system of your root partition
+  (the one containing the directory /) cannot be compiled as a module.
+
+Second extended fs support
+CONFIG_EXT2_FS
+  This is the de facto standard Linux file system (method to organize
+  files on a storage device) for hard disks. 
+
+  You want to say Y here, unless you intend to use Linux exclusively
+  from inside a DOS partition using the UMSDOS file system. The
+  advantage of the latter is that you can get away without
+  repartitioning your hard drive (which often implies backing
+  everything up and restoring afterwards); the disadvantage is that
+  Linux becomes susceptible to DOS viruses and that UMSDOS is somewhat
+  slower than ext2fs. Even if you want to run Linux in this fashion,
+  it might be a good idea to have ext2fs around: it enables you to
+  read more floppy disks and facilitates the transition to a *real*
+  Linux partition later. Another (rare) case which doesn't require
+  ext2fs is a diskless Linux box which mounts all files over the
+  network using NFS (in this case it's sufficient to say Y to "NFS
+  file system support" below). Saying Y here will enlarge your kernel
+  by about 44 KB.
+
+  The Ext2fs-Undeletion mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , gives information about
+  how to retrieve deleted files on ext2fs file systems.
+
+  To change the behavior of ext2 file systems, you can use the tune2fs
+  utility ("man tune2fs"). To modify attributes of files and
+  directories on ext2 file systems, use chattr ("man chattr").
+  
+  Ext2fs partitions can be read from within DOS using the ext2tool
+  command line tool package (available via FTP (user: anonymous) from
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/ext2 ) and from
+  within Windows NT using the ext2nt command line tool package from
+  ftp://metalab.unc.edu/pub/Linux/utils/dos . Explore2fs is a
+  graphical explorer for ext2fs partitions which runs on Windows 95
+  and Windows NT and includes experimental write support; it is
+  available from
+  http://jnewbigin-pc.it.swin.edu.au/Linux/Explore2fs.htm .
+
+  If you want to compile this file system as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called ext2.o. Be aware however that the file system of your
+  root partition (the one containing the directory /) cannot be
+  compiled as a module, and so this could be dangerous. Most everyone
+  wants to say Y here.
+
+BFS file system support (EXPERIMENTAL)
+CONFIG_BFS_FS
+  Boot File System (BFS) is a file system used under SCO UnixWare to
+  allow the bootloader access to the kernel image and other important
+  files during the boot process. It is usually mounted under /stand
+  and corresponds to the slice marked as "STAND" in the UnixWare
+  partition. You should say Y if you want to read or write
+  the files on your /stand slice from within Linux. You then also 
+  need to say Y to "UnixWare slices support", below. More information
+  about the BFS file system is contained in the file 
+  Documentation/filesystems/bfs.txt. 
+
+  If you don't know what this is about, say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called bfs.o. Note that the file system of your root partition (the
+  one containing the directory /) cannot be compiled as a module.
+
+Compressed ROM file system support
+CONFIG_CRAMFS
+  Saying Y here includes support for CramFs (Compressed ROM File
+  System). Cramfs is designed to be a simple, small, and compressed
+  file system for ROM based embedded systems. CramFs is read-only,
+  limited to 256MB file systems (with 16MB files), and doesn't support
+  16/32 bits uid/gid, hard links and timestamps.
+  
+  See Documentation/filesystems/cramfs.txt and fs/cramfs/README
+  for further information.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called cramfs.o. Note that the root file system (the one containing
+  the directory /) cannot be compiled as a module.
+
+  If unsure, say N.
+   
+Simple RAM-based file system support
+CONFIG_RAMFS
+  Ramfs is a file system which keeps all files in RAM. It allows
+  read and write access.
+
+  In contrast to RAM disks, which get allocated a fixed amount of RAM,
+  ramfs grows and shrinks to accommodate the files it contains.
+
+  Before you can use this RAM-based file system, it has to be mounted,
+  meaning it has to be given a location in the directory hierarchy. If
+  you want to use the location /ramfiles for example, you would have
+  to create that directory first and then mount the file system by
+  saying "mount -t ramfs ramfs /ramfiles" or the equivalent line in
+  /etc/fstab. Everything is "virtual" in the sense that no files will
+  be created on your hard drive; if you reboot, everything in
+  /ramfiles will be lost.
+  
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ramfs.o.
+
+ISO 9660 CDROM file system support
+CONFIG_ISO9660_FS
+  This is the standard file system used on CDROMs. It was previously
+  known as "High Sierra File System" and is called "hsfs" on other
+  Unix systems. The so-called Rock-Ridge extensions which allow for
+  long Unix filenames and symbolic links are also supported by this
+  driver. If you have a CDROM drive and want to do more with it than
+  just listen to audio CDs and watch its LEDs, say Y (and read
+  Documentation/filesystems/isofs.txt and the CDROM-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto ), thereby enlarging
+  your kernel by about 27 KB; otherwise say N.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called isofs.o.
+
+Microsoft Joliet CDROM extensions
+CONFIG_JOLIET
+  Joliet is a Microsoft extension for the ISO 9660 CDROM file system
+  which allows for long filenames in unicode format (unicode is the
+  new 16 bit character code, successor to ASCII, which encodes the
+  characters of almost all languages of the world; see
+  http://www.unicode.org for more information). Say Y here if you want
+  to be able to read Joliet CDROMs under Linux.
+
+UDF File System support (read only)
+CONFIG_UDF_FS
+  This is the new file system used on some CDROMs and DVDs. Say Y if
+  you intend to mount DVD discs or CDRW's written in packet mode, or
+  if written to by other UDF utilities, such as DirectCD. This UDF
+  file system support is read-only. If you want to write to UDF
+  file systems on some media, you need to say Y to "UDF read-write
+  support" below in addition. Please read
+  Documentation/filesystems/udf.txt.
+
+  This file system support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). The module is called udf.o. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say N.
+
+UDF write support (DANGEROUS)
+CONFIG_UDF_RW
+  Say Y if you want to test write support for UDF file systems.
+  Due to lack of support for writing to CDR/CDRW's, this option
+  is only supported for hard discs, DVD-RAM, and loopback files.
+
+DOS FAT fs support
+CONFIG_FAT_FS
+  If you want to use one of the FAT-based file systems (the MS-DOS,
+  VFAT (Windows 95) and UMSDOS (used to run Linux on top of an
+  ordinary DOS partition) file systems), then you must say Y or M here
+  to include FAT support. You will then be able to mount partitions or
+  diskettes with FAT-based file systems and transparently access the
+  files on them, i.e. MSDOS files will look and behave just like all
+  other Unix files.
+
+  This FAT support is not a file system in itself, it only provides
+  the foundation for the other file systems. You will have to say Y or
+  M to at least one of "MSDOS fs support" or "VFAT fs support" in
+  order to make use of it.
+
+  Another way to read and write MSDOS floppies and hard drive
+  partitions from within Linux (but not transparently) is with the
+  mtools ("man mtools") program suite. You don't need to say Y here in
+  order to do that.
+
+  If you need to move large files on floppies between a DOS and a
+  Linux box, say Y here, mount the floppy under Linux with an MSDOS
+  file system and use GNU tar's M option. GNU tar is a program
+  available for Unix and DOS ("man tar" or "info tar").
+  
+  It is now also becoming possible to read and write compressed FAT
+  file systems; read Documentation/filesystems/fat_cvf.txt for
+  details.
+  
+  The FAT support will enlarge your kernel by about 37 KB. If unsure,
+  say Y.
+
+  If you want to compile this as a module however ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called fat.o. Note that if you compile the FAT support as a
+  module, you cannot compile any of the FAT-based file systems into
+  the kernel -- they will have to be modules as well. The file system
+  of your root partition (the one containing the directory /) cannot
+  be a module, so don't say M here if you intend to use UMSDOS as your
+  root file system.
+
+MSDOS fs support
+CONFIG_MSDOS_FS
+  This allows you to mount MSDOS partitions of your hard drive (unless
+  they are compressed; to access compressed MSDOS partitions under
+  Linux, you can either use the DOS emulator DOSEMU, described in the
+  DOSEMU-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , or try dmsdosfs in
+  ftp://metalab.unc.edu/pub/Linux/system/filesystems/dosfs . If you
+  intend to use dosemu with a non-compressed MSDOS partition, say Y
+  here) and MSDOS floppies. This means that file access becomes
+  transparent, i.e. the MSDOS files look and behave just like all
+  other Unix files.
+
+  If you want to use UMSDOS, the Unix-like file system on top of a
+  DOS file system, which allows you to run Linux from within a DOS
+  partition without repartitioning, you'll have to say Y or M here.
+
+  If you have Windows 95 or Windows NT installed on your MSDOS
+  partitions, you should use the VFAT file system (say Y to "VFAT fs
+  support" below), or you will not be able to see the long filenames
+  generated by Windows 95 / Windows NT.
+
+  This option will enlarge your kernel by about 7 KB. If unsure,
+  answer Y. This will only work if you said Y to "DOS FAT fs support"
+  as well. If you want to compile this as a module however ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called msdos.o.
+
+VFAT (Windows-95) fs support
+CONFIG_VFAT_FS
+  This option provides support for normal Windows file systems with
+  long filenames. That includes non-compressed FAT-based file systems
+  used by Windows 95, Windows 98, Windows NT 4.0, and the Unix
+  programs from the mtools package.
+
+  You cannot use the VFAT file system for your Linux root partition
+  (the one containing the directory /); use UMSDOS instead if you
+  want to run Linux from within a DOS partition (i.e. say Y to
+  "UMSDOS: Unix like fs on top of std MSDOS fs", below).
+
+  The VFAT support enlarges your kernel by about 10 KB and it only
+  works if you said Y to the "DOS FAT fs support" above. Please read
+  the file Documentation/filesystems/vfat.txt for details. If unsure,
+  say Y.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called vfat.o.
+
+UMSDOS: Unix-like file system on top of standard MSDOS fs
+CONFIG_UMSDOS_FS
+  Say Y here if you want to run Linux from within an existing DOS
+  partition of your hard drive. The advantage of this is that you can
+  get away without repartitioning your hard drive (which often implies
+  backing everything up and restoring afterwards) and hence you're
+  able to quickly try out Linux or show it to your friends; the
+  disadvantage is that Linux becomes susceptible to DOS viruses and
+  that UMSDOS is somewhat slower than ext2fs. Another use of UMSDOS
+  is to write files with long unix filenames to MSDOS floppies; it
+  also allows Unix-style soft-links and owner/permissions of files on
+  MSDOS floppies. You will need a program called umssync in order to
+  make use of UMSDOS; read Documentation/filesystems/umsdos.txt. 
+
+  To get utilities for initializing/checking UMSDOS file system, or
+  latest patches and/or information, visit the UMSDOS home page at
+  http://www.voyager.hr/~mnalis/umsdos/ .
+
+  This option enlarges your kernel by about 28 KB and it only works if
+  you said Y to both "DOS FAT fs support" and "MSDOS fs support"
+  above. If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called umsdos.o. Note that the file system of your root partition
+  (the one containing the directory /) cannot be a module, so saying M
+  could be dangerous. If unsure, say N.
+
+/proc file system support
+CONFIG_PROC_FS
+  This is a virtual file system providing information about the status
+  of the system. "Virtual" means that it doesn't take up any space on
+  your hard disk: the files are created on the fly by the kernel when
+  you try to access them. Also, you cannot read the files with older
+  version of the program less: you need to use more or cat. 
+
+  It's totally cool; for example, "cat /proc/interrupts" gives
+  information about what the different IRQs are used for at the moment
+  (there is a small number of Interrupt ReQuest lines in your computer
+  that are used by the attached devices to gain the CPU's attention --
+  often a source of trouble if two devices are mistakenly configured
+  to use the same IRQ). The program procinfo to display some
+  information about your system gathered from the /proc file system.
+
+  Before you can use the /proc file system, it has to be mounted,
+  meaning it has to be given a location in the directory hierarchy.
+  That location should be /proc. A command such as "mount -t proc proc
+  /proc" or the equivalent line in /etc/fstab does the job.
+
+  The /proc file system is explained in the file
+  Documentation/filesystems/proc.txt and on the proc(5) manpage ("man
+  5 proc").
+
+  This option will enlarge your kernel by about 67 KB. Several
+  programs depend on this, so everyone should say Y here.
+
+/dev file system support (EXPERIMENTAL)
+CONFIG_DEVFS_FS
+  This is support for devfs, a virtual file system (like /proc) which
+  provides the file system interface to device drivers, normally found
+  in /dev. Devfs does not depend on major and minor number
+  allocations. Device drivers register entries in /dev which then
+  appear automatically, which means that the system administrator does
+  not have to create character and block special device files in the
+  /dev directory using the mknod command (or MAKEDEV script) anymore.
+
+  This is work in progress. If you want to use this, you *must* read
+  the material in Documentation/filesystems/devfs/, especially the
+  file README there.
+
+  If unsure, say N.
+
+Enable automatic mounting at boot
+CONFIG_DEVFS_MOUNT
+  This option appears if you have CONFIG_DEVFS_FS enabled. Setting
+  this to 'Y' will make the kernel automatically mount devfs onto /dev
+  when the system is booted, before the init thread is started.
+  You can override this with the "devfs=nomount" boot option.
+
+  If unsure, say N.
+
+Debug devfs
+CONFIG_DEVFS_DEBUG
+  If you say Y here, then the /dev file system code will generate
+  debugging messages. See the file
+  Documentation/filesystems/devfs/boot-options for more details.
+  
+  If unsure, say N.
+
+NFS file system support
+CONFIG_NFS_FS
+  If you are connected to some other (usually local) Unix computer
+  (using SLIP, PLIP, PPP or Ethernet) and want to mount files residing
+  on that computer (the NFS server) using the Network File Sharing
+  protocol, say Y. "Mounting files" means that the client can access
+  the files with usual UNIX commands as if they were sitting on the
+  client's hard disk. For this to work, the server must run the
+  programs nfsd and mountd (but does not need to have NFS file system
+  support enabled in its kernel). NFS is explained in the Network
+  Administrator's Guide, available from
+  http://www.linuxdoc.org/docs.html#guide , on its man page: "man
+  nfs", and in the NFS-HOWTO.
+  
+  A superior but less widely used alternative to NFS is provided by
+  the Coda file system; see "Coda file system support" below.
+
+  If you say Y here, you should have said Y to TCP/IP networking also.
+  This option would enlarge your kernel by about 27 KB. 
+
+  This file system is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  If you are configuring a diskless machine which will mount its root
+  file system over NFS at boot time, say Y here and to "IP: kernel
+  level autoconfiguration" above and to "Root file system on NFS"
+  below. You cannot compile this driver as a module in this case.
+  There are two packages designed for booting diskless machines over
+  the net: netboot and etherboot, both available via FTP from
+  ftp://metalab.unc.edu/pub/Linux/system/boot/ethernet/ .
+
+  If you don't know what all this is about, say N.
+
+Provide NFSv3 client support (EXPERIMENTAL)
+CONFIG_NFS_V3
+  Say Y here if you want your NFS client to be able to speak the newer
+  version 3 of the NFS protocol. 
+ 
+  If unsure, say N.
+
+Root file system on NFS
+CONFIG_ROOT_NFS
+  If you want your Linux box to mount its whole root file system (the
+  one containing the directory /) from some other computer over the
+  net via NFS (presumably because your box doesn't have a hard disk),
+  say Y. Read Documentation/nfsroot.txt for details. It is likely that
+  in this case, you also want to say Y to "IP: kernel level
+  autoconfiguration" so that your box can discover its network address
+  at boot time.
+  
+  Most people say N here. 
+
+NFS server support
+CONFIG_NFSD
+  If you want your Linux box to act as an NFS *server*, so that other
+  computers on your local network which support NFS can access certain
+  directories on your box transparently, you have two options: you can
+  use the self-contained user space program nfsd, in which case you
+  should say N here, or you can say Y and use the kernel based NFS
+  server. The advantage of the kernel based solution is that it is
+  faster.
+
+  In either case, you will need support software; the respective
+  locations are given in the file Documentation/Changes in the NFS
+  section.
+
+  If you say Y here, you will get support for version 2 of the NFS
+  protocol (NFSv2). If you also want NFSv3, say Y to the next question
+  as well.
+
+  Please read the NFS-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  The NFS server is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called nfsd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Provide NFSv3 server support
+CONFIG_NFSD_V3
+  If you would like to include the NFSv3 server as well as the NFSv2
+  server, say Y here.  If unsure, say Y.
+
+Provide NFS over TCP server support DEVELOPER ONLY
+CONFIG_NFSD_TCP
+  If you are a developer and want to work on fixing problems with
+  NFS server over TCP support, say Y here.  If unsure, say N.
+
+  Some problems can be found by looking for FIXME in net/sunrpc/svcsock.c
+
+OS/2 HPFS file system support
+CONFIG_HPFS_FS
+  OS/2 is IBM's operating system for PC's, the same as Warp, and HPFS
+  is the file system used for organizing files on OS/2 hard disk
+  partitions. Say Y if you want to be able to read files from and
+  write files to an OS/2 HPFS partition on your hard drive. OS/2
+  floppies however are in regular MSDOS format, so you don't need this
+  option in order to be able to read them. Read
+  Documentation/filesystems/hpfs.txt.
+
+  This file system is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called hpfs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+NTFS support (read only)
+CONFIG_NTFS_FS
+  NTFS is the file system of Microsoft Windows NT. Say Y if you want
+  to get read access to files on NTFS partitions of your hard drive.
+  The Linux NTFS driver supports most of the mount options of the VFAT
+  driver, see Documentation/filesystems/ntfs.txt. Saying Y here will
+  give you read-only access to NTFS partitions.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ntfs.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+NTFS write support (DANGEROUS)
+CONFIG_NTFS_RW
+  If you say Y here, you will (maybe) be able to write to NTFS file
+  systems as well as read from them. The read-write support in
+  NTFS is far from being complete and is not well tested. If you
+  say Y here, back up your NTFS volume first since it may get
+  damaged. Also, make sure to run chkdsk from within Microsoft
+  Windows NT after having performed any writes to a NTFS partition
+  from Linux to detect any problems as early as possible.
+  Please note that write support is limited to Windows NT4 and
+  earlier versions.
+
+  If unsure, say N.
+
+System V and Coherent file system support (read only)
+CONFIG_SYSV_FS
+  SCO, Xenix and Coherent are commercial Unix systems for Intel
+  machines. Saying Y here would allow you to read from their floppies
+  and hard disk partitions. If you also want to write to these media,
+  say Y to "SYSV file system write support" below.
+
+  If you have floppies or hard disk partitions like that, it is likely
+  that they contain binaries from those other Unix systems; in order
+  to run these binaries, you will want to install iBCS2 (Intel Binary
+  Compatibility Standard is a kernel module which lets you run SCO,
+  Xenix, Wyse, UnixWare, Dell Unix and System V programs under Linux
+  and is often needed to run commercial software that's only available
+  for those systems. It's available via FTP (user: anonymous) from
+  ftp://tsx-11.mit.edu/pub/linux/BETA ).
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the System V file system support
+  (but you need NFS file system support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar"). Note also that this option has
+  nothing whatsoever to do with the option "System V IPC". Read about
+  the System V file system in Documentation/filesystems/sysv-fs.txt.
+  Saying Y here will enlarge your kernel by about 27 KB.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called sysv.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+SYSV file system write support (DANGEROUS)
+CONFIG_SYSV_FS_WRITE
+  If you say Y here, you will be able to write to hard drive
+  partitions and floppy disks which carry a SYSV file system used the
+  commercial Unixes SCO, Xenix and Coherent. 
+
+  This support is experimental and you may destroy your data. If
+  unsure, say N.
+
+Amiga FFS file system support
+CONFIG_AFFS_FS
+  The Fast File System (FFS) is the common file system used on hard
+  disks by Amiga(tm) systems since AmigaOS Version 1.3 (34.20). Say Y
+  if you want to be able to read and write files from and to an Amiga
+  FFS partition on your hard drive. Amiga floppies however cannot be
+  read with this driver due to an incompatibility of the floppy
+  controller used in an Amiga and the standard floppy controller in
+  PCs and workstations. Read Documentation/filesystems/affs.txt and
+  fs/affs/Changes. 
+
+  With this driver you can also mount disk files used by Bernd
+  Schmidt's Un*X Amiga Emulator (http://www.freiburg.linux.de/~uae/ ).
+  If you want to do this, you will also need to say Y or M to "Loop
+  device support", above.
+
+  This file system is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called affs.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. If unsure, say N.
+
+Apple Macintosh file system support (EXPERIMENTAL)
+CONFIG_HFS_FS
+  If you say Y here, you will be able to mount Macintosh-formatted
+  floppy disks and hard drive partitions with full read-write access.
+  Please read fs/hfs/HFS.txt to learn about the available mount
+  options. 
+
+  This file system support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). The module is called hfs.o. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+ROM file system support
+CONFIG_ROMFS_FS
+  This is a very small read-only file system mainly intended for
+  initial ram disks of installation disks, but it could be used for
+  other read-only media as well. Read
+  Documentation/filesystems/romfs.txt for details. 
+
+  This file system support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). The module is called romfs.o. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt. Note that the file system of your root
+  partition (the one containing the directory /) cannot be a module.
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4 file system support (read only) (EXPERIMENTAL)
+CONFIG_QNX4FS_FS
+  This is the file system used by the operating system QNX 4. Say Y if
+  you intend to mount QNX hard disks or floppies. Unless you say Y to
+  "QNX4FS read-write support" below, you will only be able to read
+  these file systems.
+
+  This file system support is also available as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). The module is called qnx4.o. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If you don't know whether you need it, then you don't need it:
+  answer N.
+
+QNX4FS write support (DANGEROUS)
+CONFIG_QNX4FS_RW
+  Say Y if you want to test write support for QNX4 file systems.
+
+Kernel automounter support
+CONFIG_AUTOFS_FS
+  The automounter is a tool to automatically mount remote file systems
+  on demand. This implementation is partially kernel-based to reduce
+  overhead in the already-mounted case; this is unlike the BSD
+  automounter (amd), which is a pure user space daemon.
+
+  To use the automounter you need the user-space tools from the autofs
+  package; you can find the location in Documentation/Changes. You
+  also want to answer Y to "NFS file system support", below.
+
+  If you want to use the newer version of the automounter with more
+  features, say N here and say Y to "Kernel automounter v4 support",
+  below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called autofs.o. 
+
+  If you are not a part of a fairly large, distributed network, you
+  probably do not need an automounter, and can say N here.
+
+Kernel automounter v4 support
+CONFIG_AUTOFS4_FS
+  The automounter is a tool to automatically mount remote file systems
+  on demand. This implementation is partially kernel-based to reduce
+  overhead in the already-mounted case; this is unlike the BSD
+  automounter (amd), which is a pure user space daemon.
+
+  To use the automounter you need the user-space tools from
+  ftp://ftp.kernel.org/pub/linux/daemons/autofs/testing-v4 ; you also
+  want to answer Y to "NFS file system support", below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called autofs4.o.  You will need to add "alias autofs autofs4" to
+  your modules configuration file.
+
+  If you are not a part of a fairly large, distributed network or
+  don't have a laptop which needs to dynamically reconfigure to the
+  local network, you probably do not need an automounter, and can say
+  N here.
+
+EFS file system support (read-only) (EXPERIMENTAL)
+CONFIG_EFS_FS
+  EFS is an older file system used for non-ISO9660 CDROMs and hard
+  disk partitions by SGI's IRIX operating system (IRIX 6.0 and newer
+  uses the XFS file system for hard disk partitions however).
+
+  This implementation only offers read-only access. If you don't know
+  what all this is about, it's safe to say N. For more information
+  about EFS see its home page at http://aeschi.ch.eu.org/efs/ .
+
+  If you want to compile the EFS file system support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called efs.o. 
+
+Journalling Flash File System (JFFS) support (EXPERIMENTAL)
+CONFIG_JFFS_FS
+  JFFS is a new file system designed for use on flash memory devices
+  rather than on block devices. It was developed on the 2.0 kernel
+  by Axis Communications AB for use on their Linux-based products,
+  and released under GPL, then 'borrowed' and ported to work with 
+  the 2.4 kernel and the new Memory Technology Device system. 
+
+  The 2.4 port is experimental and not yet supported by Axis. Basically,
+  the good bits are probably theirs, and if it's broken in 2.4 it's 
+  probably our fault. See http://www.developer.axis.com/software/jffs/
+  for more information about JFFS.
+
+  Any potential patches or queries should be sent to Axis' mailing 
+  list for JFFS: <jffs-dev@axis.com>
+
+UFS file system support (read-only)
+CONFIG_UFS_FS
+  BSD and derivate versions of Unix (such as SunOS, FreeBSD, NetBSD,
+  OpenBSD and NeXTstep) use a file system called UFS. Some System V
+  Unixes can create and mount hard disk partitions and diskettes using
+  this file system as well. Saying Y here will allow you to read from
+  these partitions; if you also want to write to them, say Y to the
+  experimental "UFS file system write support", below. Please read the
+  file Documentation/filesystems/ufs.txt for more information.
+
+  If you only intend to mount files from some other Unix over the
+  network using NFS, you don't need the UFS file system support (but
+  you need NFS file system support obviously). 
+
+  Note that this option is generally not needed for floppies, since a
+  good portable way to transport files and directories between unixes
+  (and even other operating systems) is given by the tar program ("man
+  tar" or preferably "info tar").
+
+  When accessing NeXTstep files, you may need to convert them from the
+  NeXT character set to the Latin1 character set; use the program
+  recode ("info recode") for this purpose. 
+
+  If you want to compile the UFS file system support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called ufs.o. 
+
+  If you haven't heard about all of this before, it's safe to say N.
+
+UFS file system write support (DANGEROUS)
+CONFIG_UFS_FS_WRITE
+  Say Y here if you want to try writing to UFS partitions. This is
+  experimental, so you should back up your UFS partitions beforehand.
+
+Advanced partition selection
+CONFIG_PARTITION_ADVANCED
+  Say Y here if you would like to use hard disks under Linux which
+  were partitioned under an operating system running on a different
+  architecture than your Linux system.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about foreign partitioning schemes. 
+
+  If unsure, say N.
+
+Alpha OSF partition support
+CONFIG_OSF_PARTITION
+  Say Y here if you would like to use hard disks under Linux which
+  were partitioned on an Alpha machine.
+
+Macintosh partition map support
+CONFIG_MAC_PARTITION
+  Say Y here if you would like to use hard disks under Linux which
+  were partitioned on a Macintosh.
+
+PC BIOS (MSDOS partition tables) support
+CONFIG_MSDOS_PARTITION
+  Say Y here if you would like to use hard disks under Linux which
+  were partitioned on an x86 PC (not necessarily by DOS).
+
+BSD disklabel (FreeBSD partition tables) support
+CONFIG_BSD_DISKLABEL
+  FreeBSD uses its own hard disk partition scheme on your PC. It
+  requires only one entry in the primary partition table of your disk
+  and manages it similarly to DOS extended partitions, putting in its
+  first sector a new partition table in BSD disklabel format. Saying Y
+  here allows you to read these disklabels and further mount FreeBSD
+  partitions from within Linux if you have also said Y to "UFS
+  file system support", above. If you don't know what all this is
+  about, say N.
+
+Sun partition tables support
+CONFIG_SUN_PARTITION
+  Like most systems, SunOS uses its own hard disk partition table
+  format, incompatible with all others. Saying Y here allows you to
+  read these partition tables and further mount SunOS partitions from
+  within Linux if you have also said Y to "UFS file system support",
+  above. This is mainly used to carry data from a SPARC under SunOS to
+  your Linux box via a removable medium like magneto-optical or ZIP
+  drives; note however that a good portable way to transport files and
+  directories between unixes (and even other operating systems) is
+  given by the tar program ("man tar" or preferably "info tar"). If
+  you don't know what all this is about, say N.
+
+Solaris (x86) partition table support
+CONFIG_SOLARIS_X86_PARTITION
+  Like most systems, Solaris x86 uses its own hard disk partition
+  table format, incompatible with all others. Saying Y here allows you
+  to read these partition tables and further mount Solaris x86
+  partitions from within Linux if you have also said Y to "UFS
+  file system support", above.
+
+SGI partition support
+CONFIG_SGI_PARTITION
+  Say Y here if you would like to be able to read the hard disk
+  partition table format used by SGI machines.
+
+ADFS file system support (EXPERIMENTAL)
+CONFIG_ADFS_FS
+  The Acorn Disc Filing System is the standard file system of the
+  RiscOS operating system which runs on Acorn's ARM-based Risc PC
+  systems and the Acorn Archimedes range of machines. If you say Y
+  here, Linux will be able to read from ADFS partitions on hard drives
+  and from ADFS-formatted floppy discs. If you also want to be able to
+  write to those devices, say Y to "ADFS write support" below.
+
+  The ADFS partition should be the first partition (i.e.,
+  /dev/[hs]d?1) on each of your drives. Please read the file
+  Documentation/filesystems/adfs.txt for further details.
+
+  This code is also available as a module called adfs.o ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+  If unsure, say N.
+
+ADFS write support (DANGEROUS)
+CONFIG_ADFS_FS_RW
+  If you say Y here, you will be able to write to ADFS partitions on
+  hard drives and ADFS-formatted floppy disks. This is experimental
+  codes, so if you're unsure, say N.
+
+/dev/pts file system for Unix98 PTYs
+CONFIG_DEVPTS_FS
+  You should say Y here if you said Y to "Unix98 PTY support" above.
+  You'll then get a virtual file system which can be mounted on
+  /dev/pts with "mount -t devpts". This, together with the pseudo
+  terminal master multiplexer /dev/ptmx, is used for pseudo terminal
+  support as described in The Open Group's Unix98 standard: in order
+  to acquire a pseudo terminal, a process opens /dev/ptmx; the number
+  of the pseudo terminal is then made available to the process and the
+  pseudo terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example. 
+
+  The GNU C library glibc 2.1 contains the requisite support for this
+  mode of operation; you also need client programs that use the Unix98
+  API. Please read Documentation/Changes for more information about
+  the Unix98 pty devices.
+
+  Note that the experimental "/dev file system support"
+  (CONFIG_DEVFS_FS)  is a more general facility.
+
+UnixWare slices support (EXPERIMENTAL)
+CONFIG_UNIXWARE_DISKLABEL
+  Like some systems, UnixWare uses its own slice table inside a
+  partition (VTOC - Virtual Table of Contents). Its format is
+  incompatible with all other OSes. Saying Y here allows you to read
+  VTOC and further mount UnixWare partitions read-only from within
+  Linux if you have also said Y to "UFS file system support" or
+  "System V and Coherent file system support", above.
+
+  This is mainly used to carry data from a UnixWare box to your
+  Linux box via a removable medium like magneto-optical, ZIP or
+  removable IDE drives. Note, however, that a good portable way to
+  transport files and directories between unixes (and even other
+  operating systems) is given by the tar program ("man tar" or
+  preferably "info tar"). 
+
+  If you don't know what all this is about, say N.
+
+SMB file system support (to mount Windows shares etc.)
+CONFIG_SMB_FS
+  SMB (Server Message Block) is the protocol Windows for Workgroups
+  (WfW), Windows 95/98, Windows NT and OS/2 Lan Manager use to share
+  files and printers over local networks. Saying Y here allows you to
+  mount their file systems (often called "shares" in this context) and
+  access them just like any other Unix directory. Currently, this
+  works only if the Windows machines use TCP/IP as the underlying
+  transport protocol, and not NetBEUI. For details, read
+  Documentation/filesystems/smbfs.txt and the SMB-HOWTO, available
+  from http://www.linuxdoc.org/docs.html#howto .
+
+  Note: if you just want your box to act as an SMB *server* and make
+  files and printing services available to Windows clients (which need
+  to have a TCP/IP stack), you don't need to say Y here; you can use
+  the program samba (available via FTP (user: anonymous) in
+  ftp://metalab.unc.edu/pub/Linux/system/network/samba ) for that.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html .
+
+  If you want to compile the SMB support as a module ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called smbfs.o. Most people say N, however.
+
+use nls by default
+CONFIG_SMB_NLS_DEFAULT
+  Enabling this will make smbfs use nls translations by default. You
+  need to specify the local charset (CONFIG_NLS_DEFAULT) in the nls
+  settings and you need to give the default nls for the SMB server as
+  CONFIG_SMB_NLS_REMOTE.
+
+  The nls settings can be changed at mount time, if your smbmount
+  supports that, using the codepage and iocharset parameters.
+
+  Currently no smbmount distributed with samba supports this, it is
+  assumed future versions will. In the meantime you can get an
+  unofficial patch for samba 2.0.7 from:
+  http://www.hojdpunkten.ac.se/054/samba/index.html
+
+nls support setting
+CONFIG_SMB_NLS_REMOTE
+  This setting allows you to specify a default value for which
+  codepage the server uses. If this field is left blank no
+  translations will be done by default. The local codepage/charset
+  default to CONFIG_NLS_DEFAULT.
+
+  The nls settings can be changed at mount time, if your smbmount
+  supports that, using the codepage and iocharset parameters.
+
+  Currently no smbmount distributed with samba supports this, it is
+  assumed future versions will. In the meantime you can get an
+  unofficial patch for samba 2.0.7 from:
+  http://www.hojdpunkten.ac.se/054/samba/index.html
+
+Coda file system support (advanced network fs)
+CONFIG_CODA_FS
+  Coda is an advanced network file system, similar to NFS in that it
+  enables you to mount file systems of a remote server and access them
+  with regular Unix commands as if they were sitting on your hard
+  disk. Coda has several advantages over NFS: support for disconnected
+  operation (e.g. for laptops), read/write server replication,
+  security model for authentication and encryption, persistent client
+  caches and write back caching.
+
+  If you say Y here, your Linux box will be able to act as a Coda
+  *client*. You will need user level code as well, both for the client
+  and server. Servers are currently user level, i.e. they need no
+  kernel support. Please read Documentation/filesystems/coda.txt and
+  check out the Coda home page http://www.coda.cs.cmu.edu .
+
+  If you want to compile the coda client support as a module ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called coda.o. 
+
+NCP file system support (to mount NetWare volumes)
+CONFIG_NCP_FS
+  NCP (NetWare Core Protocol) is a protocol that runs over IPX and is
+  used by Novell NetWare clients to talk to file servers. It is to IPX
+  what NFS is to TCP/IP, if that helps. Saying Y here allows you to
+  mount NetWare file server volumes and to access them just like any
+  other Unix directory. For details, please read the file
+  Documentation/filesystems/ncpfs.txt in the kernel source and the
+  IPX-HOWTO from http://www.linuxdoc.org/docs.html#howto .
+
+  You do not have to say Y here if you want your Linux box to act as a
+  file *server* for Novell NetWare clients.
+
+  General information about how to connect Linux, Windows machines and
+  Macs is on the WWW at http://www.eats.com/linux_mac_win.html .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called ncpfs.o. Say N unless you are connected to a Novell network.
+
+Packet signatures
+CONFIG_NCPFS_PACKET_SIGNING
+  NCP allows packets to be signed for stronger security. If you want
+  security, say Y. Normal users can leave it off. To be able to use
+  packet signing you must use ncpfs > 2.0.12.
+
+Proprietary file locking
+CONFIG_NCPFS_IOCTL_LOCKING
+  Allows locking of records on remote volumes. Say N unless you have
+  special applications which are able to utilize this locking scheme.
+
+Clear remove/delete inhibit when needed
+CONFIG_NCPFS_STRONG
+  Allows manipulation of files flagged as Delete or Rename Inhibit. To
+  use this feature you must mount volumes with the ncpmount parameter
+  "-s" (ncpfs-2.0.12 and newer). Say Y unless you are not mounting
+  volumes with -f 444.
+
+Use NFS namespace when available
+CONFIG_NCPFS_NFS_NS
+  Allows you to utilize NFS namespace on NetWare servers. It brings
+  you case sensitive filenames. Say Y. You can disable it at
+  mount-time with the `-N nfs' parameter of ncpmount.
+
+Use OS2/LONG namespace when available
+CONFIG_NCPFS_OS2_NS
+  Allows you to utilize OS2/LONG namespace on NetWare servers.
+  Filenames in this namespace are limited to 255 characters, they are
+  case insensitive, and case in names is preserved. Say Y. You can
+  disable it at mount time with the -N os2 parameter of ncpmount.
+
+Lowercase DOS filenames on LONG namespace volume
+CONFIG_NCPFS_SMALLDOS
+  If you say Y here, every filename on a NetWare server volume using
+  the OS2/LONG namespace and created under DOS or on a volume using
+  DOS namespace will be converted to lowercase characters.
+  Saying N here will give you these filenames in uppercase.
+  
+  This is only a cosmetic option since the OS2/LONG namespace is case
+  insensitive. The only major reason for this option is backward
+  compatibility when moving from DOS to OS2/LONG namespace support.
+  Long filenames (created by Win95) will not be affected.
+
+  This option does not solve the problem that filenames appear
+  differently under Linux and under Windows, since Windows does an
+  additional conversions on the client side. You can achieve similar
+  effects by saying Y to "Allow using of Native Language Support"
+  below.
+
+Allow mounting of volume subdirectories
+CONFIG_NCPFS_MOUNT_SUBDIR
+  Allows you to mount not only whole servers or whole volumes, but
+  also subdirectories from a volume. It can be used to reexport data
+  and so on. There is no reason to say N, so Y is recommended unless
+  you count every byte.
+
+  To utilize this feature you must use ncpfs-2.0.12 or newer.
+
+NDS authentication support
+CONFIG_NCPFS_NDS_DOMAINS
+  This allows storing NDS private keys in kernel space where they
+  can be used to authenticate another server as interserver NDS
+  accesses need it. You must use ncpfs-2.0.12.1 or newer to utilize
+  this feature. Say Y if you are using NDS connections to NetWare
+  servers. Do not say Y if security is primary for you because root
+  can read your session key (from /proc/kcore).
+
+Allow using of Native Language Support
+CONFIG_NCPFS_NLS
+  Allows you to use codepages and I/O charsets for file name
+  translation between the server file system and input/output. This
+  may be useful, if you want to access the server with other operating
+  systems, e.g. Windows 95. See also NLS for more Information.
+
+  To select codepages and I/O charsets use ncpfs-2.2.0.13 or newer.
+
+Symbolic links and mode permission bits
+CONFIG_NCPFS_EXTRAS
+  This enables the use of symbolic links and an execute permission
+  bit on NCPFS. The file server need not have long name space or NFS
+  name space loaded for these to work.
+
+  To use the new attributes, it is recommended to use the flags
+  '-f 600 -d 755' on the ncpmount command line.
+
+nls default codepage
+CONFIG_NLS_DEFAULT
+  The default NLS used when mounting filesystem. Currently, the valid
+  values are:
+  big5, cp437, cp737, cp775, cp850, cp852, cp855, cp857, cp860, cp861,
+  cp862, cp863, cp864, cp865, cp866, cp869, cp874, cp932, cp936,
+  cp949, cp950, euc-jp, euc-kr, gb2312, iso8859-1, iso8859-2, iso8859-3,
+  iso8859-4, iso8859-5, iso8859-6, iso8859-7, iso8859-8, iso8859-9,
+  iso8859-14, iso8859-15, koi8-r, sjis
+  If you specify a wrong value, it will use the built-in NLS; compatible
+  with iso8859-1.
+
+  If unsure, specify it as "iso8859-1".
+
+nls codepage 437
+CONFIG_NLS_CODEPAGE_437
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used in
+  the United States and parts of Canada. This is recommended.
+
+nls codepage 737
+CONFIG_NLS_CODEPAGE_737
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  Greek. If unsure, say N.
+
+nls codepage 775
+CONFIG_NLS_CODEPAGE_775
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored
+  in so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used
+  for the Baltic Rim Languages. If unsure, say N.
+
+nls codepage 850
+CONFIG_NLS_CODEPAGE_850
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage that is used for
+  much of Europe -- United Kingdom, Germany, Spain, Italy, and [add
+  more countries here]. It has some characters useful to many European
+  languages that are not part of the US codepage 437. 
+
+  If unsure, say Y.
+
+nls codepage 852
+CONFIG_NLS_CODEPAGE_852
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the Latin 2 codepage used by DOS
+  for much of Central and Eastern Europe. It has all the required
+  characters for these languages: Albanian, Croatian, Czech, English,
+  Finnish, Hungarian, Irish, German, Polish, Romanian, Serbian (Latin
+  transcription), Slovak, Slovenian, and Sorbian.
+
+nls codepage 855
+CONFIG_NLS_CODEPAGE_855
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Cyrillic.
+
+nls codepage 857
+CONFIG_NLS_CODEPAGE_857
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Turkish.
+
+nls codepage 860
+CONFIG_NLS_CODEPAGE_860
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Portuguese.
+
+nls codepage 861
+CONFIG_NLS_CODEPAGE_861
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Icelandic.
+
+nls codepage 862
+CONFIG_NLS_CODEPAGE_862
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Hebrew.
+
+nls codepage 863
+CONFIG_NLS_CODEPAGE_863
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Canadian
+  French.
+
+nls codepage 864
+CONFIG_NLS_CODEPAGE_864
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Arabic.
+
+nls codepage 865
+CONFIG_NLS_CODEPAGE_865
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for the Nordic
+  European countries.
+
+nls codepage 866
+CONFIG_NLS_CODEPAGE_866
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for
+  Cyrillic/Russian.
+
+nls codepage 869
+CONFIG_NLS_CODEPAGE_869
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Greek.
+
+nls codepage 874
+CONFIG_NLS_CODEPAGE_874
+  The Microsoft FAT file system family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Thai.
+
+nls codepage 932
+CONFIG_NLS_CODEPAGE_932
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Shift-JIS
+  or EUC-JP. To use EUC-JP, you can use 'euc-jp' as mount option or
+  NLS Default value during kernel configuration , instead of 'cp932'
+
+nls codepage 936
+CONFIG_NLS_CODEPAGE_936
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Simplified
+  Chinese(GBK).
+
+nls codepage 949
+CONFIG_NLS_CODEPAGE_949
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for UHC.
+
+nls codepage 950
+CONFIG_NLS_CODEPAGE_950
+  The Microsoft fat filesystem family can deal with filenames in
+  native language character sets. These character sets are stored in
+  so-called DOS codepages. You need to include the appropriate
+  codepage if you want to be able to read/write these filenames on
+  DOS/Windows partitions correctly. This does apply to the filenames
+  only, not to the file contents. You can include several codepages;
+  say Y here if you want to include the DOS codepage for Traditional
+  Chinese(Big5).
+
+nls iso8859-1
+CONFIG_NLS_ISO8859_1
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 1 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Faeroese, Finnish, French, German,
+  Galician, Irish, Icelandic, Italian, Norwegian, Portuguese, Spanish,
+  and Swedish. It is also the default for the US. If unsure, say Y.
+
+nls iso8859-2
+CONFIG_NLS_ISO8859_2
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 2 character
+  set, which works for most Latin-written Slavic and Central European
+  languages: Czech, German, Hungarian, Polish, Rumanian, Croatian,
+  Slovak, Slovene.
+
+nls iso8859-3
+CONFIG_NLS_ISO8859_3
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 3 character
+  set, which is popular with authors of Esperanto, Galician, Maltese,
+  and Turkish.
+
+nls iso8859-4
+CONFIG_NLS_ISO8859_4
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 4 character
+  set which introduces letters for Estonian, Latvian, and
+  Lithuanian. It is an incomplete predecessor of Latin 6.
+
+nls iso8859-5
+CONFIG_NLS_ISO8859_5
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-5, a Cyrillic
+  character set with which you can type Bulgarian, Byelorussian,
+  Macedonian, Russian, Serbian, and Ukrainian. Note that the charset
+  KOI8-R is preferred in Russia.
+
+nls iso8859-6
+CONFIG_NLS_ISO8859_6
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-6, the Arabic
+  character set.
+
+nls iso8859-7
+CONFIG_NLS_ISO8859_7
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-7, the Modern
+  Greek character set.
+
+nls iso8859-8
+CONFIG_NLS_ISO8859_8
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for ISO8859-8, the Hebrew
+  character set.
+
+nls iso8859-9
+CONFIG_NLS_ISO8859_9
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 5 character
+  set, and it replaces the rarely needed Icelandic letters in Latin 1
+  with the Turkish ones. Useful in Turkey.
+
+nls iso8859-10
+CONFIG_NLS_ISO8859_10
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 6 character
+  set, which adds the last Inuit (Greenlandic) and Sami (Lappish)
+  letters that were missing in Latin 4 to cover the entire Nordic
+  area.
+
+NLS ISO 8859-14 (Latin 8; Celtic)
+CONFIG_NLS_ISO8859_14
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 8 character
+  set, which adds the last accented vowels for Welsh (aka Cymraeg)
+  (and Manx Gaelic) hat were missing in Latin 1.
+  http://linux.speech.cymru.org/ has further information.
+
+nls iso8859-15
+CONFIG_NLS_ISO8859_15
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the Latin 9 character
+  set, which covers most West European languages such as Albanian,
+  Catalan, Danish, Dutch, English, Estonian, Faeroese, Finnish,
+  French, German, Galician, Irish, Icelandic, Italian, Norwegian,
+  Portuguese, Spanish, and Swedish. Latin 9 is an update to
+  Latin 1 (ISO 8859-1) that removes a handful of rarely used
+  characters and instead adds support for Estonian, corrects the
+  support for French and Finnish, and adds the new Euro character.  If
+  unsure, say Y.
+
+nls koi8-r
+CONFIG_NLS_KOI8_R
+  If you want to display filenames with native language characters
+  from the Microsoft FAT file system family or from JOLIET CDROMs
+  correctly on the screen, you need to include the appropriate
+  input/output character sets. Say Y here for the preferred Russian
+  character set.
+
+Virtual terminal
+CONFIG_VT
+  If you say Y here, you will get support for terminal devices with
+  display and keyboard devices. These are called "virtual" because you
+  can run several virtual terminals (also called virtual consoles) on
+  one physical terminal. This is rather useful, for example one
+  virtual terminal can collect system messages and warnings, another
+  one can be used for a text-mode user session, and a third could run
+  an X session, all in parallel. Switching between virtual terminals
+  is done with certain key combinations, usually Alt-<function key>.
+
+  The setterm command ("man setterm") can be used to change the
+  properties (such as colors or beeping) of a virtual terminal. The
+  man page console_codes(4) ("man console_codes") contains the special
+  character sequences that can be used to change those properties
+  directly. The fonts used on virtual terminals can be changed with
+  the setfont ("man setfont") command and the key bindings are defined
+  with the loadkeys ("man loadkeys") command.
+
+  You need at least one virtual terminal device in order to make use
+  of your keyboard and monitor. Therefore, only people configuring an
+  embedded system would want to say N here in order to save some
+  memory; the only way to log into such a system is then via a serial
+  or network connection.
+
+  If unsure, say Y, or else you won't be able to do much with your new
+  shiny Linux system :-)
+
+Support for console on virtual terminal
+CONFIG_VT_CONSOLE
+  The system console is the device which receives all kernel messages
+  and warnings and which allows logins in single user mode. If you
+  answer Y here, a virtual terminal (the device used to interact with
+  a physical terminal) can be used as system console. This is the most
+  common mode of operations, so you should say Y here unless you want
+  the kernel messages be output only to a serial port (in which case
+  you should say Y to "Console on serial port", below).
+
+  If you do say Y here, by default the currently visible virtual
+  terminal (/dev/tty0) will be used as system console. You can change
+  that with a kernel command line option such as "console=tty3" which
+  would use the third virtual terminal as system console. (Try "man
+  bootparam" or see the documentation of your boot loader (lilo or
+  loadlin) about how to pass options to the kernel at boot time.)
+
+  If unsure, say Y.
+
+Support for PowerMac keyboard
+CONFIG_MAC_KEYBOARD
+  This option allows you to use an ADB keyboard attached to your
+  machine. Note that this disables any other (ie. PS/2) keyboard
+  support, even if your machine is physically capable of using both at
+  the same time.
+  
+  If you use an ADB keyboard (4 pin connector), say Y here.
+  If you use a PS/2 keyboard (6 pin connector), say N here.
+
+Standard/generic serial support
+CONFIG_SERIAL
+  This selects whether you want to include the driver for the standard
+  serial ports. The standard answer is Y. People who might say N here
+  are those that are setting up dedicated Ethernet WWW/FTP servers, or
+  users that have one of the various bus mice instead of a serial
+  mouse and don't intend to use their machine's standard serial port
+  for anything. (Note that the Cyclades and Stallion multi serial port
+  drivers do not need this driver built in for them to work.)
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called serial.o.
+  [WARNING: Do not compile this driver as a module if you are using
+  non-standard serial ports, since the configuration information will
+  be lost when the driver is unloaded. This limitation may be lifted
+  in the future.]
+
+  BTW1: If you have a mouseman serial mouse which is not recognized by
+  the X window system, try running gpm first. 
+  
+  BTW2: If you intend to use a software modem (also called Winmodem)
+  under Linux, forget it. These modems are crippled and require
+  proprietary drivers which are only available under Windows.
+
+  Most people will say Y or M here, so that they can use serial mice,
+  modems and similar devices connecting to the standard serial ports.
+
+Support for console on serial port
+CONFIG_SERIAL_CONSOLE
+  If you say Y here, it will be possible to use a serial port as the
+  system console (the system console is the device which receives all
+  kernel messages and warnings and which allows logins in single user
+  mode). This could be useful if some terminal or printer is connected
+  to that serial port.
+
+  Even if you say Y here, the currently visible virtual console
+  (/dev/tty0) will still be used as the system console by default, but
+  you can alter that using a kernel command line option such as
+  "console=ttyS1". (Try "man bootparam" or see the documentation of
+  your boot loader (lilo or loadlin) about how to pass options to the
+  kernel at boot time.)
+
+  If you don't have a VGA card installed and you say Y here, the
+  kernel will automatically use the first serial line, /dev/ttyS0, as
+  system console.
+
+  If unsure, say N.
+
+Support for PowerMac serial ports
+CONFIG_MAC_SERIAL
+  If you have Macintosh style serial ports (8 pin mini-DIN), say Y
+  here. If you also have regular serial ports and enable the driver
+  for them, you can't currently use the serial console feature.
+
+Comtrol Rocketport support
+CONFIG_ROCKETPORT
+  This is a driver for the Comtrol Rocketport cards which provide
+  multiple serial ports. You would need something like this to connect
+  more than two modems to your Linux box, for instance in order to
+  become a dial-in server.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called rocket.o.
+
+Digiboard Intelligent async support
+CONFIG_DIGIEPCA
+  This is a driver for Digi International's Xx, Xeve, and Xem series
+  of cards which provide multiple serial ports. You would need
+  something like this to connect more than two modems to your Linux
+  box, for instance in order to become a dial-in server. This driver
+  supports the original PC (ISA) boards as well as PCI, and EISA. If
+  you have a card like this, say Y here and read the file
+  Documentation/digiepca.txt.
+
+  NOTE: There is another, separate driver for the Digiboard PC boards:
+  "Digiboard PC/Xx Support" below. You should (and can) only select
+  one of the two drivers. 
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called epca.o.
+
+Digiboard PC/Xx Support
+CONFIG_DIGI
+  This is a driver for the Digiboard PC/Xe, PC/Xi, and PC/Xeve cards
+  that give you many serial ports. You would need something like this
+  to connect more than two modems to your Linux box, for instance in
+  order to become a dial-in server. If you have a card like that, say
+  Y here and read the file Documentation/digiboard.txt.
+
+  If you want to compile this driver as a module, say M here and read
+  Documentation/modules.txt. The module will be called pcxx.o.
+
+SDL RISCom/8 card support
+CONFIG_RISCOM8
+  This is a driver for the SDL Communications RISCom/8 multiport card,
+  which gives you many serial ports. You would need something like
+  this to connect more than two modems to your Linux box, for instance
+  in order to become a dial-in server. If you have a card like that,
+  say Y here and read the file Documentation/riscom8.txt.
+
+  Also it's possible to say M here and compile this driver as kernel
+  loadable module; the module will be called riscom8.o.
+
+Computone IntelliPort Plus serial support
+CONFIG_COMPUTONE
+  This driver supports the entire family of Intelliport II/Plus
+  controllers with the exception of the MicroChannel controllers and 
+  products previous to the Intelliport II. These are multiport cards,
+  which give you many serial ports. You would need something like 
+  this to connect more than two modems to your Linux box, for 
+  instance in order to become a dial-in server. If you have a
+  card like that, say Y here and read Documentation/computone.txt.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. You will get two
+  modules called ip2.o and ip2main.o.
+
+Specialix IO8+ card support
+CONFIG_SPECIALIX
+  This is a driver for the Specialix IO8+ multiport card (both the
+  ISA and the PCI version) which gives you many serial ports. You 
+  would need something like this to connect more than two modems to 
+  your Linux box, for instance in order to become a dial-in server.
+
+  If you have a card like that, say Y here and read the file
+  Documentation/specialix.txt. Also it's possible to say M here and
+  compile this driver as kernel loadable module which will be called
+  specialix.o.
+
+Specialix DTR/RTS pin is RTS
+CONFIG_SPECIALIX_RTSCTS
+  The Specialix card can only support either RTS or DTR. If you say N
+  here, the driver will use the pin as "DTR" when the tty is in
+  software handshake mode. If you say Y here or hardware handshake is
+  on, it will always be RTS. Read the file Documentation/specialix.txt
+  for more information.
+
+Cyclades async mux support
+CONFIG_CYCLADES
+  This is a driver for a card that gives you many serial ports. You
+  would need something like this to connect more than two modems to
+  your Linux box, for instance in order to become a dial-in server.
+  For information about the Cyclades-Z card, read
+  drivers/char/README.cycladesZ.
+
+  As of 1.3.9x kernels, this driver's minor numbers start at 0 instead
+  of 32.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called cyclades.o. 
+
+  If you haven't heard about it, it's safe to say N.
+
+Cyclades-Z interrupt mode operation (EXPERIMENTAL)
+CONFIG_CYZ_INTR
+  The Cyclades-Z family of multiport cards allows 2 (two) driver op
+  modes: polling and interrupt. In polling mode, the driver will check
+  the status of the Cyclades-Z ports every certain amount of time
+  (which is called polling cycle and is configurable). In interrupt
+  mode, it will use an interrupt line (IRQ) in order to check the
+  status of the Cyclades-Z ports. The default op mode is polling. If
+  unsure, say N.
+
+Stallion multiport serial support 
+CONFIG_STALDRV
+  Stallion cards give you many serial ports. You would need something
+  like this to connect more than two modems to your Linux box, for
+  instance in order to become a dial-in server. If you say Y here, you
+  will be asked for your specific card model in the next questions.
+  Make sure to read drivers/char/README.stallion in this case. If you
+  have never heard about all this, it's safe to say N.
+
+Stallion EasyIO or EC8/32 support 
+CONFIG_STALLION
+  If you have an EasyIO or EasyConnection 8/32 multiport Stallion
+  card, then this is for you; say Y. Make sure to read
+  Documentation/stallion.txt. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called stallion.o.
+
+Stallion EC8/64, ONboard, Brumby support
+CONFIG_ISTALLION
+  If you have an EasyConnection 8/64, ONboard, Brumby or Stallion
+  serial multiport card, say Y here. Make sure to read
+  Documentation/stallion.txt. 
+
+  To compile it as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt. The module will be called
+  istallion.o.
+
+Microgate SyncLink adapter support
+CONFIG_SYNCLINK
+  Provides support for the SyncLink ISA and PCI
+  multiprotocol serial adapters. These adapters
+  support asynchronous and HDLC bit synchronous
+  communication up to 10Mbps (PCI adapter).
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called synclink.o. If you want to do that, say M
+  here.
+
+Synchronous HDLC line discipline support
+CONFIG_N_HDLC
+  Allows synchronous HDLC communications with tty device drivers that
+  support synchronous HDLC such as the Microgate SyncLink adapter.
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called n_hdlc.o. If you want to do that, say M
+  here.
+
+Specialix SX (and SI) card support
+CONFIG_SX
+  This is a driver for the SX and SI multiport serial cards.
+  Please read the file Documentation/sx.txt for details.
+
+  This driver can only be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sx.o. If you want to do that, say M here.
+
+Hayes ESP serial port support
+CONFIG_ESPSERIAL
+  This is a driver which supports Hayes ESP serial ports. Both single
+  port cards and multiport cards are supported. Make sure to read
+  Documentation/hayes-esp.txt. 
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called esp.o.
+  If unsure, say N.
+
+Moxa Intellio support
+CONFIG_MOXA_INTELLIO
+  Say Y here if you have a Moxa Intellio multiport serial card.
+
+  This driver can also be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called moxa.o. If you want to do that, say M
+  here.
+
+Moxa SmartIO support
+CONFIG_MOXA_SMARTIO
+  Say Y here if you have a Moxa SmartIO multiport serial card.
+
+  This driver can also be built as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called mxser.o. If you want to do that, say M
+  here.
+
+Multi-Tech multiport card support (EXPERIMENTAL)
+CONFIG_ISI
+  This is a driver for the Multi-Tech cards which provide several
+  serial ports. The driver is experimental and can currently only be
+  built as a module ( = code which can be inserted in and removed from
+  the running kernel whenever you want). Please read
+  Documentation/modules.txt. The module will be called isicom.o
+
+Unix98 PTY support
+CONFIG_UNIX98_PTYS
+  A pseudo terminal (PTY) is a software device consisting of two
+  halves: a master and a slave. The slave device behaves identical to
+  a physical terminal; the master device is used by a process to
+  read data from and write data to the slave, thereby emulating a
+  terminal. Typical programs for the master side are telnet servers
+  and xterms.
+  
+  Linux has traditionally used the BSD-like names /dev/ptyxx for
+  masters and /dev/ttyxx for slaves of pseudo terminals. This scheme
+  has a number of problems. The GNU C library glibc 2.1 and later,
+  however, supports the Unix98 naming standard: in order to acquire a
+  pseudo terminal, a process opens /dev/ptmx; the number of the pseudo
+  terminal is then made available to the process and the pseudo
+  terminal slave can be accessed as /dev/pts/<number>. What was
+  traditionally /dev/ttyp2 will then be /dev/pts/2, for example.
+
+  The entries in /dev/pts/ are created on the fly by a virtual
+  file system; therefore, if you say Y here you should say Y to
+  "/dev/pts file system for Unix98 PTYs" as well.
+
+  If you want to say Y here, you need to have the C library glibc 2.1
+  or later (equal to libc-6.1, check with "ls -l /lib/libc.so.*").
+  Read the instructions in Documentation/Changes pertaining to pseudo
+  terminals. It's safe to say N.
+
+Maximum number of Unix98 PTYs in use (0-2048)
+CONFIG_UNIX98_PTY_COUNT
+  The maximum number of Unix98 PTYs that can be used at any one time.
+  The default is 256, and should be enough for desktop systems. Server
+  machines which support incoming telnet/rlogin/ssh connections and/or
+  serve several X terminals may want to increase this: every incoming
+  connection and every xterm uses up one PTY.
+
+  When not in use, each additional set of 256 PTYs occupy
+  approximately 8 KB of kernel memory on 32-bit architectures.
+
+Parallel printer support
+CONFIG_PRINTER
+  If you intend to attach a printer to the parallel port of your Linux
+  box (as opposed to using a serial printer; if the connector at the
+  printer has 9 or 25 holes ["female"], then it's serial), say Y. Also
+  read the Printing-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  It is possible to share one parallel port among several devices
+  (e.g. printer and ZIP drive) and it is safe to compile the
+  corresponding drivers into the kernel. If you want to compile this
+  driver as a module however ( = code which can be inserted in and
+  removed from the running kernel whenever you want), say M here and
+  read Documentation/modules.txt and Documentation/parport.txt. The 
+  module will be called lp.o. 
+
+  If you have several parallel ports, you can specify which ports to
+  use with the "lp" kernel command line option. (Try "man bootparam"
+  or see the documentation of your boot loader (lilo or loadlin) about
+  how to pass options to the kernel at boot time.) The syntax of the
+  "lp" command line option can be found in drivers/char/lp.c.
+
+  If you have more than 3 printers, you need to increase the LP_NO
+  variable in lp.c.
+
+Support for console on line printer
+CONFIG_LP_CONSOLE
+  If you want kernel messages to be printed out as they occur, you
+  can have a console on the printer. This option adds support for
+  doing that; to actually get it to happen you need to pass the
+  option "console=lp0" to the kernel at boot time.
+
+  Note that kernel messages can get lost if the printer is out of
+  paper (or off, or unplugged, or too busy..), but this behaviour
+  can be changed. See drivers/char/lp.c (do this at your own risk).
+
+  If unsure, say N.
+
+Support for user-space parallel port device drivers
+CONFIG_PPDEV
+  Saying Y to this adds support for /dev/parport device nodes.  This
+  is needed for programs that want portable access to the parallel
+  port, for instance deviceid (which displays Plug-and-Play device
+  IDs).
+
+  This is the parallel port equivalent of SCSI generic support (sg).
+  It is safe to say N to this -- it is not needed for normal printing
+  or parallel port CD-ROM/disk support.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called ppdev.o.
+
+  If unsure, say N.
+
+I2C support
+CONFIG_I2C
+  I2C (pronounce: I-square-C) is a slow serial bus protocol used in
+  many micro controller applications and developed by Philips. SMBus,
+  or System Management Bus is a subset of the I2C protocol. More
+  information is contained in the directory Documentation/i2c/,
+  especially in the file called "summary" there.
+
+  Both I2C and SMBus are supported here. You will need this for
+  hardware sensors support, and also for Video for Linux support.
+  Specifically, if you want to use a BT848 based frame grabber/overlay
+  boards under Linux, say Y here and also to "I2C bit-banging
+  interfaces", below.
+
+  If you want I2C support, you should say Y here and also to the
+  specific driver for your bus adapter(s) below. If you say Y to
+  "/proc file system" below, you will then get a /proc interface which
+  is documented in Documentation/i2c/proc-interface.
+
+  This I2C support is also available as a module. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called i2c-core.o.
+
+I2C bit-banging interfaces
+CONFIG_I2C_ALGOBIT
+  This allows you to use a range of I2C adapters called bit-banging
+  adapters. Say Y if you own an I2C adapter belonging to this class
+  and then say Y to the specific driver for you adapter below.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-algo-bit.o.
+
+Philips style parallel port adapter
+CONFIG_I2C_PHILIPSPAR
+  This supports parallel-port I2C adapters made by Philips. Say Y if
+  you own such an adapter.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-philips-par.o.
+
+  Note that if you want support for different parallel port devices,
+  life will be much easier if you compile them all as modules.
+
+ELV adapter
+CONFIG_I2C_ELV
+  This supports parallel-port I2C adapters called ELV. Say Y if you
+  own such an adapter.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-elv.o.
+
+Velleman K9000 adapter
+CONFIG_I2C_VELLEMAN
+  This supports the Velleman K9000 parallel-port I2C adapter. Say Y if
+  you own such an adapter.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-velleman.o.
+
+I2C PCF 8584 interfaces
+CONFIG_I2C_ALGOPCF
+  This allows you to use a range of I2C adapters called PCF adapters.
+  Say Y if you own an I2C adapter belonging to this class and then say
+  Y to the specific driver for you adapter below.
+
+  This support is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-algo-pcf.o.
+
+Elektor ISA card
+CONFIG_I2C_ELEKTOR
+  This supports the PCF8584 ISA bus I2C adapter. Say Y if you own such
+  an adapter.
+
+  This driver is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-elektor.o.
+
+I2C device interface
+CONFIG_I2C_CHARDEV
+  Say Y here to use i2c-* device files, usually found in the /dev
+  directory on your system. They make it possible to have user-space
+  programs use the I2C bus. Information on how to do this is contained
+  in the file Documentation/i2c/dev-interface.
+
+  This code is also available as a module. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt. The
+  module will be called i2c-dev.o.
+
+Bus Mouse Support
+CONFIG_BUSMOUSE
+  Say Y here if your machine has a bus mouse as opposed to a serial
+  mouse. Most people have a regular serial MouseSystem or
+  Microsoft mouse (made by Logitech) that plugs into a COM port
+  (rectangular with 9 or 25 pins). These people say N here. If you
+  have something else, read the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto , and say Y here.
+
+  If you have a laptop, you either have to check the documentation or
+  experiment a bit to find out whether the trackball is a serial mouse
+  or not; it's best to say Y here for you. 
+
+  This is the generic bus mouse driver code. If you have a bus mouse,
+  you will have to say Y here and also to the specific driver for your
+  mouse below.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called busmouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Mouse Support (not serial and bus mice)
+CONFIG_MOUSE
+  This is for machines with a mouse which is neither a serial nor a
+  bus mouse. Examples are PS/2 mice (such as the track balls on some
+  laptops) and some digitizer pads. Most people have a regular serial
+  MouseSystem or Microsoft mouse (made by Logitech) that plugs into a
+  COM port (rectangular with 9 or 25 pins). These people say N here.
+  If you have something else, read the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . This HOWTO contains
+  information about all non-serial mice, not just bus mice.
+
+  If you have a laptop, you either have to check the documentation or
+  experiment a bit to find out whether the trackball is a serial mouse
+  or not; it's best to say Y here for you. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about non-serial mice. If unsure, say Y.
+
+Logitech busmouse support
+CONFIG_LOGIBUSMOUSE
+  Logitech mouse connected to a proprietary interface card. It's
+  generally a round connector with 9 pins. Note that the newer mice
+  made by Logitech don't use the Logitech protocol anymore; for those,
+  you don't need this option. You want to read the Busmouse-HOWTO ,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called busmouse.o. If you are unsure, say N and read the HOWTO
+  nevertheless: it will tell you what you have.
+
+PS/2 mouse (aka "auxiliary device") support
+CONFIG_PSMOUSE
+  The PS/2 mouse connects to a special mouse port that looks much like
+  the keyboard port (small circular connector with 6 pins). This way,
+  the mouse does not use any serial ports. This port can also be used
+  for other input devices like light pens, tablets, keypads. Compaq,
+  AST and IBM all use this as their mouse port on currently shipping
+  machines. The trackballs of some laptops are PS/2 mice also. In
+  particular, the C&T 82C710 mouse on TI Travelmates is a PS/2 mouse.
+
+  Although PS/2 mice are not technically bus mice, they are explained
+  in detail in the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  When using a PS/2 mouse, you can get problems if you want to use the
+  mouse both on the Linux console and under X. Using the "-R" option
+  of the Linux mouse managing program gpm (available from
+  ftp://metalab.unc.edu/pub/Linux/system/mouse ) solves this
+  problem, or you can get the "mconv2" utility from the same location.
+
+C&T 82C710 mouse port support (as on TI Travelmate)
+CONFIG_82C710_MOUSE
+  This is a certain kind of PS/2 mouse used on the TI Travelmate. If
+  you are unsure, try first to say N here and come back if the mouse
+  doesn't work. Read the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+PC110 digitizer pad support
+CONFIG_PC110_PAD
+  This drives the digitizer pad on the IBM PC110 palmtop. It can turn
+  the digitizer pad into a PS/2 mouse emulation with tap gestures or
+  into an absolute pad.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pc110pad.o.
+
+Microsoft busmouse support
+CONFIG_MS_BUSMOUSE
+  These animals (also called Inport mice) are connected to an
+  expansion board using a round connector with 9 pins. If this is what
+  you have, say Y and read the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have. Also be aware that several vendors talk
+  about 'Microsoft busmouse' and actually mean PS/2 busmouse -- so
+  count the pins on the connector.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called msbusmouse.o. 
+
+Apple Desktop Bus mouse support
+CONFIG_ADBMOUSE
+  Say Y here if you have this type of bus mouse (4 pin connector) as
+  is common on Macintoshes. You may want to read the Busmouse-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called adbmouse.o.
+
+ATIXL busmouse support
+CONFIG_ATIXL_BUSMOUSE
+  This is a rare type of busmouse that is connected to the back of an
+  ATI video card. Say Y if you have one of those. Note however that
+  most mice by ATI are actually Microsoft busmice; you should say Y to
+  "Microsoft busmouse support" above if you have one of those. Read
+  the Busmouse-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called atixlmouse.o. 
+
+  If you are unsure, say N and read the HOWTO nevertheless: it will
+  tell you what you have.
+
+QIC-02 tape support
+CONFIG_QIC02_TAPE
+  If you have a non-SCSI tape drive like that, say Y. Or, if you want
+  to compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  tpqic02.o.
+
+Do you want runtime configuration for QIC-02
+CONFIG_QIC02_DYNCONF
+  You can either configure this driver once and for all by editing a
+  header file (include/linux/tpqic02.h), in which case you should
+  say N, or you can fetch a program via anonymous FTP which is able
+  to configure this driver during runtime. The program to do this is
+  called 'qic02conf' and it is part of the tpqic02-support-X.Y.tar.gz
+  support package.
+
+  If you want to use the qic02conf program, say Y.
+
+Floppy tape drive (QIC-80/40/3010/3020/TR-1/TR-2/TR-3) support
+CONFIG_FTAPE
+  If you have a tape drive that is connected to your floppy
+  controller, say Y here. 
+
+  Some tape drives (like the Seagate "Tape Store 3200" or the Iomega
+  "Ditto 3200" or the Exabyte "Eagle TR-3") come with a "high speed"
+  controller of their own. These drives (and their companion
+  controllers) are also supported if you say Y here. 
+
+  If you have a special controller (such as the CMS FC-10, FC-20,
+  Mountain Mach-II, or any controller that is based on the Intel 82078
+  FDC like the high speed controllers by Seagate and Exabyte and
+  Iomega's "Ditto Dash") you must configure it by selecting the
+  appropriate entries from the "Floppy tape controllers" sub-menu
+  below and possibly modify the default values for the IRQ and DMA
+  channel and the IO base in ftape's configuration menu. 
+
+  If you want to use your floppy tape drive on a PCI-bus based system,
+  please read the file drivers/char/ftape/README.PCI. 
+
+  The ftape kernel driver is also available as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. The module
+  will be called ftape.o. 
+
+  Note that the Ftape-HOWTO is out of date (sorry) and documents the
+  older version 2.08 of this software but still contains useful
+  information. There is a web page with more recent documentation at
+  http://www.math1.rwth-aachen.de/~heine/ftape/ . This page
+  always contains the latest release of the ftape driver and useful
+  information (backup software, ftape related patches and
+  documentation, FAQ). Note that the file system interface has changed
+  quite a bit compared to previous versions of ftape. Please read
+  Documentation/ftape.txt.
+
+The file system interface for ftape
+CONFIG_ZFTAPE
+  Normally, you want to say Y or M. DON'T say N here or you
+  WON'T BE ABLE TO USE YOUR FLOPPY TAPE DRIVE.
+
+  The ftape module itself no longer contains the routines necessary
+  to interface with the kernel VFS layer (i.e. to actually write data
+  to and read data from the tape drive). Instead the file system
+  interface (i.e. the hardware independent part of the driver) has
+  been moved to a separate module.
+
+  If you say M zftape will be compiled as a runtime loadable
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). In this case you should read
+  Documentation/modules.txt. The module will be called zftape.o.
+
+  Regardless of whether you say Y or M here, an additional runtime
+  loadable module called `zft-compressor.o' which contains code to
+  support user transparent on-the-fly compression based on Ross
+  William's lzrw3 algorithm will be produced. If you have enabled the
+  kernel module loader (i.e. have said Y to "Kernel module loader
+  support", above) then `zft-compressor.o' will be loaded
+  automatically by zftape when needed.
+
+  Despite its name, zftape does NOT use compression by default. The
+  file Documentation/ftape.txt contains a short description of the
+  most important changes in the file system interface compared to
+  previous versions of ftape. The ftape home page
+  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ contains
+  further information.
+
+  IMPORTANT NOTE: zftape can read archives created by previous
+  versions of ftape and provide file mark support (i.e. fast skipping
+  between tape archives) but previous version of ftape will lack file
+  mark support when reading archives produced by zftape.
+
+Default block size for zftape
+CONFIG_ZFT_DFLT_BLK_SZ
+  If unsure leave this at its default value, i.e. 10240. Note that
+  you specify only the default block size here. The block size can be
+  changed at run time using the MTSETBLK tape operation with the
+  MTIOCTOP ioctl (i.e. with "mt -f /dev/qft0 setblk #BLKSZ" from the
+  shell command line).
+
+  The probably most striking difference between zftape and previous
+  versions of ftape is the fact that all data must be written or read
+  in multiples of a fixed block size. The block size defaults to
+  10240 which is what GNU tar uses. The values for the block size
+  should be either 1 or multiples of 1024 up to a maximum value of
+  63488 (i.e. 62 K). If you specify `1' then zftape's builtin
+  compression will be disabled.
+
+  Reasonable values are `10240' (GNU tar's default block size),
+  `5120' (afio's default block size), `32768' (default block size some
+  backup programs assume for SCSI tape drives) or `1' (no restriction
+  on block size, but disables builtin compression).
+
+Number of DMA buffers
+CONFIG_FT_NR_BUFFERS
+  Please leave this at `3' unless you REALLY know what you are doing.
+  It is not necessary to change this value. Values below 3 make the
+  proper use of ftape impossible, values greater than 3 are a waste of
+  memory. You can change the amount of DMA memory used by ftape at
+  runtime with "mt -f /dev/qft0 setdrvbuffer #NUMBUFFERS". Each buffer
+  wastes 32 KB of memory. Please note that this memory cannot be
+  swapped out.
+
+Procfs entry for ftape
+CONFIG_FT_PROC_FS
+  Optional. Saying Y will result in creation of a directory
+  `/proc/ftape' under the /proc file system. The files can be viewed
+  with your favorite pager (i.e. use "more /proc/ftape/history" or
+  "less /proc/ftape/history" or simply "cat /proc/ftape/history"). The
+  file will contain some status information about the inserted
+  cartridge, the kernel driver, your tape drive, the floppy disk
+  controller and the error history for the most recent use of the
+  kernel driver. Saying Y will enlarge the size of the ftape driver
+  by approximately 2 KB.
+
+  WARNING: When compiling ftape as a module (i.e. saying M to "Floppy
+  tape drive") it is dangerous to use ftape's /proc file system
+  interface. Accessing `/proc/ftape' while the module is unloaded will
+  result in a kernel Oops. This cannot be fixed from inside ftape.
+
+Controlling the amount of debugging output of ftape
+CONFIG_FT_NORMAL_DEBUG
+  This option controls the amount of debugging output the ftape driver
+  is ABLE to produce; it does not increase or diminish the debugging
+  level itself. If unsure, leave this at its default setting,
+  i.e. choose "Normal".
+
+  Ftape can print lots of debugging messages to the system console
+  resp. kernel log files. Reducing the amount of possible debugging
+  output reduces the size of the kernel module by some KB, so it might
+  be a good idea to use "None" for emergency boot floppies.
+
+  If you want to save memory then the following strategy is
+  recommended: leave this option at its default setting "Normal" until
+  you know that the driver works as expected, afterwards reconfigure
+  the kernel, this time specifying "Reduced" or "None" and recompile
+  and install the kernel as usual. Note that choosing "Excessive"
+  debugging output does not increase the amount of debugging output
+  printed to the console but only makes it possible to produce
+  "Excessive" debugging output.
+
+  Please read Documentation/ftape.txt for a short description
+  how to control the amount of debugging output.
+
+The floppy drive controller for ftape
+CONFIG_FT_STD_FDC
+  Only change this setting if you have a special controller. If you
+  didn't plug any add-on card into your computer system but just
+  plugged the floppy tape cable into the already existing floppy drive
+  controller then you don't want to change the default setting,
+  i.e. choose "Standard".
+
+  Choose "MACH-2" if you have a Mountain Mach-2 controller.
+  Choose "FC-10/FC-20" if you have a Colorado FC-10 or FC-20
+  controller.
+  Choose "Alt/82078" if you have another controller that is located at
+  an IO base address different from the standard floppy drive
+  controller's base address of `0x3f0', or uses an IRQ (interrupt)
+  channel different from `6', or a DMA channel different from
+  `2'. This is necessary for any controller card that is based on
+  Intel's 82078 FDC such as Seagate's, Exabyte's and Iomega's "high
+  speed" controllers.
+
+  If you choose something other than "Standard" then please make
+  sure that the settings for the IO base address and the IRQ and DMA
+  channel in the configuration menus below are correct. Use the manual
+  of your tape drive to determine the correct settings!
+
+  If you are already successfully using your tape drive with another
+  operating system then you definitely should use the same settings
+  for the IO base, the IRQ and DMA channel that have proven to work
+  with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the hardware setup. The hardware configuration can be changed at
+  boot time (when ftape is compiled into the kernel, i.e. if you
+  have said Y to "Floppy tape drive") or module load time (i.e. if you
+  have said M to "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which
+  contains a short description of the parameters that can be set at
+  boot or load time. If you want to use your floppy tape drive on a
+  PCI-bus based system, please read the file
+  drivers/char/ftape/README.PCI.
+
+IO base of the floppy disk controller used with Ftape
+CONFIG_FT_FDC_BASE
+  You don't need to specify a value if the following default
+  settings for the base IO address are correct:
+  <<< MACH-2     : 0x1E0 >>>
+  <<< FC-10/FC-20: 0x180 >>>
+  <<< Secondary  : 0x370 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IO base. The hardware configuration can be changed at boot time
+  (when ftape is compiled into the kernel, i.e. if you specified Y to
+  "Floppy tape drive") or module load time (i.e. if you have said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+IRQ channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_IRQ
+  You don't need to specify a value if the following default
+  settings for the interrupt channel are correct:
+  <<< MACH-2     : 6 >>>
+  <<< FC-10/FC-20: 9 >>>
+  <<< Secondary  : 6 >>>
+  Secondary refers to secondary a FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the IRQ channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+DMA channel for the floppy disk controller used with Ftape
+CONFIG_FT_FDC_DMA
+  You don't need to specify a value if the following default
+  settings for the DMA channel are correct:
+  <<< MACH-2     : 2 >>>
+  <<< FC-10/FC-20: 3 >>>
+  <<< Secondary  : 2 >>>
+  Secondary refers to a secondary FDC controller like the "high speed"
+  controllers delivered by Seagate or Exabyte or Iomega's Ditto Dash.
+  Please make sure that the setting for the IO base address
+  specified here is correct. USE THE MANUAL OF YOUR TAPE DRIVE OR
+  CONTROLLER CARD TO DETERMINE THE CORRECT SETTING. If you are already
+  successfully using the tape drive with another operating system then
+  you definitely should use the same settings for the IO base that has
+  proven to work with that other OS.
+
+  Note that this menu lets you specify only the default setting for
+  the DMA channel. The hardware configuration can be changed at boot
+  time (when ftape is compiled into the kernel, i.e. if you said Y to
+  "Floppy tape drive") or module load time (i.e. if you said M to
+  "Floppy tape drive").
+
+  Please read also the file Documentation/ftape.txt which contains a
+  short description of the parameters that can be set at boot or load
+  time.
+
+FDC FIFO Threshold before requesting DMA service
+CONFIG_FT_FDC_THR
+  Set the FIFO threshold of the FDC. If this is higher the DMA
+  controller may serve the FDC after a higher latency time. If this is
+  lower, fewer DMA transfers occur leading to less bus contention.
+  You may try to tune this if ftape annoys you with "reduced data
+  rate because of excessive overrun errors" messages. However, this
+  doesn't seem to have too much effect.
+
+  If unsure, don't touch the initial value, i.e. leave it at "8".
+
+FDC maximum data rate
+CONFIG_FT_FDC_MAX_RATE
+  With some motherboard/FDC combinations ftape will not be able to
+  run your FDC/tape drive combination at the highest available
+  speed. If this is the case you'll encounter "reduced data rate
+  because of excessive overrun errors" messages and lots of retries
+  before ftape finally decides to reduce the data rate.
+
+  In this case it might be desirable to tell ftape beforehand that
+  it need not try to run the tape drive at the highest available
+  speed. If unsure, leave this disabled, i.e. leave it at 2000
+  bits/sec.
+
+Direct Rendering Manager (XFree86 DRI support)
+CONFIG_DRM
+  Kernel-level support for the Direct Rendering Infrastructure (DRI)
+  introduced in XFree86 4.0. If you say Y here, you need to select
+  the module that's right for your graphics card from the list below.
+  These modules provide support for synchronization, security, and
+  DMA transfers. Please see http://dri.sourceforge.net for more
+  details.  You should also select and configure AGP
+  (/dev/agpgart) support.
+
+3dfx Banshee/Voodoo3+
+CONFIG_DRM_TDFX
+  Choose this option if you have a 3dfx Banshee or Voodoo3 (or later),
+  graphics card.  If M is selected, the module will be called tdfx.o.
+
+3dlabs GMX 2000
+CONFIG_DRM_GAMMA
+  Choose this option if you have a 3dlabs GMX 2000 graphics card.
+  If M is selected, the module will be called gamma.o.
+
+ATI Rage 128
+CONFIG_DRM_R128
+  Choose this option if you have an ATI Rage 128 graphics card.  If M
+  is selected, the module will be called r128.o.  AGP support for
+  this card is strongly suggested (unless you have a PCI version).
+
+Intel I810
+CONFIG_DRM_I810
+  Choose this option if you have an Intel I810 graphics card.  If M is
+  selected, the module will be called i810.o.  AGP support is required
+  for this driver to work.
+
+Matrox g200/g400
+CONFIG_DRM_MGA
+  Choose this option if you have a Matrox g200 or g400 graphics card.  If M
+  is selected, the module will be called mga.o.  AGP support is required
+  for this driver to work.
+
+MTRR control and configuration
+CONFIG_MTRR
+  On Intel P6 family processors (Pentium Pro, Pentium II and later)
+  the Memory Type Range Registers (MTRRs) may be used to control
+  processor access to memory ranges. This is most useful if you have
+  a video (VGA) card on a PCI or AGP bus. Enabling write-combining
+  allows bus write transfers to be combined into a larger transfer
+  before bursting over the PCI/AGP bus. This can increase performance
+  of image write operations 2.5 times or more. Saying Y here creates a
+  /proc/mtrr file which may be used to manipulate your processor's
+  MTRRs. Typically the X server should use this. 
+
+  This code has a reasonably generic interface so that similar 
+  control registers on other processors can be easily supported 
+  as well:
+
+  The Cyrix 6x86, 6x86MX and M II processors have Address Range
+  Registers (ARRs) which provide a similar functionality to MTRRs. For
+  these, the ARRs are used to emulate the MTRRs.
+  The AMD K6-2 (stepping 8 and above) and K6-3 processors have two
+  MTRRs. The Centaur C6 (WinChip) has 8 MCRs, allowing
+  write-combining. All of these processors are supported by this code
+  and it makes sense to say Y here if you have one of them.
+
+  Saying Y here also fixes a problem with buggy SMP BIOSes which only
+  set the MTRRs for the boot CPU and not for the secondary CPUs. This
+  can lead to all sorts of problems, so it's good to say Y here.
+
+  You can safely say Y even if your machine doesn't have MTRRs, you'll
+  just add about 9 KB to your kernel.
+
+  See Documentation/mtrr.txt for more information.
+
+Main CPU frequency, only for DEC alpha machine
+CONFIG_FT_ALPHA_CLOCK
+  On some DEC Alpha machines the CPU clock frequency cannot be
+  determined automatically, so you need to specify it here ONLY if
+  running a DEC Alpha, otherwise this setting has no effect.
+
+Double Talk PC internal speech card support
+CONFIG_DTLK
+  This driver is for the DoubleTalk PC, a speech synthesizer
+  manufactured by RC Systems (http://www.rcsys.com/ ).  It is also
+  called the `internal DoubleTalk'.  If you want to compile this as a
+  module ( = code which can be inserted in and removed from the
+  running kernel whenever you want), say M here and read
+  Documentation/modules.txt. The module will be called dtlk.o.
+
+Siemens R3964 serial protocol support
+CONFIG_R3964
+  This driver allows synchronous communication with devices using the
+  Siemens R3964 packet protocol. Unless you are dealing with special
+  hardware like PLCs, you are unlikely to need this.
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called 
+  n_r3964.o.
+
+  If unsure, say N.
+
+Applicom intelligent fieldbus card support
+CONFIG_APPLICOM
+  This driver provides the kernel-side support for the intelligent
+  fieldbus cards made by Applicom International. More information
+  about these cards can be found on the WWW at the address
+  http://www.applicom-int.com/ , or by email from David Woodhouse
+  <dwmw2@infradead.org>.
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  applicom.o.
+
+  If unsure, say N.
+
+Intel Random Number Generator support
+CONFIG_INTEL_RNG
+  This driver provides kernel-side support for the Random Number
+  Generator hardware found on Intel i8xx-based motherboards.
+
+  Both a character driver, used to read() entropy data, and a timer
+  function which automatically adds entropy directly into the
+  kernel pool, are exported by this driver.
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  i810_rng.o.
+
+  If unsure, say N.
+
+Power Management support
+CONFIG_PM
+  "Power Management" means that parts of your computer are shut
+  off or put into a power conserving "sleep" mode if they are not
+  being used. There are two competing standards for doing this: APM
+  and ACPI. If you want to use either one, say Y here and then also to
+  the requisite support below. 
+
+  Power Management is most important for battery powered laptop
+  computers; if you have a laptop, check out the Linux Laptop home
+  page on the WWW at
+  http://www.cs.utexas.edu/users/kharker/linux-laptop/ and the Battery
+  Powered Linux mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  Note that, even if you say N here, Linux on the x86 architecture
+  will issue the hlt instruction if nothing is to be done, thereby
+  sending the processor to sleep and saving power.
+
+ACPI Support
+CONFIG_ACPI
+  ACPI/OSPM support for Linux is currently under development. As such, 
+  this support is preliminary and EXPERIMENTAL. Configuring ACPI support
+  enables kernel interfaces that allow higher level software (OSPM) to
+  manipulate ACPI defined hardware and software interfaces, including
+  the evaluation of ACPI control methods. If unsure, choose N here.
+  Note, this option will enlarge your kernel by about 120K.
+
+  This support requires an ACPI compliant platform (hardware/firmware).
+  If both ACPI and Advanced Power Management (APM) support are
+  configured, ACPI is used.
+
+  This code DOES NOT currently provide a complete OSPM implementation --
+  it has not yet reached APM's level of functionality. When fully
+  implemented, Linux ACPI/OSPM will provide a more robust functional
+  replacement for legacy configuration and power management interfaces,
+  including the Plug-and-Play BIOS specification (PNP BIOS), the Multi-
+  Processor Specification (MPS), and the Advanced Power Management 
+  specification (APM).
+
+  Linux support for ACPI/OSPM is based on Intel Corporation's ACPI
+  Component Architecture (ACPI CA). The latest ACPI CA source code,
+  documentation, debug builds, and implementation status information
+  can be downloaded from:
+  http://developer.intel.com/technology/iapc/acpi/downloads.htm
+  
+  The ACPI mailing list may also be of interest:
+  http://phobos.fs.tum.de/acpi/index.html
+
+Advanced Power Management BIOS support
+CONFIG_APM
+  APM is a BIOS specification for saving power using several different
+  techniques. This is mostly useful for battery powered laptops with
+  APM compliant BIOSes. If you say Y here, the system time will be
+  reset after a RESUME operation, the /proc/apm device will provide
+  battery status information, and user-space programs will receive
+  notification of APM "events" (e.g. battery status change).
+
+  If you select "Y" here, you can disable actual use of the APM
+  BIOS by passing the "apm=off" option to the kernel at boot time.
+
+  Note that the APM support is almost completely disabled for
+  machines with more than one CPU.
+
+  In order to use APM, you will need supporting software. For location
+  and more information, read Documentation/pm.txt and the Battery
+  Powered Linux mini-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto .
+
+  This driver does not spin down disk drives (see the hdparm(8)
+  manpage ("man 8 hdparm") for that), and it doesn't turn off
+  VESA-compliant "green" monitors. 
+
+  This driver does not support the TI 4000M TravelMate and the ACER
+  486/DX4/75 because they don't have compliant BIOSes. Many "green"
+  desktop machines also don't have compliant BIOSes, and this driver
+  may cause those machines to panic during the boot phase.
+
+  Generally, if you don't have a battery in your machine, there isn't
+  much point in using this driver and you should say N. If you get
+  random kernel OOPSes or reboots that don't seem to be related to
+  anything, try disabling/enabling this option (or disabling/enabling
+  APM in your BIOS). 
+
+  Some other things you should try when experiencing seemingly random,
+  "weird" problems:
+
+   1) make sure that you have enough swap space and that it is
+      enabled. 
+   2) pass the "no-hlt" option to the kernel 
+   3) switch on floating point emulation in the kernel and pass
+      the "no387" option to the kernel
+   4) pass the "floppy=nodma" option to the kernel
+   5) pass the "mem=4M" option to the kernel (thereby disabling 
+      all but the first 4 MB of RAM)
+   6) make sure that the CPU is not over clocked.
+   7) read the sig11 FAQ at http://www.bitwizard.nl/sig11/
+   8) disable the cache from your BIOS settings
+   9) install a fan for the video card or exchange video RAM
+   10) install a better fan for the CPU
+   11) exchange RAM chips 
+   12) exchange the motherboard.
+
+  To compile this driver as a module ( = code which can be inserted in
+  and removed from the running kernel whenever you want), say M here
+  and read Documentation/modules.txt. The module will be called
+  apm.o.
+
+Ignore USER SUSPEND
+CONFIG_APM_IGNORE_USER_SUSPEND
+  This option will ignore USER SUSPEND requests. On machines with a
+  compliant APM BIOS, you want to say N. However, on the NEC Versa M
+  series notebooks, it is necessary to say Y because of a BIOS bug.
+
+Enable APM at boot time
+CONFIG_APM_DO_ENABLE
+  Enable APM features at boot time. From page 36 of the APM BIOS
+  specification: "When disabled, the APM BIOS does not automatically
+  power manage devices, enter the Standby State, enter the Suspend
+  State, or take power saving steps in response to CPU Idle calls."
+  This driver will make CPU Idle calls when Linux is idle (unless this
+  feature is turned off -- see "Do CPU IDLE calls", below). This
+  should always save battery power, but more complicated APM features
+  will be dependent on your BIOS implementation. You may need to turn
+  this option off if your computer hangs at boot time when using APM
+  support, or if it beeps continuously instead of suspending. Turn
+  this off if you have a NEC UltraLite Versa 33/C or a Toshiba
+  T400CDT. This is off by default since most machines do fine without
+  this feature.
+
+Do CPU IDLE calls
+CONFIG_APM_CPU_IDLE
+  Enable calls to APM CPU Idle/CPU Busy inside the kernel's idle loop.
+  On some machines, this can activate improved power savings, such as
+  a slowed CPU clock rate, when the machine is idle. These idle calls
+  are made after the idle loop has run for some length of time (e.g.,
+  333 mS). On some machines, this will cause a hang at boot time or
+  whenever the CPU becomes idle. (On machines with more than one CPU,
+  this option does nothing.)
+
+Enable console blanking using APM
+CONFIG_APM_DISPLAY_BLANK
+  Enable console blanking using the APM. Some laptops can use this to
+  turn off the LCD backlight when the screen blanker of the Linux
+  virtual console blanks the screen. Note that this is only used by
+  the virtual console screen blanker, and won't turn off the backlight
+  when using the X Window system. This also doesn't have anything to
+  do with your VESA-compliant power-saving monitor. Further, this
+  option doesn't work for all laptops -- it might not turn off your
+  backlight at all, or it might print a lot of errors to the console,
+  especially if you are using gpm.
+
+RTC stores time in GMT
+CONFIG_APM_RTC_IS_GMT
+  Say Y here if your RTC (Real Time Clock a.k.a. hardware clock)
+  stores the time in GMT (Greenwich Mean Time). Say N if your RTC
+  stores localtime.
+
+  It is in fact recommended to store GMT in your RTC, because then you
+  don't have to worry about daylight savings time changes. The only
+  reason not to use GMT in your RTC is if you also run a broken OS
+  that doesn't understand GMT.
+
+Allow interrupts during APM BIOS calls
+CONFIG_APM_ALLOW_INTS
+  Normally we disable external interrupts while we are making calls to
+  the APM BIOS as a measure to lessen the effects of a badly behaving
+  BIOS implementation.  The BIOS should reenable interrupts if it
+  needs to.  Unfortunately, some BIOSes do not -- especially those in
+  many of the newer IBM Thinkpads.  If you experience hangs when you
+  suspend, try setting this to Y.  Otherwise, say N.
+
+Use real mode APM BIOS call to power off
+CONFIG_APM_REAL_MODE_POWER_OFF
+  Use real mode APM BIOS calls to switch off the computer. This is
+  a work-around for a number of buggy BIOSes. Switch this option on if
+  your computer crashes instead of powering off properly.
+
+Watchdog Timer Support 
+CONFIG_WATCHDOG
+  If you say Y here (and to one of the following options) and create a
+  character special file /dev/watchdog with major number 10 and minor
+  number 130 using mknod ("man mknod"), you will get a watchdog, i.e.:
+  subsequently opening the file and then failing to write to it for
+  longer than 1 minute will result in rebooting the machine. This
+  could be useful for a networked machine that needs to come back
+  online as fast as possible after a lock-up. There's both a watchdog
+  implementation entirely in software (which can sometimes fail to
+  reboot the machine) and a driver for hardware watchdog boards, which
+  are more robust and can also keep track of the temperature inside
+  your computer. For details, read Documentation/watchdog.txt in the
+  kernel source.
+
+  The watchdog is usually used together with the watchdog daemon 
+  which is available via FTP (user: anonymous) from
+  ftp://tsx-11.mit.edu/pub/linux/sources/sbin/ . This daemon can also
+  monitor NFS connections and can reboot the machine when the process
+  table is full.
+
+  If unsure, say N.
+
+Disable watchdog shutdown on close
+CONFIG_WATCHDOG_NOWAYOUT
+  The default watchdog behaviour (which you get if you say N here) is
+  to stop the timer if the process managing it closes the file
+  /dev/watchdog. It's always remotely possible that this process might
+  get killed. If you say Y here, the watchdog cannot be stopped once
+  it has been started.
+
+WDT Watchdog timer
+CONFIG_WDT
+  If you have a WDT500P or WDT501P watchdog board, say Y here,
+  otherwise N. It is not possible to probe for this board, which means
+  that you have to inform the kernel about the IO port and IRQ using
+  the "wdt=" kernel option (try "man bootparam" or see the
+  documentation of your boot loader (lilo or loadlin) about how to
+  pass options to the kernel at boot time).
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called wdt.o.
+
+WDT PCI Watchdog timer
+CONFIG_WDTPCI
+  If you have a PCI WDT500/501 watchdog board, say Y here,
+  otherwise N. It is not possible to probe for this board, which means
+  that you have to inform the kernel about the IO port and IRQ using
+  the "wdt=" kernel option (try "man bootparam" or see the
+  documentation of your boot loader (lilo or loadlin) about how to
+  pass options to the kernel at boot time).
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called wdt_pci.o.
+
+WDT501 features
+CONFIG_WDT_501
+  Saying Y here and creating a character special file /dev/temperature
+  with major number 10 and minor number 131 ("man mknod") will give
+  you a thermometer inside your computer: reading from
+  /dev/temperature yields one byte, the temperature in degrees
+  Fahrenheit. This works only if you have a WDT501P watchdog board
+  installed.
+
+Fan Tachometer
+CONFIG_WDT_501_FAN
+  Enable the Fan Tachometer on the WDT501. Only do this if you have a
+  fan tachometer actually set up.
+
+Software Watchdog
+CONFIG_SOFT_WATCHDOG
+  A software monitoring watchdog. This will fail to reboot your system
+  from some situations that the hardware watchdog will recover
+  from. Equally it's a lot cheaper to install. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called softdog.o.
+
+Berkshire Products PC Watchdog
+CONFIG_PCWATCHDOG
+  This is the driver for the Berkshire Products PC Watchdog card.
+  This card simply watches your kernel to make sure it doesn't freeze,
+  and if it does, it reboots your computer after a certain amount of
+  time. This driver is like the WDT501 driver but for different
+  hardware. Please read Documentation/pcwd-watchdog.txt. The PC
+  watchdog cards can be ordered from http://www.berkprod.com . 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pcwd.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+  Most people will say N.
+
+Acquire SBC Watchdog Timer
+CONFIG_ACQUIRE_WDT
+  This is the driver for the hardware watchdog on the PSC-6x86 Single
+  Board Computer produced by Acquire Inc (and others). This watchdog
+  simply watches your kernel to make sure it doesn't freeze, and if
+  it does, it reboots your computer after a certain amount of time.
+
+  This driver is like the WDT501 driver but for different hardware.
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called pscwdt.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. Most people
+  will say N.
+
+Mixcom Watchdog
+CONFIG_MIXCOMWD 
+  This is a driver for the Mixcom hardware watchdog cards. This
+  watchdog simply watches your kernel to make sure it doesn't freeze,
+  and if it does, it reboots your computer after a certain amount of
+  time.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called mixcomwd.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt. Most people
+  will say N.
+
+Toshiba Laptop support
+CONFIG_TOSHIBA
+  If you intend to run this the kernel on a Toshiba portable say yes
+  here. This adds a driver to safely access the System Management
+  Mode of the CPU on Toshiba portables. The System Management Mode
+  is used to set the BIOS and power saving options on Toshiba portables.
+
+  For information on utilities to make use of this driver see the
+  Toshiba Linux utilities website at:
+  http://www.buzzard.org.uk/toshiba/
+
+/dev/cpu/microcode - Intel IA32 CPU microcode support
+CONFIG_MICROCODE
+  If you say Y here and also to "/dev file system support" in the
+  'File systems' section, you will be able to update the microcode on
+  Intel processors in the IA32 family, e.g. Pentium Pro, Pentium II,
+  Pentium III, Pentium 4, Xeon etc. You will obviously need the actual 
+  microcode binary data itself which is not shipped with the Linux kernel.
+
+  For latest news and information on obtaining all the required
+  ingredients for this driver, check:
+  http://www.urbanmyth.org/microcode/
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called microcode.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt. If you use
+  modprobe or kmod you may also want to add the line
+  'alias char-major-10-184 microcode' to your /etc/modules.conf file.
+
+/dev/cpu/*/msr - Model-specific register support
+CONFIG_X86_MSR
+  This device gives privileged processes access to the x86
+  Model-Specific Registers (MSRs).  It is a character device with
+  major 202 and minors 0 to 31 for /dev/cpu/0/msr to /dev/cpu/31/msr.
+  MSR accesses are directed to a specific CPU on multi-processor
+  systems.
+
+/dev/cpu/*/cpuid - CPU information support
+CONFIG_X86_CPUID
+  This device gives processes access to the x86 CPUID instruction to
+  be executed on a specific processor.  It is a character device
+  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
+  /dev/cpu/31/cpuid.
+
+Enhanced Real Time Clock Support
+CONFIG_RTC
+  If you say Y here and create a character special file /dev/rtc with
+  major number 10 and minor number 135 using mknod ("man mknod"), you
+  will get access to the real time clock (or hardware clock) built 
+  into your computer.
+
+  Every PC has such a clock built in. It can be used to generate
+  signals from as low as 1Hz up to 8192Hz, and can also be used
+  as a 24 hour alarm. It reports status information via the file
+  /proc/driver/rtc and its behaviour is set by various ioctls on
+  /dev/rtc.
+
+  If you run Linux on a multiprocessor machine and said Y to
+  "Symmetric Multi Processing" above, you should say Y here to read
+  and set the RTC in an SMP compatible fashion.
+
+  If you think you have a use for such a device (such as periodic data
+  sampling), then say Y here, and read Documentation/rtc.txt for
+  details.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called rtc.o. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. 
+
+### Add
+#EFI Real Time Clock Services
+#CONFIG_EFI_RTC
+
+Tadpole ANA H8 Support
+CONFIG_H8
+  The Hitachi H8/337 is a microcontroller used to deal with the power
+  and thermal environment. If you say Y here, you will be able to
+  communicate with it via a character special device. 
+
+  If unsure, say N.
+
+/dev/nvram support
+CONFIG_NVRAM
+  If you say Y here and create a character special file /dev/nvram
+  with major number 10 and minor number 144 using mknod ("man mknod"),
+  you get read and write access to the 50 bytes of non-volatile memory
+  in the real time clock (RTC), which is contained in every PC and
+  most Ataris. 
+
+  This memory is conventionally called "CMOS RAM" on PCs and "NVRAM"
+  on Ataris. /dev/nvram may be used to view settings there, or to
+  change them (with some utility). It could also be used to frequently
+  save a few bits of very important data that may not be lost over
+  power-off and for which writing to disk is too insecure. Note
+  however that most NVRAM space in a PC belongs to the BIOS and you
+  should NEVER idly tamper with it. See Ralf Brown's interrupt list
+  for a guide to the use of CMOS bytes by your BIOS.
+
+  On Atari machines, /dev/nvram is always configured and does not need
+  to be selected.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called nvram.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Joystick support
+CONFIG_JOYSTICK
+  If you have a joystick, 6dof controller, gamepad, steering wheel,
+  weapon control system or something like that you can say Y here to
+  enable generic support for these controllers. You will also need to
+  say Y or M to at least one of the hardware specific drivers. This
+  will make the controllers available as /dev/input/jsX devices.
+  Please read the file Documentation/joystick.txt which contains more
+  information and the location of the joystick package that you'll
+  need.
+
+ns558 gameports
+CONFIG_INPUT_NS558
+  Say Y here if you have an ISA, ISAPnP or PCI standard gameport.
+  For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ns558.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+PDPI Lightning 4 gamecard
+CONFIG_INPUT_LIGHTNING
+  Say Y here if you have a PDPI Lightning 4 gamecard. For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called lightning.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Aureal Vortex and Trident 4DWave gameports
+CONFIG_INPUT_PCIGAME
+  Say Y here if you have a Trident 4DWave DX/NX or Aureal Vortex 1/2
+  card. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called pcigame.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Classic PC analog joysticks and gamepads
+CONFIG_INPUT_ANALOG
+  Say Y here if you have a controller that connects to the PC
+  gameport. This supports many different types, including joysticks
+  with throttle control, with rudders, or with extensions like
+  additional hats and buttons compatible with CH Flightstick Pro,
+  ThrustMaster FCS, 6 and 8 button gamepads, or Saitek Cyborg
+  joysticks. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called analog.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Assasin 3D and MadCatz Panther devices
+CONFIG_INPUT_A3D
+  Say Y here if you have an FPGaming or MadCatz controller using the
+  A3D protocol over the PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called a3d.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Logitech ADI digital joysticks and gamepads
+CONFIG_INPUT_ADI
+  Say Y here if you have a Logitech controller using the ADI
+  protocol over the PC gameport. For more information on how to use
+  the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called adi.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Creative Labs Blaster Cobra gamepad
+CONFIG_INPUT_COBRA
+  Say Y here if you have a Creative Labs Blaster Cobra gamepad.
+  For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called cobra.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Genius Flight2000 Digital joysticks and gamepads
+CONFIG_INPUT_GF2K
+  Say Y here if you have a Genius Flight2000 or MaxFighter
+  digitally communicating joystick or gamepad. For more information
+  on how to use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called gf2k.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Gravis GrIP joysticks and gamepads
+CONFIG_INPUT_GRIP
+  Say Y here if you have a Gravis controller using the GrIP protocol
+  over the PC gameport. For more information on how to use the driver
+  please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called grip.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+InterAct digital joysticks and gamepads
+CONFIG_INPUT_INTERACT
+  Say Y hereif you have an InterAct gameport or joystick
+  communicating digitally over the gameport. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called interact.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+ThrustMaster DirectConnect joysticks and gamepads
+CONFIG_INPUT_TMDC
+  Say Y here if you have a ThrustMaster controller using the
+  DirectConnect (BSP) protocol over the PC gameport. For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called tmdc.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Microsoft SideWinder digital joysticks and gamepads
+CONFIG_INPUT_SIDEWINDER
+  Say Y here if you have a Microsoft controller using the Digital
+  Overdrive protocol over PC gameport. For more information on how to
+  use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called sidewinder.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Serial port input line discipline
+CONFIG_INPUT_SERPORT
+  Say Y hereif you plan to use a joystick that communicates over the
+  serial (COM) port. For more information on how to use the driver
+  please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called serport.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Logitech WingMan Warrior joystick
+CONFIG_INPUT_WARRIOR
+  Say Y here if you have a Logitech WingMan Warrior joystick
+  connected to your computer's serial port. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called warrior.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+LogiCad3d Magellan/SpaceMouse 6dof controller
+CONFIG_INPUT_MAGELLAN
+  Say Y here if you have a Magellan or Space Mouse 6DOF controller
+  connected to your computer's serial port.  For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called magellan.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+SpaceTec SpaceOrb/Avenger 6dof controller
+CONFIG_INPUT_SPACEORB
+  Say Y here if you have a SpaceOrb 360 or SpaceBall Avenger 6DOF
+  controller connected to your computer's serial port.  For more
+  information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called spaceorb.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+ 
+SpaceTec SpaceBall 4000 FLX 6dof controller
+CONFIG_INPUT_SPACEBALL
+  Say Y here if you have a SpaceTec SpaceBall 4000 FLX controller
+  connected to your computer's serial port. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+I-Force joysticks/wheels
+CONFIG_INPUT_IFORCE_232
+  Say Y here if you have an I-Force joystick or steering wheel
+  connected to your serial (COM) port. For more information on
+  how to use the driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called iforce.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+I-Force joysticks/wheels
+CONFIG_INPUT_IFORCE_USB
+  Say Y here if you have an I-Force joystick or steering wheel
+  connected to your USB port. For more information on how to use the
+  driver please read Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called iforce.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+ 
+Multisystem, Sega Genesis, Saturn joysticks and gamepads
+CONFIG_INPUT_DB9
+  Say Y here if you have a Sega Master System gamepad, Sega Genesis
+  gamepad, Sega Saturn gamepad, or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port. 
+  For more information on how to use the driver please read 
+  Documentation/joystick.txt and Documentation/joystick-parport.txt.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called db9.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Multisystem, NES, SNES, N64, PSX joysticks and gamepads
+CONFIG_INPUT_GAMECON
+  Say Y here if you have a Nintendo Entertainment System gamepad,
+  Super Nintendo Entertainment System gamepad, Nintendo 64 gamepad,
+  Sony PlayStation gamepad or a Multisystem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick connected to your parallel port.
+  For more information on how to use the driver please read
+  Documentation/joystick.txt and Documentation/joystick-parport.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called gamecon.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Multisystem joysticks via TurboGraFX device
+CONFIG_INPUT_TURBOGRAFX
+  Say Y here if you have the TurboGraFX interface by Steffen
+  Schwenke, and want to use it with Multiststem -- Atari, Amiga,
+  Commodore, Amstrad CPC joystick. For more information on how to use
+  the driver please read Documentation/joystick.txt and
+  Documentation/joystick-parport.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called turbografx.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Amiga joysticks
+CONFIG_INPUT_AMIJOY
+  Say Y here if you have an Amiga with a digital joystick connected
+  to it. For more information on how to use the driver please read
+  Documentation/joystick.txt
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called joy-amiga.o. If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+Atomwide Serial Support
+CONFIG_ATOMWIDE_SERIAL
+  If you have an Atomwide Serial card for an Acorn system, say Y to
+  this option. The driver can handle 1, 2, or 3 port cards.
+  If unsure, say N
+
+The Serial Port Dual Serial Port
+CONFIG_DUALSP_SERIAL
+  If you have the Serial Port's dual serial card for an Acorn system,
+  say Y to this option. If unsure, say N
+
+NetWinder Button
+CONFIG_NWBUTTON
+  If you say Y here and create a character device node /dev/nwbutton
+  with major and minor numbers 10 and 158 ("man mknod"), then every
+  time the orange button is pressed a number of times, the number of
+  times the button was pressed will be written to that device.
+
+  This is most useful for applications, as yet unwritten, which
+  perform actions based on how many times the button is pressed in a
+  row.
+
+  Do not hold the button down for too long, as the driver does not
+  alter the behaviour of the hardware reset circuitry attached to the
+  button; it will still execute a hard reset if the button is held
+  down for longer than approximately five seconds.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called nwbutton.o.
+
+  Most people will answer Y to this question and "Reboot Using Button"
+  below to be able to initiate a system shutdown from the button.
+
+Reboot Using Button
+CONFIG_NWBUTTON_REBOOT
+  If you say Y here, then you will be able to initiate a system
+  shutdown and reboot by pressing the orange button a number of times.
+  The number of presses to initiate the shutdown is two by default,
+  but this can be altered by modifying the value of NUM_PRESSES_REBOOT
+  in nwbutton.h and recompiling the driver or, if you compile the
+  driver as a module, you can specify the number of presses at load
+  time with "insmod button reboot_count=<something>".
+
+Sound card support
+CONFIG_SOUND
+  If you have a sound card in your computer, i.e. if it can say more
+  than an occasional beep, say Y. Be sure to have all the information
+  about your sound card and its configuration down (I/O port,
+  interrupt and DMA channel), because you will be asked for it. 
+
+  You want to read the Sound-HOWTO, available from
+  http://www.linuxdoc.org/docs.html#howto . General information
+  about the modular sound system is contained in the files
+  Documentation/sound/Introduction. The file
+  Documentation/sound/README.OSS contains some slightly outdated but
+  still useful information as well.
+
+  If you have a PnP sound card and you want to configure it at boot
+  time using the ISA PnP tools (read
+  http://www.roestock.demon.co.uk/isapnptools/ ), then you need to
+  compile the sound card support as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want)
+  and load that module after the PnP configuration is finished. To do
+  this, say M here and read Documentation/modules.txt as well as
+  Documentation/sound/README.modules; the module will be called
+  soundcore.o.
+
+  I'm told that even without a sound card, you can make your computer
+  say more than an occasional beep, by programming the PC speaker.
+  Kernel patches and supporting utilities to do that are in the pcsp
+  package, available at ftp://ftp.infradead.org/pub/pcsp/ .
+
+OSS sound modules
+CONFIG_SOUND_OSS
+  OSS is the Open Sound System suite of sound card drivers. They make
+  sound programming easier since they provide a common API. Say Y or M
+  here (the module will be called sound.o) if you haven't found a
+  driver for your sound card above, then pick your driver from the
+  list below.
+
+Persistent DMA buffers
+CONFIG_SOUND_DMAP
+  Linux can often have problems allocating DMA buffers for ISA sound
+  cards on machines with more than 16MB of RAM. This is because ISA
+  DMA buffers must exist below the 16MB boundary and it is quite
+  possible that a large enough free block in this region cannot be
+  found after the machine has been running for a while. If you say Y
+  here the DMA buffers (64Kb) will be allocated at boot time and kept
+  until the shutdown. This option is only useful if you said Y to
+  "OSS sound modules", above. If you said M to "OSS sound modules"
+  then you can get the persistent DMA buffer functionality by passing
+  the command-line argument "dmabuf=1" to the sound.o module.
+
+  Say Y unless you have 16MB or less RAM or a PCI sound card.
+
+Support for Aztech Sound Galaxy (non-PnP) cards
+CONFIG_SOUND_SGALAXY
+  This module initializes the older non Plug and Play sound galaxy
+  cards from Aztech. It supports the Waverider Pro 32 - 3D and the
+  Galaxy Washington 16.
+
+  If you compile the driver into the kernel, you have to add
+  "sgalaxy=<io>,<irq>,<dma>,<dma2>,<sgbase>" to the kernel command
+  line.
+
+Support for AD1816(A) based cards (EXPERIMENTAL)
+CONFIG_SOUND_AD1816
+  Say M here if you have a sound card based on the Analog Devices 
+  AD1816(A) chip.
+
+  If you compile the driver into the kernel, you have to add
+  "ad1816=<io>,<irq>,<dma>,<dma2>" to the kernel command line.
+
+Yamaha OPL3-SA1 audio controller
+CONFIG_SOUND_OPL3SA1
+  Say Y or M if you have a Yamaha OPL3-SA1 sound chip, which is
+  usually built into motherboards. Read Documentation/sound/OPL3-SA
+  for details.
+
+  If you compile the driver into the kernel, you have to add
+  "opl3sa=<io>,<irq>,<dma>,<dma2>,<mpuio>,<mpuirq>" to the kernel
+  command line.
+
+ProAudioSpectrum 16 support
+CONFIG_SOUND_PAS
+  Answer Y only if you have a Pro Audio Spectrum 16, ProAudio Studio
+  16 or Logitech SoundMan 16 sound card. Answer N if you have some
+  other card made by Media Vision or Logitech since those are not
+  PAS16 compatible. Please read Documentation/sound/PAS16.
+
+  If you compile the driver into the kernel, you have to add
+  "pas2=<io>,<irq>,<dma>,<dma2>,<sbio>,<sbirq>,<sbdma>,<sbdma2>
+  to the kernel command line.
+
+100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support
+CONFIG_SOUND_SB
+  Answer Y if you have an original Sound Blaster card made by Creative
+  Labs or a 100% hardware compatible clone (like the Thunderboard or
+  SM Games). For an unknown card you may answer Y if the card claims
+  to be Sound Blaster-compatible.
+
+  Please read the file Documentation/sound/Soundblaster.
+
+  You should also say Y here for cards based on the Avance Logic
+  ALS-007 and ALS-1X0 chips (read Documentation/sound/ALS) and for cards
+  based on ESS chips (read Documentation/sound/ESS1868 and
+  Documentation/sound/ESS). If you have an SB AWE 32 or SB AWE 64, say
+  Y here and also to "AWE32 synth" below and read 
+  Documentation/sound/INSTALL.awe. If you have an IBM Mwave card, say
+  Y here and read Documentation/sound/mwave.
+
+  If you compile the driver into the kernel and don't want to use
+  isapnp, you have to add "sb=<io>,<irq>,<dma>,<dma2>" to the kernel
+  command line.
+  
+  You can say M here to compile this driver as a module; the module is
+  called sb.o.
+
+#Loopback MIDI device support
+#CONFIG_SOUND_VMIDI
+###
+### somebody please fill this in.
+###
+#
+Gravis Ultrasound support
+CONFIG_SOUND_GUS
+  Say Y here for any type of Gravis Ultrasound card, including
+  the GUS or GUS MAX. See also Documentation/sound/ultrasound for
+  more information on configuring this card with modules.
+
+  If you compile the driver into the kernel, you have to add
+  "gus=<io>,<irq>,<dma>,<dma2>" to the kernel command line.
+
+MPU-401 support (NOT for SB16)
+CONFIG_SOUND_MPU401
+  Be careful with this question. The MPU401 interface is supported by
+  all sound cards. However, some natively supported cards have their
+  own driver for MPU401. Enabling this MPU401 option with these cards
+  will cause a conflict. Also, enabling MPU401 on a system that
+  doesn't really have a MPU401 could cause some trouble. If your card
+  was in the list of supported cards, look at the card specific
+  instructions in the drivers/sound/Readme.cards file. It's safe to
+  answer Y if you have a true MPU401 MIDI interface card.
+
+  If you compile the driver into the kernel, you have to add
+  "mpu401=<io>,<irq>" to the kernel command line.
+
+6850 UART support
+CONFIG_SOUND_UART6850
+  This option enables support for MIDI interfaces based on the 6850
+  UART chip. This interface is rarely found on sound cards. It's safe
+  to answer N to this question.
+
+  If you compile the driver into the kernel, you have to add
+  "uart6850=<io>,<irq>" to the kernel command line.
+
+PSS (AD1848, ADSP-2115, ESC614) support
+CONFIG_SOUND_PSS
+  Answer Y or M if you have an Orchid SW32, Cardinal DSP16, Beethoven
+  ADSP-16 or some other card based on the PSS chipset (AD1848 codec +
+  ADSP-2115 DSP chip + Echo ESC614 ASIC CHIP). For more information on
+  how to compile it into the kernel or as a module see the file
+  Documentation/sound/PSS.
+
+  If you compile the driver into the kernel, you have to add
+  "pss=<io>,<mssio>,<mssirq>,<mssdma>,<mpuio>,<mpuirq>" to the kernel
+  command line.
+
+Enable PSS mixer (Beethoven ADSP-16 and other compatible)
+CONFIG_PSS_MIXER
+  Answer Y for Beethoven ADSP-16. You may try to say Y also for other
+  cards if they have master volume, bass, treble, and you can't
+  control it under Linux. If you answer N for Beethoven ADSP-16, you
+  can't control master volume, bass, treble and synth volume.
+
+  If you said M to "PSS support" above, you may enable or disable this
+  PSS mixer with the module parameter pss_mixer. For more information
+  see the file Documentation/sound/PSS.
+
+Have DSPxxx.LD firmware file
+CONFIG_PSS_HAVE_BOOT
+  If you have the DSPxxx.LD file or SYNTH.LD file for you card, say Y
+  to include this file. Without this file the synth device (OPL) may
+  not work.
+
+Full pathname of DSPxxx.LD firmware file
+CONFIG_PSS_BOOT_FILE
+  Enter the full pathname of your DSPxxx.LD file or SYNTH.LD file,
+  starting from /.
+
+Microsoft Sound System support
+CONFIG_SOUND_MSS
+  Again think carefully before answering Y to this question. It's safe
+  to answer Y if you have the original Windows Sound System card made
+  by Microsoft or Aztech SG 16 Pro (or NX16 Pro). Also you may say Y
+  in case your card is NOT among these:
+
+     ATI Stereo F/X, AdLib, Audio Excell DSP16, Cardinal DSP16,
+     Ensoniq SoundScape (and compatibles made by Reveal and Spea),
+     Gravis Ultrasound, Gravis Ultrasound ACE, Gravis Ultrasound Max,
+     Gravis Ultrasound with 16 bit option, Logitech Sound Man 16,
+     Logitech SoundMan Games, Logitech SoundMan Wave, MAD16 Pro (OPTi
+     82C929), Media Vision Jazz16, MediaTriX AudioTriX Pro, Microsoft
+     Windows Sound System (MSS/WSS), Mozart (OAK OTI-601), Orchid
+     SW32, Personal Sound System (PSS), Pro Audio Spectrum 16, Pro
+     Audio Studio 16, Pro Sonic 16, Roland MPU-401 MIDI interface,
+     Sound Blaster 1.0, Sound Blaster 16, Sound Blaster 16ASP, Sound
+     Blaster 2.0, Sound Blaster AWE32, Sound Blaster Pro, TI TM4000M
+     notebook, ThunderBoard, Turtle Beach Tropez, Yamaha FM
+     synthesizers (OPL2, OPL3 and OPL4), 6850 UART MIDI Interface.
+
+  For cards having native support in VoxWare, consult the card
+  specific instructions in drivers/sound/Readme.cards. Some drivers
+  have their own MSS support and saying Y to this option will cause a
+  conflict.
+
+  If you compile the driver into the kernel, you have to add
+  "ad1848=<io>,<irq>,<dma>,<dma2>[,<type>]" to the kernel command
+  line.
+
+SGI Visual Workstation on-board audio
+CONFIG_SOUND_VWSND
+  Say Y or M if you have an SGI Visual Workstation and you want to
+  be able to use its on-board audio.  Read Documentation/sound/vwsnd
+  for more info on this driver's capabilities.
+
+Ensoniq Soundscape support
+CONFIG_SOUND_SSCAPE
+  Answer Y if you have a sound card based on the Ensoniq SoundScape
+  chipset. Such cards are being manufactured at least by Ensoniq, Spea
+  and Reveal (Reveal makes also other cards).
+
+  If you compile the driver into the kernel, you have to add
+  "sscape=<io>,<irq>,<dma>,<mpuio>,<mpuirq>" to the kernel command
+  line.
+
+MediaTriX AudioTriX Pro support
+CONFIG_SOUND_TRIX
+  Answer Y if you have the AudioTriX Pro sound card manufactured
+  by MediaTrix.
+
+Have TRXPRO.HEX firmware file
+CONFIG_TRIX_HAVE_BOOT
+  The MediaTrix AudioTrix Pro has an on-board microcontroller which
+  needs to be initialized by downloading the code from the file
+  TRXPRO.HEX in the DOS driver directory. If you don't have the
+  TRXPRO.HEX file handy you may skip this step. However, the SB and
+  MPU-401 modes of AudioTrix Pro will not work without this file!
+
+Full pathname of TRXPRO.HEX firmware file
+CONFIG_TRIX_BOOT_FILE
+  Enter the full pathname of your TRXPRO.HEX file, starting from /.
+
+Support for OPTi MAD16 and/or Mozart based cards
+CONFIG_SOUND_MAD16
+  Answer Y if your card has a Mozart (OAK OTI-601) or MAD16 (OPTi
+  82C928 or 82C929 or 82C931) audio interface chip. These chips are 
+  quite common so it's possible that many no-name cards have one of
+  them. In addition the MAD16 chip is used in some cards made by known
+  manufacturers such as Turtle Beach (Tropez), Reveal (some models)
+  and Diamond (latest ones). Note however that the Tropez sound cards
+  have their own driver; if you have one of those, say N here and Y or
+  M to "Full support for Turtle Beach WaveFront", below. 
+
+  If you compile the driver into the kernel, you have to add
+  "mad16=<io>,<irq>,<dma>,<dma2>,<mpuio>,<mpuirq>" to the
+  kernel command line.
+
+  See also Documentation/sound/Opti and Documentation/sound/MAD16 for
+  more information on setting these cards up as modules.
+
+Full support for Turtle Beach WaveFront synth/sound cards
+CONFIG_SOUND_WAVEFRONT
+  Answer Y or M if you have a Tropez Plus, Tropez or Maui sound card
+  and read the files Documentation/sound/Wavefront and
+  Documentation/sound/Tropez+.
+  
+Support MIDI in older MAD16 based cards (requires SB)
+CONFIG_MAD16_OLDCARD
+  Answer Y (or M) if you have an older card based on the C928 or
+  Mozart chipset and you want to have MIDI support. If you enable this
+  option you also need to enable support for Sound Blaster.
+
+Support for Crystal CS4232 based (PnP) cards
+CONFIG_SOUND_CS4232
+  Say Y here if you have a card based on the Crystal CS4232 chip set,
+  which uses its own Plug and Play protocol.
+
+  If you compile the driver into the kernel, you have to add
+  "cs4232=<io>,<irq>,<dma>,<dma2>,<mpuio>,<mpuirq>" to the kernel
+  command line.
+
+  See Documentation/sound/CS4232 for more information on configuring
+  this card.
+
+Support for Yamaha OPL3-SA2, SA3, and SAx based PnP cards
+CONFIG_SOUND_OPL3SA2
+  Say Y or M if you have a card based on one of these Yamaha
+  sound chipsets. Read Documentation/sound/OPL3-SA2 for more
+  information on configuring these cards.
+
+  If you compile the driver into the kernel, you have to add
+  "opl3sa2=<io>,<irq>,<dma>,<dma2>,<mssio>,<mpuio>" to the kernel
+  command line.
+
+Support for Turtle Beach Wave Front (Maui, Tropez) synthesizers
+CONFIG_SOUND_MAUI
+  Say Y here if you have a Turtle Beach Wave Front, Maui, or Tropez
+  sound card.
+
+  If you compile the driver into the kernel, you have to add
+  "maui=<io>,<irq>" to the kernel command line.
+
+Have OSWF.MOT firmware file
+CONFIG_MAUI_HAVE_BOOT
+  Turtle Beach Maui and Tropez sound cards have a microcontroller
+  which needs to be initialized prior to use. OSWF.MOT is a file
+  distributed with the card's DOS/Windows drivers. Answer Y if you
+  have this file.
+
+Full pathname of OSWF.MOT firmware file
+CONFIG_MAUI_BOOT_FILE
+  Enter the full pathname of your OSWF.MOT file, starting from /.
+
+Support for Turtle Beach MultiSound Classic, Tahiti, Monterey
+CONFIG_SOUND_MSNDCLAS
+  Say M here if you have a Turtle Beach MultiSound Classic, Tahiti or
+  Monterey (not for the Pinnacle or Fiji). 
+
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of MSNDINIT.BIN firmware file
+CONFIG_MSNDCLAS_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of MSNDPERM.BIN firmware file
+CONFIG_MSNDCLAS_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Support for Turtle Beach MultiSound Pinnacle, Fiji
+CONFIG_SOUND_MSNDPIN
+  Say M here if you have a Turtle Beach MultiSound Pinnacle or Fiji.
+  See Documentation/sound/MultiSound for important information about
+  this driver.
+
+Full pathname of PNDSPINI.BIN firmware file
+CONFIG_MSNDPIN_INIT_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+Full pathname of PNDSPERM.BIN firmware file
+CONFIG_MSNDPIN_PERM_FILE
+  The MultiSound cards have two firmware files which are required for
+  operation, and are not currently included. These files can be
+  obtained from Turtle Beach. See Documentation/sound/MultiSound for
+  information on how to obtain this.
+
+MSND Pinnacle have S/PDIF I/O
+CONFIG_MSNDPIN_DIGITAL
+  If you have the S/PDIF daughter board for the Pinnacle or Fiji,
+  answer Y here; otherwise, say N. If you have this, you will be able
+  to play and record from the S/PDIF port (digital signal). See
+  Documentation/sound/MultiSound for information on how to make use of
+  this capability.
+
+MSND Pinnacle non-PnP Mode
+CONFIG_MSNDPIN_NONPNP
+  The Pinnacle and Fiji card resources can be configured either with
+  PnP, or through a configuration port. Say Y here if your card is NOT
+  in PnP mode. For the Pinnacle, configuration in non-PnP mode allows
+  use of the IDE and joystick peripherals on the card as well; these
+  do not show up when the card is in PnP mode. Specifying zero for any
+  resource of a device will disable the device. If you are running the
+  card in PnP mode, you must say N here and use isapnptools to
+  configure the card's resources.
+
+MSND Pinnacle config port
+CONFIG_MSNDPIN_CFG
+  This is the port which the Pinnacle and Fiji uses to configure the
+  card's resources when not in PnP mode. If your card is in PnP mode,
+  then be sure to say N to the previous option, "MSND Pinnacle Non-PnP
+  Mode".
+
+MSND buffer size (kB)
+CONFIG_MSND_FIFOSIZE
+  Configures the size of each audio buffer, in kilobytes, for
+  recording and playing in the MultiSound drivers (both the Classic
+  and Pinnacle). Larger values reduce the chance of data overruns at
+  the expense of overall latency. If unsure, use the default.
+
+FM synthesizer (YM3812/OPL-3) support
+CONFIG_SOUND_YM3812
+  Answer Y if your card has a FM chip made by Yamaha (OPL2/OPL3/OPL4).
+  Answering Y is usually a safe and recommended choice, however some
+  cards may have software (TSR) FM emulation. Enabling FM support with
+  these cards may cause trouble (I don't currently know of any such
+  cards, however).
+  Please read the file Documentation/sound/OPL3 if your card has an
+  OPL3 chip.
+
+  If you compile the driver into the kernel, you have to add
+  "opl3=<io>" to the kernel command line.
+
+  If unsure, say Y.
+
+ACI mixer (miroPCM12/PCM20)
+CONFIG_SOUND_ACI_MIXER
+  ACI (Audio Command Interface) is a protocol used to communicate with
+  the microcontroller on some sound cards produced by miro, e.g. the
+  miroSOUND PCM12 and PCM20. The main function of the ACI is to
+  control the mixer and to get a product identification. 
+
+  This Voxware ACI driver currently only supports the ACI functions on
+  the miroSOUND PCM12 and PCM20 cards. On the PCM20, ACI also controls
+  the radio tuner. This is supported in the video4linux
+  radio-miropcm20 driver.
+
+SB32/AWE support
+CONFIG_SOUND_AWE32_SYNTH
+  Say Y here if you have a Sound Blaster SB32, AWE32-PnP, SB AWE64 or
+  similar sound card. See Documentation/sound/README.awe,
+  Documentation/sound/AWE32 and the Soundblaster-AWE mini-HOWTO,
+  available from http://www.linuxdoc.org/docs.html#howto for more
+  info.
+
+Gallant's Audio Excel DSP 16 support (SC-6000 and SC-6600)
+CONFIG_SOUND_AEDSP16
+  Answer Y if you have a Gallant's Audio Excel DSP 16 card. This
+  driver supports Audio Excel DSP 16 but not the III nor PnP versions
+  of this card.
+
+  The Gallant's Audio Excel DSP 16 card can emulate either an SBPro or
+  a Microsoft Sound System card, so you should have said Y to either
+  "100% Sound Blaster compatibles (SB16/32/64, ESS, Jazz16) support"
+  or "Microsoft Sound System support", above, and you need to answer
+  the "MSS emulation" and "SBPro emulation" questions below
+  accordingly. You should say Y to one and only one of these two
+  questions.
+
+  Read the drivers/sound/lowlevel/README.aedsp16 file and the head of
+  drivers/sound/lowlevel/aedsp16.c as well as
+  Documentation/sound/AudioExcelDSP16 to get more information about
+  this driver and its configuration.
+
+Audio Excel DSP 16 (SBPro emulation)
+CONFIG_AEDSP16_SBPRO
+  Answer Y if you want your audio card to emulate Sound Blaster Pro.
+  You should then say Y to "100% Sound Blaster compatibles
+  (SB16/32/64, ESS, Jazz16) support" and N to "Audio Excel DSP 16 (MSS
+  emulation)".
+
+  If you compile the driver into the kernel, you have to add
+  "aedsp16=<io>,<irq>,<dma>,<mssio>,<mpuio>,<mouirq>" to the kernel
+  command line.
+
+Audio Excel DSP 16 (MSS emulation)
+CONFIG_AEDSP16_MSS
+  Answer Y if you want your audio card to emulate Microsoft Sound
+  System. You should then say Y to "Microsoft Sound System support"
+  and say N to "Audio Excel DSP 16 (SBPro emulation)".
+
+SC-6600 based audio cards (new Audio Excel DSP 16)
+CONFIG_SC6600
+  The SC6600 is the new version of DSP mounted on the Audio Excel DSP
+  16 cards. Find in the manual the FCC ID of your audio card and
+  answer Y if you have an SC6600 DSP.
+
+SC-6600 Joystick Interface
+CONFIG_SC6600_JOY
+  Say Y here in order to use the joystick interface of the Audio Excel
+  DSP 16 card.
+
+SC-6600 CDROM Interface
+CONFIG_SC6600_CDROM
+  This is used to activate the the CDROM interface of the Audio Excel
+  DSP 16 card. Enter: 0 for Sony, 1 for Panasonic, 2 for IDE, 4 for no
+  CDROM present.
+
+Audio Excel DSP 16 (MPU401 emulation)
+CONFIG_AEDSP16_MPU401
+  Answer Y if you want your audio card to emulate the MPU-401 midi
+  interface. You should then also say Y to "MPU-401 support".
+  
+  Note that the I/O base for MPU-401 support of aedsp16 is the same
+  you have selected for "MPU-401 support". If you are using this
+  driver as a module you have to specify the MPU I/O base address with
+  the parameter 'mpu_base=0xNNN'.
+
+Creative EMU10K1 based PCI sound cards
+CONFIG_SOUND_EMU10K1
+  Say Y or M if you have a PCI sound card using the EMU10K1
+  chipset, such as the Creative SBLive!,  SB PCI512 or Emu-APS.
+
+Crystal SoundFusion (CS4280/461x)
+CONFIG_SOUND_FUSION
+  This module drives the Crystal SoundFusion devices (CS4280/46xx series)
+  when wired as native sound drivers with AC97 codecs. If this driver
+  does not work try the CS4232 driver.
+
+Ensoniq ES1370 based PCI sound cards
+CONFIG_SOUND_ES1370
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1370 chipset, such as Ensoniq's AudioPCI (non-97). To find
+  out if your sound card uses an ES1370 without removing your
+  computer's cover, use lspci -n and look for the PCI ID 
+  1274:5000. Since Ensoniq was bought by Creative Labs,
+  Sound Blaster 64/PCI models are either ES1370 or ES1371 based.
+  This driver differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/es1370.
+
+Ensoniq ES1371 based PCI sound cards
+CONFIG_SOUND_ES1371
+  Say Y or M if you have a PCI sound card utilizing the Ensoniq
+  ES1371 chipset, such as Ensoniq's AudioPCI97. To find out if
+  your sound card uses an ES1371 without removing your computer's
+  cover, use lspci -n and look for the PCI ID 1274:1371. Since
+  Ensoniq was bought by Creative Labs, Sound Blaster 64/PCI
+  models are either ES1370 or ES1371 based. This driver differs
+  slightly from OSS/Free, so PLEASE READ Documentation/sound/es1371.
+
+ESS Solo1 based PCI sound cards (eg. SC1938)
+CONFIG_SOUND_ESSSOLO1
+  Say Y or M if you have a PCI sound card utilizing the ESS Technology
+  Solo1 chip. To find out if your sound card uses a
+  Solo1 chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 125D:1969. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/solo1.
+
+S3 SonicVibes based PCI sound cards
+CONFIG_SOUND_SONICVIBES
+  Say Y or M if you have a PCI sound card utilizing the S3
+  SonicVibes chipset. To find out if your sound card uses a
+  SonicVibes chip without removing your computer's cover, use
+  lspci -n and look for the PCI ID 5333:CA00. This driver 
+  differs slightly from OSS/Free, so PLEASE READ
+  Documentation/sound/sonicvibes.
+
+Trident 4DWave DX/NX, SiS 7018 or ALi 5451 PCI Audio Core
+CONFIG_SOUND_TRIDENT
+  Say Y or M if you have a PCI sound card utilizing the Trident
+  4DWave-DX/NX chipset or your mother board chipset has SiS 7018
+  or ALi 5451 built-in. The SiS 7018 PCI Audio Core is embedded
+  in SiS960 Super South Bridge and SiS540/630 Single Chipset.
+  The ALi 5451 PCI Audio Core is embedded in ALi M1535, M1535D,
+  M1535+ or M1535D+ South Bridge.
+
+  Use lspci -n to find out if your sound card or chipset uses
+  Trident 4DWave or SiS 7018. PCI ID 1023:2000 or 1023:2001 stands
+  for Trident 4Dwave. PCI ID 1039:7018 stands for SiS7018. PCI ID
+  10B9:5451 stands for ALi5451.
+
+  This driver supports S/PDIF in/out (record/playback) for ALi 5451
+  embedded in ALi M1535+ and M1535D+. Note that they aren't all 
+  enabled by default; you can enable them by saying Y to "/proc file
+  system support" and "Sysctl support", and after the /proc file 
+  system has been mounted, executing the command
+
+	command			what is enabled
+  
+  echo 0>/proc/ALi5451	pcm out is also set to S/PDIF out. (Default).
+  
+  echo 1>/proc/ALi5451	use S/PDIF out to output pcm data.
+  
+  echo 2>/proc/ALi5451	use S/PDIF out to output non-pcm data.(AC3...).
+
+  echo 3>/proc/ALi5451	record from Ac97 in(MIC, Line in...). (Default).
+  
+  echo 4>/proc/ALi5451	no matter Ac97 settings, record from S/PDIF in.
+  
+  
+  This driver differs slightly from OSS/Free, so PLEASE READ the
+  comments at the top of driver/sound/trident.c
+
+Rockwell WaveArtist
+CONFIG_SOUND_WAVEARTIST
+  Say Y here to include support for the Rockwell WaveArtist sound
+  system.  This driver is mainly for the NetWinder.
+
+VIA 82Cxxx Audio Codec
+CONFIG_SOUND_VIA82CXXX
+  Say Y here to include support for the audio codec found on VIA
+  82Cxxx-based chips. Typically these are built into a motherboard. DO
+  NOT select Sound Blaster or Adlib with this driver, unless you have
+  a Sound Blaster or Adlib card in addition to your VIA audio chip.
+
+NeoMagic 256AV/256ZX sound chipsets
+CONFIG_SOUND_NM256
+  Say M here to include audio support for the NeoMagic 256AV/256ZX
+  chipsets. These are the audio chipsets found in the Sony
+  Z505S/SX/DX, some Sony F-series, and the Dell Latitude CPi and CPt
+  laptops. It includes support for an AC97-compatible mixer and an
+  apparently proprietary sound engine.
+
+  See Documentation/sound/NM256 for further information.
+
+ESS Maestro sound chipsets
+CONFIG_SOUND_MAESTRO
+  Say Y or M if you have a sound system driven by ESS's Maestro line
+  of PCI sound chips.  These include the Maestro 1, Maestro 2, and
+  Maestro 2E.  See Documentation/sound/Maestro for more details.
+
+Are you using a crosscompiler
+CONFIG_CROSSCOMPILE
+  Say Y here if you are compiling the kernel on a different
+  architecture than the one it is intended to run on.
+
+Kernel support for Linux/MIPS 32-bit binary compatibility
+CONFIG_MIPS32_COMPAT
+  Select this option if you want Linux/MIPS 32-bit binary
+  compatibility. Since all software available for Linux/MIPS is
+  currently 32-bit you should say Y here.
+
+Build fp exception handler module
+CONFIG_MIPS_FPE_MODULE
+  Build the floating point exception handler module. This option is
+  only useful for people working on the floating point exception
+  handler. If you don't, say N.
+
+Remote GDB kernel debugging
+CONFIG_REMOTE_DEBUG
+  If you say Y here, it will be possible to remotely debug the MIPS
+  kernel using gdb. This enlarges your kernel image disk size by
+  several megabytes and requires a machine with more than 16 MB,
+  better 32 MB RAM to avoid excessive linking time. This is only
+  useful for kernel hackers. If unsure, say N.
+
+Magic System Request Key support
+CONFIG_MAGIC_SYSRQ
+  If you say Y here, you will have some control over the system even
+  if the system crashes for example during kernel debugging (e.g., you
+  will be able to flush the buffer cache to disk, reboot the system
+  immediately or dump some status information). This is accomplished
+  by pressing various keys while holding SysRq (Alt+PrintScreen). It
+  also works on a serial console (on PC hardware at least), if you
+  send a BREAK and then within 5 seconds a command keypress. The
+  keys are documented in Documentation/sysrq.txt. Don't say Y unless
+  you really know what this hack does.
+
+ISDN subsystem
+CONFIG_ISDN
+  ISDN ("Integrated Services Digital Networks", called RNIS in France)
+  is a special type of fully digital telephone service; it's mostly
+  used to connect to your Internet service provider (with SLIP or
+  PPP). The main advantage is that the speed is higher than ordinary
+  modem/telephone connections, and that you can have voice
+  conversations while downloading stuff. It only works if your
+  computer is equipped with an ISDN card and both you and your service
+  provider purchased an ISDN line from the phone company. For details,
+  read http://alumni.caltech.edu/~dank/isdn/ on the WWW.
+
+  This driver allows you to use an ISDN-card for networking
+  connections and as dialin/out device. The isdn-tty's have a built in
+  AT-compatible modem emulator. Network devices support autodial,
+  channel-bundling, callback and caller-authentication without having
+  a daemon running. A reduced T.70 protocol is supported with tty's
+  suitable for German BTX. On D-Channel, the protocols EDSS1
+  (Euro-ISDN) and 1TR6 (German style) are supported. See
+  Documentation/isdn/README for more information. 
+
+  If you want to compile the ISDN code as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want), say M here and read Documentation/modules.txt. The module
+  will be called isdn.o. If unsure, say N.
+
+Support synchronous PPP
+CONFIG_ISDN_PPP
+  Over digital connections such as ISDN, there is no need to
+  synchronize sender and recipient's clocks with start and stop bits
+  as is done over analog telephone lines. Instead, one can use
+  "synchronous PPP". Saying Y here will include this protocol. This
+  protocol is used by Cisco and Sun for example. So you want to say Y
+  here if the other end of your ISDN connection supports it. You will
+  need a special version of pppd (called ipppd) for using this
+  feature. See Documentation/isdn/README.syncppp and
+  Documentation/isdn/syncPPP.FAQ for more information.
+
+Support generic MP (RFC 1717)
+CONFIG_ISDN_MPP
+  With synchronous PPP enabled, it is possible to increase throughput
+  by bundling several ISDN-connections, using this protocol. See
+  Documentation/isdn/README.syncppp for more information.
+
+Use VJ-compression with synchronous PPP
+CONFIG_ISDN_PPP_VJ
+  This enables Van Jacobson header compression for synchronous PPP.
+  Say Y if the other end of the connection supports it.
+
+Support audio via ISDN
+CONFIG_ISDN_AUDIO
+  If you say Y here, the modem-emulator will support a subset of the
+  EIA Class 8 Voice commands. Using a getty with voice-support
+  (mgetty+sendfax by gert@greenie.muc.de with an extension, available
+  with the ISDN utility package for example), you will be able to use
+  your Linux box as an ISDN-answering machine. Of course, this must be
+  supported by the lowlevel driver also. Currently, the HiSax driver
+  is the only voice-supporting driver. See
+  Documentation/isdn/README.audio for more information.
+
+X.25 PLP on top of ISDN
+CONFIG_ISDN_X25
+  This feature provides the X.25 protocol over ISDN connections. 
+  See Documentation/isdn/README.x25 for more information
+  if you are thinking about using this.
+
+ISDN diversion services support
+CONFIG_ISDN_DIVERSION
+  This option allows you to use some supplementary diversion
+  services in conjunction with the HiSax driver on an EURO/DSS1
+  line. 
+
+  Supported options are CD (call deflection), CFU (Call forward
+  unconditional), CFB (Call forward when busy) and CFNR (call forward
+  not reachable). Additionally the actual CFU, CFB and CFNR state may
+  be interrogated.
+
+  The use of CFU, CFB, CFNR and interrogation may be limited to some
+  countries. The keypad protocol is still not implemented. CD should
+  work in all countries if the service has been subscribed to.
+
+  Please read the file Documentation/isdn/README.diversion.
+
+ICN 2B and 4B support
+CONFIG_ISDN_DRV_ICN
+  This enables support for two kinds of ISDN-cards made by a German
+  company called ICN. 2B is the standard version for a single ISDN
+  line with two B-channels, 4B supports two ISDN lines. For running
+  this card, additional firmware is necessary, which has to be
+  downloaded into the card using a utility which is distributed
+  separately. See Documentation/isdn/README and README.icn for more
+  information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called icn.o.
+
+isdnloop support
+CONFIG_ISDN_DRV_LOOP
+  This driver provides a virtual ISDN card. Its primary purpose is
+  testing of linklevel features or configuration without getting
+  charged by your service-provider for lots of phone calls.
+  You need will need the loopctrl utility from the latest isdn4k-utils
+  package to set up this driver.
+
+HiSax SiemensChipSet driver support
+CONFIG_ISDN_DRV_HISAX
+  This is a driver supporting the Siemens chipset on various
+  ISDN-cards (like AVM A1, Elsa ISDN cards, Teles S0-16.0, Teles
+  S0-16.3, Teles S0-8, Teles/Creatix PnP, ITK micro ix1 and many
+  compatibles). 
+
+  HiSax is just the name of this driver, not the name of any hardware.
+  
+  If you have a card with such a chipset, you should say Y here and
+  also to the configuration option of the driver for your particular
+  card, below.
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called hisax.o. See Documentation/isdn/README.HiSax for more
+  information on using this driver.
+
+HiSax Support for EURO/DSS1
+CONFIG_HISAX_EURO
+  Say Y or N according to the D-channel protocol which your local
+  telephone service company provides.
+
+  The call control protocol E-DSS1 is used in most European countries.
+  If unsure, say yes.
+
+Support for german charge info
+CONFIG_DE_AOC
+  If you want that the HiSax hardware driver sends messages to the
+  upper level of the isdn code on each AOCD (Advice Of Charge, During
+  the call -- transmission of the fee information during a call) and
+  on each AOCE (Advice Of Charge, at the End of the call --
+  transmission of fee information at the end of the call), say Y here.
+  This works only in Germany.
+
+Disable sending complete
+CONFIG_HISAX_NO_SENDCOMPLETE
+  If you have trouble with some ugly exchanges or you live in
+  Australia select this option.
+
+Disable sending low layer compatibility
+CONFIG_HISAX_NO_LLC
+  If you have trouble with some ugly exchanges try to select this
+  option.
+
+Disable keypad protocol option
+CONFIG_HISAX_NO_KEYPAD
+  If you like to send special dial strings including * or # without
+  using the keypad protocol, select this option.
+
+HiSax Support for German 1TR6
+CONFIG_HISAX_1TR6
+  Say Y or N according to the D-channel protocol which your local
+  telephone service company provides.
+
+  1TR6 is an old call control protocol which was used in Germany
+  before E-DSS1 was established. Nowadays, all new lines in Germany
+  use E-DSS1.
+
+HiSax Support for US NI1
+CONFIG_HISAX_NI1
+  Enable this if you like to use ISDN in US on a NI1 basic rate interface.
+
+Teles 16.0/8.0
+CONFIG_HISAX_16_0
+  This enables HiSax support for the Teles ISDN-cards S0-16.0, S0-8
+  and many compatibles. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port/shmem settings.
+
+Teles 16.3 or PNP or PCMCIA
+CONFIG_HISAX_16_3
+  This enables HiSax support for the Teles ISDN-cards S0-16.3 the
+  Teles/Creatix PnP and the Teles PCMCIA.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Teles PCI
+CONFIG_HISAX_TELESPCI
+  This enables HiSax support for the Teles PCI.
+  See Documentation/isdn/README.HiSax on how to configure it.
+ 
+Teles S0Box
+CONFIG_HISAX_S0BOX
+  This enables HiSax support for the Teles/Creatix parallel port
+  S0BOX.  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 (Fritz)
+CONFIG_HISAX_AVM_A1
+  This enables HiSax support for the AVM A1 (aka "Fritz").
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+AVM PnP/PCI (Fritz!PNP/PCI)
+CONFIG_HISAX_FRITZPCI
+  This enables HiSax support for the AVM "Fritz!PnP" and "Fritz!PCI".
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+AVM A1 PCMCIA (Fritz)
+CONFIG_HISAX_AVM_A1_PCMCIA
+  This enables HiSax support for the AVM A1 "Fritz!PCMCIA").
+  See Documentation/isdn/README.HiSax on how to configure it.
+
+Elsa cards
+CONFIG_HISAX_ELSA
+  This enables HiSax support for the Elsa Mircolink ISA cards, for the
+  Elsa Quickstep series cards and Elsa PCMCIA.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ITK ix1-micro Revision 2
+CONFIG_HISAX_IX1MICROR2
+  This enables HiSax support for the ITK ix1-micro Revision 2 card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Eicon.Diehl Diva cards
+CONFIG_HISAX_DIEHLDIVA
+  This enables HiSax support for the Eicon.Diehl Diva none PRO
+  versions passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+ASUSCOM ISA cards
+CONFIG_HISAX_ASUSCOM
+  This enables HiSax support for the AsusCom and their OEM versions
+  passive ISDN ISA cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+TELEINT cards
+CONFIG_HISAX_TELEINT
+  This enables HiSax support for the TELEINT SA1 semiactiv ISDN card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+HFC-S based cards
+CONFIG_HISAX_HFCS
+  This enables HiSax support for the HFC-S 2BDS0 based cards, like
+  teles 16.3c.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+Sedlbauer cards
+CONFIG_HISAX_SEDLBAUER
+  This enables HiSax support for the Sedlbauer passive ISDN cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using the
+  different cards, a different D-channel protocol, or non-standard
+  IRQ/port settings.
+
+USR Sportster internal TA
+CONFIG_HISAX_SPORTSTER
+  This enables HiSax support for the USR Sportster internal TA card.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+MIC card
+CONFIG_HISAX_MIC
+  This enables HiSax support for the ITH MIC card. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+NETjet card
+CONFIG_HISAX_NETJET
+  This enables HiSax support for the NetJet from Traverse
+  Technologies.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+NETspider U card
+CONFIG_HISAX_NETJET_U
+  This enables HiSax support for the Netspider U interface ISDN card from
+  Traverse Technologies.
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Niccy PnP/PCI card
+CONFIG_HISAX_NICCY
+  This enables HiSax support for the Dr. Neuhaus Niccy PnP or PCI. 
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Siemens I-Surf card
+CONFIG_HISAX_ISURF
+  This enables HiSax support for the Siemens I-Talk/I-Surf card with
+  ISAR chip.
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HST Saphir card
+CONFIG_HISAX_HSTSAPHIR
+  This enables HiSax support for the HST Saphir card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Telekom A4T card
+CONFIG_HISAX_BKM_A4T
+  This enables HiSax support for the Telekom A4T card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Scitel Quadro card
+CONFIG_HISAX_SCT_QUADRO
+  This enables HiSax support for the Scitel Quadro card.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+Gazel cards
+CONFIG_HISAX_GAZEL
+  This enables HiSax support for the Gazel cards.
+
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC PCI-Bus cards
+CONFIG_HISAX_HFC_PCI
+  This enables HiSax support for the HFC-S PCI 2BDS0 based cards.
+  
+  For more informations see under Documentation/isdn/README.hfc-pci.
+
+Winbond W6692 based cards
+CONFIG_HISAX_W6692
+  This enables HiSax support for Winbond W6692 based PCI ISDN cards.
+  
+  See Documentation/isdn/README.HiSax on how to configure it using a
+  different D-channel protocol, or non-standard IRQ/port settings.
+
+HFC-S+, HFC-SP, HFC-PCMCIA cards (EXPERIMENTAL)
+CONFIG_HISAX_HFC_SX
+  This enables HiSax support for the HFC-S+, HFC-SP and HFC-PCMCIA
+  cards. This code is not finished yet.
+
+Am7930 (EXPERIMENTAL)
+CONFIG_HISAX_AMD7930
+  This enables HiSax support for the AMD7930 chips on some SPARCs.
+  This code is not finished yet.
+
+PCBIT-D support
+CONFIG_ISDN_DRV_PCBIT
+  This enables support for the PCBIT ISDN-card. This card is
+  manufactured in Portugal by Octal. For running this card, additional
+  firmware is necessary, which has to be downloaded into the card
+  using a utility which is distributed separately. See
+  Documentation/isdn/README and Documentation/isdn/README.pcbit for
+  more information. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called pcbit.o.
+
+Spellcaster support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_SC
+  This enables support for the Spellcaster BRI ISDN boards. This
+  driver currently builds only in a modularized version ( = code which
+  can be inserted in and removed from the running kernel whenever you
+  want, details in Documentation/modules.txt); the module will be
+  called sc.o. See Documentation/isdn/README.sc and
+  http://www.spellcast.com for more information.
+
+Eicon active card support
+CONFIG_ISDN_DRV_EICON
+  Say Y here if you have an Eicon active ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using the eiconctrl utility which is part of the
+  latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+  
+Eicon Diva Server card support
+CONFIG_ISDN_DRV_EICON_PCI
+  Say Y here if you have an Eicon Diva Server (BRI/PRI/4BRI) ISDN card.
+  Please read Documentation/isdn/README.eicon for more information.
+  
+Eicon old-type card support
+CONFIG_ISDN_DRV_EICON_ISA
+  Say Y here if you have an old-type Eicon active ISDN card. In order
+  to use this card, additional firmware is necessary, which has to be
+  loaded into the card using the eiconctrl utility which is part of
+  the latest isdn4k-utils package. Please read the file
+  Documentation/isdn/README.eicon for more information.
+
+Eicon driver type standalone
+CONFIG_ISDN_DRV_EICON_STANDALONE
+  Enable this option if you want the eicon driver as standalone
+  version with no interface to the ISDN4Linux isdn module. If you
+  say Y here, the eicon module only supports the Diva Server PCI
+  cards and will provide its own IDI interface. You should say N
+  here.
+
+Support AT-Fax Class 1 and 2 commands
+CONFIG_ISDN_TTY_FAX
+  If you say Y here, the modem-emulator will support a subset of the
+  Fax Class 1 and 2 commands. Using a getty with fax-support
+  (mgetty+sendfax, hylafax), you will be able to use your Linux box as
+  an ISDN-fax-machine. This must be supported by the lowlevel driver
+  also. See Documentation/isdn/README.fax for more information.
+
+CAPI2.0 support
+CONFIG_ISDN_CAPI
+  This provides the CAPI (Common ISDN Application Programming
+  Interface, a standard making it easy for programs to access ISDN
+  hardware, see http://www.capi.org/ . This is needed for AVM's set of
+  active ISDN controllers like B1, T1, M1.
+
+  This code is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The modules will be called capi.o and kernelcapi.o. If you want to
+  compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+AVM B1 ISA support
+CONFIG_ISDN_DRV_AVMB1_B1ISA
+  Enable support for the ISA version of the AVM B1 card.
+
+AVM B1 PCI support
+CONFIG_ISDN_DRV_AVMB1_B1PCI
+  Enable support for the PCI version of the AVM B1 card.
+
+AVM B1 PCI V4 support
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4
+  Enable support for the V4 version of AVM B1 PCI card.
+
+AVM T1/T1-B ISA support
+CONFIG_ISDN_DRV_AVMB1_T1ISA
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM B1/M1/M2 PCMCIA support
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA
+  Enable support for the PCMCIA version of the AVM B1 card.
+
+AVM T1/T1-B PCI support
+CONFIG_ISDN_DRV_AVMB1_T1PCI
+  Enable support for the AVM T1 T1B card.
+  Note: This is a PRI card and handle 30 B-channels.
+
+AVM C4 support
+CONFIG_ISDN_DRV_AVMB1_C4
+  Enable support for the AVM C4 PCI card.
+  This card handle 4 BRI ISDN lines (8 channels).
+
+Verbose reason code reporting (kernel size +=7K)
+CONFIG_ISDN_DRV_AVMB1_VERBOSE_REASON
+  If you say Y here, the AVM B1 driver will give verbose reasons for
+  disconnecting. This will increase the size of the kernel by 7 KB. If
+  unsure, say Y.
+
+IBM Active 2000 support (EXPERIMENTAL)
+CONFIG_ISDN_DRV_ACT2000
+  Say Y here if you have an IBM Active 2000 ISDN card. In order to use
+  this card, additional firmware is necessary, which has to be loaded
+  into the card using a utility which is part of the latest
+  isdn4k-utils package. Please read the file
+  Documentation/isdn/README.act2000 for more information.
+
+Hypercope HYSDN cards (Champ, Ergo, Metro) support (module)
+CONFIG_HYSDN
+  Say Y here if you have one of Hypercope's active PCI ISDN cards
+  Champ, Ergo and Metro. You will then get a module called hysdn.o.
+  Please read the file Documentation/isdn/README.hysdn for more
+  information.
+
+HYSDN CAPI 2.0 support
+CONFIG_HYSDN_CAPI
+  Say Y here if you like to use Hypercope's CAPI 2.0 interface
+
+Support for Sun4 architecture
+CONFIG_SUN4
+  Say Y here if, and only if, your machine is a Sun4. Note that
+  a kernel compiled with this option will run only on Sun4.
+  (And the current version will probably work only on sun4/330.)
+
+SPARC ESP SCSI support
+CONFIG_SCSI_SUNESP
+  This is the driver for the Sun ESP SCSI host adapter. The ESP
+  chipset is present in most SPARC SBUS-based computers.
+
+  This support is also available as a module called esp.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+PTI Qlogic, ISP Driver
+CONFIG_SCSI_QLOGICPTI
+  This driver supports SBUS SCSI controllers from PTI or QLogic. These
+  controllers are known under Solaris as qpti and in the openprom as
+  PTI,ptisp or QLGC,isp. Note that PCI QLogic SCSI controllers are
+  driven by a different driver.
+
+  This support is also available as a module called qlogicpti.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SPARC /dev/openprom compatibility driver (EXPERIMENTAL)
+CONFIG_SUN_OPENPROMIO
+  This driver provides user programs with an interface to the SPARC
+  PROM device tree. The driver implements a SunOS-compatible
+  interface and a NetBSD-compatible interface. 
+
+  If you want to compile this as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M and read Documentation/modules.txt. If unsure, say Y.
+
+Openprom tree appears in /proc/openprom
+CONFIG_SUN_OPENPROMFS
+  If you say Y, the OpenPROM device tree will be available as a
+  virtual file system, which you can mount to /proc/openprom by "mount
+  -t openpromfs none /proc/openprom".
+
+  If you want to compile the /proc/openprom support as a module ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want), say M here and read Documentation/modules.txt.
+  The module will be called openpromfs.o. If unsure, say M.
+
+Kernel support for Linux/Sparc 32bit binary compatibility
+CONFIG_SPARC32_COMPAT
+  This allows you to run 32-bit binaries on your Ultra.
+  Everybody wants this; say Y.
+
+Kernel support for 32-bit ELF binaries
+CONFIG_BINFMT_ELF32
+  This allows you to run 32-bit Linux/ELF binaries on your Ultra.
+  Everybody wants this; say Y.
+
+Kernel support for 32-bit (ie. SunOS) a.out binaries
+CONFIG_BINFMT_AOUT32
+  This allows you to run 32-bit a.out format binaries on your Ultra.
+  If you want to run SunOS binaries (see SunOS binary emulation below)
+  or other a.out binaries, say Y. If unsure, say N.
+
+SunOS binary emulation
+CONFIG_SUNOS_EMUL
+  This allows you to run most SunOS binaries. If you want to do this,
+  say Y here and place appropriate files in /usr/gnemul/sunos. See
+  http://www.ultralinux.org/faq.html for more information. If you want
+  to run SunOS binaries on an Ultra you must also say Y to "Kernel
+  support for 32-bit a.out binaries" above.
+
+Mostek real time clock support
+CONFIG_SUN_MOSTEK_RTC
+  The Mostek RTC chip is used on all known Sun computers except
+  some JavaStations. For a JavaStation you need to say Y both here
+  and to "Enhanced Real Time Clock Support".
+
+  Say Y here unless you are building a special purpose kernel.
+
+OBP Flash Device support
+CONFIG_OBP_FLASH
+  The OpenBoot PROM on Ultra systems is flashable. If you want to be
+  able to upgrade the OBP firmware, say Y here.
+
+JavaStation OS Flash SIMM
+CONFIG_SUN_JSFLASH
+  If you say Y here, you will be able to boot from your JavaStation's
+  Flash memory.
+
+Siemens SAB82532 serial support
+CONFIG_SAB82532
+  This driver supports the serial ports on newer (PCI) Ultra systems.
+  Say Y if you want to be able to use your serial ports.
+
+Aurora Multiboard 1600se (EXPERIMENTAL)
+CONFIG_SUN_AURORA
+  The Aurora Multiboard is a multi-port high-speed serial controller.
+  If you have one of these, say Y.
+
+Audio support (EXPERIMENTAL)
+CONFIG_SPARCAUDIO
+  This driver provides support for the build-in sound devices on most
+  Sun machines. If you want to be able to use this, select this option
+  and one or more of the lowlevel drivers below. See
+  http://www.dementia.org/~shadow/sparcaudio.html for more
+  information.
+
+AMD7930 Lowlevel Driver
+CONFIG_SPARCAUDIO_AMD7930
+  This driver supports the AMD 7930 chip found on sun4c, 4/6xx, and
+  SparcClassic systems.
+
+CS4231 Lowlevel Driver
+CONFIG_SPARCAUDIO_CS4231
+  This driver supports the Crystal Semiconductor CS4231 chip found on
+  the SS4, SS5, and Ultras.
+
+DBRI Lowlevel Driver
+CONFIG_SPARCAUDIO_DBRI
+  This driver supports the DBRI audio interface found on the SS10,
+  SS20, Sparcbook 3, and Voyager systems.
+
+Dummy lowlevel Driver
+CONFIG_SPARCAUDIO_DUMMY
+  This is a pseudo-driver used for debugging and testing the
+  sparcaudio subsystem. Say N unless you want to work on this
+  subsystem.
+
+Sparc hardware (EXPERIMENTAL)
+CONFIG_PARPORT_SUNBPP
+  This driver provides support for the bidirectional parallel port
+  found on many Sun machines. Note that many of the newer Ultras
+  actually have pc style hardware instead.
+
+#
+# m68k-specific kernel options
+# Documented by Chris Lawrence <quango@themall.net> et al.
+#
+Amiga support
+CONFIG_AMIGA
+  This option enables support for the Amiga series of computers. If
+  you plan to use this kernel on an Amiga, say Y here and browse the
+  material available in Documentation/m68k; otherwise say N.
+
+Atari support
+CONFIG_ATARI
+  This option enables support for the 68000-based Atari series of
+  computers (including the TT, Falcon and Medusa). If you plan to use
+  this kernel on an Atari, say Y here and browse the material
+  available in Documentation/m68k; otherwise say N.
+
+Hades support
+CONFIG_HADES
+  This option enables support for the Hades Atari clone. If you plan
+  to use this kernel on a Hades, say Y here; otherwise say N.
+
+Macintosh support
+CONFIG_MAC
+  This option enables support for the Apple Macintosh series of
+  computers (yes, there is experimental support now, at least for part
+  of the series).
+  
+  Say N unless you're willing to code the remaining necessary support.
+  ;)
+
+HP9000/300 support
+CONFIG_HP300
+  This option enables support for the HP9000/300 series of
+  workstations. Support for these machines is still very experimental.
+  If you plan to try to use the kernel on such a machine say Y here.
+  Everybody else says N.
+
+Sun 3X support
+CONFIG_SUN3X
+  This option enables support for the Sun 3x series of workstations.
+  Be warned that this support is very experimental. You will also want
+  to say Y to 68020 support and N to the other processors below.
+
+  If you don't want to compile a kernel for a Sun 3x, say N.
+
+68020 support
+CONFIG_M68020
+  If you anticipate running this kernel on a computer with a MC68020
+  processor, say Y. Otherwise, say N. Note that the 68020 requires a
+  68851 MMU (Memory Management Unit) to run Linux/m68k, except on the
+  Sun 3, which provides its own version.
+
+68030 support
+CONFIG_M68030
+  If you anticipate running this kernel on a computer with a MC68030
+  processor, say Y. Otherwise, say N. Note that a MC68EC030 will not
+  work, as it does not include an MMU (Memory Management Unit).
+
+68040 support
+CONFIG_M68040
+  If you anticipate running this kernel on a computer with a MC68LC040
+  or MC68040 processor, say Y. Otherwise, say N. Note that an
+  MC68EC040 will not work, as it does not include an MMU (Memory
+  Management Unit).
+
+68060 support
+CONFIG_M68060
+  If you anticipate running this kernel on a computer with a MC68060
+  processor, say Y. Otherwise, say N.
+
+Math emulation support (EXPERIMENTAL)
+CONFIG_M68KFPU_EMU
+  At some point in the future, this will cause floating-point math
+  instructions to be emulated by the kernel on machines that lack a
+  floating-point math coprocessor.  Thrill-seekers and chronically
+  sleep-deprived psychotic hacker types can say Y now, everyone else
+  should probably wait a while.
+
+Math emulation only kernel
+CONFIG_M68KFPU_EMU_ONLY
+  This option prevents any floating-point instructions from being
+  compiled into the kernel, thereby the kernel doesn't save any
+  floating point context anymore during task switches, so this
+  kernel will only be usable on machines without a floating-point
+  math coprocessor. This makes the kernel a bit faster as no tests
+  needs to be executed whether a floating-point instruction in the
+  kernel should be executed or not.
+
+Math emulation extra precision
+CONFIG_M68KFPU_EMU_EXTRAPREC
+  The fpu uses normally a few bit more during calculations for
+  correct rounding, the emulator can (often) do the same but this
+  extra calculation can cost quite some time, so you can disable
+  it here. The emulator will then "only" calculate with a 64 bit
+  mantissa and round slightly incorrect, what is more then enough
+  for normal usage.
+
+Advanced configuration options
+CONFIG_ADVANCED
+  This gives you access to some advanced options for the CPU. The
+  defaults should be fine for most users, but these options may make
+  it possible for you to improve performance somewhat if you know what
+  you are doing. 
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about these options.
+
+  Most users should say N to this question.
+
+Use read-modify-write instructions
+CONFIG_RMW_INSNS
+  This allows to use certain instructions that work with indivisible
+  read-modify-write bus cycles. While this is faster than the
+  workaround of disabling interrupts, it can conflict with DMA 
+  ( = direct memory access) on many Amiga systems, and it is also said
+  to destabilize other machines. It is very likely that this will
+  cause serious problems on any Amiga or Atari Medusa if set. The only
+  configuration where it should work are 68030-based Ataris, where it
+  apparently improves performance. But you've been warned! Unless you
+  really know what you are doing, say N. Try Y only if you're quite
+  adventurous.
+
+Zorro support
+CONFIG_ZORRO
+  This enables support for the Zorro bus in the Amiga. If you have
+  expansion cards in your Amiga that conform to the Amiga
+  AutoConfig(tm) specification, say Y, otherwise N. Note that even
+  expansion cards that do not fit in the Zorro slots but fit in e.g.
+  the CPU slot may fall in this category, so you have to say Y to let
+  Linux use these.
+
+Zorro device name database
+CONFIG_ZORRO_NAMES
+  By default, the kernel contains a database of all known Zorro device
+  names to make the information in /proc/iomem comprehensible to the
+  user. This database increases the size of the kernel image by about
+  15KB, but it gets freed after the system boots up, so it doesn't
+  take up kernel memory. Anyway, if you are building an installation
+  floppy or kernel for an embedded system where kernel image size
+  really matters, you can disable this feature and you'll get device
+  ID numbers instead of names.
+
+  When in doubt, say Y.
+
+Amiga 1200/600 PCMCIA support (EXPERIMENTAL)
+CONFIG_AMIGA_PCMCIA
+  Include support in the kernel for pcmcia on Amiga 1200 and Amiga
+  600. If you intend to use pcmcia cards say Y; otherwise say N.
+
+Amiga Zorro II ramdisk support
+CONFIG_AMIGA_Z2RAM
+  This enables support for using Chip RAM and Zorro II RAM as a
+  ramdisk or as a swap partition. Say Y if you want to include this
+  driver in the kernel. This driver is also available as a module 
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). The module is called z2ram.o. If you want
+  to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari ST-RAM swap support
+CONFIG_STRAM_SWAP
+  This enables support for using (parts of) ST-RAM as swap space,
+  instead of as normal system memory. This can first enhance system
+  performance if you have lots of alternate RAM (compared to the size
+  of ST-RAM), because executable code always will reside in faster
+  memory. ST-RAM will remain as ultra-fast swap space. On the other
+  hand, it allows much improved dynamic allocations of ST-RAM buffers
+  for device driver modules (e.g. floppy, ACSI, SLM printer, DMA
+  sound). The probability that such allocations at module load time
+  fail is drastically reduced.
+
+Atari ACSI support
+CONFIG_ATARI_ACSI
+  This enables support for the Atari ACSI interface. The driver
+  supports hard disks and CD-ROMs, which have 512-byte sectors, or can
+  be switched to that mode. Due to the ACSI command format, only disks
+  up to 1 GB are supported. Special support for certain ACSI to SCSI
+  adapters, which could relax that, isn't included yet. The ACSI
+  driver is also the basis for certain other drivers for devices
+  attached to the ACSI bus: Atari SLM laser printer, BioNet-100
+  Ethernet, and PAMsNet Ethernet. If you want to use one of these
+  devices, you need ACSI support, too. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called acsi.o.
+
+Probe all LUNs on each ACSI device
+CONFIG_ACSI_MULTI_LUN
+  If you have a ACSI device that supports more than one LUN (Logical
+  Unit Number), e.g. a CD jukebox, you should say Y here so that all
+  will be found by the ACSI driver. An ACSI device with multiple LUNs
+  acts logically like multiple ACSI devices. The vast majority of ACSI
+  devices have only one LUN, and so most people can say N here and
+  should in fact do so, because it is safer.
+
+Atari SLM laser printer support
+CONFIG_ATARI_SLM
+  If you have an Atari SLM laser printer, say Y to include support for
+  it in the kernel. Otherwise, say N. This driver is also available as
+  a module ( = code which can be inserted in and removed from the
+  running kernel whenever you want). The module will be called
+  acsi_slm.o. Be warned: the driver needs much ST-RAM and can cause
+  problems due to that fact!
+
+A3000 WD33C93A support
+CONFIG_A3000_SCSI
+  If you have an Amiga 3000 and have SCSI devices connected to the
+  built-in SCSI controller, say Y. Otherwise, say N. This driver is
+  also available as a module ( = code which can be inserted in and
+  removed from the running kernel whenever you want). The module is
+  called wd33c93.o. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+A2091 WD33C93A support
+CONFIG_A2091_SCSI
+  If you have a Commodore A2091 SCSI controller, say Y. Otherwise,
+  say N. This driver is also available as a module ( = code which can
+  be inserted in and removed from the running kernel whenever you
+  want). The module is called wd33c93.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+GVP Series II WD33C93A support
+CONFIG_GVP11_SCSI
+  If you have a Great Valley Products Series II SCSI controller,
+  answer Y. Also say Y if you have a later model of GVP SCSI
+  controller (such as the GVP A4008 or a Combo board). Otherwise,
+  answer N. This driver does NOT work for the T-Rex series of
+  accelerators from TekMagic and GVP-M.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module will be called gvp11.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+Cyberstorm SCSI support
+CONFIG_CYBERSTORM_SCSI
+  If you have an Amiga with an original (MkI) Phase5 Cyberstorm
+  accelerator board and the optional Cyberstorm SCSI controller,
+  answer Y. Otherwise, say N.
+
+Cyberstorm II SCSI support
+CONFIG_CYBERSTORMII_SCSI
+  If you have an Amiga with a Phase5 Cyberstorm MkII accelerator board
+  and the optional Cyberstorm SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 2060 SCSI support (EXPERIMENTAL)
+CONFIG_BLZ2060_SCSI
+  If you have an Amiga with a Phase5 Blizzard 2060 accelerator board
+  and want to use the onboard SCSI controller, say Y. Otherwise,
+  answer N.
+
+Blizzard 1230IV/1260 SCSI support
+CONFIG_BLZ1230_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard 1230IV or Blizzard
+  1260 accelerator, and the optional SCSI module, say Y. Otherwise,
+  say N.
+
+Blizzard PowerUP 603e+ SCSI support
+CONFIG_BLZ603EPLUS_SCSI
+  If you have an Amiga 1200 with a Phase5 Blizzard PowerUP 603e+
+  accelerator, say Y. Otherwise, say N.
+
+Fastlane SCSI support
+CONFIG_FASTLANE_SCSI
+  If you have the Phase5 Fastlane Z3 SCSI controller, or plan to use
+  one in the near future, say Y to this question. Otherwise, say N.
+
+Atari native SCSI support
+CONFIG_ATARI_SCSI
+  If you have an Atari with built-in NCR5380 SCSI controller (TT,
+  Falcon, ...) say Y to get it supported. Of course also, if you have
+  a compatible SCSI controller (e.g. for Medusa). This driver is also
+  available as a module ( = code which can be inserted in and removed
+  from the running kernel whenever you want). The module is called
+  atari_scsi.o. If you want to compile it as a module, say M here and
+  read Documentation/modules.txt. This driver supports both styles of
+  NCR integration into the system: the TT style (separate DMA), and
+  the Falcon style (via ST-DMA, replacing ACSI). It does NOT support
+  other schemes, like in the Hades (without DMA).
+
+Long delays for Toshiba CD-ROMs
+CONFIG_ATARI_SCSI_TOSHIBA_DELAY
+  This option increases the delay after a SCSI arbitration to
+  accommodate some flaky Toshiba CD-ROM drives. Say Y if you intend to
+  use a Toshiba CD-ROM drive; otherwise, the option is not needed and
+  would impact performance a bit, so say N.
+
+Hades SCSI DMA emulator
+CONFIG_TT_DMA_EMUL
+  This option enables code which emulates the TT SCSI DMA chip on the
+  Hades. This increases the SCSI transfer rates at least ten times
+  compared to PIO transfers.
+
+Ariadne support
+CONFIG_ARIADNE
+  If you have a Village Tronic Ariadne Ethernet adapter, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called ariadne.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+Ariadne II and X-Surf support
+CONFIG_ARIADNE2
+  This driver is for the Village Tronic Ariadne II and the Individual
+  Computers X-Surf Ethernet cards. If you have such a card, say Y.
+  Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called ariadne2.o. If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+A2065 support
+CONFIG_A2065
+  If you have a Commodore A2065 Ethernet adapter, say Y. Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called a2065.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Hydra support
+CONFIG_HYDRA
+  If you have a Hydra Ethernet adapter, say Y. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called hydra.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Pcmcia NE2000 compatible support
+CONFIG_APNE
+  If you have a pcmcia ne2000 compatible adapter, say Y.  Otherwise,
+  say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). The module is called apne.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari Lance support
+CONFIG_ATARILANCE
+  Say Y to include support for several Atari Ethernet adapters based
+  on the AMD Lance chipset: RieblCard (with or without battery), or
+  PAMCard VME (also the version by Rhotron, with different addresses).
+
+BioNet-100 support
+CONFIG_ATARI_BIONET
+  Say Y to include support for BioData's BioNet-100 Ethernet adapter
+  for the ACSI port. The driver works (has to work...) with a polled
+  I/O scheme, so it's rather slow :-(
+
+PAMsNet support
+CONFIG_ATARI_PAMSNET
+  Say Y to include support for the PAMsNet Ethernet adapter for the
+  ACSI port ("ACSI node"). The driver works (has to work...) with a
+  polled I/O scheme, so it's rather slow :-(
+
+Amiga mouse support
+CONFIG_AMIGAMOUSE
+  If you want to be able to use an Amiga mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called amigamouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari mouse support
+CONFIG_ATARIMOUSE
+  If you want to be able to use an Atari mouse in Linux, say Y. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module is called atarimouse.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+Atari MFP serial support
+CONFIG_ATARI_MFPSER
+  If you like to use the MFP serial ports ("Modem1", "Serial1") under
+  Linux, say Y. The driver equally supports all kinds of MFP serial
+  ports and automatically detects whether Serial1 is available. 
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. 
+
+  Note for Falcon users: You also have an MFP port, it's just not
+  wired to the outside... But you could use the port under Linux.
+
+Atari SCC serial support
+CONFIG_ATARI_SCC
+  If you have serial ports based on a Zilog SCC chip (Modem2, Serial2,
+  LAN) and like to use them under Linux, say Y. All built-in SCC's are
+  supported (TT, MegaSTE, Falcon), and also the ST-ESCC. If you have
+  two connectors for channel A (Serial2 and LAN), they are visible as
+  two separate devices.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari SCC serial DMA support
+CONFIG_ATARI_SCC_DMA
+  This enables DMA support for receiving data on channel A of the SCC.
+  If you have a TT you may say Y here and read
+  drivers/char/atari_SCC.README. All other users should say N here,
+  because only the TT has SCC-DMA, even if your machine keeps claiming
+  so at boot time.
+
+Atari MIDI serial support
+CONFIG_ATARI_MIDI
+  If you want to use your Atari's MIDI port in Linux, say Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari DSP56k Digital Signal Processor support (EXPERIMENTAL)
+CONFIG_ATARI_DSP56K
+  If you want to be able to use the DSP56001 in Falcons, say Y. This
+  driver is still experimental, and if you don't know what it is, or
+  if you don't have this processor, just say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Amiga builtin serial support
+CONFIG_AMIGA_BUILTIN_SERIAL
+  If you want to use your Amiga's built-in serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+GVP IO-Extender support
+CONFIG_GVPIOEXT
+  If you want to use a GVP IO-Extender serial card in Linux, say Y.
+  Otherwise, say N.
+
+Multiface Card III serial support
+CONFIG_MULTIFACE_III_TTY
+  If you want to use a Multiface III card's serial port in Linux,
+  answer Y.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Atari DMA sound support
+CONFIG_DMASOUND_ATARI
+  If you want to use the internal audio of your Atari in Linux, answer
+  Y to this question. This will provide a Sun-like /dev/audio,
+  compatible with the Linux/i386 sound system. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+PowerMac DMA sound support
+CONFIG_DMASOUND_AWACS
+  If you want to use the internal audio of your PowerMac in Linux,
+  answer Y to this question. This will provide a Sun-like /dev/audio,
+  compatible with the Linux/i386 sound system. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Amiga DMA sound support
+CONFIG_DMASOUND_PAULA
+  If you want to use the internal audio of your Amiga in Linux, answer
+  Y to this question. This will provide a Sun-like /dev/audio,
+  compatible with the Linux/i386 sound system. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+Q40 sound support
+CONFIG_DMASOUND_Q40
+  If you want to use the internal audio of your Q40 in Linux, answer
+  Y to this question. This will provide a Sun-like /dev/audio,
+  compatible with the Linux/i386 sound system. Otherwise, say N.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you
+  want). If you want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+HP DCA serial support
+CONFIG_HPDCA
+  If you want to use the internal "DCA" serial ports on an HP300
+  machine, say Y here.
+
+HP on-board LANCE support
+CONFIG_HPLANCE
+  If you want to use the builtin "LANCE" Ethernet controller on an
+  HP300 machine, say Y here.
+
+DIO bus support
+CONFIG_DIO
+  Say Y here to enable support for the "DIO" expansion bus used in
+  HP300 machines. If you are using such a system you almost certainly
+  want this.
+
+Processor Type
+CONFIG_6xx
+  There are four types of PowerPC chips supported. The more common
+  types (601, 603, 604, 740, 750), the Motorola embedded versions
+  (821, 823, 850, 855, 860), the IBM embedded versions (403 and
+  405) and the high end 64 bit Power processors (Power 3, Power 4).
+  Unless you are building a kernel for one of the embedded
+  processor systems, or a 64 bit IBM RS/6000, choose 6xx.  Note that
+  the kernel runs in 32-bit mode even on 64-bit chips.
+
+Machine Type
+CONFIG_PMAC
+  Linux currently supports several different kinds of PowerPC-based
+  machines: Apple Power Macintoshes and clones (such as the Motorola
+  Starmax series), PReP (PowerPC Reference Platform) machines such as
+  the Motorola PowerStack, Amiga Power-Up systems (APUS), CHRP and the
+  embedded MBX boards from Motorola. Currently, a single kernel binary
+  only supports one type or the other. However, there is very early
+  work on support for CHRP, PReP and PowerMac's from a single binary.
+
+Power management support for PowerBooks
+CONFIG_PMAC_PBOOK
+  This provides support for putting a PowerBook to sleep; it also
+  enables media bay support.  Power management works on the
+  PB2400/3400/3500, Wallstreet, Lombard, and Bronze PowerBook G3. You
+  must get the power management daemon, pmud, to make it work and you
+  must have the /dev/pmu device (see the pmud README).
+
+  Get pmud from ftp://linuxcare.com.au/pub/ppclinux/pmud/
+
+  If you have a PowerBook, you should say Y.
+
+  You may also want to compile the dma sound driver as a module and
+  have it autoloaded. The act of removing the module shuts down the
+  sound hardware for more power savings.
+
+Mac-on-Linux support
+CONFIG_MOL
+  This option enables low-level support for Mac-on-Linux.
+  MOL lets you run MacOS and Linux simultaneously. Please
+  visit <http://www.maconlinux.org> for more information.
+  If unsure, say Y.
+
+ADB raw keycode support
+CONFIG_MAC_ADBKEYCODES
+  This provides support for sending raw ADB keycodes to console
+  devices.  This is the default up to 2.4.0, but in future this may be
+  phased out in favor of generic Linux keycodes. If you say Y here, you
+  can dynamically switch via the
+      /proc/sys/dev/mac_hid/keyboard_sends_linux_keycodes
+  sysctl and with the "keyboard_sends_linux_keycodes=" kernel argument.
+  
+  If unsure, say Y here.
+
+Mouse button 2+3 emulation support
+CONFIG_MAC_EMUMOUSEBTN
+  This provides generic support for emulating the 2nd and 3rd mouse
+  button with keypresses. If you say Y here, the emulation is still
+  disabled by default. The emulation is controlled by these sysctl entries:
+      /proc/sys/dev/mac_hid/mouse_button_emulation
+      /proc/sys/dev/mac_hid/mouse_button2_keycode
+      /proc/sys/dev/mac_hid/mouse_button3_keycode
+
+Enhanced Real Time Clock Support
+CONFIG_PPC_RTC
+  If you say Y here and create a character special file /dev/rtc with
+  major number 10 and minor number 135 using mknod ("man mknod"), you
+  will get access to the real time clock (or hardware clock) built 
+  into your computer.
+  
+  If unsure, say Y here.
+
+Support for Open Firmware device tree in /proc
+CONFIG_PROC_DEVICETREE
+  This option adds a device-tree directory under /proc which contains
+  an image of the device tree that the kernel copies from Open
+  Firmware. If unsure, say Y here.
+
+MESH (Power Mac internal SCSI) support
+CONFIG_SCSI_MESH
+  Many Power Macintoshes and clones have a MESH (Macintosh Enhanced
+  SCSI Hardware) SCSI bus adaptor (the 7200 doesn't, but all of the
+  other Power Macintoshes do). Say Y to include support for this SCSI
+  adaptor. This driver is also available as a module called mesh.o
+  ( = code which can be inserted in and removed from the running
+  kernel whenever you want). If you want to compile it as a module,
+  say M here and read Documentation/modules.txt.
+
+Maximum synchronous transfer rate
+CONFIG_SCSI_MESH_SYNC_RATE
+  On Power Macintoshes (and clones) where the MESH SCSI bus adaptor
+  drives a bus which is entirely internal to the machine (such as the
+  7500, 7600, 8500, etc.), the MESH is capable of synchronous
+  operation at up to 10 MB/s. On machines where the SCSI bus
+  controlled by the MESH can have external devices connected, it is
+  usually rated at 5 MB/s. 5 is a safe value here unless you know the
+  MESH SCSI bus is internal only; in that case you can say 10. Say 0
+  to disable synchronous operation.
+
+53C94 (Power Mac external SCSI) support
+CONFIG_SCSI_MAC53C94
+  On Power Macintoshes (and clones) with two SCSI buses, the external
+  SCSI bus is usually controlled by a 53C94 SCSI bus adaptor. Older
+  machines which only have one SCSI bus, such as the 7200, also use
+  the 53C94. Say Y to include support for the 53C94. 
+
+  This driver is also available as a module called mac53c94.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+MACE (Power Mac Ethernet) support
+CONFIG_MACE
+  Power Macintoshes and clones with Ethernet built-in on the
+  motherboard will usually use a MACE (Medium Access Control for
+  Ethernet) interface. Say Y to include support for the MACE chip.
+
+  This driver is also available as a module called mace.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+BMAC (G3 ethernet) support
+CONFIG_BMAC
+  Say Y for support of BMAC Ethernet interfaces. These are used on G3
+  computers. 
+
+  This driver is also available as a module called bmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+GMAC (G4/iBook ethernet) support
+CONFIG_GMAC
+  Say Y for support of GMAC Ethernet interfaces. These are used on G4
+  and iBook computers. 
+
+  This driver is also available as a module called gmac.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Symbios 53c885 (Synergy ethernet) support
+CONFIG_NCR885E
+  This is and Ethernet driver for the dual-function NCR 53C885
+  SCSI/Ethernet controller.
+
+  This driver is also available as a module called ncr885e.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+National DP83902AV (Oak ethernet) support
+CONFIG_OAKNET
+  Say Y if your machine has this type of Ethernet network card.
+
+  This driver is also available as a module called oaknet.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Video For Linux
+CONFIG_VIDEO_DEV
+  Support for audio/video capture and overlay devices and FM radio
+  cards. The exact capabilities of each device vary. User tools for
+  this are available from
+  ftp://ftp.uk.linux.org/pub/linux/video4linux .
+
+  If you are interested in writing a driver for such an audio/video
+  device or user software interacting with such a driver, please read
+  the file Documentation/video4linux/API.html.
+
+  This driver is also available as a module called videodev.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Video For Linux /proc file system information
+CONFIG_VIDEO_PROC_FS
+  If you say Y here, you are able to access video device information
+  in /proc/video.
+
+  To use this option, you have to check, that the "/proc file system
+  support" (CONFIG_PROC_FS) is enabled too.
+
+AIMSlab RadioTrack (aka RadioReveal) support
+CONFIG_RADIO_RTRACK
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  Note that newer AIMSlab RadioTrack cards have a different chipset
+  and are not supported by this driver. For these cards, use the
+  RadioTrack II driver below.
+
+  If you have a GemTeks combined (PnP) sound- and radio card you must
+  use this driver as a module and setup the card with isapnptools. You
+  must also pass the module a suitable io parameter, 0x248 has been
+  reported to be used by these cards.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml . More information
+  is contained in the file Documentation/video4linux/radiotrack.txt.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aimslab.o.
+
+RadioTrack i/o port
+CONFIG_RADIO_RTRACK_PORT
+  Enter either 0x30f or 0x20f here. The card default is 0x30f, if you
+  haven't changed the jumper setting on the card.
+
+AIMSlab RadioTrack II support
+CONFIG_RADIO_RTRACK2
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-rtrack2.o.
+
+RadioTrack II i/o port
+CONFIG_RADIO_RTRACK2_PORT
+  Enter either 0x30c or 0x20c here. The card default is 0x30c, if you
+  haven't changed the jumper setting on the card.
+
+Aztech/Packard Bell Radio
+CONFIG_RADIO_AZTECH
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-aztech.o.
+
+Aztech/Packard Bell radio card i/o port
+CONFIG_RADIO_AZTECH_PORT
+  Enter either 0x350 or 0x358 here. The card default is 0x350, if you
+  haven't changed the setting of jumper JP3 on the card. Removing the
+  jumper sets the card to 0x358.
+
+ADS Cadet AM/FM Radio Tuner Card
+CONFIG_RADIO_CADET
+  Choose Y here if you have one of these AM/FM radio cards, and then
+  fill in the port address below.
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  Further documentation on this driver can be found on the WWW at
+  http://linux.blackhawke.net/cadet.html . 
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-cadet.o.
+
+SF16FMI Radio
+CONFIG_RADIO_SF16FMI
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-sf16fmi.o
+
+SF16FMI I/O port (0x284 or 0x384)
+CONFIG_RADIO_SF16FMI_PORT
+  Enter the I/O port of your SF16FMI radio card.
+
+Typhoon Radio
+CONFIG_RADIO_TYPHOON
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address and the frequency used for muting below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-typhoon.o
+
+Support for /proc/radio-typhoon
+CONFIG_RADIO_TYPHOON_PROC_FS
+  Say Y here if you want the typhoon radio card driver to write
+  status information (frequency, volume, muted, mute frequency,
+  base address) to /proc/radio-typhoon. The file can be viewed with
+  your favorite pager (i.e. use "more /proc/radio-typhoon" or "less
+  /proc/radio-typhoon" or simply "cat /proc/radio-typhoon").
+
+Typhoon I/O port (0x316 or 0x336)
+CONFIG_RADIO_TYPHOON_PORT
+  Enter the I/O port of your Typhoon or EcoRadio radio card.
+
+Typhoon frequency set when muting the device (kHz)
+CONFIG_RADIO_TYPHOON_MUTEFREQ
+  Enter the frequency used for muting the radio. The device is never
+  completely silent. If the volume is just turned down, you can still
+  hear silent voices and music. For that reason, the frequency of the
+  radio device is set to the frequency you can enter here whenever
+  the device is muted. There should be no local radio station at that
+  frequency.
+
+Zoltrix Radio
+CONFIG_RADIO_ZOLTRIX
+  Choose Y here if you have one of these FM radio cards, and then fill
+  in the port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-zoltrix.o
+
+ZOLTRIX I/O port (0x20c or 0x30c)
+CONFIG_RADIO_ZOLTRIX_PORT
+  Enter the I/O port of your Zoltrix radio card.
+
+IIC on parallel port
+CONFIG_I2C_PARPORT
+  I2C is a simple serial bus system used in many micro controller
+  applications. Saying Y here will allow you to use your parallel port
+  as an I2C interface.
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called i2c-parport.o.
+
+Miro PCM20 Radio
+CONFIG_RADIO_MIROPCM20
+  Choose Y here if you have this FM radio card. You also need to say Y
+  to "ACI mixer (miroPCM12/PCM20)" (in "additional low level sound
+  drivers") for this to work.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-miropcm20.o
+
+GemTek Radio Card
+CONFIG_RADIO_GEMTEK
+  Choose Y here if you have this FM radio card, and then fill in the 
+  port address below.
+
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on 
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-gemtek.o.
+
+GemTek i/o port
+CONFIG_RADIO_GEMTEK_PORT
+  Enter either 0x20c, 0x30c, 0x24c or 0x34c here. The card default is
+  0x34c, if you haven't changed the jumper setting on the card. On
+  Sound Vision 16 Gold PnP with FM Radio (ESS1869+FM Gemtek), the i/o
+  port is 0x28c.
+
+PlanB Video-In for PowerMacs
+CONFIG_VIDEO_PLANB
+  PlanB is the V4L driver for the PowerMac 7x00/8x00 series video
+  input hardware. If you want to experiment with this, say Y.
+  Otherwise, or if you don't understand a word, say N.
+  See http://www.cpu.lu/~mlan/planb.html for more info.
+
+  Saying M will compile this driver as a module (planb.o).
+
+TerraTec ActiveRadio
+CONFIG_RADIO_TERRATEC
+  Choose Y here if you have this FM radio card, and then fill in the
+  port address below. (TODO)
+
+  Note: This driver is in its early stages. Right now volume and
+  frequency control and muting works at least for me, but
+  unfortunately i have not found anybody who wants to use this card
+  with Linux. So if it is this what YOU are trying to do right now,
+  PLEASE DROP ME A NOTE!! Rolf Offermanns (rolf@offermanns.de)
+  
+  In order to control your radio card, you will need to use programs
+  that are compatible with the Video for Linux API. Information on
+  this API and pointers to "v4l" programs may be found on the WWW at
+  http://roadrunner.swansea.uk.linux.org/v4l.shtml .
+
+  If you want to compile this driver as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want),
+  say M here and read Documentation/modules.txt. The module will be
+  called radio-terratec.o.
+
+Terratec i/o port (normally 0x590)
+CONFIG_RADIO_TERRATEC_PORT
+  Fill in the i/o port of your TerraTec FM radio card. If unsure, go
+  with the default.
+
+### Add these
+# Zoran ZR36057/36060 support
+# CONFIG_VIDEO_ZORAN
+
+# Include support for Iomega Buz
+# CONFIG_VIDEO_BUZ
+
+Trust FM radio card
+CONFIG_RADIO_TRUST
+  This is a driver for the Trust FM radio cards. Say Y if you have
+  such a card and want to use it under Linux.
+
+  This driver is also available as a module called radio-trust.o ( =
+  code which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Trust i/o port (usually 0x350 or 0x358)
+CONFIG_RADIO_TRUST_PORT
+  Enter the i/o port of your Trust FM radio card. If unsure, try the
+  values "0x350" or "0x358".
+
+BT848 Video For Linux
+CONFIG_VIDEO_BT848
+  Support for BT848 based frame grabber/overlay boards. This includes
+  the Miro, Hauppauge and STB boards. Please read the material in
+  Documentation/video4linux/bttv for more information.
+
+  If you say Y or M here, you need to say Y or M to "I2C support" and
+  "I2C bit-banging interfaces" in the character device section.
+  
+  This driver is available as a module called bttv.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+ZR36120/36125 Video for Linux
+CONFIG_VIDEO_ZR36120
+  Support for ZR36120/ZR36125 based frame grabber/overlay boards.
+  This includes the Victor II, WaveWatcher, Video Wonder, Maxi-TV,
+  and Buster boards. Please read the material in
+  Documentation/video4linux/zr36120.txt for more information.
+
+  This driver is also available as a module called zr36120.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+SAA5249 Teletext processor
+CONFIG_VIDEO_SAA5249
+  Support for I2C bus based teletext using the SAA5249 chip. At the
+  moment this is only useful on some European WinTV cards.
+
+  This driver is also available as a module called saa5249.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Quickcam BW Video For Linux
+CONFIG_VIDEO_BWQCAM
+  Say Y have if you the black and white version of the QuickCam
+  camera. See the next option for the color version. 
+
+  This driver is also available as a module called bw-qcam.o ( = code
+  which can be inserted in and removed from the running kernel
+  whenever you want). If you want to compile it as a module, say M
+  here and read Documentation/modules.txt.
+
+Colour QuickCam Video For Linux
+CONFIG_VIDEO_CQCAM
+  This is the video4linux driver for the colour version of the
+  Connectix Quickcam. If you have one of these cameras, say Y here,
+  otherwise say N. This driver does not work with the original
+  monochrome Quickcam, Quickcam VC or QuickClip. It is also available
+  as a module (c-qcam.o). Read Documentation/video4linux/CQcam.txt for
+  more information.
+
+CPiA Video For Linux
+CONFIG_VIDEO_CPIA
+  This is the video4linux driver for cameras based on Vision's CPiA
+  (Colour Processor Interface ASIC), such as the Creative Labs Video
+  Blaster Webcam II. If you have one of these cameras, say Y here
+  and select parallel port and/or USB lowlevel support below,
+  otherwise say N. This will not work with the Creative Webcam III.
+  
+  Please read Documentation/video4linux/README.cpia for more
+  information.
+  
+  This driver is also available as a module (cpia.o).
+
+CPiA Parallel Port Lowlevel Support
+CONFIG_VIDEO_CPIA_PP
+  This is the lowlevel parallel port support for cameras based on
+  Vision's CPiA (Colour Processor Interface ASIC), such as the
+  Creative Webcam II. If you have the parallel port version of one
+  of these cameras, say Y here, otherwise say N. It is also available
+  as a module (cpia_pp.o).
+
+CPiA USB Lowlevel Support
+CONFIG_VIDEO_CPIA_USB
+  This is the lowlevel USB support for cameras based on Vision's CPiA
+  (Colour Processor Interface ASIC), such as the Creative Webcam II.
+  If you have the USB version of one of these cameras, say Y here,
+  otherwise say N. This will not work with the Creative Webcam III.
+  It is also available as a module (cpia_usb.o).
+
+Mediavision Pro Movie Studio Video For Linux
+CONFIG_VIDEO_PMS
+  Say Y if you have such a thing. This driver is also available as a
+  module called pms.o ( = code which can be inserted in and removed
+  from the running kernel whenever you want). If you want to compile
+  it as a module, say M here and read Documentation/modules.txt.
+
+SAB3036 tuner support
+CONFIG_TUNER_3036
+  Say Y here to include support for Philips SAB3036 compatible tuners.
+  If in doubt, say N.
+
+Compaq SMART2 support
+CONFIG_BLK_CPQ_DA
+   This is the driver for Compaq Smart Array controllers.  
+   Everyone using these boards should say Y here.  
+   See the file Documentation/cpqarray.txt for the current list of 
+   boards supported by this driver, and for further information 
+   on the use of this driver. 
+
+#
+# ARM options
+#
+ARM System type
+CONFIG_ARCH_ARCA5K
+  This selects what ARM system you wish to build the kernel for. It
+  also selects to some extent the CPU type. If you are unsure what
+  to set this option to, please consult any information supplied with
+  your system.
+
+2MB physical memory
+CONFIG_PAGESIZE_16
+  Say Y here if your Archimedes or A5000 system has only 2MB of
+  memory, otherwise say N.  The resulting kernel will not run on a
+  machine with 4MB of memory.
+
+Include support for the CATS
+CONFIG_ARCH_CATS
+  Say Y here if you intend to run this kernel on the CATS.
+
+  Saying N will reduce the size of the Footbridge kernel.
+
+Include support for the EBSA285
+CONFIG_ARCH_EBSA285
+  Say Y here if you intend to run this kernel on the EBSA285 card
+  in host ("central function") mode.
+
+  Saying N will reduce the size of the Footbridge kernel.
+
+Include support for the LinkUp Systems L7200 SDB
+CONFIG_ARCH_L7200
+  Say Y here if you intend to run this kernel on a LinkUp Systems
+  L7200 Software Development Board which uses an ARM720T processor.
+  Information on this board can be obtained at:
+
+  http://www.linkupsys.com/
+
+  If you have any questions or comments about the Linux kernel port
+  to this board, send e-mail to sjhill@cotw.com
+
+Include support for the NetWinder
+CONFIG_ARCH_NETWINDER
+  Say Y here if you intend to run this kernel on the Rebel.COM
+  NetWinder.  Information about this machine can be found at:
+
+  http://www.netwinder.org/
+
+  Saying N will reduce the size of the Footbridge kernel.
+
+Include support for the Compaq Personal Server
+CONFIG_ARCH_PERSONAL_SERVER
+  Say Y here if you intend to run this kernel on the Compaq
+  Personal Server.
+  
+  Saying N will reduce the size of the Footbridge kernel.
+
+  The Compaq Personal Server is not available for purchase. 
+  There are no product plans beyond the current research
+  prototypes at this time.  Information is available at:
+  
+  http://crl.research.compaq.com/projects/personalserver
+  
+  If you have any questions or comments about the  Compaq Personal
+  Server, send e-mail to skiff@crl.dec.com
+
+Include support for Assabet
+CONFIG_SA1100_ASSABET
+  Say Y here if you are using the Intel(R) StrongARM(R) SA-1110
+  Microprocessor Development Board (also known as the Assabet).
+
+Include support for Neponset
+CONFIG_ASSABET_NEPONSET
+  Say Y here if you are using the Intel(R) StrongARM(R) SA-1110
+  Microprocessor Development Board (Assabet)  with the SA-1111
+  Development Board (Nepon).
+
+Include support for the Compaq iPAQ H3600 (Bitsy)
+CONFIG_SA1100_BITSY
+  Say Y here if you intend to run this kernel on the Compaq iPAQ 
+  H3600 handheld computer.  Information about this machine and the
+  Linux port to this machine can be found at:
+
+  http://www.handhelds.org/Compaq/index.html#iPAQ_H3600
+  http://www.compaq.com/products/handhelds/pocketpc/
+
+Include support for Brutus
+CONFIG_SA1100_BRUTUS
+  Say Y here if you are using the Intel(R) StrongARM(R) SA-1100
+  Microprocessor Development Board (also known as the Brutus).
+
+Include support for LART
+CONFIG_SA1100_LART
+  Say Y here if you are using the Linux Advanced Radio Terminal
+  (also known as the LART).  See http://www.lart.tudelft.nl/ for
+  information on the LART.
+
+Include support for GraphicsClient
+CONFIG_SA1100_GRAPHICSCLIENT
+  Say Y here if you are using an Applied Data Systems Intel(R)
+  StrongARM(R) SA-1100 based Graphics Client SBC.  See
+  http://www.flatpanels.com/ for information on this system.
+
+Include support for Victor
+CONFIG_SA1100_VICTOR
+  Say Y here if you are using a Visu Aide Intel(R) StrongARM(R)
+  SA-1100 based Victor Digital Talking Book Reader.  See
+  http://www.visuaide.com/pagevictor.en.html for information on
+  this system.
+
+Support ARM610 processor
+CONFIG_CPU_ARM6
+  Say Y here if you wish to include support for the ARM610 processor.
+
+Support ARM710 processor
+CONFIG_CPU_ARM7
+  Say Y here if you wish to include support for the ARM710 processor.
+
+Support StrongARM(R) SA-110 processor
+CONFIG_CPU_SA110
+  Say Y here if you wish to include support for the Intel(R)
+  StrongARM(R) SA-110 processor.
+
+Support ARM720 processor
+CONFIG_CPU_ARM720
+  Say Y here if you wish to include support for the ARM720 processor.
+
+Support ARM920
+CONFIG_CPU_ARM920
+  Say Y here if you wish to include support for the ARM920 processor.
+
+Support ARM610 processor
+CONFIG_CPU_ARM6
+  Say Y here if you wish to include support for the ARM610 processor.
+
+Support ARM710 processor
+CONFIG_CPU_ARM7
+  Say Y here if you wish to include support for the ARM710 processor.
+
+Support StrongARM(R) SA-110 processor
+CONFIG_CPU_SA110
+  Say Y here if you wish to include support for the Intel(R)
+  StrongARM(R) SA-110 processor.
+
+Support ARM720 processor
+CONFIG_CPU_ARM720
+  Say Y here if you wish to include support for the ARM720 processor.
+
+Support ARM920
+CONFIG_CPU_ARM920
+  Say Y here if you wish to include support for the ARM920 processor.
+
+Math emulation
+CONFIG_NWFPE
+  Say Y to include the NWFPE floating point emulator in the kernel.
+  This is necessary to run most binaries. Linux does not currently
+  support floating point hardware so you need to say Y here even if
+  your machine has an FPA or floating point co-processor podule.
+
+  It is also possible to say M to build the emulator as a module
+  (nwfpe.o) or indeed to leave it out altogether. However, unless you
+  know what you are doing this can easily render your machine
+  unbootable. Saying Y is the safe option.
+
+  You may say N here if you are going to load the Acorn FPEmulator
+  early in the bootup.
+
+DS1620 Thermometer support
+CONFIG_DS1620
+  Say Y here to include support for the thermal management hardware
+  found in the NetWinder. This driver allows the user to control the
+  temperature set points and to read the current temperature.
+
+  It is also possible to say M here to build it as a module (ds1620.o)
+  It is recommended to be used on a NetWinder, but it is not a
+  necessity.
+
+Verbose kernel error messages
+CONFIG_DEBUG_ERRORS
+  This option controls verbose debugging information which can be
+  printed when the kernel detects an internal error. This debugging
+  information is useful to kernel hackers when tracking down problems,
+  but mostly meaningless to other people. It's safe to say Y unless
+  you are concerned with the code size or don't want to see these
+  messages.
+
+Compile kernel with frame pointer
+CONFIG_FRAME_POINTER
+  If you say Y here, the resulting kernel will be slightly larger and
+  slower, but it will give useful debugging information. If you don't
+  debug the kernel, you can say N.
+
+User fault debugging
+CONFIG_DEBUG_USER
+  When a user program crashes due to an exception, the kernel can
+  print a brief message explaining what the problem was. This is
+  sometimes helpful for debugging but serves no purpose on a
+  production system. Most people should say N here.
+
+Include gdb debugging information in kernel binary
+CONFIG_DEBUG_INFO
+  Say Y here to include source-level debugging information in the
+  `vmlinux' binary image. This is handy if you want to use gdb or
+  addr2line to debug the kernel. It has no impact on the in-memory
+  footprint of the running kernel but it can increase the amount of
+  time and disk space needed for compilation of the kernel. If in
+  doubt say N.
+
+Kernel low-level debugging functions
+CONFIG_DEBUG_LL
+  Say Y here to include definitions of printascii, printchar, printhex
+  in the kernel.  This is helpful if you are debugging code that
+  executes before the console is initialized.
+
+Kernel low-level debugging messages via footbridge serial port
+CONFIG_DEBUG_DC21285_PORT
+  Say Y here if you want the low-level print routines to direct their
+  output to the serial port in the DC21285 (Footbridge).
+
+Split initialisation functions into discardable section
+CONFIG_TEXT_SECTIONS
+  If you say Y here, kernel code that is only used during
+  initialisation is collected into a special area of the kernel so
+  that it can be discarded and the memory reclaimed when
+  initialisation is complete. In addition, if the kernel you wish to
+  build is able to run on multiple architectures, it allows the unused
+  code to be discarded. Some versions of binutils, however, have a bug
+  that causes the kernel to crash during startup when this option is
+  enabled. Say Y unless you experience problems that you suspect may
+  be caused by this.
+
+Disable pgtable cache (EXPERIMENTAL)
+CONFIG_NO_PGT_CACHE
+  Normally the kernel maintains a `quicklist' of preallocated
+  pagetable structures in order to increase performance. On machines
+  with very few pages this may however be a loss. Say Y here to
+  disable the pgtable cache.
+
+RISC OS personality
+CONFIG_ARTHUR
+  Say Y here to include the kernel code necessary if you want to run
+  Acorn RISC OS/Arthur binaries under Linux. This code is still very 
+  experimental; if this sounds frightening, say N and sleep in peace.
+  You can also say M here to compile this support as a module (which
+  will be called arthur.o).
+
+Initial kernel command line
+CONFIG_CMDLINE
+  On some architectures (EBSA110 and CATS), there is currently no way
+  for the boot loader to pass arguments to the kernel. For these
+  architectures, you should supply some command-line options at build
+  time by entering them here. As a minimum, you should specify the
+  memory size and the root device (e.g., mem=64M root=/dev/nfs)
+
+Hardware alignment trap (EXPERIMENTAL)
+CONFIG_ALIGNMENT_TRAP
+  ARM processors can not fetch/store information which is not
+  naturally aligned on the bus, i.e., a 4 byte fetch must start at an
+  address divisible by 4. On 32-bit ARM processors, these non-aligned
+  fetch/store instructions will be emulated in software if you say
+  here, which has a severe performance impact. This is necessary for
+  correct operation of some network protocols. With an IP-only
+  configuration it is safe to say N, otherwise say Y.
+
+21285 serial port support
+CONFIG_SERIAL_21285
+  If you have a machine based on a 21285 (Footbridge) StrongARM(R)/
+  PCI bridge you can enable its onboard serial port by enabling this
+  option. The device has major ID 4, minor 64.
+
+Console on 21285 serial port
+CONFIG_SERIAL_21285_CONSOLE
+  If you have enabled the serial port on the 21285 footbridge you can
+  make it the console by answering Y to this option.
+
+SA1100 serial port support
+CONFIG_SERIAL_SA1100
+  If you have a machine based on a SA1100/SA1110 StrongARM CPU you can
+  enable its onboard serial port by enabling this option.
+  Please read Documentation/arm/SA1100/serial_UART for further info.
+
+Console on SA1100 serial port
+CONFIG_SERIAL_SA1100_CONSOLE
+  If you have enabled the serial port on the SA1100/SA1110 StrongARM
+  CPU you can make it the console by answering Y to this option.
+
+L7200 serial port support
+CONFIG_SERIAL_L7200
+  If you have a LinkUp Systems L7200 board you can enable its two
+  onboard serial ports by enabling this option. The device numbers
+  are major ID 4 with minor 64 and 65 respectively.
+
+Console on L7200 serial port
+CONFIG_SERIAL_L7200_CONSOLE
+  If you have enabled the serial ports on the L7200 development board
+  you can make the first serial port the console by answering Y to
+  this option.
+
+Footbridge Mode
+CONFIG_HOST_FOOTBRIDGE
+  The 21285 Footbridge chip can operate in either `host mode' or
+  `add-in' mode.  Say Y if your 21285 is in host mode, and therefore
+  is the configuration master, otherwise say N. This must not be
+  set to Y if the card is used in 'add-in' mode.
+
+MFM hard disk support
+CONFIG_BLK_DEV_MFM
+  Support the MFM hard drives on the Acorn Archimedes both
+  on-board the A4x0 motherboards and via the Acorn MFM podules.
+  Drives up to 64MB are supported. If you haven't got one of these
+  machines or drives just say N.
+
+Old Archimedes floppy (1772) support
+CONFIG_BLK_DEV_FD1772
+  Support the floppy drive on the Acorn Archimedes (A300, A4x0, A540,
+  R140 and R260) series of computers; it supports only 720K floppies
+  at the moment. If you don't have one of these machines just answer
+  N.
+
+Autodetect hard drive geometry
+CONFIG_BLK_DEV_MFM_AUTODETECT
+  If you answer Y, the MFM code will attempt to automatically detect
+  the cylinders/heads/sectors count on your hard drive. WARNING: This
+  sometimes doesn't work and it also does some dodgy stuff which
+  potentially might damage your drive.
+
+NetWinder /dev/flash support
+CONFIG_NWFLASH
+  If you say Y here and create a character device /dev/flash with
+  major 10 and minor 160 you can manipulate the flash ROM containing
+  the NetWinder firmware. Be careful as accidentally overwriting the
+  flash contents can render your computer unbootable. On no account
+  allow random users access to this device. :-)
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called nwflash.o. If you want to compile it as a
+  module, say M here and read Documentation/modules.txt.
+
+  If you're not sure, say N.
+
+Footbridge internal watchdog
+CONFIG_21285_WATCHDOG
+  The Intel Footbridge chip contains a builtin watchdog circuit. Say Y 
+  here if you wish to use this. Alternatively say M to compile the
+  driver as a module, which will be called wdt285.o.
+
+  This driver does not work on all machines. In particular, early CATS 
+  boards have hardware problems that will cause the machine to simply 
+  lock up if the watchdog fires.
+
+  "If in doubt, leave it out" - say N.
+
+NetWinder WB977 watchdog
+CONFIG_977_WATCHDOG
+  Say Y here to include support for the WB977 watchdog included in 
+  NetWinder machines. Alternatively say M to compile the driver as
+  a module, which will be called wdt977.o.
+
+  Not sure? It's safe to say N.
+
+IrDA subsystem support
+CONFIG_IRDA
+  Say Y here if you want to build support for the IrDA (TM) protocols.
+  The Infrared Data Associations (tm) specifies standards for wireless
+  infrared communication and is supported by most laptops and PDA's.
+
+  To use Linux support for the IrDA (tm) protocols, you will also need
+  some user-space utilities like the irmanager and probably irattach
+  as well. For more information, see the file
+  Documentation/networking/irda.txt. You also want to read the
+  IR-HOWTO, available at http://www.linuxdoc.org/docs.html#howto .
+
+  This support is also available as a module called irda.o. If you
+  want to compile it as a module, say M here and read
+  Documentation/modules.txt.
+
+IrDA Cache last LSAP
+CONFIG_IRDA_CACHE_LAST_LSAP
+  Say Y here if you want IrLMP to cache the last LSAP used. This makes
+  sense since most frames will be sent/received on the same
+  connection. Enabling this option will save a hash-lookup per frame.
+
+  If unsure, say Y.
+
+IrDA Fast RR's
+CONFIG_IRDA_FAST_RR
+  Say Y here is you want IrLAP to send fast RR (Receive Ready) frames
+  when acting as a primary station. This will make IrLAP send out a RR
+  frame immediately when receiving a frame if its own transmit queue
+  is currently empty. This will give a lot of speed improvement when
+  receiving much data since the secondary station will not have to
+  wait the max. turn around time before it is allowed to transmit the
+  next time. If the transmit queue of the secondary is also empty the
+  primary will back off waiting longer for sending out the RR frame
+  until the timeout reaches the normal value. Enabling this option
+  will make the IR-diode burn more power and thus reduce your battery
+  life.
+
+  If unsure, say N.
+
+IrDA Debug
+CONFIG_IRDA_DEBUG
+  Say Y here if you want the IrDA subsystem to write debug information
+  to your syslog. You can change the debug level in
+  /proc/sys/net/irda/debug
+
+  If unsure, say Y (since it makes it easier to find the bugs).
+
+IrLAP Compression support
+CONFIG_IRDA_COMPRESSION
+  Compression is _not_ part of the IrDA(tm) protocol specification,
+  but it's working great! Linux is the first to try out compression
+  support at the IrLAP layer. This means that you will only benefit
+  from compression if you are running a Linux <-> Linux configuration.
+  
+  If you say Y here, you also need to say Y or M to a compression
+  protocol below.
+
+IrLAP Deflate Compression Protocol (EXPERIMENTAL)
+CONFIG_IRDA_DEFLATE
+  Say Y here if you want to build support for the Deflate compression
+  protocol. The deflate compression (GZIP) is exactly
+  the same as the one used by the PPP protocol. 
+
+  If you want to compile this compression support as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  irda_deflate.o.
+
+IrLAN Protocol 
+CONFIG_IRLAN
+  Say Y here if you want to build support for the IrLAN protocol. If
+  you want to compile it as a module (irlan.o), say M here and read
+  Documentation/modules.txt. IrLAN emulates an Ethernet and makes it
+  possible to put up a wireless LAN using infrared beams.
+
+  The IrLAN protocol can be used to talk with infrared access points 
+  like the HP NetbeamIR, or the ESI JetEye NET. You can also connect 
+  to another Linux machine running the IrLAN protocol for ad-hoc 
+  networking!
+
+IrCOMM Protocol
+CONFIG_IRCOMM
+  Say Y here if you want to build support for the IrCOMM protocol. If
+  you want to compile it as a module (you will get ircomm.o and
+  ircomm-tty.o), say M here and read Documentation/modules.txt. IrCOMM
+  implements serial port emulation, and makes it possible to use all
+  existing applications that understands TTY's with an infrared link.
+  Thus you should be able to use application like PPP, minicom and
+  others. Enabling this option will create two modules called ircomm
+  and ircomm_tty.
+
+IrTTY IrDA Device Driver
+CONFIG_IRTTY_SIR
+  Say Y here if you want to build support for the IrTTY line
+  discipline. If you want to compile it as a module (irtty.o), say M
+  here and read Documentation/modules.txt. IrTTY makes it possible to
+  use Linux's own serial driver for all IrDA ports that are 16550
+  compatible. Most IrDA chips are 16550 compatible so you should
+  probably say Y to this option. Using IrTTY will however limit the
+  speed of the connection to 115200 bps (IrDA SIR mode)
+
+  If unsure, say Y.
+
+IrPORT IrDA Device Driver
+CONFIG_IRPORT_SIR
+  Say Y here if you want to build support for the IrPORT IrDA device
+  driver. If you want to compile it as a module (irport.o), say M here
+  and read Documentation/modules.txt. IrPORT can be used instead of
+  IrTTY and sometimes this can be better. One example is if your IrDA
+  port does not have echo-canceling, which will work OK with IrPORT
+  since this driver is working in half-duplex mode only. You don't
+  need to use irattach with IrPORT, but you just insert it the same
+  way as FIR drivers (insmod irport io=0x3e8 irq=11). Notice that
+  IrPORT is a SIR device driver which means that speed is limited to
+  115200 bps.
+
+  If unsure, say Y.
+
+Winbond W83977AF IrDA Device Driver
+CONFIG_WINBOND_FIR
+  Say Y here if you want to build IrDA support for the Winbond
+  W83977AF super-io chipset. This driver should be used for the IrDA
+  chipset in the Corel NetWinder. The driver supports SIR, MIR and FIR
+  (4Mbps) speeds.
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called w83977af_ir.o.
+
+NSC PC87108 IrDA Device Driver
+CONFIG_NSC_FIR
+  Say Y here if you want to build support for the NSC PC87108 and
+  PC87338 IrDA chipsets. This driver supports SIR, 
+  MIR and FIR (4Mbps) speeds. 
+
+  If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The module will be called nsc-ircc.o.
+
+Toshiba Type-O IR Port Device Driver
+CONFIG_TOSHIBA_FIR
+  Say Y here if you want to build support for the Toshiba Type-O IR
+  chipset. This chipset is used by the Toshiba Libretto 100CT, and
+  many more laptops. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The module will be called
+  toshoboe.o.
+
+SMC IrCC (Experimental)
+CONFIG_SMC_IRCC_FIR
+  Say Y here if you want to build support for the SMC Infrared
+  Communications Controller. It is used in the Fujitsu Lifebook 635t
+  and Sony PCG-505TX. If you want to compile it as a module, say M
+  here and read Documentation/modules.txt. The module will be called
+  smc-ircc.o.
+
+Serial dongle support
+CONFIG_DONGLE
+  Say Y here if you have an infrared device that connects to your
+  computer's serial port. These devices are called dongles. Then say Y
+  or M to the driver for your particular dongle below.
+
+  Note that the answer to this question won't directly affect the
+  kernel: saying N will just cause this configure script to skip all
+  the questions about serial dongles.
+
+ESI JetEye PC Dongle
+CONFIG_ESI_DONGLE
+  Say Y here if you want to build support for the Extended Systems
+  JetEye PC dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The ESI dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for ESI dongles you will have to
+  start irattach like this: "irattach -d esi".
+
+ACTiSYS IR-220L and IR220L+ dongle
+CONFIG_ACTISYS_DONGLE
+  Say Y here if you want to build support for the ACTiSYS
+  IR-220L and IR220L+ dongles. If you want to compile it as a module,
+  say M here and read Documentation/modules.txt. The ACTiSYS dongles
+  attaches to the normal 9-pin serial port connector, and can
+  currently only be used by IrTTY. To activate support for ACTiSYS
+  dongles you will have to start irattach like this: 
+  "irattach -d actisys" or "irattach -d actisys+".
+
+Tekram IrMate 210B dongle
+CONFIG_TEKRAM_DONGLE
+  Say Y here if you want to build support for the Tekram IrMate 210B 
+  dongle. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The Tekram dongle attaches to
+  the normal 9-pin serial port connector, and can currently only be
+  used by IrTTY. To activate support for Tekram dongles you will have
+  to start irattach like this: "irattach -d tekram".
+
+Greenwich GIrBIL dongle
+CONFIG_GIRBIL_DONGLE
+  Say Y here if you want to build support for the Greenwich GIrBIL
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Greenwich dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Greenwich dongles you will have to
+  insert "irattach -d girbil" in the /etc/irda/drivers script.
+
+Parallax Litelink dongle
+CONFIG_LITELINK_DONGLE
+  Say Y here if you want to build support for the Parallax Litelink
+  dongle. If you want to compile it as a module, say M here and read
+  Documentation/modules.txt. The Parallax dongle attaches to the
+  normal 9-pin serial port connector, and can currently only be used
+  by IrTTY. To activate support for Parallax dongles you will have to
+  start irattach like this "irattach -d litelink".
+
+Old Belkin dongle
+CONFIG_OLD_BELKIN_DONGLE
+  Say Y here if you want to build support for the Adaptec Airport 1000
+  and 2000 dongles. If you want to compile it as a module, say M here
+  and read Documentation/modules.txt. The module will be called
+  old_belkin.o. Some information is contained in the comments at the
+  top of drivers/net/irda/old_belkin.c.
+
+VME (Motorola and BVM) support
+CONFIG_VME
+  Say Y here if you want to build a kernel for a 680x0 based VME
+  board.  Boards currently supported include Motorola boards MVME162,
+  MVME166, MVME167, MVME172, and MVME177.  BVME4000 and BVME6000
+  boards from BVM Ltd are also supported.
+
+MVME162, 166 and 167 support
+CONFIG_MVME16x
+  Say Y to include support for Motorola VME boards.  This will build a
+  kernel which can run on MVME162, MVME166, MVME167, MVME172, and
+  MVME177 boards.  If you select this option you will have to select
+  the appropriate drivers for SCSI, Ethernet and serial ports later
+  on.
+
+BVME4000 and BVME6000 support
+CONFIG_BVME6000
+  Say Y to include support for VME boards from BVM Ltd.  This will
+  build a kernel which can run on BVME4000 and BVME6000 boards.  If
+  you select this option you will have to select the appropriate
+  drivers for SCSI, Ethernet and serial ports later on.
+
+Use write-through caching for 68060 supervisor accesses
+CONFIG_060_WRITETHROUGH
+  The 68060 generally uses copyback caching of recently accessed data.
+  Copyback caching means that memory writes will be held in an on-chip
+  cache and only written back to memory some time later.  Saying Y
+  here will force supervisor (kernel) accesses to use writethrough
+  caching.  Writethrough caching means that data is written to memory
+  straight away, so that cache and memory data always agree.
+  Writethrough caching is less efficient, but is needed for some
+  drivers on 68060 based systems where the 68060 bus snooping signal
+  is hardwired on.  The 53c710 SCSI driver is known to suffer from
+  this problem.
+
+NCR53C710 SCSI driver for MVME16x
+CONFIG_MVME16x_SCSI
+  The Motorola MVME162, 166, 167, 172 and 177 boards use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+NCR53C710 SCSI driver for BVME6000
+CONFIG_BVME6000_SCSI
+  The BVME4000 and BVME6000 boards from BVM Ltd use the NCR53C710
+  SCSI controller chip.  Almost everyone using one of these boards
+  will want to say Y to this question.
+
+MVME16x Ethernet support
+CONFIG_MVME16x_NET
+  This is the driver for the Ethernet interface on the Motorola
+  MVME162, 166, 167, 172 and 177 boards.  Say Y here to include the
+  driver for this chip in your kernel.   If you want to compile it as
+  a module, say M here and read Documentation/modules.txt.
+
+BVME6000 Ethernet support
+CONFIG_BVME6000_NET
+  This is the driver for the Ethernet interface on BVME4000 and
+  BVME6000 VME boards.  Say Y here to include the driver for this chip
+  in your kernel.   If you want to compile it as a module, say M here
+  and read Documentation/modules.txt.
+
+CD2401 support for MVME166/7 serial ports
+CONFIG_SERIAL167
+  This is the driver for the serial ports on the Motorola MVME166,
+  167, and 172 boards.  Everyone using one of these boards should say
+  Y here.
+
+SCC support for MVME162 serial ports
+CONFIG_MVME162_SCC
+  This is the driver for the serial ports on the Motorola MVME162 and
+  172 boards.  Everyone using one of these boards should say Y here.
+
+SCC support for BVME6000 serial ports
+CONFIG_BVME6000_SCC
+  This is the driver for the serial ports on the BVME4000 and BVME6000
+  boards from BVM Ltd.  Everyone using one of these boards should say
+  Y here.
+
+7-Segment Display support
+CONFIG_DISPLAY7SEG
+  This is the driver for the 7-segment display and LED present on
+  Sun Microsystems CompactPCI models CP1400 and CP1500.
+
+  This driver is also available as a module ( = code which can be
+  inserted in and removed from the running kernel whenever you want).
+  The module will be called display7seg.o. If you want to compile it
+  as a module, say M here and read Documentation/modules.txt.
+
+  If you do not have a CompactPCI model CP1400 or CP1500, or
+  another UltraSPARC-IIi-cEngine boardset with a 7-segment display,
+  you should say N to this option. 
+
+IA-64 system type
+CONFIG_IA64_GENERIC
+  This selects the system type of your hardware.  A "generic" kernel
+  will run on any supported IA-64 system.  However, if you configure
+  a kernel for your specific system, it will be faster and smaller.
+
+  To find out what type of IA-64 system you have, you may want to
+  check the IA-64 Linux web site at http://www.linux-ia64.org/.
+  As of the time of this writing, most hardware is DIG compliant,
+  so the "DIG-compliant" option is usually the right choice.
+
+  HP-simulator   For the HP simulator (http://software.hp.com/ia64linux/).
+  SN1-simulator  For the SGI SN1 simulator.
+  DIG-compliant  For DIG ("Developer's Interface Guide") compliant system.
+
+  If you don't know what to do, choose "generic".
+
+Kernel page size
+CONFIG_IA64_PAGE_SIZE_4KB
+
+  This lets you select the page size of the kernel.  For best IA-64
+  performance, a page size of 8KB or 16KB is recommended.  For best
+  IA-32 compatibility, a page size of 4KB should be selected (the vast
+  majority of IA-32 binaries work perfectly fine with a larger page
+  size).  For Itanium systems, do NOT chose a page size larger than
+  16KB.
+
+  4KB                For best IA-32 compatibility
+  8KB                For best IA-64 performance
+  16KB               For best IA-64 performance
+  64KB               Not for Itanium.
+
+  If you don't know what to do, choose 8KB.
+
+Enable Itanium A-step specific code
+CONFIG_ITANIUM_ASTEP_SPECIFIC
+  Select this option to build a kernel for an Itanium prototype system
+  with an A-step CPU.  You have an A-step CPU if the "revision" field in
+  /proc/cpuinfo is 0.
+
+Enable Itanium B-step specific code
+CONFIG_ITANIUM_BSTEP_SPECIFIC
+  Select this option to build a kernel for an Itanium prototype system
+  with a B-step CPU.  You have a B-step CPU if the "revision" field in
+  /proc/cpuinfo has a value in the range from 1 to 4.
+
+Enable Itanium B0-step specific code
+CONFIG_ITANIUM_B0_SPECIFIC
+  Select this option to bild a kernel for an Itanium prototype system
+  with a B0-step CPU.  You have a B0-step CPU if the "revision" field in
+  /proc/cpuinfo is 1.
+
+Force interrupt redirection
+CONFIG_IA64_HAVE_IRQREDIR
+  Select this option if you know that your system has the ability to
+  redirect interrupts to different CPUs.  Select N here if you're
+  unsure.
+
+Enable use of global TLB purge instruction (ptc.g)
+CONFIG_ITANIUM_PTCG
+  Say Y here if you want the kernel to use the IA-64 "ptc.g"
+  instruction to flush the TLB on all CPUs.  Select N here if
+  you're unsure.
+
+Enable SoftSDV hacks
+CONFIG_IA64_SOFTSDV_HACKS
+  Say Y here to enable hacks to make the kernel work on the Intel
+  SoftSDV simulator.  Select N here if you're unsure.
+
+Enable AzusA hacks
+CONFIG_IA64_AZUSA_HACKS
+  Say Y here to enable hacks to make the kernel work on the NEC
+  AzusA platform.  Select N here if you're unsure.
+
+Force socket buffers below 4GB?
+CONFIG_SKB_BELOW_4GB
+  Most of today's network interface cards (NICs) support DMA to
+  the low 32 bits of the address space only.  On machines with
+  more then 4GB of memory, this can cause the system to slow
+  down if there is no I/O TLB hardware.  Turning this option on
+  avoids the slow-down by forcing socket buffers to be allocated
+  from memory below 4GB.  The downside is that your system could
+  run out of memory below 4GB before all memory has been used up.
+  If you're unsure how to answer this question, answer Y.
+
+Enable IA-64 Machine Check Abort
+CONFIG_IA64_MCA
+  Say Y here to enable machine check support for IA-64.  If you're
+  unsure, answer Y.
+
+Performance monitor support
+CONFIG_PERFMON
+  Selects whether support for the IA-64 performance monitor hardware
+  is included in the kernel.  This makes some kernel data-structures a
+  little bigger and slows down execution a bit, but it is still
+  usually a good idea to turn this on.  If you're unsure, say N.
+
+/proc/pal support
+CONFIG_IA64_PALINFO
+  If you say Y here, you are able to get PAL (Processor Abstraction
+  Layer) information in /proc/pal.  This contains useful information
+  about the processors in your systems, such as cache and TLB sizes
+  and the PAL firmware version in use.
+
+  To use this option, you have to check that the "/proc file system
+  support" (CONFIG_PROC_FS) is enabled, too.
+
+#
+# A couple of things I keep forgetting:
+#   capitalize: AppleTalk, Ethernet, DOS, DMA, FAT, FTP, Internet, 
+#               Intel, IRQ, ISDN, Linux, MSDOS, NetWare, NetWinder, 
+#               NFS, PCI, SCSI, SPARC
+#   two words:  file system, hard drive, hard disk, home page, 
+#               user space, web site
+#   other:      it's safe to save; daemon; use --, not - or ---;
+#               use KB for 1024 bytes, not kB or K.
+#
+#
+# This is used by Emacs' spell checker ispell.el:
+#
+# LocalWords:  CONFIG coprocessor DX Pentium SX lilo loadlin HOWTO ftp metalab
+# LocalWords:  unc edu docs emu README kB BLK DEV FD Thinkpad fd MFM RLL IDE gz
+# LocalWords:  cdrom diskless netboot nfs xzvf ATAPI MB ide pavia rubini pl pd
+# LocalWords:  HD CDROMs IDECD NEC MITSUMI filesystem XT XD PCI BIOS cezar ATEN
+# LocalWords:  ISA EISA Microchannel VESA BIOSes IPC SYSVIPC ipc Ctrl dmesg hlt
+# LocalWords:  BINFMT Linkable http ac uk jo html GCC SPARC AVANTI CABRIOLET EB
+# LocalWords:  netscape gcc LD CC toplevel MODVERSIONS insmod rmmod modprobe IP
+# LocalWords:  genksyms INET loopback gatewaying ethernet PPP ARP Arp MEMSIZE
+# LocalWords:  howto multicasting MULTICAST MBONE firewalling ipfw ACCT resp ip
+# LocalWords:  proc acct IPIP encapsulator decapsulator klogd PCTCP RARP EXT PS
+# LocalWords:  telnetting subnetted NAGLE rlogin NOSR ttyS TGA techinfo mbone nl
+# LocalWords:  Mb SKB IPX Novell dosemu Appletalk DDP ATALK vmalloc visar ehome
+# LocalWords:  SD CHR scsi thingy SG CD LUNs LUN jukebox Adaptec BusLogic EATA
+# LocalWords:  buslogic DMA DPT ATT eata dma PIO UltraStor fdomain umsdos ext
+# LocalWords:  QLOGIC qlogic TMC seagate Trantor ultrastor FASST wd NETDEVICES
+# LocalWords:  unix BBS linux CSLIP PLIP Kirch's LDP CSlip SL SCC IRQ csustan
+# LocalWords:  Turbo Laplink plip NCSA port's ReQuest IRQs EQL SMC AMD PCnet NE
+# LocalWords:  COM ELPLUS Com EtherLinkIII VLB Arcnet Cabletron DEPCA DE carlos
+# LocalWords:  depca EtherWorks EWRK ewrk SEEQ EtherExpress EEXPRESS NI xxx dia
+# LocalWords:  EtherExpress WaveLAN wavelan PCLAN HPLAN VG SK Ansel Xen de ZNET
+# LocalWords:  PCMCIA cb stanford LAN TEC RealTek ATP atp DLINK NetTools VISWS
+# LocalWords:  TR Sony CDU caddyless cdu Mitsumi MCD cd mcd XA MultiSession CDA
+# LocalWords:  Matsushita Panasonic SBPCD Soundblaster Longshine sbpcd Aztech
+# LocalWords:  Okano Wearnes AZTCD CDD SE aztcd sonycd Goldstar GSCD Philips fs
+# LocalWords:  LMS OPTCD Sanyo SJCD minix faqs xiafs XIA msdos mtools Cichocki
+# LocalWords:  std softlinks umssync NetworkFileSharing nfsd mountd CDs HPFS TI
+# LocalWords:  hpfs SYSV SCO iBCS Wyse WordPerfect tsx mit unixes sysv NR irisa
+# LocalWords:  SMB WfW Cyclades async mux Logitech busmouse MouseSystem aka AST
+# LocalWords:  PSMOUSE Compaq trackballs Travelmate Inport ATIXL ATI busmice ld
+# LocalWords:  gpm config QIC DYNCONF FTAPE Stor Ftape ftape pcsndrv manpage NT
+# LocalWords:  readprofile diskdrives org com masq EtherTalk tcp netrom sunacm
+# LocalWords:  misc AIC aic pio scc Portmaster eql GIS PhotoCDs MCDX Perell PG
+# LocalWords:  mcdx gscd optcd sjcd ISP hdparm Workgroups Lan samba PARIDE PCD
+# LocalWords:  filesystems smbfs ATA ppp PCTech RZ www powerquest txt CMD ESDI
+# LocalWords:  chipset FB multicast MROUTE appletalk ifconfig IBMTR multiport
+# LocalWords:  Multisession STALDRV EasyIO EC EasyConnection ISTALLION ONboard
+# LocalWords:  Brumby pci TNC cis ohio faq usenet NETLINK dev hydra ca Tyne mem
+# LocalWords:  carleton DECstation SUNFD JENSEN Noname XXXM SLiRP LILO's amifb
+# LocalWords:  pppd Zilog ZS SRM bootloader ez mainmenu rarp ipfwadm paride pcd
+# LocalWords:  RTNETLINK mknod xos MTU lwared Macs mac netatalk macs cs Wolff
+# LocalWords:  dartmouth flowerpt MultiMaster FlashPoint tudelft etherexpress
+# LocalWords:  ICL EtherTeam ETH IDESCSI TXC SmartRAID SmartCache httpd sjc dlp
+# LocalWords:  thesphere TwoServers BOOTP DHCP ncpfs BPQETHER BPQ MG HIPPI cern
+# LocalWords:  bsd comp SPARCstation le SunOS ie Gracilis PackeTwin PT pt LU FX
+# LocalWords:  FX TEAC CR LCS mS ramdisk IDETAPE cmd fperllo encis tcfs unisa
+# LocalWords:  Vertos Genoa Funai hsfs NCP NetWare tgz APM apm ioctls UltraLite
+# LocalWords:  TravelMate CDT LCD backlight VC RPC Mips AXP barlow cdrecord pg
+# LocalWords:  PMAX MILO Alphas Multia Tseng linuxelf endian mipsel mips drv HT
+# LocalWords:  kerneld callouts AdvanSys advansys Admin WDT DataStor EP verden
+# LocalWords:  wdt hdb hdc bugfix SiS vlb Acculogic CSA DTC dtc Holtek ht QDI
+# LocalWords:  QD qd UMC umc ALI ali lena fnet fr azstarnet cdr fb MDA ps esdi
+# LocalWords:  Avanti XL AlphaStations Jensen DECpc AXPpci UDB Cabriolet MCA RC
+# LocalWords:  AlphaPC mca AOUT OUTput PPro sipx gwdg lo nwe FourPort Boca unm
+# LocalWords:  Keepalive linefill RELCOM keepalive analogue CDR conf CDI INIT
+# LocalWords:  OPTi isp irq noisp VFAT vfat NTFS losetup dmsdosfs dosfs ISDN MP
+# LocalWords:  NOWAYOUT behaviour dialin isdn callback BTX Teles  XXXX LVM lvm
+ICN EDSS Cisco
+# LocalWords:  ipppd syncppp RFC MPP VJ downloaded icn NICCY Creatix shmem ufr
+# LocalWords:  ibp md ARCnet ether encap NDIS arcether ODI Amigas AmiTCP NetBSD
+# LocalWords:  initrd tue util DES funet des OnNet BIOSP smc Travan Iomega CMS
+# LocalWords:  FC DC dc PPA IOMEGA's ppa RNFS FMV Fujitsu ARPD arpd loran layes
+# LocalWords:  FRAD indiana framerelay DLCI DCLIs Sangoma SDLA mrouted sync sec
+# LocalWords:  Starmode Metricom MosquitoNet mosquitonet kbit nfsroot Digiboard
+# LocalWords:  DIGI Xe Xeve digiboard UMISC touchscreens mtu ethernets HBAs MEX
+# LocalWords:  Shifflett netcom js jshiffle WIC DECchip ELCP EtherPower dst RTC
+# LocalWords:  rtc SMP lp Digi Intl RightSwitch DGRS dgrs AFFS Amiga UFS SDL AP
+# LocalWords:  Solaris RISCom riscom syncPPP PCBIT pcbit sparc anu au artoo MFB
+# LocalWords:  hitchcock Crynwr cnam pktdrvr NCSA's CyDROM CyCDROM FreeBSD NeXT
+# LocalWords:  NeXTstep disklabel disklabels SMD FFS tm AmigaOS diskfiles Un IQ
+# LocalWords:  Bernd informatik rwth aachen uae affs multihosting bytecode java
+# LocalWords:  applets applet JDK ncsa cabi SNI Alphatronix readme LANs scarab
+# LocalWords:  winsock RNIS caltech OSPF honour Honouring Mbit LocalTalk DEFRAG
+# LocalWords:  localtalk download Packetwin Baycom baycom interwork ASCII JNT
+# LocalWords:  Camtec proxying indyramp defragment defragmented UDP FAS FASXX
+# LocalWords:  FastSCSI SIO FDC qlogicfas QLogic qlogicisp setbaycom ife ee LJ
+# LocalWords:  ethz ch Travelmates ProAudioSpectrum ProAudio SoundMan SB SBPro
+# LocalWords:  Thunderboard SM OPL FM ADLIB TSR Gravis MPU PSS ADI SW DSP codec
+# LocalWords:  ADSP ESC ASIC daughtercard GUSMAX MSS NX AdLib Excell Ensoniq YM
+# LocalWords:  SoundScape Spea MediaTriX AudioTriX WSS OTI ThunderBoard VoxWare
+# LocalWords:  Soundscape SSCAPE TRIX MediaTrix PnP Maui dsp midixx EIA getty
+# LocalWords:  mgetty sendfax gert greenie muc lowlevel Lasermate LanManager io
+# LocalWords:  OOPSes trackball binghamton mobileip ncr IOMAPPED settags ns ser
+# LocalWords:  setsync NEGO MPARITY autotuning prefetch PIIX cdwrite utils rc
+# LocalWords:  PCWATCHDOG berkprod bitgate boldt ucsb jf kyoto jp euc Tetsuyasu 
+# LocalWords:  YAMADA tetsu cauchy nslab ntt nevod perm su doc kaf kheops wsc
+# LocalWords:  traduc Bourgin dbourgin menuconfig kfill READMEs HOWTOs Virge WA
+# LocalWords:  IDEDISK IDEFLOPPY EIDE firewalls QMAGIC ZMAGIC LocalWords opti
+# LocalWords:  SVGATextMode vga svga Xkernel syr jmwobus comfaqs dhcp flakey GD
+# LocalWords:  IPv IPng interoperability ipng ipv radio's tapr pkthome PLP nano
+# LocalWords:  Ses Mhz sethdlc SOUNDMODEM WindowsSoundSystem smdiag pcf inka ES
+# LocalWords:  smmixer ptt circ soundmodem MKISS FDDI DEFEA DEFPA DEFXX redhat
+# LocalWords:  HyperNews khg mconv sed lina wuftpd MicroChannel netlink irc cum
+# LocalWords:  raudio RealAudio PPROP NETBIOS GUI IBMMCA ELMC Racal Interlan fi
+# LocalWords:  eth shapecfg src esp PCWD PREVSTAT bootparam sig bitwizard SBC
+# LocalWords:  downloads AFSK TCM FP Karn KA FSK RUH LinkSys cron mouseman LLC
+# LocalWords:  SyQuest SyQuest's CCITT MicroSolutions BPCD bpcd ESPSERIAL PROM
+# LocalWords:  SUNESP openprom OPENPROMIO quango themall al TT MC MMU LC RMW AA
+# LocalWords:  INSNS Ataris AutoConfig ZORRO OCS AMIFB Agnus Denise ECS CDTV GB
+# LocalWords:  AGA Cybervision CYBER GSP TMS DMI Zorro ACSI ROMs SLM BioNet GVP
+# LocalWords:  PAMsNet TekMagic Cyberstorm MkI CYBERSTORMII MkII BLZ onboard cx
+# LocalWords:  Village Tronic ATARILANCE RieblCard PAMCard VME MFP sangoma LAPB
+# LocalWords:  Rhotron BioData's Multiface AMIGAMOUSE COPCON Amiga's bitplanes
+# LocalWords:  ATARIMOUSE MFPSER SCC's MegaSTE ESCC Atari's GVPIOEXT DMASOUND
+# LocalWords:  fdutils cisco univercd rpcg htm iface lapb LAPBETHER tpqic qic
+# LocalWords:  SYNTH xd en binfmt aout ipip terra ipx sd sr sg wic framebuffer
+# LocalWords:  ibmmca lapbether mkiss dlci sdla fmv eepro eexpress ni hp ne es
+# LocalWords:  ibmtr isofs ROMFS romfs pcxx cyclades istallion psaux msbusmouse
+# LocalWords:  atixlmouse sbin softdog pcwd USS Lite ACI miroSOUND PCM miroPCM
+# LocalWords:  microcontroller miro Voxware downloading teles acsi slm gvp ltpc
+# LocalWords:  atari ariadne amigamouse atarimouse builtin IPDDP maths bradford
+# LocalWords:  AppleTalk Farallon PhoneNet Zubkoff lnz SCCB HAPN WANs vesafb nt
+# LocalWords:  wanrouter WANPIPE multiprotocol Mbps wanpipe EtherWORKS nodma SC
+# LocalWords:  smp HiSax SiemensChipSet Siemens AVM Elsa ITK hisax PCC MICROR
+# LocalWords:  Mircolink EURO DSS Spellcaster BRI sc spellcast Digiboards GPIO
+# LocalWords:  SYMBIOS COMPAT SDMS rev ASUS Tekram HX VX API ibmmcascsi ASY asy
+# LocalWords:  loader's PCnetPCI automounter AUTOFS amd autofs VT Gallant's Pnp
+# LocalWords:  AEDSP aedsp enskip tik Sysctl sysctl PARPORT parport pnp IDs EPP
+# LocalWords:  Autoprobe bart patrickr HDLS READBACK AB usr DAMA DS SparQ aten
+# LocalWords:  Symbios PCscsi tmscsim RoamAbout GHz Hinds contrib mathematik ok
+# LocalWords:  darmstadt okir DIGIEPCA International's Xem digiepca epca bootup
+# LocalWords:  zorro CAPI AVMB capi avmb VP SYN syncookies EM em pc Ethertalk
+# LocalWords:  Dayna DL Daynatalk LT PhoneNET ATB Daystar queueing CMDS SCBs ls
+# LocalWords:  SCB STATS Thinnet ThunderLAN TLAN Netelligent NetFlex tlan james
+# LocalWords:  caldera Preload Preloading slowdowns schoebel uni NBD nbd prog
+# LocalWords:  stuttgart rdist TRANS hostnames mango jukeboxes ESS userland PD
+# LocalWords:  hardlinked NAMETRANS env mtab fstab umount nologin runlevel gid
+# LocalWords:  adm Nodename hostname uname Kernelname bootp nmi DI OV StegFS
+# LocalWords:  KERNNAME kname ktype kernelname Kerneltype KERNTYPE Alt RX mdafb
+# LocalWords:  dataless kerneltype SYSNAME Comtrol Rocketport palmtop fbset EGS
+# LocalWords:  nvram SYSRQ SysRq PrintScreen sysrq NVRAMs NvRAM Shortwave RTTY
+# LocalWords:  Sitor Amtor Pactor GTOR hayes TX TMOUT JFdocs BIGMEM DAC IRQ's
+# LocalWords:  IDEPCI IDEDMA PDC pdc TRM trm raidtools luthien nuclecu BAGET VR
+# LocalWords:  unam mx miguel koobera uic EMUL solaris pp ieee lpsg co DMAs TOS
+# LocalWords:  BLDCONFIG preloading jumperless BOOTINIT modutils multipath GRE
+# LocalWords:  misconfigured autoconfiguration IPGRE ICMP tracert ipautofw PIM
+# LocalWords:  netis rlynch autofw ipportfw monmouth ipsubs portforwarding pimd
+# LocalWords:  portfw PIMSM netweb usc pim pf EUI aggregatable PB decapsulate
+# LocalWords:  ipddp Decapsulation DECAP bool HAMRADIO tcpdump af CDs tx FBCON
+# LocalWords:  ethertap multisession PPC MMIO GDT GDTH ICP gdth hamradio  bpp
+# LocalWords:  lmh weejock AIMSlab RadioTrack RTRACK HZP OptoSCC TRX rx TRXECHO
+# LocalWords:  DMASCC paccomm dmascc addr cfg oevsv oe kib picpar FDX baudrate
+# LocalWords:  baudrates fdx HDX hdx PSK kanren frforum QoS SCHED CBQ SCH sched
+# LocalWords:  sch cbq CSZ Shenker Zhang csz SFQ sfq TBF tbf PFIFO fifo PRIO RW
+# LocalWords:  prio Micom xIO dwmw rimi OMIRR omirr omirrd unicode ntfs cmu NIC
+# LocalWords:  Braam braam Schmidt's freiburg nls codepages codepage Romanian
+# LocalWords:  Slovak Slovenian Sorbian Nordic iso Catalan Faeroese Galician SZ
+# LocalWords:  Valencian Slovene Esperanto Estonian Latvian Byelorussian KOI mt
+# LocalWords:  charset Inuit Greenlandic Sami Lappish koi Alexey Kuznetsov's sa
+# LocalWords:  Specialix specialix DTR RTS RTSCTS cycladesZ Exabyte ftape's inr
+# LocalWords:  Iomega's LBFM claus ZFTAPE VFS zftape zft William's lzrw DFLT kb
+# LocalWords:  MTSETBLK MTIOCTOP qft setblk zftape's tar's afio's setdrvbuffer
+# LocalWords:  Procfs Exabyte's THR FCD sysvinit init PSC pscwdt VMIDI Euro SAB
+# LocalWords:  Mostek Fastlane PowerMac PReP PMAC PowerPC Macintoshes Starmax
+# LocalWords:  PowerStack Starmaxes MCOMMON DEVICETREE ATY IMS IMSTT videodev
+# LocalWords:  BT Hauppauge STB bttv Quickcam BW BWQCAM bw qcam Mediavision PMS
+# LocalWords:  pms Avatar Freecom Imation Superdisk BPCK bpck COMM comm DSTR ru
+# LocalWords:  dstr EPAT EPEZ epat EPIA epia FreeCom FRPW frpw KingByte KBIC HW
+# LocalWords:  KingByte's kbic OnSpec ValuStore FASTROUTE fastroute FLOWCONTROL
+# LocalWords:  struct APIC realtime OSs LynxOS CNC tmp cvf HFS hfs ADFS Risc os
+# LocalWords:  adfs ncpmount namespace SUBDIR reexport NDS kcore FT SPX spx DAT
+# LocalWords:  interserver BLKSZ NUMBUFFERS apmd Tadpole ANA roestock QuickCam
+# LocalWords:  isapnptools Colour CQCAM colour Connectix QuickClip prive mentre
+# LocalWords:  KMOD kmod conformant utexas kharker UnixWare Mwave cgi cl ts ibm
+# LocalWords:  eXchange threepio oakland simtel pre ULTRAMCA EtherLink isa luik
+# LocalWords:  EtherLink OpenBSD pts DEVPTS devpts ptmx ttyp glibc readback SA
+# LocalWords:  mwave OLDCARD isdnloop linklevel loopctrl Eicon Diehl DIEHLDIVA
+# LocalWords:  ASUSCOM AsusCom TELEINT semiactiv Sedlbauer Sportster TA MIC ITH
+# LocalWords:  NETjet NetJet Niccy Neuhaus sparcs AOC AOCD AOCE Microlink SAA
+# LocalWords:  teletext WinTV saa iproute tc Quadra Performa PowerBook tor AUN
+# LocalWords:  setserial compsoc steve Econet econet AUNUDP psched TEQL TLE CLS
+# LocalWords:  teql FW Ingres TwistedPair MTRR MTRRs mtrr cfs crypto TD ktti KT
+# LocalWords:  PHd ICS ipchains adelaide rustcorp syslog Cumana steganography
+# LocalWords:  AcornSCSI EcoSCSI EESOX EESOXSCSI Powertec POWERTECSCSI dec SF
+# LocalWords:  RadioReveal gatekeeper aimslab aztech FMI sf fmi RTL rtl cesdis
+# LocalWords:  Yellowfin gsfc nasa gov yellowfin pcnet Mylex LNE lne EtherH hs
+# LocalWords:  EBSA chattr RiscOS Winmodem AGP Atomwide DUALSP pcsp robinson CT
+# LocalWords:  SGALAXY Waverider DSPxxx TRXPRO AudioTrix OSWF MOT CFB DSY kbps
+# LocalWords:  tuwien kkudielk LVD mega lun MAXTAGS Gbps arcnet Olicom SNA PAE
+# LocalWords:  SysKonnect tms sna etherboot ufs NetBEUI MultiSound MSNDCLAS GX
+# LocalWords:  MSNDINIT MSNDPERM MSNDPIN PNDSPINI PNDSPERM Ensoniq's RetinaZ SS
+# LocalWords:  AudioPCI lspci SonicVibes sonicvibes SPARCs roadrunner CLgen UPA
+# LocalWords:  swansea shtml Zoltrix zoltrix BINUTILS EGCS binutils VIDC DACs
+# LocalWords:  CyberVision Cirrus PowerBooks Topcat SBUS CGsix TurboGX BWtwo SS
+# LocalWords:  CGthree TCX unswapable vfb fbcon hicolor truecolor AFB ILBM SOC
+# LocalWords:  IPLAN gracilis Fibre SBus SparcSTORAGE SV jnewbigin swin QNX qnx
+# LocalWords:  PTY PTYS ptyxx ttyxx PTYs ssh sb Avance ALS pss pvv kerneli hd
+# LocalWords:  synth WaveFront MSND NONPNP AudioExcelDSP STRAM APUS CHRP MBX Nx
+# LocalWords:  PowerMac's BMAC radiotrack rtrack miropcm OFFBOARD HPT UDMA DVD
+# LocalWords:  hpt fokus gmd Cyrix DXL SLC DLC NexGen MediaGX GXm IDT WinChip
+# LocalWords:  MMX MII valkyrie mdacon vdolive VDOLive cuseeme CU hippi rrunner
+# LocalWords:  SeeMe ipmasqadm juanjox ipmarkfw markfw TNCs Microdyne rhine lib
+# LocalWords:  libc jsX gamepad gameport CHF FCS FPGaming MadCatz ASSASIN GrIP
+# LocalWords:  Assasin gamepads GamePad PDPI gamecards gamecard WingMan BSP WCS
+# LocalWords:  ThunderPad CyberMan SideWinder ThrustMaster DirectConnect NES XF
+# LocalWords:  Millenium SNES PSX Multisystem Nintendo PlayStation Amstrad CPC
+# LocalWords:  Sega TurboGraFX Steffen Schwenke Multiststem PDIF FIFOSIZE EPLUS
+# LocalWords:  PowerUP RoadRunner tahallah dos functionkey setterm imladris Woz
+# LocalWords:  PowerMacs Winbond Algorithmics ALGOR algor ECOFF IRIX SGI SGI's
+# LocalWords:  gfx virtualized Xpmac mklinux XFree FBDev Woodhouse mvhi Seeq fp
+# LocalWords:  SGISEEQ HIgh ADB ADBMOUSE crosscompiler CROSSCOMPILE FPE GDB gdb
+# LocalWords:  JOYPORT rp spoofing DawiControl NOGENSUPP EEPROM HSSI Alessandro
+# LocalWords:  singleprocessor tex MATHEMU FRIQ Maxell friq Alcor XLT AlphaBook
+# LocalWords:  AlphaPCI DP LX Miata Mikasa Noritake RPX UX BX Takara EV PRIMO
+# LocalWords:  TSC Matrox Productiva matroxfb matrox multihead ia linuxhq MFW
+# LocalWords:  mfw AAA MCS Initio XXU initio imm AutoDetect IZIP CTR usec HDLC
+# LocalWords:  COSA SRP muni cz kas cosa Alteon AceNIC acenic VTOC OSes GMT SAx
+# LocalWords:  Inspiron localtime INTS Thinkpads Ralf Brown's Flightstick NNN
+# LocalWords:  Xterminator Blackhawk NN mpu ioports DCA HPDCA HPLANCE DIO Corel
+# LocalWords:  GemTek gemtek CMDLINE IrDA PDA's irmanager irattach RR AVA DN rg
+# LocalWords:  uit dagb irda LSAP IrLMP RR's IrLAP IR alloc skb's kfree skb's
+# LocalWords:  GZIP IrLAN NetbeamIR ESI JetEye IrOBEX IrCOMM TTY's minicom dti
+# LocalWords:  ircomm ircomm pluto thiguchi IrTTY Linux's bps NetWinder MIR NSC
+# LocalWords:  ACTiSYS Dongle dongle dongles esi actisys IrMate tekram BVM MVME
+# LocalWords:  BVME BVME WRITETHROUGH copyback writethrough fwmark syncookie tu
+# LocalWords:  alphalinux GOBIOS csn chemnitz nat ACARD AMI MegaRAID megaraid
+# LocalWords:  QNXFS ISI isicom xterms Apollos VPN RCPCI rcpci sgi visws pcmcia
+# LocalWords:  IrLPT UIRCC Tecra Strebel jstrebel suse Eichwalder ke INI INIA
+# LocalWords:  FCP qlogicfc sym isapnp DTLK DoubleTalk rcsys dtlk DMAP SGIVW ar
+# LocalWords:  dmabuf EcoRadio MUTEFREQ GIrBIL girbil tepkom vol mha diplom PQS
+# LocalWords:  bmac Microgate SyncLink synclink hdlc excl ioaddr Tane tanep TCQ
+# LocalWords:  PDS SMALLDOS charsets bigfoot kernelfr mcs cls fw rsvp SKnet sk
+# LocalWords:  SKMC USB UHCI OHCI intel compaq usb ohci HCD Virt Compaq's hcd
+# LocalWords:  VROOTHUB KBD ARRs MCRs NWBUTTON nwbutton NUM WaveArtist APNE cpu
+# LocalWords:  apne blackhawke PlanB lu mlan planb NWFPE FPA nwfpe unbootable
+# LocalWords:  FPEmulator ds vmlinux initialisation discardable pgtable PGT mdw
+# LocalWords:  quicklist pagetable arthur StrongARM podule podules Autodetect
+# LocalWords:  dodgy IrPORT irport Litelink litelink SuSE rtfm internet hda CY
+# LocalWords:  multmode DriveReady SeekComplete DriveStatusError miscompile AEC
+# LocalWords:  mainboard's Digital's alim FastTrak aec PIIXn piix Gayle Eyetech
+# LocalWords:  Catweasel IDEDOUBLER Powerbook Centris ICSIDE RapIDE OSM HDM IOP
+# LocalWords:  HDM's OSM's lan FibreChannel ECP autoprobe itg lbl ipmasq cjb IC
+# LocalWords:  bieringer Caulfield's dreamtime decnet SIOCFIGCONF SIOCGIFCONF
+# LocalWords:  rtnetlink Endnode Aironet Arlan Telxon ylenurme arlan ACB aeschi
+# LocalWords:  Sealevel sealevel Cyclom br wanconfig tarball conectiva cycsyn
+# LocalWords:  devel bazar cyclomx NetGear GA IBMOL Lanstreamer uhci eu efs CYZ
+# LocalWords:  olympic linuxtr usbcore acm EZUSB downloader EFS XFS INTR op IIC
+# LocalWords:  heine soundcore JavaStations JavaStation GemTeks TerraTec TODO
+# LocalWords:  ActiveRadio Standalone terratec Rolf Offermanns rolf offermanns
+# LocalWords:  Zoran ZR Buz LML CPQ DA cpqarray PPDEV deviceid vlp ppdev atyfb
+# LocalWords:  AcceleRAID eXtremeRAID NETFILTER Netfilter masqueraded netfilter
+# LocalWords:  kernelnotes Cardbus PCMCIA's CardBus clgenfb Permedia YAM MMAP
+# LocalWords:  mmapped ATM atm PVCs SVCs InARP ATMARP neighbour neighbours MPOA
+# LocalWords:  VCs ENI FPGA Tonga MMF MF UTP printks ZeitNet ZN ZATM uPD SAR PN
+# LocalWords:  approx NICStAR NICs ForeRunnerLE Madge Collage ATMizer Dxxxx VCI
+# LocalWords:  ServeRAID IPS ips ipslinux gzip BSDCOMP LZW RAYCS Interphase app
+# LocalWords:  Tachyon IPHASE Surfboard NextLevel SURFboard jacksonville Tigon
+# LocalWords:  fventuri adelphia siglercm linuxpower AceNICs Starfire starfire
+# LocalWords:  ISOC CPiA cpia uss ACPI UDF DirectCD udf CDRW's OSF Manx acpi DM
+# LocalWords:  Unixware cymru Computone IntelliPort Intelliport computone SI sx
+# LocalWords:  adbmouse DRI DRM dlabs GMX PLCs Applicom fieldbus applicom int
+# LocalWords:  VWSND eg ESSSOLO CFU CFNR scribed eiconctrl eicon hylafax KFPU
+# LocalWords:  EXTRAPREC fpu mainboards KHTTPD kHTTPd khttpd Xcelerator SBNI tw
+# LocalWords:  LOGIBUSMOUSE Granch granch sbni Raylink NOHIGHMEM Athlon SIM sim
+# LocalWords:  hpl Tourrilhes DuraLAN starfile Davicom davicom dmfe auk tms tr
+# LocalWords:  TokenExpress Belkin Peracom eTek DVDs infradead Cxxx Adlib AV ZX
+# LocalWords:  NeoMagic CPi CPt Celeron decapsulation Undeletion BFS bfs nVidia
+# LocalWords:  OnStream Irongate Riva phonedev QuickNet LineJack PhoneJack IXJ
+# LocalWords:  Quicknet PhoneJACK LineJACK ixj pnpdump Quicknet's Joandi SSID
+# LocalWords:  aironet quickconfig adhoc btw bap NONCS cardservices Xircom lin
+# LocalWords:  Netwave AirSurfer netwave HomePNA failover MVP iMacs ALi aktual
+# LocalWords:  Aladin HIDBP usbkbd KEYBDEV MOUSEDEV JOYDEV EVDEV UAB WhiteHEAT
+# LocalWords:  Handspring ov DABUSB URB URB's dabusb CRAMFS NFSv ELV IOAPIC WIP
+# LocalWords:  NLMv SMBus ALGOBIT algo PHILIPSPAR philips elv Velleman velleman
+# LocalWords:  ALGOPCF Elektor elektor CHARDEV dfx TDFX tdfx Extensa dof gravis
+# LocalWords:  assasin logitech Overdrive thrustmaster DWave Aureal magellan db
+# LocalWords:  SpaceTec SpaceOrb SpaceBall spaceorb FLX spaceball turbografx zr
+# LocalWords:  amiga ESS's WaveWatcher Maxi belkin RW's ata glx GART MPV Baget
+# LocalWords:  OpenGL Xserver agpgart HOTPLUG CyberPro Integraphics Netwinder
+# LocalWords:  aty FONTWIDTH eni zatm nicstar ForeRunner OC DECstations DEC's
+# LocalWords:  PHYsical SUNI reinsertion ChipSAR KVC PHY ClassID iphase iadbg
+# LocalWords:  DEVS FireWire PCILynx pcilynx LOCALRAM miro's DV RAWIO GRED Mk
+# LocalWords:  Diffserv DSMARK Ingress Qdisc TCINDEX TMSPCI tmspci Ringode JE
+# LocalWords:  MADGEMC madgemc TokenRing SMCTR TokenCard smctr Wacom Graphire
+# LocalWords:  WMFORCE mousedev ConnectTech HandSpring Xirlink IBMCAM ibmcam SN
+# LocalWords:  DEVICEFS yyy Cymraeg Dwave SIMM JSFLASH JavaStation's multilink
+# LocalWords:  nsc ircc DDB Vrc CMN TB PROMs Vino rivafb DDC Matroxes MGA TVO
+# LocalWords:  MAVEN fbdev crtc maven matroxset NTSC PCA SBA AAL SKFP DAS SAS
+# LocalWords:  skfp Intuos ADMtek's pegasus PLUSB plusb pointopoint mp rio Xeon
+# LocalWords:  DEVFS devfs dd bs EDSS german TELESPCI FRITZPCI HFC HFCS BDS HST
+# LocalWords:  ISURF ISAR Saphir HSTSAPHIR Telekom BKM Scitel Quadro SCT Gazel
+# LocalWords:  SP PRI Hypercope HYSDN Hypercope's hysdn IbssJoinNetTimeout FTDI
+# LocalWords:  ARCNet Keyspan PDA ADMtek sgalaxy sgbase opl mpuio mpuirq sbio
+# LocalWords:  sbirq sbdma gus uart mssio mssirq mssdma sscape maui mouirq iph
+# LocalWords:  CHDLC UPS's usbmouse wacom wmforce keybdev joydev fibre Trunking
+# LocalWords:  Etherchannel IOC Moxa Intellio moxa SmartIO mxser Mixcom EFI ir
+# LocalWords:  MIXCOMWD mixcomwd SENDCOMPLETE GMAC iBook gmac OAKNET oaknet PCG
+# LocalWords:  diffserv irlan irtty toshoboe IrCC Lifebook idex AUTODMA FIP Cxx
+# LocalWords:  Yenta Databook TCIC FMVJ fmvj NMCLAN LiveWire nmclan XIRC xirc
+# LocalWords:  loadkeys setfont shm SuperIO soc SOCAL socal FCAL fc fcal COMX
+# LocalWords:  MultiGate ITConsult comx CMX HiCOMX downloadable hw LoCOMX PROTO
+# LocalWords:  locomx MixCOM mixcom proto MyriCOM MYRI Sbus myri sbus IBMLS hme
+# LocalWords:  lanstreamer baseT HAPPYMEAL qfe sunhme SUNLANCE sunlance BigMAC
+# LocalWords:  SUNBMAC sunbmac QuadEthernet SUNQE qe FastEthernet sunqe DSB PTI
+# LocalWords:  DSBR dsbr procinfo QLOGICPTI qpti ptisp QLGC qlogicpti se LBA NF
+# LocalWords:  OPENPROMFS OpenPROM openpromfs OBP OpenBoot flashable Multiboard
+# LocalWords:  SPARCAUDIO SparcClassic Ultras DBRI Sparcbook sparcaudio SUNBPP
+# LocalWords:  UltraDMA WDC CRC CONNTRACK IPTABLES iptables nfmark interface's
+# LocalWords:  tdfxfb TNTx HGA hgafb VERBOSEDEBUG SunTrunking SunSoft XIRTULIP
+# LocalWords:  ethercards PNIC Macronix MXIC ASIX xircom Mustek MDC gphoto mdc
+# LocalWords:  CramFs Cramfs uid cramfs AVM's kernelcapi PCIV cdrdao Cdparanoia
+# LocalWords:  DMX Domex dmx wellington ftdi sio Accton Billington Corega FEter
+# LocalWords:  MELCO LUA PNA Linksys SNC chkdsk AWACS Webcam RAMFS Ramfs ramfs
+# LocalWords:  ramfiles MAKEDEV pty WDTPCI APA apa
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/Makefile linux-2.4.20/drivers/scsi/aic7xxx/Makefile
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/Makefile	2002-08-02 18:39:44.000000000 -0600
+++ linux-2.4.20/drivers/scsi/aic7xxx/Makefile	2002-09-11 15:08:11.000000000 -0600
@@ -6,9 +6,12 @@
 
 O_TARGET := aic7xxx_drv.o
 
-list-multi	:= aic7xxx.o
+list-multi	:= aic7xxx.o aic79xx.o
 
 obj-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx.o
+ifeq ($(CONFIG_PCI),y)
+obj-$(CONFIG_SCSI_AIC79XX)	+= aic79xx.o
+endif
 
 #EXTRA_CFLAGS += -g
 
@@ -19,27 +22,42 @@
 obj-aic7xxx += aic7xxx_osm_pci.o
 endif
 # Core Files
-obj-aic7xxx += aic7xxx_core.o aic7xxx_93cx6.o aic7770.o
+obj-aic7xxx += aic7xxx_core.o aic7xxx_93cx6.o aic7770.o # aic7xxx_reg_print.o
 #PCI Specific Core Files
 ifeq ($(CONFIG_PCI),y)
 obj-aic7xxx += aic7xxx_pci.o
 endif
 
+# Platform Specific U320 Files
+obj-aic79xx = aic79xx_osm.o 
+obj-aic79xx += aic79xx_proc.o
+obj-aic79xx += aic79xx_osm_pci.o
+# Core Files
+obj-aic79xx += aic79xx_core.o aic79xx_pci.o aic79xx_reg_print.o
+
 # Override our module desitnation
 MOD_DESTDIR = $(shell cd .. && $(CONFIG_SHELL) $(TOPDIR)/scripts/pathdown.sh)
 
 include $(TOPDIR)/Rules.make
 
-aic7xxx.o: $(obj-aic7xxx)
+aic7xxx_core.o: aic7xxx_seq.h
+$(obj-aic7xxx): aic7xxx_reg.h
+aic7xxx.o: aic7xxx_seq.h aic7xxx_reg.h $(obj-aic7xxx)
 	$(LD) $(LD_RFLAG) -r -o $@ $(obj-aic7xxx)
 
-ifeq ($(CONFIG_AIC7XXX_BUILD_FIRMWARE),y)
-aic7xxx_core.o: aic7xxx_seq.h
+aic79xx_core.o: aic79xx_seq.h
+$(obj-aic79xx): aic79xx_reg.h
+aic79xx.o: aic79xx_seq.h aic79xx_reg.h $(obj-aic79xx)
+	$(LD) $(LD_RFLAG) -r -o $@ $(obj-aic79xx)
 
-$(obj-aic7xxx): aic7xxx_reg.h
+ifeq ($(CONFIG_AIC7XXX_BUILD_FIRMWARE),y)
+aic7xxx_seq.h aic7xxx_reg.h aic7xxx_reg_print.c: aic7xxx.seq aic7xxx.reg aicasm/aicasm
+	aicasm/aicasm -I. -p aic7xxx_reg_print.c -i aic7xxx_osm.h -r aic7xxx_reg.h -o aic7xxx_seq.h aic7xxx.seq
+endif
 
-aic7xxx_seq.h aic7xxx_reg.h: aic7xxx.seq aic7xxx.reg aicasm/aicasm
-	aicasm/aicasm -I. -r aic7xxx_reg.h -o aic7xxx_seq.h aic7xxx.seq
+ifeq ($(CONFIG_AIC79XX_BUILD_FIRMWARE),y)
+aic79xx_seq.h aic79xx_reg.h aic79xx_reg_print.c: aic79xx.seq aic79xx.reg aicasm/aicasm
+	aicasm/aicasm -I. -p aic79xx_reg_print.c -i aic7xxx_osm.h -r aic79xx_reg.h -o aic79xx_seq.h aic79xx.seq
 endif
 
 aicasm/aicasm: aicasm/*.[chyl]
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/scsi_iu.h linux-2.4.20/drivers/scsi/aic7xxx/scsi_iu.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/scsi_iu.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/scsi_iu.h	2002-09-11 15:08:12.000000000 -0600
@@ -0,0 +1,31 @@
+/*
+ * This file is in the public domain.
+ */
+#ifndef	_SCSI_SCSI_IU_H
+#define _SCSI_SCSI_IU_H 1
+
+struct scsi_status_iu_header
+{
+	u_int8_t reserved[2];
+	u_int8_t flags;
+#define	SIU_SNSVALID 0x2
+#define	SIU_RSPVALID 0x1
+	u_int8_t status;
+	u_int8_t sense_length[4];
+	u_int8_t pkt_failures_length[4];
+	u_int8_t pkt_failures[1];
+};
+
+#define SIU_PKTFAIL_OFFSET(siu) 12
+#define SIU_PKTFAIL_CODE(siu) (scsi_4btoul((siu)->pkt_failures) & 0xFF)
+#define		SIU_PFC_NONE			0
+#define		SIU_PFC_CIU_FIELDS_INVALID	2
+#define		SIU_PFC_TMF_NOT_SUPPORTED	4
+#define		SIU_PFC_TMF_FAILED		5
+#define		SIU_PFC_INVALID_TYPE_CODE	6
+#define		SIU_PFC_ILLEGAL_REQUEST		7
+#define SIU_SENSE_OFFSET(siu)				\
+    (12 + (((siu)->flags & SIU_RSPVALID)		\
+	? scsi_4btoul((siu)->pkt_failures_length)	\
+	: 0))
+#endif /*_SCSI_SCSI_IU_H*/
diff -urN linux-2.4.20.orig/drivers/scsi/aic7xxx/tmp.h linux-2.4.20/drivers/scsi/aic7xxx/tmp.h
--- linux-2.4.20.orig/drivers/scsi/aic7xxx/tmp.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.4.20/drivers/scsi/aic7xxx/tmp.h	2002-09-24 15:10:11.000000000 -0600
@@ -0,0 +1,1303 @@
+/*
+ * Adaptec AIC79xx device driver for Linux.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#61 $
+ *
+ */
+#ifndef _AIC79XX_LINUX_H_
+#define _AIC79XX_LINUX_H_
+
+#include <linux/types.h>
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/version.h>
+#ifndef AHD_MODVERSION_FILE
+#define __NO_VERSION__
+#endif
+#include <linux/module.h>
+#include <asm/byteorder.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/interrupt.h> /* For tasklet support. */
+#include <linux/config.h>
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+
+/* Core SCSI definitions */
+#include "../scsi.h"
+#include "../hosts.h"
+
+/* Name space conflict with BSD queue macros */
+#ifdef LIST_HEAD
+#undef LIST_HEAD
+#endif
+
+#include "cam.h"
+#include "queue.h"
+#include "scsi_message.h"
+#include "scsi_iu.h"
+
+/*********************************** Debugging ********************************/
+#ifdef CONFIG_AIC79XX_DEBUG_ENABLE
+#ifdef CONFIG_AIC79XX_DEBUG_MASK
+#define AHD_DEBUG 1
+#define AHD_DEBUG_OPTS CONFIG_AIC79XX_DEBUG_MASK
+#else
+/*
+ * Compile in debugging code, but do not enable any printfs.
+ */
+#define AHD_DEBUG 1
+#endif
+#endif
+
+/********************************** Misc Macros *******************************/
+#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
+#define	powerof2(x)	((((x)-1)&(x))==0)
+
+/************************* Forward Declarations *******************************/
+struct ahd_softc;
+typedef struct pci_dev *ahd_dev_softc_t;
+typedef Scsi_Cmnd      *ahd_io_ctx_t;
+
+/******************************* Byte Order ***********************************/
+#define ahd_htobe16(x)	cpu_to_be16(x)
+#define ahd_htobe32(x)	cpu_to_be32(x)
+#define ahd_htobe64(x)	cpu_to_be64(x)
+#define ahd_htole16(x)	cpu_to_le16(x)
+#define ahd_htole32(x)	cpu_to_le32(x)
+#define ahd_htole64(x)	cpu_to_le64(x)
+
+#define ahd_be16toh(x)	be16_to_cpu(x)
+#define ahd_be32toh(x)	be32_to_cpu(x)
+#define ahd_be64toh(x)	be64_to_cpu(x)
+#define ahd_le16toh(x)	le16_to_cpu(x)
+#define ahd_le32toh(x)	le32_to_cpu(x)
+#define ahd_le64toh(x)	le64_to_cpu(x)
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__BIG_ENDIAN)
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#if defined(__LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#endif /* BYTE_ORDER */
+
+/************************* Configuration Data *********************************/
+extern int aic79xx_detect_complete;
+extern Scsi_Host_Template* aic79xx_driver_template;
+
+/***************************** Bus Space/DMA **********************************/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
+typedef dma_addr_t bus_addr_t;
+#else
+typedef uint32_t bus_addr_t;
+#endif
+typedef uint32_t bus_size_t;
+
+typedef enum {
+	BUS_SPACE_MEMIO,
+	BUS_SPACE_PIO
+} bus_space_tag_t;
+
+typedef union {
+	u_long		  ioport;
+	volatile uint8_t *maddr;
+} bus_space_handle_t;
+
+typedef struct bus_dma_segment
+{
+	bus_addr_t	ds_addr;
+	bus_size_t	ds_len;
+} bus_dma_segment_t;
+
+struct ahd_linux_dma_tag
+{
+	bus_size_t	alignment;
+	bus_size_t	boundary;
+	bus_size_t	maxsize;
+};
+typedef struct ahd_linux_dma_tag* bus_dma_tag_t;
+
+struct ahd_linux_dmamap
+{
+	bus_addr_t	bus_addr;
+};
+typedef struct ahd_linux_dmamap* bus_dmamap_t;
+
+typedef int bus_dma_filter_t(void*, bus_addr_t);
+typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
+
+#define BUS_DMA_WAITOK		0x0
+#define BUS_DMA_NOWAIT		0x1
+#define BUS_DMA_ALLOCNOW	0x2
+#define BUS_DMA_LOAD_SEGS	0x4	/*
+					 * Argument is an S/G list not
+					 * a single buffer.
+					 */
+
+#define BUS_SPACE_MAXADDR	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
+
+int	ahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t /*parent*/,
+			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
+			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
+			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
+			   bus_size_t /*maxsize*/, int /*nsegments*/,
+			   bus_size_t /*maxsegsz*/, int /*flags*/,
+			   bus_dma_tag_t */*dma_tagp*/);
+
+void	ahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/);
+
+int	ahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			 void** /*vaddr*/, int /*flags*/,
+			 bus_dmamap_t* /*mapp*/);
+
+void	ahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			void* /*vaddr*/, bus_dmamap_t /*map*/);
+
+void	ahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/,
+			   bus_dmamap_t /*map*/);
+
+int	ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t /*dmat*/,
+			bus_dmamap_t /*map*/, void * /*buf*/,
+			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
+			void */*callback_arg*/, int /*flags*/);
+
+int	ahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);
+
+/*
+ * Operations performed by ahd_dmamap_sync().
+ */
+#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
+#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
+#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
+#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
+
+/*
+ * XXX
+ * ahd_dmamap_sync is only used on buffers allocated with
+ * the pci_alloc_consistent() API.  Although I'm not sure how
+ * this works on architectures with a write buffer, Linux does
+ * not have an API to sync "coherent" memory.  Perhaps we need
+ * to do an mb()?
+ */
+#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)
+
+/************************** SCSI Constants/Structures *************************/
+#define SCSI_REV_2 2
+#define	SCSI_STATUS_OK			0x00
+#define	SCSI_STATUS_CHECK_COND		0x02
+#define	SCSI_STATUS_COND_MET		0x04
+#define	SCSI_STATUS_BUSY		0x08
+#define SCSI_STATUS_INTERMED		0x10
+#define SCSI_STATUS_INTERMED_COND_MET	0x14
+#define SCSI_STATUS_RESERV_CONFLICT	0x18
+#define SCSI_STATUS_CMD_TERMINATED	0x22
+#define SCSI_STATUS_QUEUE_FULL		0x28
+
+/*
+ * 6 byte request sense CDB format.
+ */
+struct scsi_sense
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_sense_data
+{
+	uint8_t	error_code;
+#define	SSD_ERRCODE			0x7F
+#define		SSD_CURRENT_ERROR	0x70
+#define		SSD_DEFERRED_ERROR	0x71
+#define	SSD_ERRCODE_VALID		0x80
+	uint8_t	segment;
+	uint8_t	flags;
+#define	SSD_KEY				0x0F
+#define		SSD_KEY_NO_SENSE	0x00
+#define		SSD_KEY_RECOVERED_ERROR	0x01
+#define		SSD_KEY_NOT_READY	0x02
+#define		SSD_KEY_MEDIUM_ERROR	0x03
+#define		SSD_KEY_HARDWARE_ERROR	0x04
+#define		SSD_KEY_ILLEGAL_REQUEST	0x05
+#define		SSD_KEY_UNIT_ATTENTION	0x06
+#define		SSD_KEY_DATA_PROTECT	0x07
+#define		SSD_KEY_BLANK_CHECK	0x08
+#define		SSD_KEY_Vendor_Specific	0x09
+#define		SSD_KEY_COPY_ABORTED	0x0a
+#define		SSD_KEY_ABORTED_COMMAND	0x0b
+#define		SSD_KEY_EQUAL		0x0c
+#define		SSD_KEY_VOLUME_OVERFLOW	0x0d
+#define		SSD_KEY_MISCOMPARE	0x0e
+#define		SSD_KEY_RESERVED	0x0f
+#define	SSD_ILI		0x20
+#define	SSD_EOM		0x40
+#define	SSD_FILEMARK	0x80
+	uint8_t	info[4];
+	uint8_t	extra_len;
+	uint8_t	cmd_spec_info[4];
+	uint8_t add_sense_code;
+	uint8_t add_sense_code_qual;
+	uint8_t	fru;
+	uint8_t	sense_key_spec[3];
+#define	SSD_SCS_VALID		0x80
+#define	SSD_FIELDPTR_CMD	0x40
+#define	SSD_BITPTR_VALID	0x08
+#define	SSD_BITPTR_VALUE	0x07
+#define	SSD_MIN_SIZE	18
+	uint8_t	extra_bytes[14];
+};
+
+struct scsi_inquiry
+{ 
+	u_int8_t opcode;
+	u_int8_t byte2;
+#define	SI_EVPD 0x01
+	u_int8_t page_code;
+	u_int8_t reserved;
+	u_int8_t length;
+	u_int8_t control;
+};
+
+struct scsi_inquiry_data
+{
+	uint8_t device;
+#define	SID_TYPE(inq_data) ((inq_data)->device & 0x1f)
+#define	SID_QUAL(inq_data) (((inq_data)->device & 0xE0) >> 5)
+#define	SID_QUAL_LU_CONNECTED	0x00	/*
+					 * The specified peripheral device
+					 * type is currently connected to
+					 * logical unit.  If the target cannot
+					 * determine whether or not a physical
+					 * device is currently connected, it
+					 * shall also use this peripheral
+					 * qualifier when returning the INQUIRY
+					 * data.  This peripheral qualifier
+					 * does not mean that the device is
+					 * ready for access by the initiator.
+					 */
+#define	SID_QUAL_LU_OFFLINE	0x01	/*
+					 * The target is capable of supporting
+					 * the specified peripheral device type
+					 * on this logical unit; however, the
+					 * physical device is not currently
+					 * connected to this logical unit.
+					 */
+#define SID_QUAL_RSVD		0x02
+#define	SID_QUAL_BAD_LU		0x03	/*
+					 * The target is not capable of
+					 * supporting a physical device on
+					 * this logical unit. For this
+					 * peripheral qualifier the peripheral
+					 * device type shall be set to 1Fh to
+					 * provide compatibility with previous
+					 * versions of SCSI. All other
+					 * peripheral device type values are
+					 * reserved for this peripheral
+					 * qualifier.
+					 */
+#define	SID_QUAL_IS_VENDOR_UNIQUE(inq_data) ((SID_QUAL(inq_data) & 0x08) != 0)
+	uint8_t dev_qual2;
+#define	SID_QUAL2	0x7F
+#define	SID_IS_REMOVABLE(inq_data) (((inq_data)->dev_qual2 & 0x80) != 0)
+	uint8_t version;
+#define SID_ANSI_REV(inq_data) ((inq_data)->version & 0x07)
+#define		SCSI_REV_0		0
+#define		SCSI_REV_CCS		1
+#define		SCSI_REV_2		2
+#define		SCSI_REV_SPC		3
+#define		SCSI_REV_SPC2		4
+
+#define SID_ECMA	0x38
+#define SID_ISO		0xC0
+	uint8_t response_format;
+#define SID_AENC	0x80
+#define SID_TrmIOP	0x40
+	uint8_t additional_length;
+	uint8_t reserved[2];
+	uint8_t flags;
+#define	SID_SftRe	0x01
+#define	SID_CmdQue	0x02
+#define	SID_Linked	0x08
+#define	SID_Sync	0x10
+#define	SID_WBus16	0x20
+#define	SID_WBus32	0x40
+#define	SID_RelAdr	0x80
+#define SID_VENDOR_SIZE   8
+	char	 vendor[SID_VENDOR_SIZE];
+#define SID_PRODUCT_SIZE  16
+	char	 product[SID_PRODUCT_SIZE];
+#define SID_REVISION_SIZE 4
+	char	 revision[SID_REVISION_SIZE];
+	/*
+	 * The following fields were taken from SCSI Primary Commands - 2
+	 * (SPC-2) Revision 14, Dated 11 November 1999
+	 */
+#define	SID_VENDOR_SPECIFIC_0_SIZE	20
+	u_int8_t vendor_specific0[SID_VENDOR_SPECIFIC_0_SIZE];
+	/*
+	 * An extension of SCSI Parallel Specific Values
+	 */
+#define	SID_SPI_IUS		0x01
+#define	SID_SPI_QAS		0x02
+#define	SID_SPI_CLOCK_ST	0x00
+#define	SID_SPI_CLOCK_DT	0x04
+#define	SID_SPI_CLOCK_DT_ST	0x0C
+#define	SID_SPI_MASK		0x0F
+	uint8_t spi3data;
+	uint8_t reserved2;
+	/*
+	 * Version Descriptors, stored 2 byte values.
+	 */
+	uint8_t version1[2];
+	uint8_t version2[2];
+	uint8_t version3[2];
+	uint8_t version4[2];
+	uint8_t version5[2];
+	uint8_t version6[2];
+	uint8_t version7[2];
+	uint8_t version8[2];
+
+	uint8_t reserved3[22];
+
+#define	SID_VENDOR_SPECIFIC_1_SIZE	160
+	uint8_t vendor_specific1[SID_VENDOR_SPECIFIC_1_SIZE];
+};
+
+static __inline uint32_t scsi_4btoul(uint8_t *bytes);
+static __inline uint32_t
+scsi_4btoul(uint8_t *bytes)
+{
+	return ((bytes[0] << 24)|(bytes[1] << 16)|(bytes[2] << 8)|bytes[3]);
+}
+/************************** Timer DataStructures ******************************/
+typedef struct timer_list ahd_timer_t;
+
+/********************************** Includes **********************************/
+/* Host template and function declarations referenced by the template. */
+#include "aic79xx_host.h"
+
+/* Core driver definitions */
+#define AIC_DEBUG_REGISTERS 1
+#include "aic79xx.h"
+
+/***************************** Timer Facilities *******************************/
+#define ahd_timer_init init_timer
+#define ahd_timer_stop del_timer
+typedef void ahd_linux_callback_t (u_long);  
+static __inline void
+ahd_timer_reset(ahd_timer_t *timer, int usec, ahd_callback_t *func, void *arg)
+{
+	struct ahd_softc *ahd;
+
+	ahd = (struct ahd_softc *)arg;
+	del_timer(timer);
+	timer->data = (u_long)arg;
+	timer->expires = jiffies + (usec * HZ)/1000000;
+	timer->function = (ahd_linux_callback_t*)func;
+	add_timer(timer);
+}
+
+/***************************** SMP support ************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
+#include <linux/spinlock.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
+#include <linux/smp.h>
+#endif
+
+#define AIC79XX_DRIVER_VERSION "1.1.0"
+
+/**************************** Front End Queues ********************************/
+/*
+ * Data structure used to cast the Linux struct scsi_cmnd to something
+ * that allows us to use the queue macros.  The linux structure has
+ * plenty of space to hold the links fields as required by the queue
+ * macros, but the queue macors require them to have the correct type.
+ */
+struct ahd_cmd_internal {
+	/* Area owned by the Linux scsi layer. */
+	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
+	union {
+		STAILQ_ENTRY(ahd_cmd)	ste;
+		LIST_ENTRY(ahd_cmd)	le;
+		TAILQ_ENTRY(ahd_cmd)	tqe;
+	} links;
+	uint32_t			end;
+};
+
+struct ahd_cmd {
+	union {
+		struct ahd_cmd_internal	icmd;
+		struct scsi_cmnd	scsi_cmd;
+	} un;
+};
+
+#define acmd_icmd(cmd) ((cmd)->un.icmd)
+#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
+#define acmd_links un.icmd.links
+
+/*************************** Device Data Structures ***************************/
+/*
+ * A per probed device structure used to deal with some error recovery
+ * scenarios that the Linux mid-layer code just doesn't know how to
+ * handle.  The structure allocated for a device only becomes persistant
+ * after a successfully completed inquiry command to the target when
+ * that inquiry data indicates a lun is present.
+ */
+TAILQ_HEAD(ahd_busyq, ahd_cmd);
+typedef enum {
+	AHD_DEV_UNCONFIGURED	 = 0x01,
+	AHD_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
+	AHD_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
+	AHD_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
+	AHD_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
+	AHD_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
+	AHD_DEV_PERIODIC_OTAG	 = 0x40	 /* Send OTAG to prevent starvation */
+} ahd_dev_flags;
+
+struct ahd_linux_target;
+struct ahd_linux_device {
+	TAILQ_ENTRY(ahd_linux_device) links;
+	struct			ahd_busyq busyq;
+
+	/*
+	 * The number of transactions currently
+	 * queued to the device.
+	 */
+	int			active;
+
+	/*
+	 * The currently allowed number of 
+	 * transactions that can be queued to
+	 * the device.  Must be signed for
+	 * conversion from tagged to untagged
+	 * mode where the device may have more
+	 * than one outstanding active transaction.
+	 */
+	int			openings;
+
+	/*
+	 * A positive count indicates that this
+	 * device's queue is halted.
+	 */
+	u_int			qfrozen;
+	
+	/*
+	 * Cumulative command counter.
+	 */
+	u_long			commands_issued;
+
+	/*
+	 * The number of tagged transactions when
+	 * running at our current opening level
+	 * that have been successfully received by
+	 * this device since the last QUEUE FULL.
+	 */
+	u_int			tag_success_count;
+#define AHD_TAG_SUCCESS_INTERVAL 50
+
+	ahd_dev_flags		flags;
+
+	/*
+	 * Per device timer.
+	 */
+	struct timer_list	timer;
+
+	/*
+	 * The high limit for the tags variable.
+	 */
+	u_int			maxtags;
+
+	/*
+	 * The computed number of tags outstanding
+	 * at the time of the last QUEUE FULL event.
+	 */
+	u_int			tags_on_last_queuefull;
+
+	/*
+	 * How many times we have seen a queue full
+	 * with the same number of tags.  This is used
+	 * to stop our adaptive queue depth algorithm
+	 * on devices with a fixed number of tags.
+	 */
+	u_int			last_queuefull_same_count;
+#define AHD_LOCK_TAGS_COUNT 50
+
+	/*
+	 * How many transactions have been queued
+	 * without the device going idle.  We use
+	 * this statistic to determine when to issue
+	 * an ordered tag to prevent transaction
+	 * starvation.  This statistic is only updated
+	 * if the AHD_DEV_PERIODIC_OTAG flag is set
+	 * on this device.
+	 */
+	u_int			commands_since_idle_or_otag;
+#define AHD_OTAG_THRESH	500
+
+	int			lun;
+	struct			ahd_linux_target *target;
+};
+
+struct ahd_linux_target {
+	struct	ahd_linux_device *devices[AHD_NUM_LUNS];
+	int	channel;
+	int	target;
+	int	refcount;
+	struct	ahd_transinfo last_tinfo;
+	struct	ahd_softc *ahd;
+};
+
+/********************* Definitions Required by the Core ***********************/
+/*
+ * Number of SG segments we require.  So long as the S/G segments for
+ * a particular transaction are allocated in a physically contiguous
+ * manner and are allocated below 4GB, the number of S/G segments is
+ * unrestricted.
+ */
+#define        AHD_NSEG 128
+
+/*
+ * Per-SCB OSM storage.
+ */
+struct scb_platform_data {
+	struct ahd_linux_device	*dev;
+	bus_addr_t		 buf_busaddr;
+	uint32_t		 xfer_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+	uint32_t		 resid;		/* Transfer residual */
+#endif
+};
+
+/*
+ * Define a structure used for each host adapter.  All members are
+ * aligned on a boundary >= the size of the member to honor the
+ * alignment restrictions of the various platforms supported by
+ * this driver.
+ */
+TAILQ_HEAD(ahd_completeq, ahd_cmd);
+struct ahd_platform_data {
+	/*
+	 * Fields accessed from interrupt context.
+	 */
+	struct ahd_linux_target *targets[AHD_NUM_TARGETS]; 
+	TAILQ_HEAD(, ahd_linux_device) device_runq;
+	struct ahd_completeq	 completeq;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
+	spinlock_t		 spin_lock;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	struct tasklet_struct	 runq_tasklet;
+#endif
+	u_int			 qfrozen;
+	struct timer_list	 reset_timer;
+	struct semaphore	 eh_sem;
+	struct Scsi_Host        *host;		/* pointer to scsi host */
+#define AHD_LINUX_NOIRQ	((uint32_t)~0)
+	uint32_t		 irq;		/* IRQ for this adapter */
+	uint32_t		 bios_address;
+	uint32_t		 mem_busaddr;	/* Mem Base Addr */
+	bus_addr_t		 hw_dma_mask;
+};
+
+/************************** OS Utility Wrappers *******************************/
+#define printf printk
+#define M_NOWAIT GFP_ATOMIC
+#define M_WAITOK 0
+#define malloc(size, type, flags) kmalloc(size, flags)
+#define free(ptr, type) kfree(ptr)
+
+static __inline void ahd_delay(long);
+static __inline void
+ahd_delay(long usec)
+{
+	/*
+	 * udelay on Linux can have problems for
+	 * multi-millisecond waits.  Wait at most
+	 * 1024us per call.
+	 */
+	while (usec > 0) {
+		udelay(usec % 1024);
+		usec -= 1024;
+	}
+}
+
+
+/***************************** Low Level I/O **********************************/
+#if defined(__powerpc__) || defined(__i386__) || defined(__ia64__)
+#define MMAPIO
+#endif
+
+static __inline uint8_t ahd_inb(struct ahd_softc * ahd, long port);
+static __inline uint16_t ahd_inw_atomic(struct ahd_softc * ahd, long port);
+static __inline void ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);
+static __inline void ahd_outw_atomic(struct ahd_softc * ahd,
+				     long port, uint16_t val);
+static __inline void ahd_outsb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+static __inline void ahd_insb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+
+static __inline uint8_t
+ahd_inb(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readb(ahd->bshs[0].maddr + port);
+	} else {
+		x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline uint16_t
+ahd_inw_atomic(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readw(ahd->bshs[0].maddr + port);
+	} else {
+		x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline void
+ahd_outb(struct ahd_softc * ahd, long port, uint8_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writeb(val, ahd->bshs[0].maddr + port);
+	} else {
+		outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writew(val, ahd->bshs[0].maddr + port);
+	} else {
+		outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		ahd_outb(ahd, port, *array++);
+}
+
+static __inline void
+ahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		*array++ = ahd_inb(ahd, port);
+}
+
+/**************************** Initialization **********************************/
+int		ahd_linux_register_host(struct ahd_softc *,
+					Scsi_Host_Template *);
+
+uint64_t	ahd_linux_get_memsize(void);
+
+/*************************** Pretty Printing **********************************/
+struct info_str {
+	char *buffer;
+	int length;
+	off_t offset;
+	int pos;
+};
+
+void	ahd_format_transinfo(struct info_str *info,
+			     struct ahd_transinfo *tinfo);
+
+/******************************** Locking *************************************/
+/* Lock protecting internal data structures */
+static __inline void ahd_lockinit(struct ahd_softc *);
+static __inline void ahd_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock held during command compeletion to the upper layer */
+static __inline void ahd_done_lockinit(struct ahd_softc *);
+static __inline void ahd_done_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_done_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock held during ahd_list manipulation and ahd softc frees */
+extern spinlock_t ahd_list_spinlock;
+static __inline void ahd_list_lockinit(void);
+static __inline void ahd_list_lock(unsigned long *flags);
+static __inline void ahd_list_unlock(unsigned long *flags);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
+static __inline void
+ahd_lockinit(struct ahd_softc *ahd)
+{
+	spin_lock_init(&ahd->platform_data->spin_lock);
+}
+
+static __inline void
+ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_done_lockinit(struct ahd_softc *ahd)
+{
+	/* We don't own the iorequest lock, so we don't initialize it. */
+}
+
+static __inline void
+ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&io_request_lock, *flags);
+}
+
+static __inline void
+ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&io_request_lock, *flags);
+}
+
+static __inline void
+ahd_list_lockinit()
+{
+	spin_lock_init(&ahd_list_spinlock);
+}
+
+static __inline void
+ahd_list_lock(unsigned long *flags)
+{
+	*flags = 0;
+	spin_lock_irqsave(&ahd_list_spinlock, *flags);
+}
+
+static __inline void
+ahd_list_unlock(unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd_list_spinlock, *flags);
+}
+
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
+
+ahd_lockinit(struct ahd_softc *ahd)
+{
+}
+
+static __inline void
+ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	*flags = 0;
+	save_flags(*flags);
+	cli();
+}
+
+static __inline void
+ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	restore_flags(*flags);
+}
+
+ahd_done_lockinit(struct ahd_softc *ahd)
+{
+}
+
+static __inline void
+ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	/*
+	 * The done lock is always held while
+	 * the ahd lock is held so blocking
+	 * interrupts again would have no effect.
+	 */
+}
+
+static __inline void
+ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+}
+
+static __inline void
+ahd_list_lockinit()
+{
+}
+
+static __inline void
+ahd_list_lock(unsigned long *flags)
+{
+	*flags = 0;
+	save_flags(*flags);
+	cli();
+}
+
+static __inline void
+ahd_list_unlock(unsigned long *flags)
+{
+	restore_flags(*flags);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
+
+/******************************* PCI Definitions ******************************/
+/*
+ * PCIM_xxx: mask to locate subfield in register
+ * PCIR_xxx: config register offset
+ * PCIC_xxx: device class
+ * PCIS_xxx: device subclass
+ * PCIP_xxx: device programming interface
+ * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
+ * PCID_xxx: device ID
+ */
+#define PCIR_DEVVENDOR		0x00
+#define PCIR_VENDOR		0x00
+#define PCIR_DEVICE		0x02
+#define PCIR_COMMAND		0x04
+#define PCIM_CMD_PORTEN		0x0001
+#define PCIM_CMD_MEMEN		0x0002
+#define PCIM_CMD_BUSMASTEREN	0x0004
+#define PCIM_CMD_MWRICEN	0x0010
+#define PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
+#define PCIR_STATUS		0x06
+#define PCIR_REVID		0x08
+#define PCIR_PROGIF		0x09
+#define PCIR_SUBCLASS		0x0a
+#define PCIR_CLASS		0x0b
+#define PCIR_CACHELNSZ		0x0c
+#define PCIR_LATTIMER		0x0d
+#define PCIR_HEADERTYPE		0x0e
+#define PCIM_MFDEV		0x80
+#define PCIR_BIST		0x0f
+#define PCIR_CAP_PTR		0x34
+
+/* config registers for header type 0 devices */
+#define PCIR_MAPS	0x10
+#define PCIR_SUBVEND_0	0x2c
+#define PCIR_SUBDEV_0	0x2e
+
+/****************************** PCI-X definitions *****************************/
+#define PCIXR_COMMAND	0x96
+#define PCIXR_DEVADDR	0x98
+#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
+#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
+#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
+#define PCIXR_STATUS	0x9A
+#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
+#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
+#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
+#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
+#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
+#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
+#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
+#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
+#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+extern struct pci_driver aic79xx_pci_driver;
+#endif
+
+typedef enum
+{
+	AHD_POWER_STATE_D0,
+	AHD_POWER_STATE_D1,
+	AHD_POWER_STATE_D2,
+	AHD_POWER_STATE_D3
+} ahd_power_state;
+
+void ahd_power_state_change(struct ahd_softc *ahd,
+			    ahd_power_state new_state);
+
+/******************************* PCI Routines *********************************/
+/*
+ * We need to use the bios32.h routines if we are kernel version 2.1.92 or less.
+ */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
+#if defined(__sparc_v9__) || defined(__powerpc__)
+#error "PPC and Sparc platforms are only support under 2.1.92 and above"
+#endif
+#include <linux/bios32.h>
+#endif
+
+int			 ahd_linux_pci_probe(Scsi_Host_Template *);
+int			 ahd_pci_map_registers(struct ahd_softc *ahd);
+int			 ahd_pci_map_int(struct ahd_softc *ahd);
+
+static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t pci,
+					     int reg, int width);
+
+static __inline uint32_t
+ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
+{
+	switch (width) {
+	case 1:
+	{
+		uint8_t retval;
+
+		pci_read_config_byte(pci, reg, &retval);
+		return (retval);
+	}
+	case 2:
+	{
+		uint16_t retval;
+		pci_read_config_word(pci, reg, &retval);
+		return (retval);
+	}
+	case 4:
+	{
+		uint32_t retval;
+		pci_read_config_dword(pci, reg, &retval);
+		return (retval);
+	}
+	default:
+		panic("ahd_pci_read_config: Read size too big");
+		/* NOTREACHED */
+		return (0);
+	}
+}
+
+static __inline void ahd_pci_write_config(ahd_dev_softc_t pci,
+					  int reg, uint32_t value,
+					  int width);
+
+static __inline void
+ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
+{
+	switch (width) {
+	case 1:
+		pci_write_config_byte(pci, reg, value);
+		break;
+	case 2:
+		pci_write_config_word(pci, reg, value);
+		break;
+	case 4:
+		pci_write_config_dword(pci, reg, value);
+		break;
+	default:
+		panic("ahd_pci_write_config: Write size too big");
+		/* NOTREACHED */
+	}
+}
+
+static __inline int ahd_get_pci_function(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_function(ahd_dev_softc_t pci)
+{
+	return (PCI_FUNC(pci->devfn));
+}
+
+static __inline int ahd_get_pci_slot(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_slot(ahd_dev_softc_t pci)
+{
+	return (PCI_SLOT(pci->devfn));
+}
+
+static __inline int ahd_get_pci_bus(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_bus(ahd_dev_softc_t pci)
+{
+	return (pci->bus->number);
+}
+
+static __inline void ahd_flush_device_writes(struct ahd_softc *);
+static __inline void
+ahd_flush_device_writes(struct ahd_softc *ahd)
+{
+	/* XXX Is this sufficient for all architectures??? */
+	ahd_inb(ahd, INTSTAT);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
+#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
+#define pci_unmap_sg(pdev, sg_list, nseg, direction)
+#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
+#define sg_dma_len(sg) ((sg)->length)
+#define pci_map_single(pdev, buffer, bufflen, direction) \
+	(VIRT_TO_BUS(buffer))
+#define pci_unmap_single(pdev, buffer, buflen, direction)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+#define ahd_pci_set_dma_mask pci_set_dma_mask
+#else
+/*
+ * Always "return" 0 for success.
+ */
+#define ahd_pci_set_dma_mask(dev_softc, mask)	\
+	(((dev_softc)->dma_mask = mask) && 0)
+#endif
+/*********************** Transaction Access Wrappers **************************/
+static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
+static __inline
+void ahd_set_transaction_status(struct scb *scb, uint32_t status)
+{
+	scb->io_ctx->result &= ~(CAM_STATUS_MASK << 16);
+	scb->io_ctx->result |= status << 16;
+}
+
+static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
+static __inline
+void ahd_set_scsi_status(struct scb *scb, uint32_t status)
+{
+	scb->io_ctx->result &= ~0xFFFF;
+	scb->io_ctx->result |= status;
+}
+
+static __inline uint32_t ahd_get_transaction_status(struct scb *);
+static __inline
+uint32_t ahd_get_transaction_status(struct scb *scb)
+{
+	return ((scb->io_ctx->result >> 16) & CAM_STATUS_MASK);
+}
+
+static __inline uint32_t ahd_get_scsi_status(struct scb *);
+static __inline
+uint32_t ahd_get_scsi_status(struct scb *scb)
+{
+	return (scb->io_ctx->result & 0xFFFF);
+}
+
+static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
+static __inline
+void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
+{
+	/*
+	 * Nothing to do for linux as the incoming transaction
+	 * has no concept of tag/non tagged, etc.
+	 */
+}
+
+static __inline u_long ahd_get_transfer_length(struct scb *);
+static __inline
+u_long ahd_get_transfer_length(struct scb *scb)
+{
+	return (scb->platform_data->xfer_len);
+}
+
+static __inline int ahd_get_transfer_dir(struct scb *);
+static __inline
+int ahd_get_transfer_dir(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
+	return (scb->io_ctx->sc_data_direction);
+#else
+	if (scb->io_ctx->bufflen == 0)
+		return (CAM_DIR_NONE);
+
+	switch(scb->io_ctx->cmnd[0]) {
+	case 0x08:  /* READ(6)  */
+	case 0x28:  /* READ(10) */
+	case 0xA8:  /* READ(12) */
+		return (CAM_DIR_IN);
+        case 0x0A:  /* WRITE(6)  */
+        case 0x2A:  /* WRITE(10) */
+        case 0xAA:  /* WRITE(12) */
+		return (CAM_DIR_OUT);
+        default:
+		return (CAM_DIR_NONE);
+        }
+#endif
+}
+
+static __inline void ahd_set_residual(struct scb *, u_long);
+static __inline
+void ahd_set_residual(struct scb *scb, u_long resid)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	scb->io_ctx->resid = resid;
+#else
+	scb->platform_data->resid = resid;
+#endif
+}
+
+static __inline void ahd_set_sense_residual(struct scb *, u_long);
+static __inline
+void ahd_set_sense_residual(struct scb *scb, u_long resid)
+{
+	/* This can't be reported in Linux */
+}
+
+static __inline u_long ahd_get_residual(struct scb *);
+static __inline
+u_long ahd_get_residual(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	return (scb->io_ctx->resid);
+#else
+	return (scb->platform_data->resid);
+#endif
+}
+
+static __inline int ahd_perform_autosense(struct scb *);
+static __inline
+int ahd_perform_autosense(struct scb *scb)
+{
+	/*
+	 * We always perform autosense in Linux.
+	 * On other platforms this is set on a
+	 * per-transaction basis.
+	 */
+	return (1);
+}
+
+static __inline uint32_t
+ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (sizeof(struct scsi_sense_data));
+}
+
+static __inline void ahd_notify_xfer_settings_change(struct ahd_softc *,
+						     struct ahd_devinfo *);
+static __inline void
+ahd_notify_xfer_settings_change(struct ahd_softc *ahd,
+				struct ahd_devinfo *devinfo)
+{
+	/* Nothing to do here for linux */
+}
+
+static __inline void ahd_platform_scb_free(struct ahd_softc *ahd,
+					   struct scb *scb);
+static __inline void
+ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
+}
+
+int	ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);
+void	ahd_platform_free(struct ahd_softc *ahd);
+void	ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
+void	ahd_freeze_simq(struct ahd_softc *ahd);
+void	ahd_release_simq(struct ahd_softc *ahd);
+static __inline void	ahd_freeze_scb(struct scb *scb);
+static __inline void
+ahd_freeze_scb(struct scb *scb)
+{
+	/* Noting to do here for linux */
+}
+
+void	ahd_platform_set_tags(struct ahd_softc *ahd,
+			      struct ahd_devinfo *devinfo, ahd_queue_alg);
+int	ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
+				char channel, int lun, u_int tag,
+				role_t role, uint32_t status);
+void	ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
+void	ahd_platform_flushwork(struct ahd_softc *ahd);
+int	ahd_softc_comp(struct ahd_softc *, struct ahd_softc *);
+void	ahd_done(struct ahd_softc*, struct scb*);
+void	ahd_send_async(struct ahd_softc *, char channel,
+		       u_int target, u_int lun, ac_code, void *);
+void	ahd_print_path(struct ahd_softc *, struct scb *);
+void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
+
+#ifdef CONFIG_PCI
+#define AHD_PCI_CONFIG 1
+#else
+#define AHD_PCI_CONFIG 0
+#endif
+#define bootverbose aic79xx_verbose
+extern int aic79xx_verbose;
+#endif /* _AIC79XX_LINUX_H_ */
