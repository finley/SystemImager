diff -urN linux/Documentation/Configure.help linux-2.4.7/Documentation/Configure.help
--- linux/Documentation/Configure.help	Thu Jul 19 20:48:15 2001
+++ linux-2.4.7/Documentation/Configure.help	Mon Dec 17 13:41:18 2001
@@ -9918,6 +9918,46 @@
   then also Y to the driver for your FDDI card, below). Most people
   will say N.
 
+Channel Device Configuration
+CONFIG_CHANDEV
+  The  channel  device layer is a layer to provide a consistent 
+  interface for configuration & default  machine  check
+  ( devices  appearing  &  disappearing  ) handling on Linux for
+  s/390 & z/Series channel devices.
+  
+  s/390 & z/Series channel devices include among others
+
+  lcs ( the most common ethernet/token ring/fddi standard on zSeries )
+  ctc/escon  hi  speed  like serial link standard on s/390 & z/Series.
+  claw used to talk to cisco routers.
+  qeth gigabit ethernet.
+
+  These devices use two channels one read &  one  write  for
+  configuration  & communication ( & a third channel, the data channel in
+  the case of gigabit ethernet  ).   The  motivation  behind
+  developing  this  layer was that there was a lot of duplicate
+  code among the channel device drivers for  configuration.
+
+  Also  the  lcs  & ctc drivers tended to fight over
+  3088/08's & 3088/1F's  which  could  be  either  2216/3172
+  channel attached lcs compatible devices or escon/ctc pipes
+  between guests & to resolve this fight both device drivers
+  had  to  be configured separately as they couldn't autodetect,
+  this is now simplified by doing the configuration in a single 
+  place ( the channel device layer ).
+
+  This layer isn't invasive & it is quite okay to use channel drivers
+  which don't use the channel device layer in conjunction with
+  drivers which do.
+
+  For more info see the chandev manpage usually distributed in
+  /Documentation/s390/chandev.8 in the linux source tree.
+
+  If you don't own a s/390 or z/Series mainframe & are not
+  trying to use drivers which depend on this option you don't
+  need it.
+
+
 Digital DEFEA and DEFPA adapter support
 CONFIG_DEFXX
   This is support for the DIGITAL series of EISA (DEFEA) and PCI
@@ -17493,6 +17533,172 @@
   module called pms.o ( = code which can be inserted in and removed
   from the running kernel whenever you want). If you want to compile
   it as a module, say M here and read Documentation/modules.txt.
+
+IBM's S/390 architecture
+CONFIG_ARCH_S390
+  Select this option, if you want to run the Kernel on one of IBM's
+  mainframes of the S/390 generation. You should have installed the
+  s390-compiler released by IBM (based on gcc-2.95.1) before.
+
+Merge some code into the kernel to make the image IPLable
+CONFIG_IPLABLE
+  If you want to use the produced kernel to IPL directly from a
+  device, you have to merge a bootsector specific to the device
+  into the first bytes of the kernel. You will have to select the
+  IPL device on another question, that pops up, when you select
+  CONFIG_IPLABE.
+
+IPL from a /390 tape unit
+CONFIG_IPL_TAPE
+  Select this option if you want to IPL the image from a Tape.
+
+IPL from a virtual card reader emulated by VM/ESA
+CONFIG_IPL_RDR_VM
+  Select this option if you are running under VM/ESA and want 
+  to IPL the image from the emulated card reader.
+
+IPL from a real card reader
+CONFIG_IPL_RDR
+  Select this option if you want to IPL the image from a real
+  card reader. Maybe you still got one and want to try. We didn't
+  test.
+
+IBMs S/390 Harddisks (DASDs)
+CONFIG_DASD
+  Enable this option if you want to access DASDs directly utilizing
+  S/390s channel subsystem commands. This is necessary for running
+  natively on a single image or an LPAR.
+
+Enable DASD fast write
+CONFIG_DASD_FAST_IO
+  Enable fast I/O for DASDs. That means that the next I/O command
+  is already issued at interrupt time, if an I/O request is pending.
+  This option gives significant speedup of I/O, because we don't
+  schedule the bottom-halves as often as Intel.
+
+Support for IBM-style disk-labels (S/390)
+CONFIG_S390_PARTITION
+  Enable this option to assure standard IBM labels on the DASDs.
+  You must enable it, if you are planning to access DASDs also
+  attached to another IBM mainframe operation system (OS/390, 
+  VM/ESA, VSE/ESA).
+
+ECKD devices
+CONFIG_DASD_ECKD
+  ECKD devices are the most commonly used devices. you should enable
+  this option unless you are very sure to have no ECKD device.
+
+CKD devices
+CONFIG_DASD_CKD
+  CKD devices are currently unsupported.
+
+FBA devices
+CONFIG_DASD_FBA
+  FBA devices are currently unsupported.
+
+CTC device support
+CONFIG_CTC
+ 
+  Select this option if you want to use channel-to-channel
+  networking on IBM S/390 or zSeries. This device driver supports
+  real CTC coupling using ESCON. It also supports virtual CTCs
+  when running under VM. It will use the channel device
+  configuration if this is available.
+  This option is also available as a module which will be called
+  ctc.o.
+  If you do not know what it is, it's safe to say "Y".
+ 
+Support for DIAG access to CMS reserved Disks
+CONFIG_DASD_DIAG
+ 
+  Select this option if you want to use CMS reserved Disks under
+  VM with the Diagnose250 command.
+  If you are not running under VM or unsure what it is, say "N".
+ 
+XPRAM disk support
+CONFIG_BLK_DEV_XPRAM
+ 
+  Select this option if you want to use your expanded storage on
+  S/390 or zSeries as a disk.
+  This is useful as a _fast_ swap device if you want to access
+  more than 2G of memory when running in 31 bit mode.
+  This option is also available as a module which will be called
+  xpram.o.
+  If unsure, say "N".
+ 
+Fast IRQ handling
+CONFIG_FAST_IRQ
+ 
+  Select this option in order to get the interrupts processed
+  faster on your S/390 or zSeries machine.
+  If selected, after an interrupt is processed, the channel
+  subsystem will be asked for other pending interrupts which
+  will also be processed before leaving the interrupt context.
+  This speeds up the I/O a lot. Say "Y".
+
+IUCV device support (VM only)
+CONFIG_IUCV
+ 
+  Select this option if you want to use inter-user communication
+  vehicle networking under VM or VIF.
+  This option is also available as a module which will be called
+  iucv.o.
+  If unsure, say "Y".
+ 
+Kernel support for 31 bit ELF binaries
+CONFIG_S390_SUPPORT
+ 
+  Select this option if you want to enable your system kernel
+  to handle system-calls from ELF binaries for 31 bit ESA.
+  This option (and some other stuff like libraries and such)
+  is needed for executing 31 bit applications.
+  It is safe to say "Y".
+
+S/390 tape device support
+CONFIG_S390_TAPE
+ 
+  Select this option if you want to access channel-attached tape
+  devices on IBM S/390 or zSeries.
+  If you select this option you will also want to select at
+  least one of the tape interface options and one of the tape
+  hardware options in order to access a tape device.
+  This option is also available as a module. The module will be
+  called tape390.o and include all selected interfaces and
+  hardware drivers.
+ 
+Support for tape character devices
+CONFIG_S390_TAPE_CHAR
+ 
+  Select this option if you want to access your channel-attached
+  tape devices using the character device interface.
+  This interface is similar to other Linux tape devices like
+  SCSI-Tapes (st) and the floppy tape device (ftape).
+  If unsure, say "Y".
+ 
+Support for tape block devices
+CONFIG_S390_TAPE_BLOCK
+ 
+  Select this option if you want to access your channel-attached
+  tape devices using the block device interface.
+  This interface is similar to CD-ROM devices on other platforms.
+  The tapes can only be accessed read-only when using this inter-
+  face.
+  Have a look at Documentation/s390/TAPE for further information
+  about creating volumes for and using this interface.
+  It is safe to say "Y" here.
+ 
+Support for 3490 tape hardware
+CONFIG_S390_TAPE_3490
+ 
+  Select this option if you want to access IBM 3480 magnetic
+  tape subsystems and 100% compatibles.
+  It is safe to say "Y" here.
+
+Support for 3480 tape hardware
+CONFIG_S390_TAPE_3480
+ 
+  Select this option if you want to access IBM 3490 magnetic
+  tape subsystems and 100% compatibles.
 
 IBM's S/390 architecture
 CONFIG_ARCH_S390
diff -urN linux/Documentation/devices.txt linux-2.4.7/Documentation/devices.txt
--- linux/Documentation/devices.txt	Sat May 19 20:43:05 2001
+++ linux-2.4.7/Documentation/devices.txt	Mon Dec 17 13:41:18 2001
@@ -1610,34 +1610,35 @@
 		  1 = /dev/dcxx1	Second capture card
 		    ...
 
+    block	IBM S/390 DASD block storage
+		  0 = /dev/dasda	First DASD device, major
+		  1 = /dev/dasda1	First DASD device, block 1
+		  2 = /dev/dasda2	First DASD device, block 2
+		  3 = /dev/dasda3	First DASD device, block 3
+		  4 = /dev/dasdb	Second DASD device, major
+		  5 = /dev/dasdb1	Second DASD device, block 1
+		  6 = /dev/dasdb2	Second DASD device, block 2
+		  7 = /dev/dasdb3	Second DASD device, block 3
+		    ...
+
  95 char	IP filter
 		  0 = /dev/ipl		Filter control device/log file
 		  1 = /dev/ipnat	NAT control device/log file
 		  2 = /dev/ipstate	State information log file
 		  3 = /dev/ipauth	Authentication control device/log file
-
-    block	IBM S/390 DASD block storage
-		  0 = /dev/dasd0	First DASD device, major
-		  1 = /dev/dasd0a	First DASD device, block 1
-		  2 = /dev/dasd0b	First DASD device, block 2
-		  3 = /dev/dasd0c	First DASD device, block 3
-		  4 = /dev/dasd1	Second DASD device, major
-		  5 = /dev/dasd1a	Second DASD device, block 1
-		  6 = /dev/dasd1b	Second DASD device, block 2
-		  7 = /dev/dasd1c	Second DASD device, block 3
 		    ...		
 
+    block	IBM S/390 VM/ESA minidisk
+		  0 = /dev/mnda		First VM/ESA minidisk
+		  1 = /dev/mndb		Second VM/ESA minidisk
+		    ...
+
  96 char	Parallel port ATAPI tape devices
 		  0 = /dev/pt0		First parallel port ATAPI tape
 		  1 = /dev/pt1		Second parallel port ATAPI tape
 		    ...
 		128 = /dev/npt0		First p.p. ATAPI tape, no rewind
 		129 = /dev/npt1		Second p.p. ATAPI tape, no rewind
-		    ...
-
-    block	IBM S/390 VM/ESA minidisk
-		  0 = /dev/msd0		First VM/ESA minidisk
-		  1 = /dev/msd1		Second VM/ESA minidisk
 		    ...
 
  97 char	Parallel port generic ATAPI interface
diff -urN linux/Documentation/s390/3270.txt linux-2.4.7/Documentation/s390/3270.txt
--- linux/Documentation/s390/3270.txt	Thu May 24 18:14:08 2001
+++ linux-2.4.7/Documentation/s390/3270.txt	Mon Dec 17 13:41:48 2001
@@ -34,17 +34,6 @@
 dialed-in x3270.
 
 
-HELP !!!
-
-The device name of e.g. /dev/3270/tty620 noted below is at variance
-with "standard" Linux device names.  What should it be?  The portion
-"/dev/3270" was recommended by H. Peter Anvin, maintainer of the
-official Linux major-numbers list; the portion "tty620" was recommended
-by me.  Please send your thoughts on this issue at least to me at
-rbh00@utsglobal.com.  Even if you think it's okay as is, please let me
-know.  Thanks.
-
-
 INSTALLATION.
 
 You install the driver by installing a patch, doing a kernel build, and
@@ -60,9 +49,14 @@
 
 If you have chosen to make tub3270 a module, you add a line to
 /etc/modules.conf.  If you are working on a VM virtual machine, you
-can use DEF GRAF to define virtual 3270 devices.  If you generate 3270
-console support, the driver automatically converts your console at boot
-time to a 3270 if it is a 3215.
+can use DEF GRAF to define virtual 3270 devices.
+
+You may generate both 3270 and 3215 console support, or one or the
+other, or neither.  If you generate both, the console type under VM is
+not changed.  Use #CP Q TERM to see what the current console type is.
+Use #CP TERM CONMODE 3270 to change it to 3270.  If you generate only
+3270 console support, then the driver automatically converts your console
+at boot time to a 3270 if it is a 3215.
 
 In brief, these are the steps:
 	1. Install the tub3270 patch
@@ -78,21 +72,17 @@
 
 Here are the installation steps in detail:
 
-	0.  Retrieve the patch file via anonymous ftp from
-	ftp://ftp.utsglobal.com/pub/tub3270.  The patch is designed
-	to apply smoothly to an IBM 2.4.0 system with no other
-	UTS-Global patches applied.  We know of some easily resolvable
-	conflicts between this and other of our patches.
-
-	1. Apply the patch.  Then do
+	1.  The 3270 driver is a part of the official Linux kernel
+	source.  Build a tree with the kernel source and any necessary
+	patches.  Then do
 		make oldconfig
-			(Reply "y" or "m" for CONFIG_3270; if "y",
-			reply "y" or "n" for CONFIG_3270_CONSOLE)
+		(If you wish to disable 3215 console support, edit
+		.config; change CONFIG_TN3215's value to "n";
+		and rerun "make oldconfig".)
 		make dep
 		make image
 		make modules
 		make modules_install
-		<run silo in the usual way>
 
 	2. (Perform this step only if you have configured tub3270 as a
 	module.)  Add a line to /etc/modules.conf to automatically
@@ -122,12 +112,17 @@
 	config3270.sh.	Inspect the output script it produces,
 	/tmp/mkdev3270, and then run that script.  This will create the
 	necessary character special device files and make the necessary
-	changes to /etc/inittab.  Then notify /sbin/init that /etc/inittab
-	has changed, by issuing the telinit command with the q operand:
+	changes to /etc/inittab.  If you have selected DEVFS, the driver
+	itself creates the device files, and /tmp/mkdev3270 only changes
+	/etc/inittab.
+
+	Then notify /sbin/init that /etc/inittab has changed, by issuing
+	the telinit command with the q operand:
 		cd /usr/src/linux/Documentation/s390
 		sh config3270.sh
 		sh /tmp/mkdev3270
 		telinit q
+
 	This should be sufficient for your first time.	If your 3270
 	configuration has changed and you're reusing config3270, you
 	should follow these steps:
diff -urN linux/Documentation/s390/CommonIO linux-2.4.7/Documentation/s390/CommonIO
--- linux/Documentation/s390/CommonIO	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/Documentation/s390/CommonIO	Mon Dec 17 13:41:18 2001
@@ -0,0 +1,139 @@
+S/390 common I/O-Layer - command line parameters and /proc entries
+==================================================================
+
+Command line parameters
+-----------------------
+
+* cio_msg = yes | no
+  
+  Determines whether information on found devices and sensed device 
+  characteristics should be shown during startup, i. e. messages of the types 
+  "Detected device 4711 on subchannel 42" and "SenseID: Device 4711 reports: ...".
+
+  Default is off.
+
+
+* cio_notoper_msg = yes | no
+
+  Determines whether messages of the type "Device 4711 became 'not operational'"
+  should be shown during startup; after startup, they will always be shown.
+  
+  Default is on.
+
+
+* cio_ignore = <range of device numbers>, <range of device numbers>, ...
+
+  The given device numbers will be ignored by the common I/O-layer; no detection
+  and device sensing will be done on any of those devices. The subchannel to 
+  which the device in question is attached will be treated as if no device was
+  attached.
+
+  An ignored device can be un-ignored later; see the "/proc entries"-section for
+  details.
+
+  The device numbers must be given hexadecimal.
+
+  For example, 
+	cio_ignore=0x23-0x42,0x4711
+  will ignore all devices with device numbers ranging from 23 to 42 and the 
+  device with device number 4711, if detected.
+
+  By default, no devices are ignored.
+
+
+* cio_proc_devinfo = yes | no
+
+  Determines whether the entries under /proc/deviceinfo/ (see below) should be
+  created. Since there are problems with systems with many devices attached, I
+  made it configurable.
+
+  Until the problems are dealt with, default is off.
+
+
+/proc entries
+-------------
+
+* /proc/subchannels
+
+  Shows for each subchannel
+  - device number
+  - device type/model and if applicable control unit type/model
+  - whether the device is in use
+  - path installed mask, path available mask, path operational mask and last 
+    path used mask
+  - the channel path IDs (chpids)
+
+
+* /proc/deviceinfo/
+
+  Shows in subdirectories for each device some characteristics:
+  - /proc/deviceinfo/<devno>/chpids: 
+	the channel path IDs
+  - /proc/deviceinfo/<devno>/in_use: 
+	whether the device is in use
+  - /proc/deviceinfo/<devno>/sensedata:
+    	the device type/model and if applicable control unit type/model of the
+	device
+
+  NOTE: Since the number of inodes which can be dynamically allocated by procfs
+        is limited, device entries will only be created up to a magic number of
+        devices. The kernel will utter a warning that not all entries can be
+        created. In this case, you shouldn't use "cio_proc_devinfo=yes" (see
+        above).
+
+* /proc/cio_ignore
+
+  Lists the ranges of device numbers which are ignored by common I/O.
+
+  You can un-ignore certain or all devices by piping to /proc/cio_ignore. 
+  "free all" will un-ignore all ignored devices, 
+  "free <devnorange>, <devnorange>, ..." will un-ignore the specified devices.
+
+  For example, if devices 23 to 42 and 4711 are ignored,
+  - echo free 0x30-0x32 > /proc/cio_ignore
+    will un-ignore devices 30 to 32 and will leave devices 23 to 2F, 33 to 42
+    and 4711 ignored;
+  - echo free 0x41 > /proc/cio_ignore will furthermore un-ignore device 41;
+  - echo free all > /proc/cio_ignore will un-ignore all remaining ignored 
+    devices.
+
+  When a device is un-ignored, device recognition and sensing is performed and 
+  the device driver will be notified if possible, so the device will become
+  available to the system.
+
+  You can also add ranges of devices to be ignored by piping to 
+  /proc/cio_ignore; "add <devnorange>, <devnorange>, ..." will ignore the 
+  specified devices.
+
+  Note: Already known devices cannot be ignored; this also applies to devices
+        which are gone after a machine check.
+
+  For example, if device abcd is already known and all other devices a000-afff 
+  are not known, "echo add 0xa000-0xaccc, 0xaf00-0xafff > /proc/cio_ignore" 
+  will add af00-afff to the list of ignored devices and skip a000-accc.
+
+
+* /proc/s390dbf/cio_*/ (S/390 debug feature)
+
+  Some views generated by the debug feature to hold various debug outputs.
+
+  - /proc/s390dbf/cio_crw/sprintf
+    Messages from the processing of pending channel report words (machine check
+    handling), which will also show when CONFIG_DEBUG_CRW is defined.
+
+  - /proc/s390dbf/cio_msg/sprintf
+    Various debug messages from the common I/O-layer; generally, messages which 
+    will also show when CONFIG_DEBUG_IO is defined.
+
+  - /proc/s390dbf/cio_trace/hex_ascii
+    Logs the calling of functions in the common I/O-layer and, if applicable, 
+    which subchannel they were called for.
+
+  The level of logging can be changed to be more or less verbose by piping to 
+  /proc/s390dbf/cio_*/level a number between 0 and 6; see the documentation on
+  the S/390 debug feature (Documentation/s390/s390dbf.txt) for details.
+
+* /proc/irq_count
+
+  This entry counts how many times s390_process_IRQ has been called for each 
+  CPU. This info is in /proc/interrupts on other architectures.
diff -urN linux/Documentation/s390/Debugging390.txt linux-2.4.7/Documentation/s390/Debugging390.txt
--- linux/Documentation/s390/Debugging390.txt	Sun May 20 15:11:38 2001
+++ linux-2.4.7/Documentation/s390/Debugging390.txt	Mon Dec 17 13:42:41 2001
@@ -1,5 +1,5 @@
               
-                          Debugging on Linux for s/390 & zSeries
+                          Debugging on Linux for s/390 & z/Architecture
 			               by
 		Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
 		Copyright (C) 2000-2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
@@ -8,7 +8,7 @@
 Overview of Document:
 =====================
 This document is intended to give an good overview of how to debug 
-Linux for s/390 & zSeries it isn't intended as a complete reference & not a
+Linux for s/390 & z/Architecture it isn't intended as a complete reference & not a
 tutorial on the fundamentals of C & assembly, it dosen't go into
 390 IO in any detail. It is intended to compliment the documents in the
 reference section below & any other worthwhile references you get.
@@ -21,46 +21,46 @@
 ========
 Register Set
 Address Spaces on Intel Linux
-Address Spaces on Linux for s/390 & zSeries
-The Linux for s/390 & zSeries Kernel Task Structure
-Register Usage & Stackframes on Linux for s/390 & zSeries
+Address Spaces on Linux for s/390 & z/Architecture
+The Linux for s/390 & z/Architecture Kernel Task Structure
+Register Usage & Stackframes on Linux for s/390 & z/Architecture
 A sample program with comments
-Compiling programs for debugging on Linux for s/390 & zSeries
+Compiling programs for debugging on Linux for s/390 & z/Architecture
 Figuring out gcc compile errors
 Debugging Tools
 objdump
 strace
 Performance Debugging 
 Debugging under VM
-s/390 & zSeries IO Overview
-Debugging IO on s/390 & zSeries under VM
-GDB on s/390 & zSeries
+s/390 & z/Architecture IO Overview
+Debugging IO on s/390 & z/Architecture under VM
+GDB on s/390 & z/Architecture
 Stack chaining in gdb by hand
 Examining core dumps
 ldd
 Debugging modules
 The proc file system
 Starting points for debugging scripting languages etc.
-Tools soon to be available
 SysRq
 References
+Special Thanks
 
 Register Set
 ============
 The current architectures have the following registers.
  
-16  General propose registers, 32 bit on s/390 64 bit on zSeries, r0-r15 or gpr0-gpr15 used for arithmetic & addressing. 
+16  General propose registers, 32 bit on s/390 64 bit on z/Architecture, r0-r15 or gpr0-gpr15 used for arithmetic & addressing. 
 
-16 Control registers, 32 bit on s/390 64 bit on zSeries, ( cr0-cr15 kernel usage only ) used for memory managment,
+16 Control registers, 32 bit on s/390 64 bit on z/Architecture, ( cr0-cr15 kernel usage only ) used for memory managment,
 interrupt control,debugging control etc.
 
-16 Access registers ( ar0-ar15 ) 32 bit on s/390 & zSeries
+16 Access registers ( ar0-ar15 ) 32 bit on s/390 & z/Architecture
 not used by normal programs but potentially could 
 be used as temporary storage. Their main purpose is their 1 to 1
 association with general purpose registers and are used in
 the kernel for copying data between kernel & user address spaces.
-Access register 0 ( & access register 1 on z/Series ( needs 64 bit pointer ) )
-is currently used by the pthread library as a pointer to
+Access register 0 ( & access register 1 on z/Architecture ( needs 64 bit 
+pointer ) ) is currently used by the pthread library as a pointer to
 the current running threads private area.
 
 16 64 bit floating point registers (fp0-fp15 ) IEEE & HFP floating 
@@ -72,7 +72,7 @@
 
 
 The PSW is the most important register on the machine it
-is 64 bit on s/390 & 128 bit on zSeries & serves the roles of 
+is 64 bit on s/390 & 128 bit on z/Architecture & serves the roles of 
 a program counter (pc), condition code register,memory space designator.
 In IBM standard notation I am counting bit 0 as the MSB.
 It has several advantages over a normal program counter
@@ -83,7 +83,7 @@
 currently running at.
 
       Bit           Value
-s/390 zSeries
+s/390 z/Architecture
 0       0     Reserved ( must be 0 ) otherwise specification exception occurs.
 
 1       1     Program Event Recording 1 PER enabled, 
@@ -100,7 +100,7 @@
 
 8-11  8-11    PSW Key used for complex memory protection mechanism not used under linux
 
-12      12    1 on s/390 0 on zSeries
+12      12    1 on s/390 0 on z/Architecture
 
 13      13    Machine Check Mask 1=enable machine check interrupts
 
@@ -175,15 +175,19 @@
                compatible.
  	  
 	  
-Prefix Page
------------	  
+Prefix Page(s)
+--------------	  
 This per cpu memory area is too intimately tied to the processor not to mention.
-It exists between the real addresses 0-4096 on the processor & is exchanged 
-with a page in absolute storage by the set prefix instruction in linux'es startup. 
-This page different on each processor.
-Bytes 0-512 ( 200 hex ) are used by the processor itself for holding such
-information as exception indications & entry points for exceptions.
-Bytes after 0xc00 hex are used by linux for per processor globals.
+It exists between the real addresses 0-4096 on s/390 & 0-8192 z/Architecture & is exchanged 
+with a 1 page on s/390 or 2 pages on z/Architecture in absolute storage by the set 
+prefix instruction in linux'es startup. 
+This page is mapped to a different prefix for each processor in an SMP configuration
+( assuming the os designer is sane of course :-) ).
+Bytes 0-512 ( 200 hex ) on s/390 & 0-512,4096-4544,4604-5119 currently on z/Architecture 
+are used by the processor itself for holding such information as exception indications & 
+entry points for exceptions.
+Bytes after 0xc00 hex are used by linux for per processor globals on s/390 & z/Architecture 
+( there is a gap on z/Architecure too currently between 0xc00 & 1000 which linux uses ).
 The closest thing to this on traditional architectures is the interrupt
 vector table. This is a good thing & does simplify some of the kernel coding
 however it means that we now cannot catch stray NULL pointers in the
@@ -219,9 +223,6 @@
 If using the virtual machine ( VM ) as a debugger it is quite difficult to
 know which user process is running as the address space you are looking at
 could be from any process in the run queue.
-Thankfully you normally get lucky as address spaces don't overlap that &
-you can recognise the code at by cross referencing with a dump made by objdump
-( more about that later ).
 
 The limitation of Intels addressing technique is that the linux
 kernel uses a very simple real address to virtual addressing technique
@@ -240,35 +241,77 @@
 of our 32 bit addresses,however, we use entirely separate address 
 spaces for the user & kernel.
 
-This means we can support 2GB of non Extended RAM, & more
-with the Extended memory managment swap device & 64 Bit
-when it comes along.
+This means we can support 2GB of non Extended RAM on s/390, & more
+with the Extended memory managment swap device & 
+currently 4TB of physical memory currently on z/Architecture.
 
 
-Address Spaces on Linux for S390
-================================
+Address Spaces on Linux for s/390 & z/Architecture
+==================================================
 
 Our addressing scheme is as follows
 
 
-Himem 0x7fffffff 2GB on s/390   *****************          ****************
-2^64 bytes on zSeries           *  User Stack   *          *              *
-				*****************          *              *
-		                *  Shared Libs  *          *              *          
-                                *****************          *              *  
-			        *               *          *    Kernel    *  
-		                *  User Program *          *              *
-		                *   Data BSS    *          *              *
-                                *    Text       *          *              *
-            			*   Sections    *          *              *
-0x00000000                      *****************          ****************
+Himem 0x7fffffff 2GB on s/390    *****************          ****************
+currently 0x3ffffffffff (2^42)-1 *  User Stack   *          *              *
+on z/Architecture.		 *****************          *              *
+		                 *  Shared Libs  *          *              *      
+                                 *****************          *              *  
+			         *               *          *    Kernel    *  
+		                 *  User Program *          *              *
+		                 *   Data BSS    *          *              *
+                                 *    Text       *          *              *
+            			 *   Sections    *          *              *
+0x00000000                       *****************          ****************
 
 This also means that we need to look at the PSW problem state bit
 or the addressing mode to decide whether we are looking at
-user or kernel space. 
+user or kernel space.
+
+Virtual Addresses on s/390 & z/Architecture
+===========================================
+
+A virtual address on s/390 is made up of 3 parts
+The SX ( segment index, roughly corresponding to the PGD & PMD in linux terminology ) 
+being bits 1-11.
+The PX ( page index, corresponding to the page table entry (pte) in linux terminology )
+being bits 12-19. 
+The remaining bits BX (the byte index are the offset in the page )
+i.e. bits 20 to 31.
+
+On z/Architecture in linux we currently make up an address from 4 parts.
+The region index bits (RX) 0-32 we currently use bits 22-32
+The segment index (SX) being bits 33-43
+The page index (PX) being bits  44-51
+The byte index (BX) being bits  52-63
+
+Notes:
+1) s/390 has no PMD so the PMD is really the PGD also.
+A lot of this stuff is defined in pgtable.h.
+
+2) Also seeing as s/390's page indexes are only 1k  in size 
+(bits 12-19 x 4 bytes per pte ) we use 1 ( page 4k )
+to make the best use of memory by updating 4 segment indices 
+entries each time we mess with a PMD & use offsets 
+0,1024,2048 & 3072 in this page as for our segment indexes.
+On z/Architecture our page indexes are now 2k in size
+( bits 12-19 x 8 bytes per pte ) we do a similar trick
+but only mess with 2 segment indices each time we mess with
+a PMD.
+
+3) As z/Architecture supports upto a massive 5-level page table lookup we 
+can only use 3 currently on Linux ( as this is all the generic kernel
+currently supports ) however this may change in future
+this allows us to access ( according to my sums )
+4TB of virtual storage per process i.e.
+4096*512(PTES)*1024(PMDS)*2048(PGD) = 4398046511104 bytes,
+enough for another 2 or 3 of years I think :-).
+to do this we use a region-third-table designation type in
+our address space control registers.
+ 
 
-The Linux for s/390 & zSeries Kernel Task Structure
-===================================================
+The Linux for s/390 & z/Architecture Kernel Task Structure
+==========================================================
 Each process/thread under Linux for S390 has its own kernel task_struct
 defined in linux/include/linux/sched.h
 The S390 on initialisation & resuming of a process on a cpu sets
@@ -287,7 +330,7 @@
             *        ( 4K )        *
 8K aligned  ************************ 
 
-                     zSeries
+                 z/Architecture
             ************************
             *  2 page kernel stack *
 	    *        ( 8K )        *
@@ -298,7 +341,7 @@
 
 What this means is that we don't need to dedicate any register or global variable
 to point to the current running process & can retrieve it with the following
-very simple construct for s/390 & one very similar for zSeries.
+very simple construct for s/390 & one very similar for z/Architecture.
 
 static inline struct task_struct * get_current(void)
 {
@@ -317,8 +360,8 @@
 
 
 
-Register Usage & Stackframes on Linux for s/390 & zSeries
-=========================================================
+Register Usage & Stackframes on Linux for s/390 & z/Architecture
+=================================================================
 Overview:
 ---------
 This is the code that gcc produces at the top & the bottom of
@@ -331,7 +374,7 @@
 limited knowledge of one assembly language.
 
 It should be noted that there are some differences between the
-s/390 & zSeries stack layouts as the zSeries stack layout didn't have
+s/390 & z/Architecture stack layouts as the z/Architecture stack layout didn't have
 to maintain compatibility with older linkage formats.
 
 Glossary:
@@ -367,8 +410,8 @@
 The code generated by the compiler to return to the caller.
 
 frameless-function
-A frameless function in Linux for s390 & zSeries is one which doesn't need 
-more than the register save area ( 96 bytes on s/390, 160 on zSeries )
+A frameless function in Linux for s390 & z/Architecture is one which doesn't 
+need more than the register save area ( 96 bytes on s/390, 160 on z/Architecture )
 given to it by the caller.
 A frameless function never:
 1) Sets up a back chain.
@@ -428,8 +471,8 @@
 }
 
 
-s/390 & zSeries Register usage
-==============================
+s/390 & z/Architecture Register usage
+=====================================
 r0       used by syscalls/assembly                  call-clobbered
 r1	 used by syscalls/assembly                  call-clobbered
 r2       argument 0 / return value 0                call-clobbered
@@ -449,8 +492,8 @@
 
 f0       argument 0 / return value ( float/double ) call-clobbered
 f2       argument 1                                 call-clobbered
-f4       zSeries argument 2                           saved
-f6       zSeries argument 3                           saved
+f4       z/Architecture argument 2                  saved
+f6       z/Architecture argument 3                  saved
 The remaining floating points
 f1,f3,f5 f7-f15 are call-clobbered.
 
@@ -479,12 +522,13 @@
 area if crossing this boundary.
 6) Floating point parameters are mixed with outgoing args
 on the outgoing args area in the order the are passed in as parameters.
-7) Floating point arguments 2 & 3 are saved in the outgoing args area for zSeries
+7) Floating point arguments 2 & 3 are saved in the outgoing args area for 
+z/Architecture
 
 
 Stack Frame Layout
 ------------------
-s/390     zSeries
+s/390     z/Architecture
 0         0             back chain ( a 0 here signifies end of back chain )
 4         8             eos ( end of stack, not used on Linux for S390 used in other linkage formats )
 8         16            glue used in other s/390 linkage formats for saved routine descriptors etc.
@@ -598,8 +642,8 @@
 stack backchain in optimised code as this also causes pipeline stalls, you
 have been warned.
 
-64 bit zSeries code disassembly
--------------------------------
+64 bit z/Architecture code disassembly
+--------------------------------------
 
 If you understand the stuff above you'll understand the stuff
 below too so I'll avoid repeating myself & just say that 
@@ -637,12 +681,14 @@
 
 
 
-Compiling programs for debugging on Linux for s/390 & zSeries
-=============================================================
--gdwarf2 now works & normal -g debugging works much better now
+Compiling programs for debugging on Linux for s/390 & z/Architecture
+====================================================================
+-gdwarf-2 now works it should be considered the default debugging
+format for s/390 & z/Architecture as it is more reliable for debugging
+shared libraries,  normal -g debugging works much better now
 Thanks to the IBM java compiler developers bug reports. 
 
-This is typically done adding/appending the flags -g to the 
+This is typically done adding/appending the flags -g or -gdwarf-2 to the 
 CFLAGS & LDFLAGS variables Makefile of the program concerned.
 
 If using gdb & you would like accurate displays of registers &
@@ -1148,7 +1194,7 @@
 --------------------------------
 D G will display all the gprs
 Adding a extra G to all the commands is neccessary to access the full 64 bit 
-content in VM on zSeries obviously this isn't required for access registers
+content in VM on z/Architecture obviously this isn't required for access registers
 as these are still 32 bit.
 e.g. DGG instead of DG 
 D X will display all the control registers
@@ -1241,17 +1287,21 @@
 circumstances as the process may change when doing a 
 TR I R <address range>.
 Thankfully after reading VM's online help I figured out how to debug
-I particular process.
+particular processes in 31 bit mode, however, according to the current 
+VM online help documentation the method described below uses 
+TR STO or STD which don't currently work on  z/Series while in 
+64-bit mode.
 
 Your first problem is to find the STD ( segment table designation )
 of the program you wish to debug.
+
 There are several ways you can do this here are a few
 1) objdump --syms <program to be debugged> | grep main
 To get the address of main in the program.
 tr i pswa <address of main>
 Start the program, if VM drops to CP on what looks like the entry
 point of the main function this is most likely the process you wish to debug.
-Now do a D X13 or D XG13 on zSeries.
+Now do a D X13 or D XG13 on z/Architecture.
 On 31 bit the STD is bits 1-19 ( the STO segment table origin ) 
 & 25-31 ( the STL segment table length ) of CR13.
 now type
@@ -1260,7 +1310,48 @@
 TR I R STD 8F32E1FF 0.7fffffff
 Another very useful variation is
 TR STORE INTO STD <CR13's value> <address range>
+for finding out when a particular variable changes.
 
+An alternative way of finding the STD of a currently running process 
+is to do the following, ( this method is more complex but
+could be quite convient if you aren't updating the kernel much &
+so your kernel structures will stay constant for a reasonable period of
+time ).
+
+grep task /proc/<pid>/status
+from this you should see something like
+task: 0f160000 ksp: 0f161de8 pt_regs: 0f161f68
+This now gives you a pointer to the task structure.
+Now make CC:="s390-gcc -g" kernel/sched.s
+To get the task_struct stabinfo.
+( task_struct is defined in include/linux/sched.h ).
+Now we want to look at
+task->active_mm->pgd
+on my machine the active_mm in the task structure stab is
+active_mm:(4,12),672,32
+its offset is 672/8=84=0x54
+the pgd member in the mm_struct stab is
+pgd:(4,6)=*(29,5),96,32
+so its offset is 96/8=12=0xc
+
+so we'll
+hexdump -s 0xf160054 /dev/mem | more
+i.e. task_struct+active_mm offset
+to look at the active_mm member
+f160054 0fee cc60 0019 e334 0000 0000 0000 0011
+hexdump -s 0x0feecc6c /dev/mem | more
+i.e. active_mm+pgd offset
+feecc6c 0f2c 0000 0000 0001 0000 0001 0000 0010
+we get something like
+now do 
+TR I R STD <pgd|0x7f> 0.7fffffff
+i.e. the 0x7f is added because the pgd only
+gives the page table origin & we need to set the low bits
+to the maximum possible segment table length.
+TR I R STD 0f2c007f 0.7fffffff
+on z/Architecture you'll probably need to do
+TR I R STD <pgd|0x7> 0.ffffffffffffffff
+to set the TableType to 0x1 & the Table length to 3.
 
 
 
@@ -1347,10 +1438,18 @@
 
 Help for displaying ascii textstrings
 -------------------------------------
-As textstrings are cannot be displayed in ASCII under the VM debugger ( I love EBDIC too ) I have 
-written this little program which will convert a command line of hex digits to ascii text
-which can be compiled under linux & you can copy the hex digits from your x3270 terminal to
-your xterm if you are debugging from a linuxbox.
+On the very latest VM Nucleus'es VM can now display ascii
+( thanks Neale for the hint ) by doing
+D TX<lowaddr>.<len>
+e.g.
+D TX0.100
+
+Alternatively
+=============
+Under older VM debuggers ( I love EBDIC too ) you can use this little program I wrote which
+will convert a command line of hex digits to ascii text which can be compiled under linux & 
+you can copy the hex digits from your x3270 terminal to your xterm if you are debugging
+from a linuxbox.
 
 This is quite useful when looking at a parameter passed in as a text string
 under VM ( unless you are good at decoding ASCII in your head ).
@@ -1532,8 +1631,8 @@
 
 
 
-s/390 & zSeries IO Overview
-===========================
+s/390 & z/Architecture IO Overview
+==================================
 
 I am not going to give a course in 390 IO architecture as this would take me quite a
 while & I'm no expert. Instead I'll give a 390 IO architecture summary for Dummies if you have 
@@ -1685,15 +1784,15 @@
 between 2 machines. We use 2 cables under linux to do a bi-directional serial link.
 
 
-Debugging IO on s/390 & zSeries under VM
-=========================================
+Debugging IO on s/390 & z/Architecture under VM
+===============================================
 
 Now we are ready to go on with IO tracing commands under VM
 
 A few self explanatory queries:
 Q OSA
 Q CTC
-Q DISK
+Q DISK ( This command is CMS specific )
 Q DASD
 
 
@@ -1998,9 +2097,14 @@
 This is done using a the same trick described for VM 
 p/x (*($sp+56))&0x7fffffff get the first backchain.
 
-For zSeries do
-p/x *($sp+112) i.e. replace 56 with 112 & ignore the &0x7fffffff
-in the macros below.
+For z/Architecture
+Replace 56 with 112 & ignore the &0x7fffffff
+in the macros below & do nasty casts to longs like the following
+as gdb unfortunately deals with printed arguments as ints which
+messes up everything.
+i.e. here is a 3rd backchain dereference
+p/x *(long *)(***(long ***)$sp+112)
+
 
 this outputs 
 $5 = 0x528f18 
@@ -2265,6 +2369,21 @@
 
 Some driver debugging techniques
 ================================
+debug feature
+-------------
+Some of our drivers now support a "debug feature" in
+/proc/s390dbf see s390dbf.txt in the linux/Documentation directory
+for more info.
+e.g. 
+to switch on the lcs "debug feature"
+echo 5 > /proc/s390dbf/lcs/level
+& then after the error occured.
+cat /proc/s390dbf/lcs/sprintf >/logfile
+the logfile now contains some information which may help
+tech support resolve a problem in the field.
+
+
+
 high level debugging network drivers
 ------------------------------------
 ifconfig is a quite useful command
@@ -2339,65 +2458,10 @@
 & type ? in the debugger for help.
 
 
-Debugging Drivers
-=================
-Some of our drivers now support a debug logging feature in
-/proc/s390dbf see s390dbf.txt in the linux/Documentation directory
-for more info.
-e.g. 
-to switch on lcs debugging
-echo 5 > /proc/s390dbf/lcs/level
-& then after the error occured.
-cat /proc/s390dbf/lcs/sprintf >/logfile
-the logfile now contains some information which may help
-tech support resolve a problem in the field.
-
-If you have VM look at the chapter Debugging IO on S390 under VM.
-
-
-
-
-Tools soon to be available
-==========================
-
-Dumptool & Lcrash
------------------
-Michael Holzheu & others here at IBM have a fairly mature port of 
-SGI's lcrash tool which allows one to look at kernel structures in a
-running kernel.
-
-It also complements a tool called dumptool which dumps all the kernels
-memory pages & registers to either a tape or a disk.
-This can be used by tech support or an ambitous end user do
-post mortem debugging of a machine like gdb core dumps.
-
-Going into how to use this tool in detail will be explained
-in other documentation supplied by IBM & the lcrash homepage
-http://oss.sgi.com/projects/lkcd/.
-
-How they work
--------------
-Lcrash is a perfectly normal application
-however it requires an additional file.
-It is built using a patch to the kernel source base.
-
-
-Debugging a live system it uses /dev/mem
-alternatively for post mortem debugging it uses the data 
-collected by dumptool.
-
-
-Ltrace
-------
-We also have a tool called ltrace in our CVS repository 
-no plans on a delivery date yet.
-ltrace is a superset of strace in that it also allows
-tracing of shared libraries calls as well as system calls,
-man ltrace for more info.
 
 SysRq
 =====
-This is now supported by linux for s/390 & zSeries.
+This is now supported by linux for s/390 & z/Architecture.
 To enable it do compile the kernel with 
 Kernel Hacking -> Magic SysRq Key Enabled
 echo "1" > /proc/sys/kernel/sysrq.
@@ -2426,14 +2490,14 @@
 Various info & man pages.
 CMS Help on tracing commands.
 Linux for s/390 Elf Application Binary Interface
-Linux for zSeries Elf Application Binary Interface ( Both Highly Recommended )
+Linux for z/Series Elf Application Binary Interface ( Both Highly Recommended )
 z/Architecture Principles of Operation SA22-7832-00
 Enterprise Systems Architecture/390 Reference Summary SA22-7209-01 & the
 Enterprise Systems Architecture/390 Principles of Operation SA22-7201-05
 
-
-
-
-
-
+Special Thanks
+==============
+Special thanks to Neale Ferguson who maintains a much
+prettier HTML version of this page at
+http://penguinvm.princeton.edu/notes.html#Debug390
 
diff -urN linux/Documentation/s390/TAPE linux-2.4.7/Documentation/s390/TAPE
--- linux/Documentation/s390/TAPE	Fri Feb 16 18:53:08 2001
+++ linux-2.4.7/Documentation/s390/TAPE	Mon Dec 17 13:41:18 2001
@@ -76,10 +76,9 @@
 - ensure the tape is at the beginning 
      mt -f /dev/ntibm0 rewind 
 
-- set the blocksize of the character driver. The blocksizes 512, 1024
-  and 2048 bytes are supported by ISO9660. 1024 is the default, u
-  which will be used here. 
-     mt -f /dev/ntibm0 setblk 1024 
+- set the blocksize of the character driver. The blocksize 2048 bytes
+  is commonly used on ISO9660 CD-Roms
+     mt -f /dev/ntibm0 setblk 2048 
 
 - write the filesystem to the character device driver 
      mkisofs -o /dev/ntibm0 somedir 
@@ -88,18 +87,16 @@
      mt -f /dev/ntibm0 rewind 
 
 - Now you can mount your new filesystem as a block device: 
-     mount -t iso9660 -o ro,block=1024 /dev/btibm0 /mnt 
+     mount -t iso9660 -o ro,block=2048 /dev/btibm0 /mnt 
 
 TODO List 
 
-- The backend code has to be enhanced to support error-recovery actions. 
-
-- The seeking algorithm of the block device has to be improved to speed 
-  things up 
+   - Driver has to be stabelized still
 
 BUGS 
 
-There are lots of weaknesses still in the code. This is why it is EXPERIMENTAL.
+This driver is considered BETA, which means some weaknesses may still
+be in it.
 If an error occurs which cannot be handled by the code you will get a 
 sense-data dump.In that case please do the following: 
 
diff -urN linux/Documentation/s390/chandev.8 linux-2.4.7/Documentation/s390/chandev.8
--- linux/Documentation/s390/chandev.8	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/Documentation/s390/chandev.8	Mon Dec 17 13:42:47 2001
@@ -7,29 +7,37 @@
 .SH SYNOPSIS
 The channel device layer is a layer to provide a consistent interface for
 configuration & default machine check (devices appearing & disappearing )
-handling Linux for zSeries channel devices.
+handling on Linux for s/390 & z/Series channel devices.
 
-These include among others
+
+s/390 & z/Series channel devices include among others
 
 .Bl -item
 .It
 lcs ( the most common ethernet/token ring/fddi standard on zSeries )
 .It
-ctc/escon hi speed like serial link standard on zSeries.
+ctc/escon hi speed like serial link standard on s/390 & z/Series.
 .It
 claw used to talk to cisco routers.
 .It
 qeth gigabit ethernet.
-.El
-
+.It
+osad used by osa/sf to configure osa devices, e.g. to share a osa card between 2 or more vm guests. osad is just added to the channel device layer for completeness, there are no plans at the current time to write a driver to exploit this under linux.
+.It
 These devices use two channels one read & one write for configuration &
-or communication.
-The motivation behind producing this layer was that there is a lot of
-duplicate code among the drivers for configuration so the lcs & ctc drivers
-tended to fight over 3088/08's & 3088/1F's which could be either 2216/3172
-lcs compatible devices or escons/ctc's & to resolve this fight
-both device drivers had to be reconfigured rather than doing the
-configuration in a single place.
+or communication ( & a third channel the data channel in the case of gigabit ethernet ).
+The motivation behind developing this layer was that there was a lot of
+duplicate code among the channel device drivers for configuration. 
+Also the lcs & ctc drivers tended to fight over 3088/08's & 3088/1F's which could 
+be either 2216/3172 channel attached lcs compatible devices or escon/ctc pipes 
+between guests & to resolve this fight both device drivers had to be configured 
+separately,  this is now simplified by doing the configuration in a single place
+( the channel device layer ).
+
+This layer isn't invasive & it is quite okay to use channel drivers
+which don't use the channel device layer in conjunction with
+drivers which do.
+.El
 
 .SH DESCRIPTION
 The current setup can be read from /proc/chandev
@@ -37,30 +45,65 @@
 .Bl -enum
 .It
 Piping to /proc/chandev.
+e.g. echo reprobe >/proc/chandev
+will cause uninitialised channel devices to be probed.
 .It
-Entering them into /etc/chandev.conf comments are prefixed #.
+Entering them into /etc/chandev.conf comments are prefixed with #.
 .It
 Or from the boot command line using the 'chandev=' keyword
+e.g. chandev=noauto,0x0,0x480d;noauto,0x4810,0xffff
+will allow only devno's 0x480e & 0x480f to be autodetected.
 .El
 .Bl -item
 .It
-Multiple options can be passed separated by semicolons but no spaces are allowed between parameters. The script /bin/chandev will be called automatically on startup or a machine check of a device as follows.
-/bin/chandev <start starting_devnames> <machine_check (devnames pre_recovery_action_status) (post_recovery_action_status)>.
-The chandev layer doesn't open stdin stdout or stderr so it is advisable that you add the following lines to the start of your script.
+Multiple options can be passed separated by semicolons, no spaces or newlines are allowed between parameters on the kernel parameter line as it complicates parsing, spaces are allowed in /proc/chandev & chandev.conf, newlines are allowed in chandev.conf only. To be consistent with other hotpluggable architectures the script pointed to /proc/sys/kernel/hotplug (normally /sbin/hotplug) will be called automatically on startup or a machine check of a device as follows.
+/sbin/hotplug chandev <start starting_devnames> <machine_check (devname last/pre_recovery_status) (current/post_recovery_status)>.
+The chandev layer doesn't open stdin stdout or stderr so it is advisable that you add the following lines to the start of your script, here is a sample script which starts devices as they become available.
 .It
 #!/bin/bash
 .It
 exec >/dev/console 2>&1 0>&1
+.It
+# Uncomment line below for debugging.
+.It
+# echo $*
+.It
+if [ "$1" = "chandev" ] && [ "$2" = "start" ]
+.It
+then
+.It
+    shift 2
+.It
+    while [ "$1" != "" ]  && [ "$1" != "machine_check" ]
+.It
+    do
+.It
+        isup=`ifconfig $1 2>/dev/null | grep UP`
+.It
+	if [ "$isup" = "" ]
+.It
+	then
+.It
+	     ifup $1
+.It
+	fi
+.It
+	shift
+.It
+    done
+.It
+fi
+.It
+.It
+e.g. if tr0 & ctc0 were starting up & eth0 & eth1 devices disappeared & eth2 got a revalidate machine check ( which is normally fully recoverable ) nearly simultainously the parameters would be.
+.It
+/sbin/hotplug chandev start tr0 ctc0 machine_check eth0 gone gone eth1 gone gone eth2 revalidate good
+.It
+This can be used for example to call /etc/rc.d/init.d/network start when a device appears & make the ipldelay kernel boot parameter obselete on native machines or recover from bad machine checks where the default machine check handling isn't adequete. The machine checks that can be presented as parameters are good not_operational no_path revalidate device_gone. Normally you wouldn't want to do anything like stop networking when a device disappears as this is hopefully temporary, I just added it to be complete. The chandev layer waits a few seconds for machine checks to settle before running /sbin/hotplug because several machine checks usually happen at once & the forked scripts would possibly race against each other to shutdown & start resources at the same time & behave rather stupidly.
 .El
 
-e.g. if tr0 & ctc0 were starting up & eth0 & eth1 didn't recover from a gone machine check at the same instant the  parameters would be.
-
-
-/bin/chandev start tr0 ctc0 machine_check eth0 gone gone eth1 gone gone
 
 
-This can be used for example to call /etc/rc.d/init.d/network start when a device appears & make the ipldelay kernel boot parameter obselete on native machines or recover from bad machine checks where the default machine check handling isn't adequete. The machine checks that can be presented as parameters are good not_operational no_path revalidate device_gone.
-
 valid chandev arguments are <> indicate optional parameters, | indicate a choice.
 
 .B glossary
@@ -77,21 +120,48 @@
 .It
 
 .Bl -item
-
 .It
-.B (ctc|escon|lcs|osad|qeth|claw)<devif_num>, 
-read_devno, write_devno, <port_no/protocol_no>, <checksum_received_ip_pkts>, <use_hw_stats>
+.B (ctc|escon|lcs|osad|qeth)<devif_num>, 
+read_devno,write_devno,<data_devno,memory_usage_in_k,port_no/protocol_no,checksum_received_ip_pkts,use_hw_stats>
+.It
+devif_num of -1 indicates you don't care what device interface number is chosen, omitting it indicates this is a range of devices for which you want to force to be detected as a particular type, qeth devices can't be forced as a range as it makes no sense for them.
+The data_devno field is only valid for qeth devices, all parameters including & after memory_usage_in_k can be set optionally, if not set they
+go to default values. memory_usage_in_k ( 0 the default ) means let the driver choose,checksum_received_ip_pkts & use_hw_stats are set to false
+.It
+e.g. ctc0,0x7c00,0x7c01
+.It
+Tells the channel layer to force ctc0 if detected to use cuu's 7c00 & 7c01 port,port_no is the relative adapter no on lcs, on ctc/escon this field is the ctc/escon protocol number ( default 0 ), don't do checksumming on received ip packets & as ctc doesn't have hardware stats so it ignores this parameter. This can be used for instance to force a device if it presents bad sense data to the IO layer & thus autodetection fails.
 .It
-e.g. ctc0,0x7c00,0x7c01,0,0,0
+lcs,0x7c00,0x7d00,4096,-1
+All devices between 0x7c00 & 7d00 should be detected as lcs, let the driver use 4096k for each instance, don't care what port relative adapter number is chosen, don't checksum received ip packets & use hw stats .
 .It
-Tells the channel layer to force ctc0 if detected to use cuu's 7c00 & 7c01 port,port_no is the relative adapter no on lcs, on ctc/escon this field is the ctc/escon protocol number ( normally 0 ), don't do checksumming on received ip packets & as ctc doesn't have hardware stats so it ignores this parameter.
+qeth1,0x7c00,0x7c01,0x7c02
+.It
+devif_num=1,read=0x7c00,write=0x7c01,data=0x7c02, don't checksum received ip packets & use hw stats.
 .El
 .It
-
+.Bl -item
+.B claw devif_num, 
+read_devno,write_devno<,memory_usage_in_k,checksum_received_ip_pkts,use_hw_stats,>
+host_name,adapter_name,api_type
+.It
+CLAW currently is not autodetected as the host_name,adapter_name & api_type
+need to be set up, possibly some convention for setting these automatically
+may be contrived in the future & auto detection may be done but currently there isn't any.
+The names host_name,adapter_name,api_type may be 8 upto characters in length,
+host_name is the name of this host, adapter_name is the name of the adjacent host,
+api_type may be name 1 to 8 chars in length API & TCPIP are common values.
+The remainder of the parameters are the same as the description for other ctc escon etc. 
+.It
+A typical setup may be
+.It
+claw0,0xe00,0xe01,linuxa,rs6k,TCPIP
+.It
+.El
 .Bl -item
 .It
 .B add_parms
-,chan_type,<string>
+,chan_type,<lo_devno,hi_devno,>string
 .It
 chan_type bitfield 
 .It
@@ -99,22 +169,26 @@
 .It
 This is for device driver specific options passed as a string to the driver
 not dealt with by the channel device layer it can't contain spaces.
+low_devno & hi_devno are optional parameters to specify a range.
+The channel device layer doesn't concatenate strings if device ranges overlap,
+before passing to a device driver.
 .El
 .It
 
 .Bl -item
 .It
 .B del_parms
-<,chan_type,exact_match>
+<,chan_type,exact_match,lo_devno>
 .It
 This deletes some or all device driver specific options not specifying chan_type causes it to delete all the strings. exact_match=1 specifies only to remove driver parms where chan_type is exactly equal exact_match=0 specifies to remove parms where any bit matches chan_type.
+lo_devno is an optional parameter the delete to only happen if lo_devno matches a lo_devno in one of the ranges.
 .El
 .It
 
 .Bl -item
 .It
 .B noauto
-,<lo_devno>-<hi_devno>
+<,lo_devno,hi_devno>
 .It
 Don't probe a range of device numbers for channel devices.
 .El
@@ -128,7 +202,6 @@
 .It
 e.g. a token ring read channel 0x7c00 would have an interface called tr0x7c00 this avoids name collisions on devices.
 .El
-.El
 
 
 .B power user options
@@ -168,7 +241,6 @@
 .It
 .B add_model
 ,chan_type, cu_type, cu_model, dev_type, dev_model, max_port_no, automatic_machine_check_handling
-
 .It
 Tells the channel layer to probe for the device described, -1 for any of the parameters other than chan_type & automatic_machine_check_handling is a wildcard.
 Set max_port_no to 0 for non lcs devices.
@@ -180,18 +252,33 @@
 chan_type bitfield
 .It
 ctc=0x1, escon=0x2, lcs=0x4, osad=0x8, qeth=0x10, claw=0x20
-
-.It
+.El
 .Bl -item
 .It
 .B del_model
 ,cu_type,cu_model,dev_type,dev_model
 .It
--1 for any parameter is a wildcard,
+-1 for any parameter is a wildcard.
 .El
+
+.Bl -item
 .It
 .B del_all_models
+.It 
+should be obvious.
+.El
+.Bl -item
+.It
+.B  non_cautious_auto_detect
+.It
+Tells the channel device layer to attempt to auto detect devices even if their type/model pairs don't unambigously identify the device, e.g. 3088/1F's can either be escon CTC's or channel attached 3172 lcs compatible devices. If the wrong device driver attempts to probe these channels there may be big delays on startup or even a kernel lockup, use this option with caution.
+.El
+.Bl -item
+.It
+.B cautious_auto_detect
 .It
+ See non_cautious_auto_detect this is the default.
+.El
 .Bl -item
 .It
 .B auto_msck
@@ -248,6 +335,19 @@
 .It
 .Bl -item
 .It
+.B unregister_probe <probefunc_addr>
+.It
+unregisters a single probe function or all of them.
+.El
+.Bl -item
+.It
+.B unregister_probe_by_chan_type
+.It
+unregisters all probe functions which match the chan_type bitfield exactly,
+useful if you want a configuration to survice a kernel upgrade.
+.El
+.Bl -item
+.It
 .B read_conf
 .It
 Read instructions from /etc/chandev.conf.
@@ -259,6 +359,22 @@
 .It
 Don't automatically read /etc/chandev.conf on boot.
 .El
+.Bl -item
+.It
+.B persist 
+,chan_type
+.It
+Force drivers modules to stay loaded even if no device is found,
+this is useful for debugging & one wishes to examine debug entries in 
+/proc/s390dbf/ to find out why a module failed to load.
+.It
+e.g.
+.It
+persist,-1 forces all devices to persist.
+.It
+persist,0 forces all channel devices to be non persistent.
+.El
+
 .It
 e.g the following sequence of commands should be roughly equivalent
 to rebooting for channel devices.
@@ -290,8 +406,8 @@
 .B /proc/chandev
 .It
 cat /proc/chandev to see current options chosen.
-.Iy
-echo <command> >proc/chandev to enter a new command
+.It
+echo <command> >/proc/chandev to enter a new command
 .It
 .B /etc/chandev.conf 
 .It
@@ -302,7 +418,7 @@
 .B 'chandev=' 
 keyword.
 .It
-.B /bin/chandev
+.B /sbin/hotplug
 .It 
 A user script/executable which is run when devices come online "appear"
 or go offline "disappear".
diff -urN linux/Documentation/s390/config3270.sh linux-2.4.7/Documentation/s390/config3270.sh
--- linux/Documentation/s390/config3270.sh	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/Documentation/s390/config3270.sh	Mon Dec 17 13:41:48 2001
@@ -37,10 +37,14 @@
 echo "#!/bin/sh" > $SCR || exit 1
 echo " " >> $SCR
 echo "# Script built by /sbin/config3270" >> $SCR
-echo rm -rf "$D/$SUBD/*" >> $SCR
+if [ ! -d /dev/dasd ]; then
+	echo rm -rf "$D/$SUBD/*" >> $SCR
+fi
 echo "grep -v $TTY $INITTAB > $NINITTAB" > $SCRTMP || exit 1
 echo "echo $ADDNOTE >> $NINITTAB" >> $SCRTMP
-echo mkdir -p $D/$SUBD >> $SCR
+if [ ! -d /dev/dasd ]; then
+	echo mkdir -p $D/$SUBD >> $SCR
+fi
 
 # Now query the tub3270 driver for 3270 device information
 # and add appropriate mknod and mingetty lines to our files
@@ -48,13 +52,19 @@
 while read devno maj min;do
 	if [ $min = 0 ]; then
 		fsmaj=$maj
-		echo mknod $D/$TUB c $fsmaj 0 >> $SCR
-		echo chmod 666 $D/$TUB >> $SCR
+		if [ ! -d /dev/dasd ]; then
+			echo mknod $D/$TUB c $fsmaj 0 >> $SCR
+			echo chmod 666 $D/$TUB >> $SCR
+		fi
 	elif [ $maj = CONSOLE ]; then
-		echo mknod $D/$TUB$devno c $fsmaj $min >> $SCR
+		if [ ! -d /dev/dasd ]; then
+			echo mknod $D/$TUB$devno c $fsmaj $min >> $SCR
+		fi
 	else
-		echo mknod $D/$TTY$devno c $maj $min >>$SCR
-		echo mknod $D/$TUB$devno c $fsmaj $min >> $SCR
+		if [ ! -d /dev/dasd ]; then
+			echo mknod $D/$TTY$devno c $maj $min >>$SCR
+			echo mknod $D/$TUB$devno c $fsmaj $min >> $SCR
+		fi
 		echo "echo t$min$GETTYLINE $TTY$devno >> $NINITTAB" >> $SCRTMP
 	fi
 done < $P
diff -urN linux/Documentation/s390/s390dbf.txt linux-2.4.7/Documentation/s390/s390dbf.txt
--- linux/Documentation/s390/s390dbf.txt	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/Documentation/s390/s390dbf.txt	Mon Dec 17 13:41:49 2001
@@ -336,7 +336,7 @@
 Example:
 
 > ls /proc/s390dbf/dasd
-hex_ascii  level      raw
+flush  hex_ascii  level      raw 
 > cat /proc/s390dbf/dasd/hex_ascii | sort +1
 00 00974733272:680099 2 - 02 0006ad7e  07 ea 4a 90 | ....
 00 00974733272:682210 2 - 02 0006ade6  46 52 45 45 | FREE
@@ -362,6 +362,20 @@
 > echo "5" > /proc/s390dbf/dasd/level
 > cat /proc/s390dbf/dasd/level
 5
+
+Flushing debug areas
+--------------------
+Debug areas can be flushed with piping the number of the desired
+area (0...n) to the proc file "flush". When using "-" all debug areas
+are flushed.
+
+Examples:
+
+1. Flush debug area 0:
+> echo "0" > /proc/s390dbf/dasd/flush  
+
+2. Flush all debug areas:
+> echo "-" > /proc/s390dbf/dasd/flush
 
 lcrash Interface
 ----------------
diff -urN linux/arch/s390/Makefile linux-2.4.7/arch/s390/Makefile
--- linux/arch/s390/Makefile	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/Makefile	Mon Dec 17 13:41:18 2001
@@ -17,7 +17,11 @@
 CPP=$(CC) -E
 OBJCOPY=$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment -S
 LDFLAGS=-e start
+ifeq ($(CONFIG_SHARED_KERNEL),y)
+LINKFLAGS =-T $(TOPDIR)/arch/s390/vmlinux-shared.lds $(LDFLAGS)
+else
 LINKFLAGS =-T $(TOPDIR)/arch/s390/vmlinux.lds $(LDFLAGS)
+endif
 
 CFLAGS_PIPE := -pipe
 CFLAGS_NSR  := -fno-strength-reduce
@@ -27,8 +31,8 @@
 
 SUBDIRS := $(SUBDIRS) arch/s390/mm arch/s390/kernel arch/s390/lib \
            drivers/s390 arch/s390/math-emu
-CORE_FILES := arch/s390/mm/mm.o arch/s390/kernel/kernel.o $(CORE_FILES) \
-           drivers/s390/io.o
+CORE_FILES := arch/s390/mm/mm.o arch/s390/kernel/kernel.o $(CORE_FILES)
+DRIVERS := $(DRIVERS) drivers/s390/io.o
 LIBS := $(TOPDIR)/arch/s390/lib/lib.a $(LIBS) $(TOPDIR)/arch/s390/lib/lib.a
 
 ifeq ($(CONFIG_MATHEMU),y)
@@ -50,16 +54,6 @@
 	$(MAKE) linuxsubdirs SUBDIRS=drivers/s390
 
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
-
-MAKESILO = $(MAKE) -C arch/$(ARCH)/tools/silo
-
-MAKEDASDFMT = $(MAKE) -C arch/$(ARCH)/tools/dasdfmt
-
-silo:
-	@$(MAKESILO) silo
-
-dasdfmt:
-	@$(MAKEDASDFMT) dasdfmt
 
 image: vmlinux 
 	@$(MAKEBOOT) image
diff -urN linux/arch/s390/boot/Makefile linux-2.4.7/arch/s390/boot/Makefile
--- linux/arch/s390/boot/Makefile	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/boot/Makefile	Mon Dec 17 13:41:18 2001
@@ -1,5 +1,5 @@
 #
-# Makefile for the linux s390-specific parts of the memory manager.
+# arch/s390/boot/Makefile
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
diff -urN linux/arch/s390/config.in linux-2.4.7/arch/s390/config.in
--- linux/arch/s390/config.in	Tue Apr 17 20:19:25 2001
+++ linux-2.4.7/arch/s390/config.in	Mon Dec 17 13:41:18 2001
@@ -50,6 +50,8 @@
 tristate 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
+bool 'Pseudo page fault support' CONFIG_PFAULT
+bool 'VM shared kernel support' CONFIG_SHARED_KERNEL
 endmenu
 
 source drivers/s390/Config.in
diff -urN linux/arch/s390/defconfig linux-2.4.7/arch/s390/defconfig
--- linux/arch/s390/defconfig	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/defconfig	Mon Dec 17 13:41:18 2001
@@ -5,6 +5,8 @@
 # CONFIG_EISA is not set
 # CONFIG_MCA is not set
 CONFIG_UID16=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_ARCH_S390=y
 
 #
@@ -40,6 +42,8 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PROCESS_DEBUG is not set
+CONFIG_PFAULT=y
+# CONFIG_SHARED_KERNEL is not set
 
 #
 # Block device drivers
@@ -79,10 +83,13 @@
 #
 # S/390 character device drivers
 #
-CONFIG_3215=y
-CONFIG_3215_CONSOLE=y
+CONFIG_TN3270=y
+CONFIG_TN3270_CONSOLE=y
+CONFIG_TN3215=y
+CONFIG_TN3215_CONSOLE=y
 CONFIG_HWC=y
 CONFIG_HWC_CONSOLE=y
+CONFIG_HWC_CPI=m
 CONFIG_S390_TAPE=m
 
 #
@@ -102,6 +109,9 @@
 #
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 CONFIG_NET_ETHERNET=y
 CONFIG_TR=y
 # CONFIG_FDDI is not set
@@ -109,7 +119,8 @@
 #
 # S/390 network device drivers
 #
-# CONFIG_CHANDEV is not set
+CONFIG_CHANDEV=y
+CONFIG_HOTPLUG=y
 CONFIG_CTC=m
 CONFIG_IUCV=m
 
@@ -133,7 +144,8 @@
 # CONFIG_IP_MROUTE is not set
 # CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_IPV6 is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_NETLINK is not set
 # CONFIG_KHTTPD is not set
 # CONFIG_ATM is not set
 
@@ -178,16 +190,18 @@
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
 # CONFIG_RAMFS is not set
 # CONFIG_ISO9660_FS is not set
 # CONFIG_JOLIET is not set
 # CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
 # CONFIG_NTFS_FS is not set
 # CONFIG_NTFS_RW is not set
 # CONFIG_HPFS_FS is not set
 CONFIG_PROC_FS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVFS_MOUNT is not set
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
 # CONFIG_DEVFS_DEBUG is not set
 # CONFIG_DEVPTS_FS is not set
 # CONFIG_QNX4FS_FS is not set
@@ -195,7 +209,6 @@
 # CONFIG_ROMFS_FS is not set
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
-# CONFIG_SYSV_FS_WRITE is not set
 # CONFIG_UDF_FS is not set
 # CONFIG_UDF_RW is not set
 # CONFIG_UFS_FS is not set
@@ -243,4 +256,4 @@
 #
 # Kernel hacking
 #
-# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_MAGIC_SYSRQ=y
diff -urN linux/arch/s390/kernel/Makefile linux-2.4.7/arch/s390/kernel/Makefile
--- linux/arch/s390/kernel/Makefile	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/kernel/Makefile	Mon Dec 17 13:41:18 2001
@@ -15,7 +15,7 @@
 O_TARGET := kernel.o
 
 export-objs	:= debug.o ebcdic.o irq.o s390_ext.o smp.o s390_ksyms.o
-obj-y	:= lowcore.o entry.o bitmap.o traps.o time.o process.o irq.o \
+obj-y	:= entry.o bitmap.o traps.o time.o process.o irq.o \
             setup.o sys_s390.o ptrace.o signal.o cpcmd.o ebcdic.o \
             semaphore.o s390fpu.o reipl.o s390_ext.o debug.o
 
diff -urN linux/arch/s390/kernel/debug.c linux-2.4.7/arch/s390/kernel/debug.c
--- linux/arch/s390/kernel/debug.c	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/kernel/debug.c	Mon Dec 17 13:41:49 2001
@@ -83,6 +83,9 @@
 static int debug_input_level_fn(debug_info_t * id, struct debug_view *view,
 				struct file *file, const char *user_buf,
 				size_t user_buf_size, loff_t * offset);
+static int debug_input_flush_fn(debug_info_t * id, struct debug_view *view,
+                                struct file *file, const char *user_buf,
+                                size_t user_buf_size, loff_t * offset);
 static int debug_hex_ascii_format_fn(debug_info_t * id, struct debug_view *view,
                                 char *out_buf, const char *in_buf);
 static int debug_raw_format_fn(debug_info_t * id,
@@ -123,6 +126,15 @@
 	NULL
 };
 
+struct debug_view debug_flush_view = {
+        "flush",
+        NULL,
+        NULL,
+        NULL,
+        &debug_input_flush_fn,
+        NULL
+};
+
 struct debug_view debug_sprintf_view = {
 	"sprintf",
 	NULL,
@@ -664,6 +676,7 @@
 	if(!rc) 
 		goto out;
 	debug_register_view(rc, &debug_level_view);
+        debug_register_view(rc, &debug_flush_view);
 	printk(KERN_INFO
 	       "debug: reserved %d areas of %d pages for debugging %s\n",
 	       nr_areas, 1 << page_order, rc->name);
@@ -1027,6 +1040,73 @@
       out:
 	*offset += in_buf_size;
 	return rc;		/* number of input characters */
+}
+
+
+/*
+ * flushes debug areas
+ */
+ 
+void debug_flush(debug_info_t* id, int area)
+{
+        unsigned long flags;
+        int i;
+
+        if(!id)
+                return;
+        spin_lock_irqsave(&id->lock,flags);
+        if(area == DEBUG_FLUSH_ALL){
+                id->active_area = 0;
+                memset(id->active_entry, 0, id->nr_areas * sizeof(int));
+                for (i = 0; i < id->nr_areas; i++) 
+                        memset(id->areas[i], 0, PAGE_SIZE << id->page_order);
+                printk(KERN_INFO "debug: %s: all areas flushed\n",id->name);
+        } else if(area >= 0 && area < id->nr_areas) {
+                id->active_entry[area] = 0;
+                memset(id->areas[area], 0, PAGE_SIZE << id->page_order);
+                printk(KERN_INFO
+                        "debug: %s: area %i has been flushed\n",
+                        id->name, area);
+        } else {
+                printk(KERN_INFO
+                        "debug: %s: area %i cannot be flushed (range: %i - %i)\n",
+                        id->name, area, 0, id->nr_areas-1);
+        }
+        spin_unlock_irqrestore(&id->lock,flags);
+}
+
+/*
+ * view function: flushes debug areas 
+ */
+ 
+static int debug_input_flush_fn(debug_info_t * id, struct debug_view *view,
+                                struct file *file, const char *user_buf,
+                                size_t in_buf_size, loff_t * offset)
+{
+        char input_buf[1];
+        int rc = in_buf_size;
+ 
+        if (*offset != 0)
+                goto out;
+        if (copy_from_user(input_buf, user_buf, 1)){
+                rc = -EFAULT;
+                goto out;
+        }
+        if(input_buf[0] == '-') { 
+                debug_flush(id, DEBUG_FLUSH_ALL);
+                goto out;
+        }
+        if (isdigit(input_buf[0])) {
+                int area = ((int) input_buf[0] - (int) '0');
+                debug_flush(id, area);
+                goto out;
+        }
+
+        printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
+
+      out:
+        *offset += in_buf_size;
+        return rc;              /* number of input characters */
 }
 
 /*
diff -urN linux/arch/s390/kernel/entry.S linux-2.4.7/arch/s390/kernel/entry.S
--- linux/arch/s390/kernel/entry.S	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390/kernel/entry.S	Mon Dec 17 13:43:29 2001
@@ -14,6 +14,7 @@
 #include <linux/sys.h>
 #include <linux/linkage.h>
 #include <linux/config.h>
+#include <asm/cache.h>
 #include <asm/lowcore.h>
 #include <asm/errno.h>
 #include <asm/smp.h>
@@ -80,7 +81,7 @@
 sigpending   =  8
 need_resched = 24
 tsk_ptrace   = 28
-processor    = 60
+processor    = 56
 
 /*
  * Base Address of this Module --- saved in __LC_ENTRY_BASE
@@ -98,17 +99,27 @@
  *    R15 - kernel stack pointer
  */
 
-        .macro  SAVE_ALL psworg           # system entry macro
+        .macro  SAVE_ALL psworg,sync      # system entry macro
         stm     %r13,%r15,__LC_SAVE_AREA
-        stam    %a2,%a4,__LC_SAVE_AREA+12
         basr    %r13,0                    #  temp base pointer
         l       %r13,.Lentry_base-.(%r13) # load &entry_base to %r13 
         tm      \psworg+1,0x01            # test problem state bit
-        bz      BASED(.+12)               # skip stack setup save
-        l       %r15,__LC_KERNEL_STACK    # problem state -> load ksp
-        lam     %a2,%a4,BASED(.Lc_ac)     # set ac.reg. 2 to primary space
-                                          # and access reg. 4 to home space
-0:      s       %r15,BASED(.Lc_spsize)    # make room for registers & psw
+        stam    %a2,%a4,__LC_SAVE_AREA+12
+	.if	\sync
+        bz      BASED(1f)                 # skip stack setup save
+	.else
+        bnz     BASED(0f)                 # from user -> load kernel stack
+	l	%r14,__LC_ASYNC_STACK	  # are we already on the async stack ?
+	slr     %r14,%r15
+	sra	%r14,13
+	be	BASED(1f)
+        l       %r15,__LC_ASYNC_STACK     # load async. stack
+	b	BASED(1f)
+	.endif
+0:      l       %r15,__LC_KERNEL_STACK    # problem state -> load ksp
+	lam	%a2,%a4,BASED(.Lc_ac)	  # set ac.reg. 2 to primary space
+					  # and ac.reg. 4 to home space
+1:      s       %r15,BASED(.Lc_spsize)    # make room for registers & psw
         n       %r15,BASED(.Lc0xfffffff8) # align stack pointer to 8
         stm     %r0,%r12,SP_R0(%r15)      # store gprs 0-12 to kernel stack
         st      %r2,SP_ORIG_R2(%r15)      # store original content of gpr 2
@@ -121,7 +132,7 @@
         xc      0(4,%r15),0(%r15)         # clear back chain
         .endm
 
-        .macro  RESTORE_ALL               # system exit macro
+        .macro  RESTORE_ALL sync          # system exit macro
         mvc     __LC_RETURN_PSW(8),SP_PSW(%r15)  # move user PSW to lowcore
         lam     %a0,%a15,SP_AREGS(%r15)   # load the access registers
         lm      %r0,%r15,SP_R0(%r15)      # load gprs 0-15 of user
@@ -130,8 +141,8 @@
         .endm
 
         .macro  GET_CURRENT
-        lr      %r9,%r15                  # load pointer to task_struct to %r9
-        n       %r9,BASED(.Lc0xffffe000)
+	l	%r9,BASED(.Lc0xffffe000)  # load pointer to task_struct to %r9
+	al	%r9,__LC_KERNEL_STACK
         .endm
 
 
@@ -172,13 +183,35 @@
         br      %r14
 
 /*
+ * do_softirq calling function. We want to run the softirq functions on the
+ * asynchronous interrupt stack.
+ */
+	.global do_call_softirq
+do_call_softirq:
+	stm	%r12,%r15,24(%r15)
+	lr	%r12,%r15
+        basr    %r13,0
+do_call_base:
+	l	%r0,__LC_ASYNC_STACK
+	slr     %r0,%r15
+	sra	%r0,13
+	be	0f-do_call_base(%r13)
+	l	%r15,__LC_ASYNC_STACK
+0:	sl	%r15,.Lc_overhead-do_call_base(%r13)
+        st	%r12,0(%r15)	# store backchain
+	l	%r1,.Ldo_softirq-do_call_base(%r13)
+	basr	%r14,%r1
+	lm	%r12,%r15,24(%r12)
+	br	%r14
+	
+/*
  * SVC interrupt handler routine. System calls are synchronous events and
  * are executed with interrupts enabled.
  */
 
 	.globl  system_call
 system_call:
-        SAVE_ALL __LC_SVC_OLD_PSW
+        SAVE_ALL __LC_SVC_OLD_PSW,1
 	mvi     SP_PGM_OLD_ILC(%r15),1  # mark PGM_OLD_ILC as invalid
 pgm_system_call:	
         GET_CURRENT               # load pointer to task_struct to R9
@@ -196,17 +229,10 @@
 
 sysc_return:
         tm      SP_PSW+1(%r15),0x01 # returning to user ?
-        bno     BASED(sysc_leave) # no-> skip bottom half, resched & signal
-#
-# check, if bottom-half has to be done
-#
-        l       %r0,__LC_IRQ_STAT     # get softirq_active
-        n       %r0,__LC_IRQ_STAT+4   # and it with softirq_mask
-        bnz     BASED(sysc_handle_bottom_half)
+        bno     BASED(sysc_leave) # no-> skip resched & signal
 #
 # check, if reschedule is needed
 #
-sysc_return_bh:	
         icm     %r0,15,need_resched(%r9) # get need_resched from task_struct
         bnz     BASED(sysc_reschedule)
         icm     %r0,15,sigpending(%r9)   # get sigpending from task_struct
@@ -215,7 +241,7 @@
 	tm      SP_PGM_OLD_ILC(%r15),0xff
         bz      BASED(pgm_svcret)
 	stnsm   24(%r15),0xfc            # disable I/O and ext. interrupts
-        RESTORE_ALL
+        RESTORE_ALL 1
 
 #
 # call do_signal before return
@@ -232,9 +258,17 @@
 #
 sysc_tracesys:
         l       %r1,BASED(.Ltrace)
-	l       %r2,BASED(.Lc_ENOSYS)
-	st      %r2,SP_R2(%r15)   # give sysc_trace an -ENOSYS retval
+	l       %r7,BASED(.Lc_ENOSYS)
+	st      %r7,SP_R2(%r15)   # give sysc_trace an -ENOSYS retval
         basr    %r14,%r1
+	l       %r2,SP_R2(%r15)
+	cr      %r2,%r7 # compare with saved -ENOSYS
+	be      BASED(sysc_tracesys_dn1)
+	# strace wants to change the syscall
+	sll     %r2,24
+	srl     %r2,22
+        l       %r8,sys_call_table-entry_base(2,%r13) # get address of system call    
+sysc_tracesys_dn1:		
 	lm      %r3,%r6,SP_R3(%r15)
 	l       %r2,SP_ORIG_R2(%r15)
         basr    %r14,%r8          # call sys_xxx
@@ -245,15 +279,6 @@
 
 
 #
-# call do_softirq and return from syscall, if interrupt-level
-# is zero
-#
-sysc_handle_bottom_half:        
-        l       %r1,BASED(.Ldo_softirq)
-	la      %r14,BASED(sysc_return_bh)
-        br      %r1               # call do_softirq
-
-#
 # call schedule with sysc_return as return-address
 #
 sysc_reschedule:        
@@ -272,13 +297,9 @@
         stosm   24(%r15),0x03     # reenable interrupts
         sr      %r0,%r0           # child returns 0
         st      %r0,SP_R2(%r15)   # store return value (change R2 on stack)
-#ifdef CONFIG_SMP
         l       %r1,BASED(.Lschedtail)
 	la      %r14,BASED(sysc_return)
         br      %r1               # call schedule_tail, return to sysc_return
-#else
-        b       BASED(sysc_return)
-#endif
 
 #
 # clone, fork, vfork, exec and sigreturn need glue,
@@ -574,7 +595,10 @@
         .long  sys_madvise
 	.long  sys_getdents64		 /* 220 */
         .long  sys_fcntl64 
-	.rept  255-221
+	.long  sys_ni_syscall		 /* 222 - reserved for posix_acl */
+	.long  sys_ni_syscall		 /* 223 - reserved for posix_acl */
+	.long  sys_ni_syscall		 /* 224 - reserved for posix_acl */
+	.rept  255-224
 	.long  sys_ni_syscall
 	.endr
 
@@ -598,10 +622,10 @@
  * for LPSW?).
  */
 	stm     %r13,%r15,__LC_SAVE_AREA
-	stam    %a2,%a4,__LC_SAVE_AREA+12
 	basr    %r13,0                   # temp base pointer
 	l       %r13,.Lentry_base-.(%r13)# load &entry_base to %r13
         tm      __LC_PGM_INT_CODE+1,0x80 # check whether we got a per exception
+	stam    %a2,%a4,__LC_SAVE_AREA+12
         bz      BASED(pgm_sv)            # skip if not
         tm      __LC_PGM_OLD_PSW,0x40    # test if per event recording is on
         bnz     BASED(pgm_sv)            # skip if it is
@@ -657,10 +681,9 @@
         lh      %r7,__LC_PGM_ILC         # load instruction length
 	GET_CURRENT
 pgm_no_sv:
+	la	%r3,0x7f
         lh      %r8,__LC_PGM_INT_CODE  # N.B. saved int code used later KEEP it
-        lr      %r3,%r8
-        la      %r0,0x7f
-        nr      %r3,%r0           # clear per-event-bit
+	nr      %r3,%r8           # reload & clear per-event-bit
         be      BASED(pgm_dn)     # none of Martins exceptions occurred bypass
         l       %r1,BASED(.Ljump_table)
         sll     %r3,2
@@ -672,12 +695,8 @@
         l       %r5,SP_PSW+4(15)  # load psw addr
         sr      %r5,%r7           # substract ilc from psw
         st      %r5,SP_PSW+4(15)  # store corrected psw addr
-pgm_per:cl      %r3,BASED(.Lc20)  # pseudo page fault ?
-        be      BASED(pgm_go)     # if yes then don't reenable interrupts
-        stosm   24(%r15),0x03     # reenable interrupts
-pgm_go: basr    %r14,%r1          # branch to interrupt-handler
-pgm_dn: la      %r0,0x80
-        nr      %r8,%r0           # check for per exception
+pgm_per:basr    %r14,%r1          # branch to interrupt-handler
+pgm_dn: n	%r8,BASED(.Lc128) # check for per excepton
         be      BASED(pgm_return)
         la      %r2,SP_PTREGS(15) # address of register-save area
         l       %r1,BASED(.Lhandle_per) # load adr. of per handler
@@ -696,7 +715,7 @@
 
         .globl io_int_handler
 io_int_handler:
-        SAVE_ALL __LC_IO_OLD_PSW
+        SAVE_ALL __LC_IO_OLD_PSW,0
         GET_CURRENT               # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15) # address of register-save area
         sr      %r3,%r3
@@ -707,16 +726,19 @@
         basr    %r14,%r1          # branch to standard irq handler
 
 io_return:
-        tm      SP_PSW+1(%r15),0x01 # returning to user ?
-        bno     BASED(io_leave)   # no-> skip resched & signal
-        stosm   24(%r15),0x03     # reenable interrupts
 #
 # check, if bottom-half has to be done
 #
-        l       %r0,__LC_IRQ_STAT     # get softirq_active
-        n       %r0,__LC_IRQ_STAT+4   # and it with softirq_mask
+        l       %r1,processor(%r9)    # get cpu number from task struture
+        sll     %r1,L1_CACHE_SHIFT
+        al      %r1,BASED(.Lirq_stat) # get address of irq_stat
+        icm     %r0,15,0(%r1)         # test irq_stat[#cpu].__softirq_pending
         bnz     BASED(io_handle_bottom_half)
-io_return_bh:	
+io_return_bh:
+
+        tm      SP_PSW+1(%r15),0x01 # returning to user ?
+        bno     BASED(io_leave)   # no-> skip resched & signal
+        stosm   24(%r15),0x03     # reenable interrupts
 #
 # check, if reschedule is needed
 #
@@ -726,15 +748,14 @@
         bnz     BASED(io_signal_return)
 io_leave:
         stnsm   24(%r15),0xfc            # disable I/O and ext. interrupts
-        RESTORE_ALL
+        RESTORE_ALL 0
 
 #
-# call do_softirq and return from syscall, if interrupt-level
-# is zero
+# call do_softirq
 #
-io_handle_bottom_half:        
+io_handle_bottom_half:
         l       %r1,BASED(.Ldo_softirq)
-	la      %r14,BASED(io_return_bh)
+        la      %r14,BASED(io_return_bh)
         br      %r1               # call do_softirq
 
 #
@@ -761,7 +782,7 @@
 
         .globl  ext_int_handler
 ext_int_handler:
-        SAVE_ALL __LC_EXT_OLD_PSW
+        SAVE_ALL __LC_EXT_OLD_PSW,0
         GET_CURRENT                    # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
         lh      %r3,__LC_EXT_INT_CODE  # error code
@@ -789,11 +810,11 @@
 
         .globl mcck_int_handler
 mcck_int_handler:
-        SAVE_ALL __LC_MCK_OLD_PSW
+        SAVE_ALL __LC_MCK_OLD_PSW,0
 	l       %r1,BASED(.Ls390_mcck)
 	basr    %r14,%r1	  # call machine check handler
 mcck_return:
-        RESTORE_ALL
+        RESTORE_ALL 0
 
 #ifdef CONFIG_SMP
 /*
@@ -801,7 +822,7 @@
  */
         .globl restart_int_handler
 restart_int_handler:
-        l       %r15,__LC_KERNEL_STACK # load ksp
+        l       %r15,__LC_SAVE_AREA+60 # load ksp
         lctl    %c0,%c15,__LC_CREGS_SAVE_AREA # get new ctl regs
         lam     %a0,%a15,__LC_AREGS_SAVE_AREA
         stosm   0(%r15),0x04           # now we can turn dat on
@@ -834,6 +855,7 @@
 .Lc0xffffe000: .long  -8192        # to round stack pointer to &task_struct
 .Lc8191:       .long  8191
 .Lc_spsize:    .long  SP_SIZE
+.Lc_overhead:  .long  STACK_FRAME_OVERHEAD
 .Lc_ac:        .long  0,0,1
 .Lc_ENOSYS:    .long  -ENOSYS
 .Lc4:          .long  4
@@ -843,6 +865,7 @@
 .Lc0x2401:     .long  0x2401
 .Lc0x4000:     .long  0x4000
 .Lc0xff:       .long  0xff
+.Lc128:        .long  128
 
 /*
  * Symbol constants
@@ -854,6 +877,7 @@
 .Lentry_base:  .long  entry_base
 .Lext_hash:    .long  ext_int_hash
 .Lhandle_per:  .long  handle_per_exception
+.Lirq_stat:    .long  irq_stat
 .Ljump_table:  .long  pgm_check_table
 .Lschedule:    .long  schedule
 .Lclone:       .long  sys_clone
@@ -868,7 +892,5 @@
 .Ltrace:       .long  syscall_trace
 .Lvfork:       .long  sys_vfork
 
-#ifdef CONFIG_SMP
 .Lschedtail:   .long  schedule_tail
-#endif
 
diff -urN linux/arch/s390/kernel/gdb-stub.c linux-2.4.7/arch/s390/kernel/gdb-stub.c
--- linux/arch/s390/kernel/gdb-stub.c	Fri May 12 14:41:44 2000
+++ linux-2.4.7/arch/s390/kernel/gdb-stub.c	Mon Dec 17 13:41:18 2001
@@ -65,7 +65,8 @@
  * $m0,10#2a               +$00010203040506070809101112131415#42
  *
  */
-
+#define TRUE 1
+#define FALSE 0
 #include <asm/gdb-stub.h>
 #include <linux/string.h>
 #include <linux/kernel.h>
@@ -74,14 +75,15 @@
 #include <linux/mm.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
+#include <linux/stddef.h>
 
+#define S390_REGS_COMMON_SIZE offsetof(struct gdb_pt_regs,orig_gpr2)
 
 /*
  * external low-level support routines
  */
 
-extern int putDebugChar(char c);    /* write a single character      */
-extern char getDebugChar(void);     /* read and return a single char */
+
 extern void fltr_set_mem_err(void);
 extern void trap_low(void);
 
@@ -247,8 +249,10 @@
 
 	while (count-- > 0) {
 		ch = *(mem++);
+#if 0
 		if (mem_err)
 			return 0;
+#endif
 		*buf++ = hexchars[ch >> 4];
 		*buf++ = hexchars[ch & 0xf];
 	}
@@ -276,8 +280,10 @@
 		ch = hex(*buf++) << 4;
 		ch |= hex(*buf++);
 		*(mem++) = ch;
+#if 0
 		if (mem_err)
 			return 0;
+#endif
 	}
 
 /*	set_mem_fault_trap(0); */
@@ -349,7 +355,7 @@
 	return (numChars);
 }
 
-void gdb_stub_get_non_pt_regs(gdb_pt_regs *regs)
+void gdb_stub_get_non_pt_regs(struct gdb_pt_regs *regs)
 {
 	s390_fp_regs *fpregs=&regs->fp_regs;
 	int has_ieee=save_fp_regs1(fpregs);
@@ -365,7 +371,7 @@
 	}
 }
 
-void gdb_stub_set_non_pt_regs(gdb_pt_regs *regs)
+void gdb_stub_set_non_pt_regs(struct gdb_pt_regs *regs)
 {
 	restore_fp_regs1(&regs->fp_regs);
 }
@@ -390,7 +396,7 @@
  * returns 1 if you should skip the instruction at the trap address, 0
  * otherwise.
  */
-void gdb_stub_handle_exception(gdb_pt_regs *regs,int sigval)
+void gdb_stub_handle_exception(struct gdb_pt_regs *regs,int sigval)
 {
 	int trap;			/* Trap type */
 	int addr;
@@ -402,19 +408,23 @@
 	/*
 	 * reply to host that an exception has occurred
 	 */
+#if 0
 	send_signal(sigval);
-
+#endif
 	/*
 	 * Wait for input from remote GDB
 	 */
-	while (1) {
+	while (1) 
+	{
 		output_buffer[0] = 0;
 		getpacket(input_buffer);
 
 		switch (input_buffer[0])
 		{
 		case '?':
+#if 0
 			send_signal(sigval);
+#endif
 			continue;
 
 		case 'd':
@@ -427,9 +437,9 @@
 		case 'g':
 			gdb_stub_get_non_pt_regs(regs);
 			ptr = output_buffer;
-			ptr=  mem2hex((char *)regs,ptr,sizeof(s390_regs_common),FALSE);
+			ptr=  mem2hex((char *)regs,ptr,S390_REGS_COMMON_SIZE,FALSE);
 			ptr=  mem2hex((char *)&regs->crs[0],ptr,NUM_CRS*CR_SIZE,FALSE);
-			ptr = mem2hex((char *)&regs->fp_regs, ptr,sizeof(s390_fp_regs));
+			ptr = mem2hex((char *)&regs->fp_regs, ptr,sizeof(s390_fp_regs),FALSE);
 			break;
 	  
 		/*
@@ -438,11 +448,11 @@
 		 */
 		case 'G':
 			ptr=input_buffer;
-			hex2mem (ptr, (char *)regs,sizeof(s390_regs_common), FALSE);
-			ptr+=sizeof(s390_regs_common)*2;
+			hex2mem (ptr, (char *)regs,S390_REGS_COMMON_SIZE, FALSE);
+			ptr+=S390_REGS_COMMON_SIZE*2;
 			hex2mem (ptr, (char *)regs->crs[0],NUM_CRS*CR_SIZE, FALSE);
 			ptr+=NUM_CRS*CR_SIZE*2;
-			hex2mem (ptr, (char *)regs->fp_regs,sizeof(s390_fp_regs), FALSE);
+			hex2mem (ptr, (char *)&regs->fp_regs,sizeof(s390_fp_regs), FALSE);
 			gdb_stub_set_non_pt_regs(regs);
 			strcpy(output_buffer,"OK");
 		break;
@@ -472,7 +482,8 @@
 			if (hexToInt(&ptr, &addr)
 				&& *ptr++ == ','
 				&& hexToInt(&ptr, &length)
-				&& *ptr++ == ':') {
+				&& *ptr++ == ':') 
+			{
 				if (hex2mem(ptr, (char *)addr, length, 1))
 					strcpy(output_buffer, "OK");
 				else
@@ -490,8 +501,7 @@
 
 			ptr = &input_buffer[1];
 			if (hexToInt(&ptr, &addr))
-				regs->cp0_epc = addr;
-	  
+				regs->psw.addr = addr;
 			/*
 			 * Need to flush the instruction cache here, as we may
 			 * have deposited a breakpoint, and the icache probably
@@ -529,22 +539,22 @@
 			 * There is no single step insn in the MIPS ISA, so we
 			 * use breakpoints and continue, instead.
 			 */
+#if 0
 			single_step(regs);
+#endif
 			flush_cache_all();
 			return;
 			/* NOTREACHED */
+			break;
 
-		}
-		break;
-
-		}			/* switch */
-
-		/*
-		 * reply to the request
-		 */
+		}      /* switch */
 
+	/*
+	 * reply to the request
+	 */
+	
 		putpacket(output_buffer);
-
+	
 	} /* while */
 }
 
@@ -558,13 +568,9 @@
 {
 	if (!gdb_stub_initialised)
 		return;
-	__asm__ __volatile__(
-			".globl	breakinst\n"
-			"breakinst:\t.word   %0\n\t"
-			:
-			: "i" (S390_BREAKPOINT_U16)
-				:
-				);
+	asm volatile (".globl	breakinst\n"
+		"breakinst:\t.word   %0"
+		: : "i" (S390_BREAKPOINT_U16) );
 }
 
 
diff -urN linux/arch/s390/kernel/head.S linux-2.4.7/arch/s390/kernel/head.S
--- linux/arch/s390/kernel/head.S	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390/kernel/head.S	Mon Dec 17 13:42:47 2001
@@ -338,12 +338,12 @@
 # reset files in VM reader
 #
         stidp __LC_CPUID                       # store cpuid
-        lh    %r0,__LC_CPUID+4                 # get cpu version
-        chi   %r0,0x7490                       # running on P/390 ?
-        be    start                            #   no -> skip reset
+	tm    __LC_CPUID,0xff                  # running VM ?
+	bno   .Lnoreset
         la    %r2,.Lreset              
         lhi   %r3,26
         .long 0x83230008
+.Lnoreset:
 #endif
 	
 #
@@ -461,28 +461,52 @@
         .org  0x10000
 startup:basr  %r13,0                     # get base
 .LPG1:  lctl  %c0,%c15,.Lctl-.LPG1(%r13) # load control registers
-	l     %r12,.Lparm1-.LPG1(%r13)   # pointer to parameter area
+	la    %r12,_pstart-.LPG1(%r13)   # pointer to parameter area
 					 # move IPL device to lowcore
         mvc   __LC_IPLDEV(4),IPL_DEVICE-PARMAREA(%r12)
 	
 #
-# find out memory size.
+# find memory chunks.
 #
 	mvc   __LC_PGM_NEW_PSW(8),.Lpcmem-.LPG1(%r13)
-        lhi   %r2,1
-        sll   %r2,17                     # test in increments of 128KB
-	lr    %r1,%r2
-	ahi   %r1,-4                     # test last word in the segment
-.Lloop:	
-	l     %r0,0(%r1)                 # test 128KB segment
-	st    %r0,0(%r1)
-	ar    %r1,%r2                    # add 128KB
-	bnm   .Lloop-.LPG1(%r13)         # r1 < 0x80000000 -> loop
-.Lchkmem:
-	n     %r1,.L4malign-.LPG1(%r13)  # align to multiples of 4M
-        l     %r2,.Lmemsize-.LPG1(%r13)  # address of variable memory_size
-	st    %r1,0(%r2)                 # store memory size
-
+	la    %r1,1                      # test in increments of 128KB
+	sll   %r1,17
+	l     %r3,.Lmchunk-.LPG1(%r13)   # get pointer to memory_chunk array
+	slr   %r4,%r4                    # set start of chunk to zero
+	slr   %r5,%r5                    # set end of chunk to zero
+	slr   %r6,%r6			 # set access code to zero
+.Lloop:
+	tprot 0(%r5),0			 # test protection of first byte
+	ipm   %r7
+	srl   %r7,28
+	clr   %r6,%r7			 # compare cc with last access code
+	be    .Lsame-.LPG1(%r13)
+	clr   %r4,%r5			 # chunk size > 0?
+	be    .Lsize0-.LPG1(%r13)
+	st    %r4,0(%r3)		 # store start address of chunk
+	lr    %r0,%r5
+	slr   %r0,%r4
+	st    %r0,4(%r3)		 # store size of chunk
+	st    %r6,8(%r3)		 # store type of chunk
+	la    %r3,12(%r3)
+	lr    %r4,%r5			 # set start to end
+.Lsize0:
+	lr    %r6,%r7			 # set access code to last cc
+.Lsame:
+	ar    %r5,%r1			 # add 128KB to end of chunk
+	bno   .Lloop-.LPG1(%r13)	 # r1 < 0x80000000 -> loop
+.Lchkmem:				 # > 2GB or tprot got a program check
+	clr   %r4,%r5			 # chunk size > 0?
+	be    .Ldonemem-.LPG1(%r13)
+	st    %r4,0(%r3)		 # store start address of chunk
+	lr    %r0,%r5
+	slr   %r0,%r4
+	st    %r0,4(%r3)		 # store size of chunk
+	st    %r6,8(%r3)		 # store type of chunk
+.Ldonemem:		
+        l     %r1,.Lmemsize-.LPG1(%r13)  # address of variable memory_size
+	st    %r5,0(%r1)                 # store last end to memory size
+	
         l      %r12,.Lmflags-.LPG1(%r13) # get address of machine_flags
 #
 # find out if we are running under VM
@@ -502,9 +526,7 @@
 # find out if we have an IEEE fpu
 #
         mvc    __LC_PGM_NEW_PSW(8),.Lpcfpu-.LPG1(%r13)
-        ld     %f0,.Lflt0-.LPG1(%r13)   # load (float) 0.0
-        ldr    %f2,%f0
-        adbr   %f0,%f2                  # test IEEE add instruction
+	efpc   %r0,0                    # test IEEE extract fpc instruction
         oi     3(%r12),2                # set IEEE fpu flag
 .Lchkfpu:
 
@@ -514,7 +536,7 @@
        mvc    __LC_PGM_NEW_PSW(8),.Lpccsp-.LPG1(%r13)
        la     %r0,0
        lr     %r1,%r0
-       la     %r2,.Lflt0-.LPG1(%r13)
+       la     %r2,4
        csp    %r0,%r2                   # Test CSP instruction
        oi     3(%r12),8                 # set CSP flag
 .Lchkcsp:
@@ -536,7 +558,7 @@
 .Lentry:.long  0x00080000,0x80000000 + _stext
 .Lctl:  .long  0x04b50002               # cr0: various things
         .long  0                        # cr1: primary space segment table
-        .long  0                        # cr2: access register translation
+        .long  .Lduct                   # cr2: dispatchable unit control table
         .long  0                        # cr3: instruction authorization
         .long  0                        # cr4: instruction authorization
         .long  0                        # cr5:  various things
@@ -554,47 +576,50 @@
 .Lpcfpu:.long  0x00080000,0x80000000 + .Lchkfpu
 .Lpccsp:.long  0x00080000,0x80000000 + .Lchkcsp
 .Lpcmvpg:.long 0x00080000,0x80000000 + .Lchkmvpg
-.Lflt0: .double 0
-.Lparm1:.long  PARMAREA
-.L4malign:.long 0xffc00000
-.Lbigmem:.long 0x04000000
-.Lrdstart:.long 0x02000000
-.Lmaxchunk:.long  0x00ffffff
 .Lmemsize:.long memory_size
+.Lmchunk:.long memory_chunk
 .Lmflags:.long machine_flags
 
+	.org PARMAREA-64
+.Lduct:	.long 0,0,0,0,0,0,0,0
+	.long 0,0,0,0,0,0,0,0
+
 #
 # params at 10400 (setup.h)
 #
 	.org   PARMAREA
+	.global _pstart
+_pstart:	
         .long  0,0                      # IPL_DEVICE
         .long  0,RAMDISK_ORIGIN         # INITRD_START
-        .long  0,0x800000               # INITRD_SIZE
+        .long  0,RAMDISK_SIZE           # INITRD_SIZE
 
         .org   COMMAND_LINE
     	.byte  "root=/dev/ram0 ro"
         .byte  0
+	.org   0x11000
+	.global _pend
+_pend:	
+
+#ifdef CONFIG_SHARED_KERNEL
+	.org   0x100000
+#endif
 
 #
 # startup-code, running in virtual mode
 #
-        .org   0x10800
         .globl _stext
 _stext:	basr  %r13,0                    # get base
 .LPG2:
 #
-# Setup lowcore
+# Setup stack
 #
-        l     %r1,__LC_IPLDEV           # load ipl device number
-        spx   .Lprefix-.LPG2(%r13)      # set prefix to linux lowcore
-        st    %r1,__LC_IPLDEV           # store ipl device number
         l     %r15,.Linittu-.LPG2(%r13)
-        ahi   %r15,8192                 # init_task_union + 8191
+        ahi   %r15,8192                 # init_task_union + 8192
         st    %r15,__LC_KERNEL_STACK    # set end of kernel stack
         ahi   %r15,-96
         xc    0(4,%r15),0(%r15)         # set backchain to zero
-        lhi   %r0,-1
-        st    %r0,__LC_KERNEL_LEVEL     # set interrupt count to -1
+
 #
 # clear bss memory
 #
@@ -608,8 +633,8 @@
         jo    .-4                       # branch back, if not finish
 # check control registers
         stctl  %c0,%c15,0(%r15)
-        oc     2(1,%r15),.Locbits+5-.LPG2(%r13) # enable sigp external ints.
-        oc     0(1,%r15),.Locbits+4-.LPG2(%r13) # low addresss proctection
+	oi     2(%r15),0x20             # enable sigp external interrupts
+	oi     0(%r15),0x10             # switch on low address protection
         lctl   %c0,%c15,0(%r15)
 
 #
@@ -622,15 +647,11 @@
         basr  %r13,0
 	lpsw  .Ldw-.(%r13)           # load disabled wait psw
 #
-.Lstart:    .long  start_kernel
             .align 8
-.Lprefix:   .long  init_S390_lowcore	
+.Ldw:	    .long  0x000a0000,0x00000000
 .Linittu:   .long  init_task_union
+.Lstart:    .long  start_kernel
 .Lbss_bgn:  .long  __bss_start
 .Lbss_end:  .long  _end
-.Locbits:   .long  0x01020408,0x10204080
-            .align 4
 .Laregs:    .long  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0
-	    .align 8
-.Ldw:	    .long  0x000a0000,0x00000000
 
diff -urN linux/arch/s390/kernel/irq.c linux-2.4.7/arch/s390/kernel/irq.c
--- linux/arch/s390/kernel/irq.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390/kernel/irq.c	Mon Dec 17 13:42:41 2001
@@ -21,7 +21,7 @@
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/timex.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/random.h>
 #include <linux/smp.h>
@@ -119,7 +119,7 @@
  */
 #ifdef CONFIG_SMP
 atomic_t global_irq_holder = ATOMIC_INIT(NO_PROC_ID);
-atomic_t global_irq_lock;
+atomic_t global_irq_lock = ATOMIC_INIT(0);
 atomic_t global_irq_count = ATOMIC_INIT(0);
 atomic_t global_bh_count;
 
@@ -188,7 +188,7 @@
 		}
 
 		/* Duh, we have to loop. Release the lock to avoid deadlocks */
-		clear_bit(0,&global_irq_lock);
+		atomic_set(&global_irq_lock, 0);
 
 		for (;;) {
 			if (!--count) {
@@ -206,10 +206,8 @@
 			if (!local_bh_count(cpu)
 			    && atomic_read(&global_bh_count))
 				continue;
-			/* this works even though global_irq_lock not
-                           a long, but is arch-specific --RR */
-			if (!test_and_set_bit(0,&global_irq_lock))
-				break;
+			if (!atomic_compare_and_swap(0, 1, &global_irq_lock))
+				 break;
 		}
 	}
 }
@@ -246,18 +244,14 @@
 
 static inline void get_irqlock(int cpu)
 {
-	/* this works even though global_irq_lock not a long, but is
-	   arch-specific --RR */
-	if (test_and_set_bit(0,&global_irq_lock)) {
+	if (atomic_compare_and_swap(0, 1, &global_irq_lock) != 0) {
 		/* do we already hold the lock? */
 		if ( cpu == atomic_read(&global_irq_holder))
 			return;
 		/* Uhhuh.. Somebody else got it. Wait.. */
 		do {
-			do {
-				check_smp_invalidate(cpu);
-			} while (test_bit(0,&global_irq_lock));
-		} while (test_and_set_bit(0,&global_irq_lock));
+			check_smp_invalidate(cpu);
+		} while (atomic_compare_and_swap(0, 1, &global_irq_lock) != 0);
 	}
 	/*
 	 * We also to make sure that nobody else is running
@@ -391,6 +385,10 @@
 EXPORT_SYMBOL(__global_sti);
 EXPORT_SYMBOL(__global_save_flags);
 EXPORT_SYMBOL(__global_restore_flags);
+EXPORT_SYMBOL(global_irq_holder);
+EXPORT_SYMBOL(global_irq_lock);
+EXPORT_SYMBOL(global_irq_count);
+EXPORT_SYMBOL(global_bh_count);
 #endif
 
 EXPORT_SYMBOL(global_bh_lock);
diff -urN linux/arch/s390/kernel/lowcore.S linux-2.4.7/arch/s390/kernel/lowcore.S
--- linux/arch/s390/kernel/lowcore.S	Fri May 12 14:41:44 2000
+++ linux-2.4.7/arch/s390/kernel/lowcore.S	Wed Dec 31 19:00:00 1969
@@ -1,60 +0,0 @@
-/*
- *  arch/s390/kernel/lowcore.S
- *    S390 lowcore definition.
- *
- *  S390 version
- *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Hartmut Penner (hp@de.ibm.com)
- *               Martin Schwidefsky (schwidefsky@de.ibm.com),
- */
-
-#include <asm/lowcore.h>
-         .align 4096
-         .globl init_S390_lowcore
-init_S390_lowcore:      
-         .long  _RESTART_PSW_MASK
-         .long  restart_int_handler + _ADDR_31
-         .long  0,0
-         .long  0,0
-EXT_OLD: .long  0,0
-SVC_OLD: .long  0,0
-PGM_OLD: .long  0,0
-MCCK_OLD:.long  0,0
-IO_OLD:  .long  0,0
-         .long  0,0,0,0,0,0
-#
-# new psws need all to be physical
-# because we start with dat off
-#
-EXT_PSW: .long  _EXT_PSW_MASK
-         .long  ext_int_handler + _ADDR_31
-#
-SVC_PSW: .long  _SVC_PSW_MASK
-         .long  system_call + _ADDR_31
-#
-PGM_PSW: .long  _PGM_PSW_MASK
-         .long  pgm_check_handler + _ADDR_31
-#
-MCCK_PSW:.long  _MCCK_PSW_MASK
-         .long  mcck_int_handler + _ADDR_31
-#
-IO_PSW:  .long  _IO_PSW_MASK
-         .long  io_int_handler + _ADDR_31
-#
-#
-#
-EXTERNAL_PARAMETER:     .long  0
-CPU_ADDRESS:            .word 0
-EXT_INTERRUPT_CODE:     .word 0
-SVC_ILC:                .word 0
-SVC_CODE:               .word 0
-PGM_ILC:                .word 0
-PGM_CODE:               .word 0
-TRANS_EXC_ADDR:         .long  0                         # 090
-                        .fill 0xC00-0x094,1,0
-SAVE_AREA:              .fill 0x40,1,0                   # C00
-KERNEL_STACK:           .long 0                          # C40
-KERNEL_LEVEL:           .long 0                          # C44
-CPUID:                  .long 0,0                        # C48
-                        .fill 0x1000-0xC50,1,0
-
diff -urN linux/arch/s390/kernel/process.c linux-2.4.7/arch/s390/kernel/process.c
--- linux/arch/s390/kernel/process.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/process.c	Mon Dec 17 13:42:41 2001
@@ -44,8 +44,6 @@
 #include <asm/processor.h>
 #include <asm/irq.h>
 
-spinlock_t semaphore_wake_lock = SPIN_LOCK_UNLOCKED;
-
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 /*
@@ -63,13 +61,6 @@
 	wait_psw.mask = _WAIT_PSW_MASK;
 	wait_psw.addr = (unsigned long) &&idle_wakeup | 0x80000000L;
 	while(1) {
-                if (softirq_active(smp_processor_id()) &
-		    softirq_mask(smp_processor_id())) {
-                        do_softirq();
-                        __sti();
-                        if (!current->need_resched)
-                                continue;
-                }
                 if (current->need_resched) {
                         schedule();
                         check_pgt_cache();
@@ -215,7 +206,7 @@
 void show_regs(struct pt_regs *regs)
 {
 	char buff[80];
-	int line;
+	int i, line;
 
         printk("CPU:    %d\n",smp_processor_id());
         printk("Process %s (pid: %d, stackpage=%08X)\n",
@@ -223,6 +214,17 @@
 	
 	for (line = 0; sprintf_regs(line, buff, current, regs); line++)
 		printk(buff);
+
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+	{
+		printk("User Code:\n");
+		memset(buff, 0, 20);
+		copy_from_user(buff,
+			       (char *) (regs->psw.addr & PSW_ADDR_MASK), 20);
+		for (i = 0; i < 20; i++)
+			printk("%02x ", buff[i]);
+		printk("\n");
+	}
 }
 
 char *task_show_regs(struct task_struct *task, char *buffer)
@@ -307,11 +309,11 @@
 
         frame = (struct stack_frame *) (2*PAGE_SIZE + (unsigned long) p) -1;
         frame = (struct stack_frame *) (((unsigned long) frame)&-8L);
-        p->thread.regs = &frame->childregs;
+        p->thread.regs = (struct pt_regs *)&frame->childregs;
         p->thread.ksp = (unsigned long) frame;
-        frame->childregs = *regs;
+        memcpy(&frame->childregs,regs,sizeof(struct pt_regs));
         frame->childregs.gprs[15] = new_stackp;
-        frame->eos = 0;
+        frame->back_chain = frame->eos = 0;
 
         /* new return point is ret_from_sys_call */
         frame->gprs[8] = ((unsigned long) &ret_from_fork) | 0x80000000;
@@ -330,28 +332,19 @@
 
 asmlinkage int sys_fork(struct pt_regs regs)
 {
-        int ret;
-
-        lock_kernel();
-        ret = do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
-        unlock_kernel();
-        return ret;
+        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
 }
 
 asmlinkage int sys_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
-        int ret;
 
-        lock_kernel();
         clone_flags = regs.gprs[3];
         newsp = regs.orig_gpr2;
         if (!newsp)
                 newsp = regs.gprs[15];
-        ret = do_fork(clone_flags, newsp, &regs, 0);
-        unlock_kernel();
-        return ret;
+        return do_fork(clone_flags, newsp, &regs, 0);
 }
 
 /*
@@ -466,54 +459,3 @@
 #undef last_sched
 #undef first_sched
 
-/*
- * This should be safe even if called from tq_scheduler
- * A typical mask would be sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM) or 0.
- *
- */
-void s390_daemonize(char *name,unsigned long mask,int use_init_fs)
-{
-	struct fs_struct *fs;
-	extern struct task_struct *child_reaper;
-	struct task_struct *this_process=current;
-	
-	/*
-	 * If we were started as result of loading a module, close all of the
-	 * user space pages.  We don't need them, and if we didn't close them
-	 * they would be locked into memory.
-	 */
-	exit_mm(current);
-
-	this_process->session = 1;
-	this_process->pgrp = 1;
-	if(name)
-	{
-		strncpy(current->comm,name,15);
-		current->comm[15]=0;
-	}
-	else
-		current->comm[0]=0;
-	/* set signal mask to what we want to respond */
-        siginitsetinv(&current->blocked,mask);
-	/* exit_signal isn't set up */
-        /* if we inherit from cpu idle  */
-	this_process->exit_signal=SIGCHLD;
-	/* if priority=0 schedule can go into a tight loop */
-	this_process->policy= SCHED_OTHER;
-	/* nice goes priority=20-nice; */
-	this_process->nice=10;
-	if(use_init_fs)
-	{
-		exit_fs(this_process);	/* current->fs->count--; */
-		fs = init_task.fs;
-		current->fs = fs;
-		atomic_inc(&fs->count);
-		exit_files(current);
-	}
-	write_lock_irq(&tasklist_lock);
-	/* We want init as our parent */
-	REMOVE_LINKS(this_process);
-	this_process->p_opptr=this_process->p_pptr=child_reaper;
-	SET_LINKS(this_process);
-	write_unlock_irq(&tasklist_lock);
-}
diff -urN linux/arch/s390/kernel/s390_ext.c linux-2.4.7/arch/s390/kernel/s390_ext.c
--- linux/arch/s390/kernel/s390_ext.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/s390_ext.c	Mon Dec 17 13:42:41 2001
@@ -9,7 +9,7 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <asm/lowcore.h>
 #include <asm/s390_ext.h>
 
@@ -17,12 +17,13 @@
  * Simple hash strategy: index = code & 0xff;
  * ext_int_hash[index] is the start of the list for all external interrupts
  * that hash to this index. With the current set of external interrupts 
- * (0x1202 external call, 0x1004 cpu timer, 0x2401 hwc console and 0x4000
- * iucv) this is always the first element. 
+ * (0x1202 external call, 0x1004 cpu timer, 0x2401 hwc console, 0x4000
+ * iucv and 0x2603 pfault) this is always the first element. 
  */
 ext_int_info_t *ext_int_hash[256] = { 0, };
 ext_int_info_t ext_int_info_timer;
 ext_int_info_t ext_int_info_hwc;
+ext_int_info_t ext_int_pfault;
 
 int register_external_interrupt(__u16 code, ext_int_handler_t handler) {
         ext_int_info_t *p;
@@ -39,7 +40,9 @@
                 p = &ext_int_info_timer;
         else if (code == 0x2401) /* hwc_init is done too early too */
                 p = &ext_int_info_hwc;
-        else
+        else if (code == 0x2603) /* pfault_init is done too early too */
+		p = &ext_int_pfault;
+	else
                 p = (ext_int_info_t *)
                           kmalloc(sizeof(ext_int_info_t), GFP_ATOMIC);
         if (p == NULL)
@@ -70,7 +73,7 @@
                 q->next = p->next;
         else
                 ext_int_hash[index] = p->next;
-        if (code != 0x1004 && code != 0x2401)
+        if (code != 0x1004 && code != 0x2401 && code != 0x2603)
                 kfree(p);
         return 0;
 }
diff -urN linux/arch/s390/kernel/s390_ksyms.c linux-2.4.7/arch/s390/kernel/s390_ksyms.c
--- linux/arch/s390/kernel/s390_ksyms.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/s390_ksyms.c	Mon Dec 17 13:41:49 2001
@@ -15,11 +15,11 @@
 /*
  * memory management
  */
-EXPORT_SYMBOL(_oi_bitmap);
-EXPORT_SYMBOL(_ni_bitmap);
-EXPORT_SYMBOL(_zb_findmap);
-EXPORT_SYMBOL(__copy_from_user_fixup);
-EXPORT_SYMBOL(__copy_to_user_fixup);
+EXPORT_SYMBOL_NOVERS(_oi_bitmap);
+EXPORT_SYMBOL_NOVERS(_ni_bitmap);
+EXPORT_SYMBOL_NOVERS(_zb_findmap);
+EXPORT_SYMBOL_NOVERS(__copy_from_user_fixup);
+EXPORT_SYMBOL_NOVERS(__copy_to_user_fixup);
 
 /*
  * semaphore ops
@@ -43,6 +43,7 @@
 EXPORT_SYMBOL_NOVERS(strncpy);
 EXPORT_SYMBOL_NOVERS(strnlen);
 EXPORT_SYMBOL_NOVERS(strrchr);
+EXPORT_SYMBOL_NOVERS(strstr);
 EXPORT_SYMBOL_NOVERS(strtok);
 EXPORT_SYMBOL_NOVERS(strpbrk);
 
@@ -53,6 +54,9 @@
 EXPORT_SYMBOL(__udelay);
 EXPORT_SYMBOL(kernel_thread);
 EXPORT_SYMBOL(csum_fold);
+EXPORT_SYMBOL(console_mode);
+EXPORT_SYMBOL(console_device);
+EXPORT_SYMBOL_NOVERS(do_call_softirq);
 
 #if CONFIG_IP_MULTICAST
 /* Required for lcs gigabit ethernet multicast support */
diff -urN linux/arch/s390/kernel/setup.c linux-2.4.7/arch/s390/kernel/setup.c
--- linux/arch/s390/kernel/setup.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/setup.c	Mon Dec 17 13:42:41 2001
@@ -43,8 +43,13 @@
 /*
  * Machine setup..
  */
+unsigned int console_mode = 0;
+unsigned int console_device = -1;
 unsigned long memory_size = 0;
 unsigned long machine_flags = 0;
+struct { unsigned long addr, size, type; } memory_chunk[16];
+#define CHUNK_READ_WRITE 0
+#define CHUNK_READ_ONLY 1
 __u16 boot_cpu_addr;
 int cpus_initialized = 0;
 unsigned long cpu_initialized = 0;
@@ -141,6 +146,93 @@
 __setup("vmpoff=", vmpoff_setup);
 
 /*
+ * condev= and conmode= setup parameter.
+ */
+
+static int __init condev_setup(char *str)
+{
+	int vdev;
+
+	vdev = simple_strtoul(str, &str, 0);
+	if (vdev >= 0 && vdev < 65536)
+		console_device = vdev;
+	return 1;
+}
+
+__setup("condev=", condev_setup);
+
+static int __init conmode_setup(char *str)
+{
+#if defined(CONFIG_HWC_CONSOLE)
+	if (strncmp(str, "hwc", 4) == 0 && !MACHINE_IS_P390)
+                SET_CONSOLE_HWC;
+#endif
+#if defined(CONFIG_TN3215_CONSOLE)
+	if (strncmp(str, "3215", 5) == 0 && (MACHINE_IS_VM || MACHINE_IS_P390))
+		SET_CONSOLE_3215;
+#endif
+#if defined(CONFIG_TN3270_CONSOLE)
+	if (strncmp(str, "3270", 5) == 0 && (MACHINE_IS_VM || MACHINE_IS_P390))
+		SET_CONSOLE_3270;
+#endif
+        return 1;
+}
+
+__setup("conmode=", conmode_setup);
+
+static void __init conmode_default(void)
+{
+	char query_buffer[1024];
+	char *ptr;
+
+        if (MACHINE_IS_VM) {
+		cpcmd("QUERY TERM", query_buffer, 1024);
+		ptr = strstr(query_buffer, "CONMODE");
+		/*
+		 * Set the conmode to 3215 so that the device recognition 
+		 * will set the cu_type of the console to 3215. If the
+		 * conmode is 3270 and we don't set it back then both
+		 * 3215 and the 3270 driver will try to access the console
+		 * device (3215 as console and 3270 as normal tty).
+		 */
+		cpcmd("TERM CONMODE 3215", NULL, 0);
+		if (ptr == NULL) {
+#if defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+			return;
+		}
+		if (strncmp(ptr + 8, "3270", 4) == 0) {
+#if defined(CONFIG_TN3270_CONSOLE)
+			SET_CONSOLE_3270;
+#elif defined(CONFIG_TN3215_CONSOLE)
+			SET_CONSOLE_3215;
+#elif defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+		} else if (strncmp(ptr + 8, "3215", 4) == 0) {
+#if defined(CONFIG_TN3215_CONSOLE)
+			SET_CONSOLE_3215;
+#elif defined(CONFIG_TN3270_CONSOLE)
+			SET_CONSOLE_3270;
+#elif defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+		}
+        } else if (MACHINE_IS_P390) {
+#if defined(CONFIG_TN3215_CONSOLE)
+		SET_CONSOLE_3215;
+#elif defined(CONFIG_TN3270_CONSOLE)
+		SET_CONSOLE_3270;
+#endif
+	} else {
+#if defined(CONFIG_HWC_CONSOLE)
+		SET_CONSOLE_HWC;
+#endif
+	}
+}
+
+/*
  * Reboot, halt and power_off routines for non SMP.
  */
 
@@ -169,6 +261,8 @@
  * Setup function called from init/main.c just after the banner
  * was printed.
  */
+extern char _pstart, _pend, _stext;
+
 void __init setup_arch(char **cmdline_p)
 {
         unsigned long bootmap_size;
@@ -178,20 +272,13 @@
 	unsigned long start_pfn, end_pfn;
         static unsigned int smptrap=0;
         unsigned long delay = 0;
+	struct _lowcore *lowcore;
+	int i;
 
         if (smptrap)
                 return;
         smptrap=1;
 
-        printk("Command line is: %s\n", COMMAND_LINE);
-
-        /*
-         * Setup lowcore information for boot cpu
-         */
-        cpu_init();
-        boot_cpu_addr = S390_lowcore.cpu_data.cpu_addr;
-        __cpu_logical_map[0] = boot_cpu_addr;
-
         /*
          * print what head.S has found out about the machine 
          */
@@ -204,7 +291,7 @@
 
         ROOT_DEV = to_kdev_t(0x0100);
         memory_start = (unsigned long) &_end;    /* fixit if use $CODELO etc*/
-	memory_end = memory_size;
+	memory_end = memory_size & ~0x400000UL;  /* align memory end to 4MB */
         /*
          * We need some free virtual space to be able to do vmalloc.
          * On a machine with 2GB memory we make sure that we have at
@@ -244,7 +331,6 @@
                  * "ipldelay=XXX[sm]" sets ipl delay in seconds or minutes
                  */
                 if (c == ' ' && strncmp(from, "ipldelay=", 9) == 0) {
-			if (to != command_line) to--;
                         delay = simple_strtoul(from+9, &from, 0);
 			if (*from == 's' || *from == 'S') {
 				delay = delay*1000000;
@@ -253,7 +339,7 @@
 				delay = delay*60*1000000;
 				from++;
 			}
-			/* now wait for the requestedn amount of time */
+			/* now wait for the requested amount of time */
 			udelay(delay);
                 }
                 cn = *(from++);
@@ -261,6 +347,8 @@
                         break;
                 if (cn == '\n')
                         cn = ' ';  /* replace newlines with space */
+		if (cn == 0x0d)
+			cn = ' ';  /* replace 0x0d with space */
                 if (cn == ' ' && c == ' ')
                         continue;  /* remove additional spaces */
                 c = cn;
@@ -285,10 +373,25 @@
 	bootmap_size = init_bootmem(start_pfn, end_pfn);
 
 	/*
-	 * Register RAM pages with the bootmem allocator.
+	 * Register RAM areas with the bootmem allocator.
 	 */
-	free_bootmem(start_pfn << PAGE_SHIFT, 
-		     (end_pfn - start_pfn) << PAGE_SHIFT);
+	for (i = 0; i < 16 && memory_chunk[i].size > 0; i++) {
+		unsigned long start_chunk, end_chunk;
+
+		if (memory_chunk[i].type != CHUNK_READ_WRITE)
+			continue;
+		start_chunk = (memory_chunk[i].addr + PAGE_SIZE - 1);
+		start_chunk >>= PAGE_SHIFT;
+		end_chunk = (memory_chunk[i].addr + memory_chunk[i].size);
+		end_chunk >>= PAGE_SHIFT;
+		if (start_chunk < start_pfn)
+			start_chunk = start_pfn;
+		if (end_chunk > end_pfn)
+			end_chunk = end_pfn;
+		if (start_chunk < end_chunk)
+			free_bootmem(start_chunk << PAGE_SHIFT,
+				     (end_chunk - start_chunk) << PAGE_SHIFT);
+	}
 
         /*
          * Reserve the bootmem bitmap itself as well. We do this in two
@@ -313,6 +416,36 @@
         }
 #endif
 
+        /*
+         * Setup lowcore for boot cpu
+         */
+	lowcore = (struct _lowcore *)
+		__alloc_bootmem(PAGE_SIZE, PAGE_SIZE, 0);
+	memset(lowcore, 0, PAGE_SIZE);
+	lowcore->restart_psw.mask = _RESTART_PSW_MASK;
+	lowcore->restart_psw.addr = _ADDR_31 + (addr_t) &restart_int_handler;
+	lowcore->external_new_psw.mask = _EXT_PSW_MASK;
+	lowcore->external_new_psw.addr = _ADDR_31 + (addr_t) &ext_int_handler;
+	lowcore->svc_new_psw.mask = _SVC_PSW_MASK;
+	lowcore->svc_new_psw.addr = _ADDR_31 + (addr_t) &system_call;
+	lowcore->program_new_psw.mask = _PGM_PSW_MASK;
+	lowcore->program_new_psw.addr = _ADDR_31 + (addr_t) &pgm_check_handler;
+        lowcore->mcck_new_psw.mask = _MCCK_PSW_MASK;
+	lowcore->mcck_new_psw.addr = _ADDR_31 + (addr_t) &mcck_int_handler;
+	lowcore->io_new_psw.mask = _IO_PSW_MASK;
+	lowcore->io_new_psw.addr = _ADDR_31 + (addr_t) &io_int_handler;
+	lowcore->ipl_device = S390_lowcore.ipl_device;
+	lowcore->kernel_stack = ((__u32) &init_task_union) + 8192;
+	lowcore->async_stack = (__u32)
+		__alloc_bootmem(2*PAGE_SIZE, 2*PAGE_SIZE, 0) + 8192;
+	set_prefix((__u32) lowcore);
+        cpu_init();
+        boot_cpu_addr = S390_lowcore.cpu_data.cpu_addr;
+        __cpu_logical_map[0] = boot_cpu_addr;
+
+	/*
+	 * Create kernel page tables and switch to virtual addressing.
+	 */
         paging_init();
 
 	res = alloc_bootmem_low(sizeof(struct resource));
@@ -322,6 +455,9 @@
 	request_resource(&iomem_resource, res);
 	request_resource(res, &code_resource);
 	request_resource(res, &data_resource);
+
+        /* Setup default console */
+	conmode_default();
 }
 
 void print_cpu_info(struct cpuinfo_S390 *cpuinfo)
diff -urN linux/arch/s390/kernel/signal.c linux-2.4.7/arch/s390/kernel/signal.c
--- linux/arch/s390/kernel/signal.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/signal.c	Mon Dec 17 13:41:18 2001
@@ -12,6 +12,7 @@
  *  1997-11-28  Modified for POSIX.1b signals by Richard Henderson
  */
 
+#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -26,28 +27,21 @@
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 
-#define DEBUG_SIG 0
-
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-/* pretcode & sig are used to store the return addr on Intel
-   & the signal no as the first parameter we do this differently
-   using gpr14 & gpr2. */
-
-#define SIGFRAME_COMMON \
-__u8     callee_used_stack[__SIGNAL_FRAMESIZE]; \
-struct sigcontext sc; \
-_sigregs sregs; \
-__u8 retcode[S390_SYSCALL_SIZE];
 
 typedef struct 
 {
-	SIGFRAME_COMMON
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE];
+	struct sigcontext sc;
+	_sigregs sregs;
+	__u8 retcode[S390_SYSCALL_SIZE];
 } sigframe;
 
 typedef struct 
 {
-	SIGFRAME_COMMON
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE];
+	__u8 retcode[S390_SYSCALL_SIZE];
 	struct siginfo info;
 	struct ucontext uc;
 } rt_sigframe;
@@ -205,7 +199,7 @@
 	err=__copy_from_user(regs,&sregs->regs,sizeof(_s390_regs_common));
 	if(!err)
 	{
-		regs->orig_gpr2 = -1;		/* disable syscall checks */
+		regs->trap = -1;		/* disable syscall checks */
 		regs->psw.mask=(saved_psw.mask&~PSW_MASK_DEBUGCHANGE)|
 		(regs->psw.mask&PSW_MASK_DEBUGCHANGE);
 		regs->psw.addr=(saved_psw.addr&~PSW_ADDR_DEBUGCHANGE)|
@@ -217,53 +211,51 @@
 	return(err);
 }
 
-static int
-restore_sigcontext(struct sigcontext *sc, struct pt_regs *regs,
-		 _sigregs *sregs,sigset_t *set)
-{
-	unsigned int err;
-
-	err=restore_sigregs(regs,sregs);
-	if(!err)
-		err=__copy_from_user(&set->sig,&sc->oldmask,_SIGMASK_COPY_SIZE);
-		return(err);
-}
-
-int sigreturn_common(struct pt_regs *regs,int framesize)
+asmlinkage long sys_sigreturn(struct pt_regs *regs)
 {
 	sigframe *frame = (sigframe *)regs->gprs[15];
 	sigset_t set;
 
 	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
-		return -1;
-	if (restore_sigcontext(&frame->sc,regs,&frame->sregs,&set))
-	        return -1;
+		goto badframe;
+	if (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE))
+		goto badframe;
+
 	sigdelsetmask(&set, ~_BLOCKABLE);
 	spin_lock_irq(&current->sigmask_lock);
 	current->blocked = set;
 	recalc_sigpending(current);
 	spin_unlock_irq(&current->sigmask_lock);
-	return 0;
-}
-
-asmlinkage int sys_sigreturn(struct pt_regs *regs)
-{
 
-	if (sigreturn_common(regs,sizeof(sigframe)))
+	if (restore_sigregs(regs, &frame->sregs))
 		goto badframe;
+
 	return regs->gprs[2];
 
 badframe:
 	force_sig(SIGSEGV, current);
 	return 0;
-}	
+}
 
-asmlinkage int sys_rt_sigreturn(struct pt_regs *regs)
+asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
 {
 	rt_sigframe *frame = (rt_sigframe *)regs->gprs[15];
+	sigset_t set;
+
+	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__copy_from_user(&set.sig, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sigmask_lock);
+	current->blocked = set;
+	recalc_sigpending(current);
+	spin_unlock_irq(&current->sigmask_lock);
 
-	if (sigreturn_common(regs,sizeof(rt_sigframe)))
+	if (restore_sigregs(regs, &frame->uc.uc_mcontext))
 		goto badframe;
+
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
 	do_sigaltstack(&frame->uc.uc_stack, NULL, regs->gprs[15]);
@@ -272,7 +264,7 @@
 badframe:
 	force_sig(SIGSEGV, current);
 	return 0;
-}	
+}
 
 /*
  * Set up a signal frame.
@@ -306,58 +298,54 @@
 	return (void *)((sp - frame_size) & -8ul);
 }
 
-static void *setup_frame_common(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs,
-				int frame_size,u16 retcode)
+static inline int map_signal(int sig)
 {
-	sigframe *frame;
-	int err;
+	if (current->exec_domain
+	    && current->exec_domain->signal_invmap
+	    && sig < 32)
+		return current->exec_domain->signal_invmap[sig];
+	else
+		return sig;
+}
 
-	frame = get_sigframe(ka, regs,frame_size);
-	if (!access_ok(VERIFY_WRITE, frame,frame_size))
-		return 0;
-	err = save_sigregs(regs,&frame->sregs);
-	if(!err)
-		err=__put_user(&frame->sregs,&frame->sc.sregs);
-	if(!err)
+static void setup_frame(int sig, struct k_sigaction *ka,
+			sigset_t *set, struct pt_regs * regs)
+{
+	sigframe *frame = get_sigframe(ka, regs, sizeof(sigframe));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(sigframe)))
+		goto give_sigsegv;
+
+	if (__copy_to_user(&frame->sc.oldmask, &set->sig, _SIGMASK_COPY_SIZE))
+		goto give_sigsegv;
+
+	if (save_sigregs(regs, &frame->sregs))
+		goto give_sigsegv;
+	if (__put_user(&frame->sregs, &frame->sc.sregs))
+		goto give_sigsegv;
 
-		err=__copy_to_user(&frame->sc.oldmask,&set->sig,_SIGMASK_COPY_SIZE);
-	if(!err)
-	{
-		regs->gprs[2]=(current->exec_domain
-		           && current->exec_domain->signal_invmap
-		           && sig < 32
-		           ? current->exec_domain->signal_invmap[sig]
-		           : sig);
-		/* Set up registers for signal handler */
-		regs->gprs[15] = (addr_t)frame;
-		regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
-	}
 	/* Set up to return from userspace.  If provided, use a stub
 	   already in userspace.  */
 	if (ka->sa.sa_flags & SA_RESTORER) {
                 regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
 	} else {
                 regs->gprs[14] = FIX_PSW(frame->retcode);
-		err |= __put_user(retcode, (u16 *)(frame->retcode));
+		if (__put_user(S390_SYSCALL_OPCODE | __NR_sigreturn, 
+	                       (u16 *)(frame->retcode)))
+			goto give_sigsegv;
 	}
-	return(err ? 0:frame);
-}
 
-static void setup_frame(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs)
-{
-	sigframe *frame;
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK;
 
-	if((frame=setup_frame_common(sig,ka,set,regs,sizeof(sigframe),
-		    (S390_SYSCALL_OPCODE|__NR_sigreturn)))==0)
-		goto give_sigsegv;
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
-	/* Martin wants this for pthreads */
+	regs->gprs[2] = map_signal(sig);
 	regs->gprs[3] = (addr_t)&frame->sc;
+
+	/* We forgot to include these in the sigcontext.
+	   To avoid breaking binary compatibility, they are passed as args. */
+	regs->gprs[4] = current->thread.trap_no;
+	regs->gprs[5] = current->thread.prot_addr;
 	return;
 
 give_sigsegv:
@@ -369,34 +357,44 @@
 static void setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
 			   sigset_t *set, struct pt_regs * regs)
 {
-	rt_sigframe *frame;
-	addr_t      orig_sp=regs->gprs[15];
-	int err;
+	int err = 0;
+	rt_sigframe *frame = get_sigframe(ka, regs, sizeof(rt_sigframe));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(rt_sigframe)))
+		goto give_sigsegv;
 
-	if((frame=setup_frame_common(sig,ka,set,regs,sizeof(rt_sigframe),
-		    (S390_SYSCALL_OPCODE|__NR_rt_sigreturn)))==0)
+	if (copy_siginfo_to_user(&frame->info, info))
 		goto give_sigsegv;
-	
-	err = copy_siginfo_to_user(&frame->info, info);
 
 	/* Create the ucontext.  */
 	err |= __put_user(0, &frame->uc.uc_flags);
 	err |= __put_user(0, &frame->uc.uc_link);
 	err |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
-	err |= __put_user(sas_ss_flags(orig_sp),
+	err |= __put_user(sas_ss_flags(regs->gprs[15]),
 			  &frame->uc.uc_stack.ss_flags);
 	err |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);
-	err |= __put_user(&frame->sc,&frame->uc.sc);
-	regs->gprs[3] = (addr_t)&frame->info;
-	regs->gprs[4] = (addr_t)&frame->uc;
-
+	err |= save_sigregs(regs, &frame->uc.uc_mcontext);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 	if (err)
 		goto give_sigsegv;
 
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
+	/* Set up to return from userspace.  If provided, use a stub
+	   already in userspace.  */
+	if (ka->sa.sa_flags & SA_RESTORER) {
+                regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
+	} else {
+                regs->gprs[14] = FIX_PSW(frame->retcode);
+		err |= __put_user(S390_SYSCALL_OPCODE | __NR_rt_sigreturn, 
+	                          (u16 *)(frame->retcode));
+	}
+
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK;
+
+	regs->gprs[2] = map_signal(sig);
+	regs->gprs[3] = (addr_t)&frame->info;
+	regs->gprs[4] = (addr_t)&frame->uc;
 	return;
 
 give_sigsegv:
@@ -414,7 +412,7 @@
 	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
 {
 	/* Are we from a system call? */
-	if (regs->orig_gpr2 >= 0) {
+	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
 		switch (regs->gprs[2]) {
 			case -ERESTARTNOHAND:
@@ -561,7 +559,6 @@
                                 /* FALLTHRU */
 
 			default:
-				lock_kernel();
 				sigaddset(&current->pending.signal, signr);
 				recalc_sigpending(current);
 				current->flags |= PF_SIGNALED;
diff -urN linux/arch/s390/kernel/smp.c linux-2.4.7/arch/s390/kernel/smp.c
--- linux/arch/s390/kernel/smp.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390/kernel/smp.c	Mon Dec 17 13:42:41 2001
@@ -92,6 +92,95 @@
 
 extern void reipl(unsigned long devno);
 
+static sigp_ccode smp_ext_bitcall(int, ec_bit_sig);
+static void smp_ext_bitcall_others(ec_bit_sig);
+
+/*
+ * Structure and data for smp_call_function(). This is designed to minimise
+ * static memory requirements. It also looks cleaner.
+ */
+static spinlock_t call_lock = SPIN_LOCK_UNLOCKED;
+
+struct call_data_struct {
+	void (*func) (void *info);
+	void *info;
+	atomic_t started;
+	atomic_t finished;
+	int wait;
+};
+
+static struct call_data_struct * call_data;
+
+/*
+ * 'Call function' interrupt callback
+ */
+static void do_call_function(void)
+{
+	void (*func) (void *info) = call_data->func;
+	void *info = call_data->info;
+	int wait = call_data->wait;
+
+	atomic_inc(&call_data->started);
+	(*func)(info);
+	if (wait)
+		atomic_inc(&call_data->finished);
+}
+
+/*
+ * this function sends a 'generic call function' IPI to all other CPUs
+ * in the system.
+ */
+
+int smp_call_function (void (*func) (void *info), void *info, int nonatomic,
+			int wait)
+/*
+ * [SUMMARY] Run a function on all other CPUs.
+ * <func> The function to run. This must be fast and non-blocking.
+ * <info> An arbitrary pointer to pass to the function.
+ * <nonatomic> currently unused.
+ * <wait> If true, wait (atomically) until function has completed on other CPUs.
+ * [RETURNS] 0 on success, else a negative status code. Does not return until
+ * remote CPUs are nearly ready to execute <<func>> or are or have executed.
+ *
+ * You must not call this function with disabled interrupts or from a
+ * hardware interrupt handler, you may call it from a bottom half handler.
+ */
+{
+	struct call_data_struct data;
+	int cpus = smp_num_cpus-1;
+
+	if (!cpus || !atomic_read(&smp_commenced))
+		return 0;
+
+	data.func = func;
+	data.info = info;
+	atomic_set(&data.started, 0);
+	data.wait = wait;
+	if (wait)
+		atomic_set(&data.finished, 0);
+
+	spin_lock_bh(&call_lock);
+	call_data = &data;
+	/* Send a message to all other CPUs and wait for them to respond */
+        smp_ext_bitcall_others(ec_call_function);
+
+	/* Wait for response */
+	while (atomic_read(&data.started) != cpus)
+		barrier();
+
+	if (wait)
+		while (atomic_read(&data.finished) != cpus)
+			barrier();
+	spin_unlock_bh(&call_lock);
+
+	return 0;
+}
+
+
+/*
+ * Various special callbacks
+ */
+
 void do_machine_restart(void)
 {
         smp_send_stop();
@@ -148,7 +237,6 @@
 
 void do_ext_call_interrupt(struct pt_regs *regs, __u16 code)
 {
-        ec_ext_call *ec, *next;
         int bits;
 
         /*
@@ -169,131 +257,15 @@
 		do_machine_halt();
         if (test_bit(ec_power_off, &bits))
 		do_machine_power_off();
-	if (test_bit(ec_ptlb, &bits))
-	        local_flush_tlb();
-
-        /*
-         * Handle external call commands with a parameter area
-         */
-        do {
-                ec = (ec_ext_call *) atomic_read(&S390_lowcore.ext_call_queue);
-        } while (atomic_compare_and_swap((int) ec, 0,
-                                         &S390_lowcore.ext_call_queue));
-        if (ec == NULL)
-                return;   /* no command signals */
-
-        /* Make a fifo out of the lifo */
-        next = ec->next;
-        ec->next = NULL;
-        while (next != NULL) {
-                ec_ext_call *tmp = next->next;
-                next->next = ec;
-                ec = next;
-                next = tmp;
-        }
-
-        /* Execute every sigp command on the queue */
-        while (ec != NULL) {
-                switch (ec->cmd) {
-                case ec_callback_async: {
-                        void (*func)(void *info);
-                        void *info;
-
-                        func = ec->func;
-                        info = ec->info;
-                        atomic_set(&ec->status,ec_executing);
-                        (func)(info);
-                        return;
-                }
-                case ec_callback_sync:
-                        atomic_set(&ec->status,ec_executing);
-                        (ec->func)(ec->info);
-                        atomic_set(&ec->status,ec_done);
-                        return;
-                default:
-                }
-                ec = ec->next;
-        }
-}
-
-/*
- * Send a callback sigp to another cpu.
- */
-sigp_ccode
-smp_ext_call(int cpu, void (*func)(void *info), void *info, int wait)
-{
-        struct _lowcore *lowcore = &get_cpu_lowcore(cpu);
-        sigp_ccode ccode;
-        ec_ext_call ec;
-
-        ec.cmd = wait ? ec_callback_sync : ec_callback_async;
-        atomic_set(&ec.status, ec_pending);
-	ec.func = func;
-        ec.info = info;
-        do {
-                ec.next = (ec_ext_call*) atomic_read(&lowcore->ext_call_queue);
-        } while (atomic_compare_and_swap((int) ec.next, (int)(&ec),
-                                         &lowcore->ext_call_queue));
-        /*
-         * We try once to deliver the signal. There are four possible
-         * return codes:
-         * 0) Order code accepted - can't show up on an external call
-         * 1) Status stored - fine, wait for completion.
-         * 2) Busy - there is another signal pending. Thats fine too, because
-         *    do_ext_call from the pending signal will execute all signals on
-         *    the queue. We wait for completion.
-         * 3) Not operational - something very bad has happened to the cpu.
-         *    do not wait for completion.
-         */
-        ccode = signal_processor(cpu, sigp_external_call);
-
-        if (ccode != sigp_not_operational)
-                /* wait for completion, FIXME: possible seed of a deadlock */
-                while (atomic_read(&ec.status) != (wait?ec_done:ec_executing));
-
-        return ccode;
-}
-
-/*
- * Send a callback sigp to every other cpu in the system.
- */
-void smp_ext_call_others(void (*func)(void *info), void *info, int wait)
-{
-        struct _lowcore *lowcore;
-        ec_ext_call ec[NR_CPUS];
-        sigp_ccode ccode;
-        int i;
-
-        for (i = 0; i < smp_num_cpus; i++) {
-                if (smp_processor_id() == i)
-                        continue;
-                lowcore = &get_cpu_lowcore(i);
-		ec[i].cmd = wait ? ec_callback_sync : ec_callback_async;
-		atomic_set(&ec[i].status, ec_pending);
-		ec[i].func = func;
-		ec[i].info = info;
-                do {
-                        ec[i].next = (ec_ext_call *)
-                                        atomic_read(&lowcore->ext_call_queue);
-                } while (atomic_compare_and_swap((int) ec[i].next, (int)(ec+i),
-                                                 &lowcore->ext_call_queue));
-                ccode = signal_processor(i, sigp_external_call);
-        }
-
-        /* wait for completion, FIXME: possible seed of a deadlock */
-        for (i = 0; i < smp_num_cpus; i++) {
-                if (smp_processor_id() == i)
-                        continue;
-                while (atomic_read(&ec[i].status) != 
-		       (wait ? ec_done:ec_executing));
-        }
+	if (test_bit(ec_call_function, &bits)) 
+		do_call_function();
 }
 
 /*
  * Send an external call sigp to another cpu and return without waiting
  * for its completion.
  */
-sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig)
+static sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig)
 {
         struct _lowcore *lowcore = &get_cpu_lowcore(cpu);
         sigp_ccode ccode;
@@ -310,7 +282,7 @@
  * Send an external call sigp to every other cpu in the system and
  * return without waiting for its completion.
  */
-void smp_ext_bitcall_others(ec_bit_sig sig)
+static void smp_ext_bitcall_others(ec_bit_sig sig)
 {
         struct _lowcore *lowcore;
         sigp_ccode ccode;
@@ -329,51 +301,6 @@
 }
 
 /*
- * cycles through all the cpus,
- * returns early if info is not NULL & the processor has something
- * of intrest to report in the info structure.
- * it returns the next cpu to check if it returns early.
- * i.e. it should be used as follows if you wish to receive info.
- * next_cpu=0;
- * do
- * {
- *    info->cpu=next_cpu;
- *    next_cpu=smp_signal_others(order_code,parameter,1,info);
- *    ... check info here
- * } while(next_cpu<=smp_num_cpus)
- *
- *  if you are lazy just use it like
- * smp_signal_others(order_code,parameter,0,1,NULL);
- */
-int smp_signal_others(sigp_order_code order_code, u32 parameter,
-                      int spin, sigp_info *info)
-{
-        sigp_ccode   ccode;
-        u32          dummy;
-        u16          i;
-
-        if (info)
-                info->intresting = 0;
-        for (i = (info ? info->cpu : 0); i < smp_num_cpus; i++) {
-                if (smp_processor_id() != i) {
-                        do {
-                                ccode = signal_processor_ps(
-                                        (info ? &info->status : &dummy),
-                                        parameter, i, order_code);
-                        } while(spin && ccode == sigp_busy);
-                        if (info && ccode != sigp_order_code_accepted) {
-                                info->intresting = 1;
-                                info->cpu = i;
-                                info->ccode = ccode;
-                                i++;
-                                break;
-                        }
-                }
-        }
-        return i;
-}
-
-/*
  * this function sends a 'stop' sigp to all other CPUs in the system.
  * it goes straight through.
  */
@@ -390,7 +317,18 @@
 
         /* stop all processors */
 
-        smp_signal_others(sigp_stop, 0, 1, NULL);
+        for (i =  0; i < smp_num_cpus; i++) {
+                if (smp_processor_id() != i) {
+                        int ccode;
+                        do {
+                                ccode = signal_processor_ps(
+                                   &dummy,
+                                   0,
+                                   i,
+                                   sigp_stop);
+                        } while(ccode == sigp_busy);
+                }
+        }
 
         /* store status of all processors in their lowcores (real 0) */
 
@@ -419,7 +357,7 @@
 
 void smp_ptlb_all(void)
 {
-        smp_ext_call_others(smp_ptlb_callback, NULL, 1);
+        smp_call_function(smp_ptlb_callback, NULL, 0, 1);
 	local_flush_tlb();
 }
 
@@ -482,7 +420,7 @@
                 parms.end_ctl = cr;
                 parms.orvals[cr] = 1 << bit;
                 parms.andvals[cr] = 0xFFFFFFFF;
-                smp_ext_call_others(smp_ctl_bit_callback, &parms, 1);
+                smp_call_function(smp_ctl_bit_callback, &parms, 0, 1);
         }
         __ctl_set_bit(cr, bit);
 }
@@ -498,36 +436,12 @@
                 parms.end_ctl = cr;
                 parms.orvals[cr] = 0x00000000;
                 parms.andvals[cr] = ~(1 << bit);
-                smp_ext_call_others(smp_ctl_bit_callback, &parms, 1);
+                smp_call_function(smp_ctl_bit_callback, &parms, 0, 1);
         }
         __ctl_clear_bit(cr, bit);
 }
 
 /*
- * Call a function on all other processors
- */
-
-int
-smp_call_function(void (*func)(void *info), void *info, int retry, int wait)
-/*
- * [SUMMARY] Run a function on all other CPUs.
- * <func> The function to run. This must be fast and non-blocking.
- * <info> An arbitrary pointer to pass to the function.
- * <retry> currently unused.
- * <wait> If true, wait (atomically) until function has completed on other CPUs.
- * [RETURNS] 0 on success, else a negative status code. Does not return until
- * remote CPUs are nearly ready to execute <<func>> or are or have executed.
- *
- * You must not call this function with disabled interrupts or from a
- * hardware interrupt handler, you may call it from a bottom half handler.
- */
-{
-        if (atomic_read(&smp_commenced) != 0)
-                smp_ext_call_others(func, info, wait);
-        return 0;
-}
-
-/*
  * Lets check how many CPUs we have.
  */
 
@@ -556,6 +470,8 @@
  *      Activate a secondary processor.
  */
 extern void init_100hz_timer(void);
+extern int pfault_init(void);
+extern int pfault_token(void);
 
 int __init start_secondary(void *cpuvoid)
 {
@@ -568,6 +484,10 @@
                 /* nothing */ ;
         /* init per CPU 100 hz timer */
         init_100hz_timer();
+#ifdef CONFIG_PFAULT
+	/* Enable pfault pseudo page faults on this cpu. */
+	pfault_init();
+#endif
         /* cpu_idle will call schedule for us */
         return cpu_idle(NULL);
 }
@@ -615,12 +535,15 @@
         init_tasks[cpu] = idle;
 
         cpu_lowcore=&get_cpu_lowcore(cpu);
-        cpu_lowcore->kernel_stack=idle->thread.ksp;
-        __asm__ __volatile__("stctl 0,15,%0\n\t"
-                             "stam  0,15,%1"
+	cpu_lowcore->save_area[15] = idle->thread.ksp;
+	cpu_lowcore->kernel_stack = (idle->thread.ksp | 8191) + 1;
+        __asm__ __volatile__("la    1,%0\n\t"
+			     "stctl 0,15,0(1)\n\t"
+			     "la    1,%1\n\t"
+                             "stam  0,15,0(1)"
                              : "=m" (cpu_lowcore->cregs_save_area[0]),
                                "=m" (cpu_lowcore->access_regs_save_area[0])
-                             : : "memory");
+                             : : "1", "memory");
 
         eieio();
         signal_processor(cpu,sigp_restart);
@@ -650,7 +573,7 @@
 
 void __init smp_boot_cpus(void)
 {
-        struct _lowcore *curr_lowcore;
+	unsigned long async_stack;
         sigp_ccode   ccode;
         int i;
 
@@ -675,34 +598,37 @@
 
         for(i = 0; i < smp_num_cpus; i++)
         {
-                curr_lowcore = (struct _lowcore *)
-                                    __get_free_page(GFP_KERNEL|GFP_DMA);
-                if (curr_lowcore == NULL) {
-                        printk("smp_boot_cpus failed to allocate prefix memory\n");
-                        break;
-                }
-                lowcore_ptr[i] = curr_lowcore;
-                memcpy(curr_lowcore, &S390_lowcore, sizeof(struct _lowcore));
+		lowcore_ptr[i] = (struct _lowcore *)
+			__get_free_page(GFP_KERNEL|GFP_DMA);
+                if (lowcore_ptr[i] == NULL)
+                        panic("smp_boot_cpus failed to "
+			      "allocate prefix memory\n");
+		async_stack = __get_free_pages(GFP_KERNEL,1);
+		if (async_stack == 0)
+			panic("smp_boot_cpus failed to allocate "
+			      "asyncronous interrupt stack\n");
+
+                memcpy(lowcore_ptr[i], &S390_lowcore, sizeof(struct _lowcore));
+		lowcore_ptr[i]->async_stack = async_stack + (2 * PAGE_SIZE);
                 /*
                  * Most of the parameters are set up when the cpu is
                  * started up.
                  */
-                if (smp_processor_id() == i)
-                        set_prefix((u32) curr_lowcore);
-                else {
-                        ccode = signal_processor_p((u32)(curr_lowcore),
-                                                   i, sigp_set_prefix);
-                        if(ccode) {
-                                /* if this gets troublesome I'll have to do
-                                 * something about it. */
-                                printk("ccode %d for cpu %d  returned when "
-                                       "setting prefix in smp_boot_cpus not good.\n",
-                                       (int) ccode, (int) i);
-                        }
-                        else
-                                do_boot_cpu(i);
-                }
-        }
+		if (smp_processor_id() == i)
+			set_prefix((u32) lowcore_ptr[i]);
+		else {
+			ccode = signal_processor_p((u32)(lowcore_ptr[i]),
+						   i, sigp_set_prefix);
+			if (ccode)
+				/* if this gets troublesome I'll have to do
+				 * something about it. */
+				printk("ccode %d for cpu %d  returned when "
+				       "setting prefix in smp_boot_cpus not good.\n",
+				       (int) ccode, (int) i);
+			else
+				do_boot_cpu(i);
+		}
+	}
 }
 
 /*
@@ -741,8 +667,6 @@
                 s390_do_profile(regs->psw.addr);
 
         if (!--prof_counter[cpu]) {
-                int system = 1-user;
-                struct task_struct * p = current;
 
                 /*
                  * The multiplier may have changed since the last time we got
@@ -766,9 +690,7 @@
                  * WrongThing (tm) to do.
                  */
 
-                irq_enter(cpu, 0);
 		update_process_times(user);
-                irq_exit(cpu, 0);
         }
 }
 
diff -urN linux/arch/s390/kernel/time.c linux-2.4.7/arch/s390/kernel/time.c
--- linux/arch/s390/kernel/time.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390/kernel/time.c	Mon Dec 17 13:42:41 2001
@@ -95,9 +95,10 @@
 {
 	unsigned long flags;
 	unsigned long usec, sec;
-	unsigned long lost_ticks = jiffies - wall_jiffies;
+	unsigned long lost_ticks;
 
 	read_lock_irqsave(&xtime_lock, flags);
+	lost_ticks = jiffies - wall_jiffies;
 	usec = do_gettimeoffset();
 	if (lost_ticks)
 		usec +=(USECS_PER_JIFFY*lost_ticks);
@@ -150,15 +151,14 @@
 
 void do_timer_interrupt(struct pt_regs *regs, __u16 error_code)
 {
-        unsigned long flags;
+	int cpu = smp_processor_id();
+
+	irq_enter(cpu, 0);
 
         /*
          * reset timer to 10ms minus time already elapsed
          * since timer-interrupt pending
          */
- 
-        save_flags(flags);
-        cli();
 #ifdef CONFIG_SMP
 	if(S390_lowcore.cpu_data.cpu_addr==boot_cpu_addr) {
 		write_lock(&xtime_lock);
@@ -194,8 +194,8 @@
 		write_unlock(&xtime_lock);
 #endif
 	}
-        restore_flags(flags);
 
+	irq_exit(cpu, 0);
 }
 
 /*
@@ -249,4 +249,7 @@
         init_timer_cc -= 0x8126d60e46000000LL -
                          (0x3c26700LL*1000000*4096);
         tod_to_timeval(init_timer_cc, &xtime);
+
+	/* Set do_get_fast_time function pointer.  */
+	do_get_fast_time = do_gettimeofday;
 }
diff -urN linux/arch/s390/kernel/traps.c linux-2.4.7/arch/s390/kernel/traps.c
--- linux/arch/s390/kernel/traps.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/arch/s390/kernel/traps.c	Mon Dec 17 13:42:41 2001
@@ -36,6 +36,7 @@
 #include <asm/gdb-stub.h>
 #endif
 #include <asm/cpcmd.h>
+#include <asm/s390_ext.h>
 
 /* Called from entry.S only */
 extern void handle_per_exception(struct pt_regs *regs);
@@ -53,6 +54,11 @@
 
 extern pgm_check_handler_t do_page_fault;
 extern pgm_check_handler_t do_pseudo_page_fault;
+#ifdef CONFIG_PFAULT
+extern int pfault_init(void);
+extern void pfault_fini(void);
+extern void pfault_interrupt(struct pt_regs *regs, __u16 error_code);
+#endif
 
 spinlock_t die_lock;
 
@@ -86,8 +92,16 @@
 static void inline do_trap(long interruption_code, int signr, char *str,
                            struct pt_regs *regs, siginfo_t *info)
 {
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+        if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
         if (regs->psw.mask & PSW_PROBLEM_STATE) {
                 struct task_struct *tsk = current;
+
                 tsk->thread.trap_no = interruption_code;
 		if (info)
 			force_sig_info(signr, info, tsk);
@@ -129,7 +143,7 @@
 #if CONFIG_REMOTE_DEBUG
 		if(gdb_stub_initialised)
 		{
-			gdb_stub_handle_exception((gdb_pt_regs *)regs,signal);
+			gdb_stub_handle_exception((struct gdb_pt_regs *)regs,signal);
 			return 0;
 		}
 #endif
@@ -142,7 +156,7 @@
 DO_ERROR(SIGILL,  "privileged operation", privileged_op)
 DO_ERROR(SIGILL,  "execute exception", execute_exception)
 DO_ERROR(SIGSEGV, "addressing exception", addressing_exception)
-DO_ERROR(SIGILL,  "fixpoint divide exception", divide_exception)
+DO_ERROR(SIGFPE,  "fixpoint divide exception", divide_exception)
 DO_ERROR(SIGILL,  "translation exception", translation_exception)
 DO_ERROR(SIGILL,  "special operand exception", special_op_exception)
 DO_ERROR(SIGILL,  "operand exception", operand_exception)
@@ -152,21 +166,27 @@
         __u8 opcode[6];
 	__u16 *location;
 	int signal = 0;
-	int problem_state=(regs->psw.mask & PSW_PROBLEM_STATE);
 
-        lock_kernel();
 	location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
-	if(problem_state)
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
 		get_user(*((__u16 *) opcode), location);
 	else
 		*((__u16 *)opcode)=*((__u16 *)location);
-	if(*((__u16 *)opcode)==S390_BREAKPOINT_U16)
+	if (*((__u16 *)opcode)==S390_BREAKPOINT_U16)
         {
 		if(do_debugger_trap(regs,SIGTRAP))
 			signal = SIGILL;
 	}
 #ifdef CONFIG_MATHEMU
-        else if (problem_state)
+        else if (regs->psw.mask & PSW_PROBLEM_STATE)
 	{
 		if (opcode[0] == 0xb3) {
 			get_user(*((__u16 *) (opcode+2)), location+1);
@@ -197,7 +217,6 @@
         } else if (signal)
 		do_trap(interruption_code, signal,
 			"illegal operation", regs, NULL);
-        unlock_kernel();
 }
 
 
@@ -207,12 +226,19 @@
 specification_exception(struct pt_regs * regs, long interruption_code)
 {
         __u8 opcode[6];
-	__u16 *location;
+	__u16 *location = NULL;
 	int signal = 0;
 
-        lock_kernel();
+	location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+		
         if (regs->psw.mask & PSW_PROBLEM_STATE) {
-		location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
 		get_user(*((__u16 *) opcode), location);
 		switch (opcode[0]) {
 		case 0x28: /* LDR Rx,Ry   */
@@ -250,7 +276,6 @@
         } else if (signal)
                 do_trap(interruption_code, signal,
 			"specification exception", regs, NULL);
-        unlock_kernel();
 }
 #else
 DO_ERROR(SIGILL, "specification exception", specification_exception)
@@ -262,8 +287,15 @@
 	__u16 *location;
 	int signal = 0;
 
-        lock_kernel();
 	location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
 	if (MACHINE_HAS_IEEE)
 		__asm__ volatile ("stfpc %0\n\t" 
 				  : "=m" (current->thread.fp_regs.fpc));
@@ -333,7 +365,6 @@
 	} else if (signal) 
                 do_trap(interruption_code, signal,
 			"data exception", regs, NULL);
-        unlock_kernel();
 }
 
 
@@ -361,8 +392,26 @@
  	pgm_check_table[0x14] = &do_pseudo_page_fault;
         pgm_check_table[0x15] = &operand_exception;
         pgm_check_table[0x1C] = &privileged_op;
+#ifdef CONFIG_PFAULT
+	if (MACHINE_IS_VM) {
+		/* request the 0x2603 external interrupt */
+		if (register_external_interrupt(0x2603, pfault_interrupt) != 0)
+			panic("Couldn't request external interrupt 0x2603");
+		/*
+		 * First try to get pfault pseudo page faults going.
+		 * If this isn't available turn on pagex page faults.
+		 */
+		if (pfault_init() != 0) {
+			/* Tough luck, no pfault. */
+			unregister_external_interrupt(0x2603,
+						      pfault_interrupt);
+			cpcmd("SET PAGEX ON", NULL, 0);
+		}
+	}
+#else
 	if (MACHINE_IS_VM)
-	        cpcmd("SET PAGEX ON", NULL, 0);
+		cpcmd("SET PAGEX ON", NULL, 0);
+#endif
 }
 
 
diff -urN linux/arch/s390/math-emu/math.c linux-2.4.7/arch/s390/math-emu/math.c
--- linux/arch/s390/math-emu/math.c	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/arch/s390/math-emu/math.c	Mon Dec 17 13:41:49 2001
@@ -1471,20 +1471,98 @@
 }
 
 /* Test data class long double */
-static int emu_tcxb (int rx, double *val) {
-        display_emulation_not_implemented("tcxb");
+static int emu_tcxb (int rx, long val) {
+        FP_DECL_Q(QA);
+	mathemu_ldcv cvt;
+	int bit;
+
+        cvt.w.high = current->thread.fp_regs.fprs[rx].ui;
+        cvt.w.low = current->thread.fp_regs.fprs[rx+2].ui;
+        FP_UNPACK_RAW_QP(QA, &cvt.ld);
+	switch (QA_e) {
+	default:
+		bit = 8;		/* normalized number */
+		break;
+	case 0:
+		if (_FP_FRAC_ZEROP_4(QA))
+			bit = 10;	/* zero */
+		else
+			bit = 6;	/* denormalized number */
+		break;
+	case _FP_EXPMAX_Q:
+		if (_FP_FRAC_ZEROP_4(QA))
+			bit = 4;	/* infinity */
+		else if (_FP_FRAC_HIGH_RAW_Q(QA) & _FP_QNANBIT_Q)
+			bit = 2;	/* quiet NAN */
+		else
+			bit = 0;	/* signaling NAN */
+		break;
+	}
+	if (!QA_s)
+		bit++;
+	emu_set_CC(((__u32) val >> bit) & 1);
         return 0;
 }
 
 /* Test data class double */
-static int emu_tcdb (int rx, double *val) {
-        display_emulation_not_implemented("tcdb");
+static int emu_tcdb (int rx, long val) {
+        FP_DECL_D(DA);
+	int bit;
+
+        FP_UNPACK_RAW_DP(DA, &current->thread.fp_regs.fprs[rx].d);
+	switch (DA_e) {
+	default:
+		bit = 8;		/* normalized number */
+		break;
+	case 0:
+		if (_FP_FRAC_ZEROP_2(DA))
+			bit = 10;	/* zero */
+		else
+			bit = 6;	/* denormalized number */
+		break;
+	case _FP_EXPMAX_D:
+		if (_FP_FRAC_ZEROP_2(DA))
+			bit = 4;	/* infinity */
+		else if (_FP_FRAC_HIGH_RAW_D(DA) & _FP_QNANBIT_D)
+			bit = 2;	/* quiet NAN */
+		else
+			bit = 0;	/* signaling NAN */
+		break;
+	}
+	if (!DA_s)
+		bit++;
+	emu_set_CC(((__u32) val >> bit) & 1);
         return 0;
 }
 
 /* Test data class float */
-static int emu_tceb (int rx, __u32 val) {
-        display_emulation_not_implemented("tceb");
+static int emu_tceb (int rx, long val) {
+        FP_DECL_S(SA);
+	int bit;
+
+        FP_UNPACK_RAW_SP(SA, &current->thread.fp_regs.fprs[rx].f);
+	switch (SA_e) {
+	default:
+		bit = 8;		/* normalized number */
+		break;
+	case 0:
+		if (_FP_FRAC_ZEROP_1(SA))
+			bit = 10;	/* zero */
+		else
+			bit = 6;	/* denormalized number */
+		break;
+	case _FP_EXPMAX_S:
+		if (_FP_FRAC_ZEROP_1(SA))
+			bit = 4;	/* infinity */
+		else if (_FP_FRAC_HIGH_RAW_S(SA) & _FP_QNANBIT_S)
+			bit = 2;	/* quiet NAN */
+		else
+			bit = 0;	/* signaling NAN */
+		break;
+	}
+	if (!SA_s)
+		bit++;
+	emu_set_CC(((__u32) val >> bit) & 1);
         return 0;
 }
 
@@ -1796,13 +1874,13 @@
         int _fex = 0;
 
         static const __u8 format_table[256] = {
-                [0x04] = 0x08,[0x05] = 0x07,[0x06] = 0x09,[0x07] = 0x07,
-		[0x08] = 0x03,[0x09] = 0x03,[0x0a] = 0x03,[0x0b] = 0x03,
-		[0x0c] = 0x08,[0x0d] = 0x03,[0x0e] = 0x06,[0x0f] = 0x06,
-                [0x10] = 0x03,[0x11] = 0x02,[0x12] = 0x01,[0x14] = 0x03,
-		[0x15] = 0x02,[0x17] = 0x03,[0x18] = 0x02,[0x19] = 0x02,
-		[0x1a] = 0x02,[0x1b] = 0x02,[0x1c] = 0x02,[0x1d] = 0x02,
-                [0x1e] = 0x05,[0x1f] = 0x05,
+                [0x04] = 0x06,[0x05] = 0x05,[0x06] = 0x07,[0x07] = 0x05,
+		[0x08] = 0x02,[0x09] = 0x02,[0x0a] = 0x02,[0x0b] = 0x02,
+		[0x0c] = 0x06,[0x0d] = 0x02,[0x0e] = 0x04,[0x0f] = 0x04,
+                [0x10] = 0x08,[0x11] = 0x09,[0x12] = 0x0a,[0x14] = 0x02,
+		[0x15] = 0x01,[0x17] = 0x02,[0x18] = 0x01,[0x19] = 0x01,
+		[0x1a] = 0x01,[0x1b] = 0x01,[0x1c] = 0x01,[0x1d] = 0x01,
+                [0x1e] = 0x03,[0x1f] = 0x03,
         };
         static const void *jump_table[]= {
                 [0x04] = emu_ldeb,[0x05] = emu_lxdb,[0x06] = emu_lxeb,
@@ -1817,25 +1895,7 @@
         };
 
         switch (format_table[opcode[5]]) {
-        case 1: /* RXE format, long double constant */ {
-                __u64 *dxb, temp[2];
-                __u32 opc;
-
-                if ((opcode[1] >> 4) & 2)
-			return SIGILL;
-                emu_store_regd((opcode[1] >> 4) & 15);
-                emu_store_regd(((opcode[1] >> 4) & 15) + 2);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_copy_from_user(&temp, dxb, 16);
-                /* call the emulation function */
-                _fex = ((int (*)(int, long double *)) jump_table[opcode[5]])
-                        (opcode[1] >> 4, (long double *) &temp);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                emu_load_regd(((opcode[1] >> 4) & 15) + 2);
-                break;
-        }
-        case 2: /* RXE format, double constant */ {
+        case 1: /* RXE format, double constant */ {
                 __u64 *dxb, temp;
                 __u32 opc;
 
@@ -1849,7 +1909,7 @@
                 emu_load_regd((opcode[1] >> 4) & 15);
                 break;
         }
-        case 3: /* RXE format, float constant */ {
+        case 2: /* RXE format, float constant */ {
                 __u32 *dxb, temp;
                 __u32 opc;
 
@@ -1863,27 +1923,7 @@
                 emu_load_rege((opcode[1] >> 4) & 15);
                 break;
         }
-        case 4: /* RXF format, long double constant */ {
-                __u64 *dxb, temp[2];
-                __u32 opc;
-
-                if (((opcode[1] >> 4) & 0x20) || ((opcode[4] >> 4) & 0x20))
-			return SIGILL;
-                emu_store_regd((opcode[1] >> 4) & 15);
-                emu_store_regd(((opcode[1] >> 4) & 15) + 2);
-                emu_store_regd((opcode[4] >> 4) & 15);
-                emu_store_regd(((opcode[4] >> 4) & 15) + 2);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs, opc >> 16, opc >> 12, opc);
-                mathemu_copy_from_user(&temp, dxb, 16);
-                /* call the emulation function */
-                _fex = ((int (*)(int,long double *,int)) jump_table[opcode[5]])
-                        (opcode[1] >> 4, (double *) &temp, opcode[4] >> 4);
-                emu_load_regd((opcode[1] >> 4) & 15);
-                emu_load_regd(((opcode[1] >> 4) & 15) + 2);
-                break;
-        }
-        case 5: /* RXF format, double constant */ {
+        case 3: /* RXF format, double constant */ {
                 __u64 *dxb, temp;
                 __u32 opc;
 
@@ -1898,7 +1938,7 @@
                 emu_load_regd((opcode[1] >> 4) & 15);
                 break;
         }
-        case 6: /* RXF format, float constant */ {
+        case 4: /* RXF format, float constant */ {
                 __u32 *dxb, temp;
                 __u32 opc;
 
@@ -1913,7 +1953,7 @@
                 emu_load_rege((opcode[4] >> 4) & 15);
                 break;
         }
-        case 7: /* RXE format, double constant */
+        case 5: /* RXE format, double constant */
                 /* store double and load long double */ 
         {
                 __u64 *dxb, temp;
@@ -1931,7 +1971,7 @@
                 emu_load_regd(((opcode[1] >> 4) & 15) + 2);
                 break;
         }
-        case 8: /* RXE format, float constant */
+        case 6: /* RXE format, float constant */
                 /* store float and load double */ 
         {
                 __u32 *dxb, temp;
@@ -1946,7 +1986,7 @@
                 emu_load_regd((opcode[1] >> 4) & 15);
                 break;
         }
-        case 9: /* RXE format, float constant */
+        case 7: /* RXE format, float constant */
                 /* store float and load long double */ 
         {
                 __u32 *dxb, temp;
@@ -1962,6 +2002,45 @@
                         (opcode[1] >> 4, (float *) &temp);
                 emu_load_regd((opcode[1] >> 4) & 15);
                 emu_load_regd(((opcode[1] >> 4) & 15) + 2);
+                break;
+        }
+        case 8: /* RXE format, RX address used as int value */ {
+                __u64 dxb;
+                __u32 opc;
+
+                emu_store_rege((opcode[1] >> 4) & 15);
+                opc = *((__u32 *) opcode);
+                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
+                /* call the emulation function */
+                _fex = ((int (*)(int, long)) jump_table[opcode[5]])
+                        (opcode[1] >> 4, dxb);
+                break;
+        }
+        case 9: /* RXE format, RX address used as int value */ {
+                __u64 dxb;
+                __u32 opc;
+
+                emu_store_regd((opcode[1] >> 4) & 15);
+                opc = *((__u32 *) opcode);
+                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
+                /* call the emulation function */
+                _fex = ((int (*)(int, long)) jump_table[opcode[5]])
+                        (opcode[1] >> 4, dxb);
+                break;
+        }
+        case 10: /* RXE format, RX address used as int value */ {
+                __u64 dxb;
+                __u32 opc;
+
+                if ((opcode[1] >> 4) & 2)
+			return SIGILL;
+                emu_store_regd((opcode[1] >> 4) & 15);
+                emu_store_regd(((opcode[1] >> 4) & 15) + 2);
+                opc = *((__u32 *) opcode);
+                dxb = (__u64) calc_addr(regs, opc >> 16, opc >> 12, opc);
+                /* call the emulation function */
+                _fex = ((int (*)(int, long)) jump_table[opcode[5]])
+                        (opcode[1] >> 4, dxb);
                 break;
         }
         default: /* invalid operation */
diff -urN linux/arch/s390/mm/Makefile linux-2.4.7/arch/s390/mm/Makefile
--- linux/arch/s390/mm/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390/mm/Makefile	Mon Dec 17 13:41:18 2001
@@ -1,5 +1,5 @@
 #
-# Makefile for the linux i386-specific parts of the memory manager.
+# Makefile for the linux s390-specific parts of the memory manager.
 #
 # Note! Dependencies are done automagically by 'make dep', which also
 # removes any old dependencies. DON'T put your own dependencies here
diff -urN linux/arch/s390/mm/extable.c linux-2.4.7/arch/s390/mm/extable.c
--- linux/arch/s390/mm/extable.c	Fri May 12 14:41:45 2000
+++ linux-2.4.7/arch/s390/mm/extable.c	Mon Dec 17 13:41:49 2001
@@ -10,6 +10,7 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/spinlock.h>
 #include <asm/uaccess.h>
 
 extern const struct exception_table_entry __start___ex_table[];
@@ -36,28 +37,37 @@
         return 0;
 }
 
+extern spinlock_t modlist_lock;
+
 unsigned long
 search_exception_table(unsigned long addr)
 {
-	unsigned long ret;
+	unsigned long ret = 0;
+	unsigned long flags;
 
 #ifndef CONFIG_MODULES
         addr &= 0x7fffffff;  /* remove amode bit from address */
 	/* There is only the kernel to search.  */
 	ret = search_one_table(__start___ex_table, __stop___ex_table-1, addr);
-	if (ret) return FIX_PSW(ret);
+	if (ret) ret = FIX_PSW(ret);
+	return ret;
 #else
 	/* The kernel is the last "module" -- no need to treat it special.  */
 	struct module *mp;
         addr &= 0x7fffffff;  /* remove amode bit from address */
+
+	spin_lock_irqsave(&modlist_lock, flags);
 	for (mp = module_list; mp != NULL; mp = mp->next) {
-		if (mp->ex_table_start == NULL)
+		if (mp->ex_table_start == NULL || !(mp->flags&(MOD_RUNNING|MOD_INITIALIZING)))
 			continue;
 		ret = search_one_table(mp->ex_table_start,
 				       mp->ex_table_end - 1, addr);
-		if (ret) return FIX_PSW(ret);
+		if (ret) {
+			ret = FIX_PSW(ret);
+			break;
+		}
 	}
+	spin_unlock_irqrestore(&modlist_lock, flags);
+	return ret;
 #endif
-
-	return 0;
 }
diff -urN linux/arch/s390/mm/fault.c linux-2.4.7/arch/s390/mm/fault.c
--- linux/arch/s390/mm/fault.c	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/mm/fault.c	Mon Dec 17 13:42:47 2001
@@ -4,6 +4,7 @@
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
+ *               Ulrich Weigand (uweigand@de.ibm.com)
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -22,6 +23,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/compatmac.h>
+#include <linux/init.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -33,6 +35,7 @@
 #endif
 
 extern void die(const char *,struct pt_regs *,long);
+static void force_sigsegv(struct task_struct *tsk, int code, void *address);
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -52,18 +55,31 @@
         unsigned long address;
         unsigned long fixup;
         int write;
-        unsigned long psw_mask;
-        unsigned long psw_addr;
 	int si_code = SEGV_MAPERR;
 	int kernel_address = 0;
 
-        /*
-         *  get psw mask of Program old psw to find out,
-         *  if user or kernel mode
-         */
+        tsk = current;
+        mm = tsk->mm;
+	
+	/* 
+         * Check for low-address protection.  This needs to be treated
+	 * as a special case because the translation exception code 
+	 * field is not guaranteed to contain valid data in this case.
+	 */
+	if ((error_code & 0xff) == 4 && !(S390_lowcore.trans_exc_code & 4)) {
+
+		/* Low-address protection hit in kernel mode means 
+		   NULL pointer write access in kernel mode.  */
+ 		if (!(regs->psw.mask & PSW_PROBLEM_STATE)) {
+			address = 0;
+			kernel_address = 1;
+			goto no_context;
+		}
 
-        psw_mask = S390_lowcore.program_old_psw.mask;
-        psw_addr = S390_lowcore.program_old_psw.addr;
+		/* Low-address protection hit in user mode 'cannot happen'.  */
+		die ("Low-address protection", regs, error_code);
+        	do_exit(SIGKILL);
+	}
 
         /* 
          * get the failing address 
@@ -73,12 +89,6 @@
 
         address = S390_lowcore.trans_exc_code&0x7ffff000;
 
-        tsk = current;
-        mm = tsk->mm;
-
-        if (in_interrupt() || !mm)
-                goto no_context;
-
 
 	/*
 	 * Check which address space the address belongs to
@@ -109,6 +119,7 @@
 			}
 		}
 		die("page fault via unknown access register", regs, error_code);
+        	do_exit(SIGKILL);
 		break;
 
 	case 2: /* Secondary Segment Table Descriptor */
@@ -117,12 +128,20 @@
 		break;
 	}
 
+	/*
+	 * Check whether we have a user MM in the first place.
+	 */
+        if (in_interrupt() || !mm || !(regs->psw.mask & _PSW_IO_MASK_BIT))
+                goto no_context;
 
 	/*
 	 * When we get here, the fault happened in the current
-	 * task's user address space, so we search the VMAs
+	 * task's user address space, so we can switch on the
+	 * interrupts again and then search the VMAs
 	 */
 
+	__sti();
+
         down_read(&mm->mmap_sem);
 
         vma = find_vma(mm, address);
@@ -185,8 +204,7 @@
         up_read(&mm->mmap_sem);
 
         /* User mode accesses just cause a SIGSEGV */
-        if (psw_mask & PSW_PROBLEM_STATE) {
-		struct siginfo si;
+        if (regs->psw.mask & PSW_PROBLEM_STATE) {
                 tsk->thread.prot_addr = address;
                 tsk->thread.trap_no = error_code;
 #ifndef CONFIG_SYSCTL
@@ -203,10 +221,8 @@
 			show_regs(regs);
 		}
 #endif
-		si.si_signo = SIGSEGV;
-		si.si_code = si_code;
-		si.si_addr = (void*) address;
-		force_sig_info(SIGSEGV, &si, tsk);
+
+		force_sigsegv(tsk, si_code, (void *)address);
                 return;
 	}
 
@@ -228,9 +244,6 @@
         else
                 printk(KERN_ALERT "Unable to handle kernel paging request"
 		       " at virtual user address %08lx\n", address);
-/*
- * need to define, which information is useful here
- */
 
         die("Oops", regs, error_code);
         do_exit(SIGKILL);
@@ -243,7 +256,7 @@
 out_of_memory:
 	up_read(&mm->mmap_sem);
 	printk("VM: killing process %s\n", tsk->comm);
-	if (psw_mask & PSW_PROBLEM_STATE)
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
 		do_exit(SIGKILL);
 	goto no_context;
 
@@ -259,10 +272,22 @@
 	force_sig(SIGBUS, tsk);
 
 	/* Kernel mode? Handle exceptions or die */
-	if (!(psw_mask & PSW_PROBLEM_STATE))
+	if (!(regs->psw.mask & PSW_PROBLEM_STATE))
 		goto no_context;
 }
 
+/*
+ * Send SIGSEGV to task.  This is an external routine
+ * to keep the stack usage of do_page_fault small.
+ */
+static void force_sigsegv(struct task_struct *tsk, int code, void *address)
+{
+	struct siginfo si;
+	si.si_signo = SIGSEGV;
+	si.si_code = code;
+	si.si_addr = address;
+	force_sig_info(SIGSEGV, &si, tsk);
+}
 
 typedef struct _pseudo_wait_t {
        struct _pseudo_wait_t *next;
@@ -275,25 +300,17 @@
 static spinlock_t pseudo_wait_spinlock; /* spinlock to protect lock queue */
 
 /*
- * This routine handles pseudo page faults.
+ * This routine handles 'pagex' pseudo page faults.
  */
 asmlinkage void
 do_pseudo_page_fault(struct pt_regs *regs, unsigned long error_code)
 {
-        DECLARE_WAITQUEUE(wait, current);
         pseudo_wait_t wait_struct;
         pseudo_wait_t *ptr, *last, *next;
-        unsigned long psw_mask;
         unsigned long address;
         int kernel_address;
 
         /*
-         *  get psw mask of Program old psw to find out,
-         *  if user or kernel mode
-         */
-        psw_mask = S390_lowcore.program_old_psw.mask;
-
-        /*
          * get the failing address
          * more specific the segment and page table portion of
          * the address
@@ -332,7 +349,7 @@
                 spin_unlock(&pseudo_wait_spinlock);
         } else {
                 /* Pseudo page faults in kernel mode is a bad idea */
-                if (!(psw_mask & PSW_PROBLEM_STATE)) {
+                if (!(regs->psw.mask & PSW_PROBLEM_STATE)) {
                         /*
 			 * VM presents pseudo page faults if the interrupted
 			 * state was not disabled for interrupts. So we can
@@ -366,7 +383,11 @@
                                          "  la   2,0(%0)\n"
                                          "  sacf 512\n"
                                          "  ic   2,0(2)\n"
-                                         "  sacf 0"
+					 "0:sacf 0\n"
+					 ".section __ex_table,\"a\"\n"
+					 "  .align 4\n"
+					 "  .long  0b,0b\n"
+					 ".previous"
                                          : : "a" (address) : "2" );
 
                         return;
@@ -383,4 +404,133 @@
                 wait_event(wait_struct.queue, wait_struct.resolved);
         }
 }
-    
+
+#ifdef CONFIG_PFAULT 
+/*
+ * 'pfault' pseudo page faults routines.
+ */
+static int pfault_disable = 0;
+
+static int __init nopfault(char *str)
+{
+	pfault_disable = 1;
+	return 1;
+}
+
+__setup("nopfault", nopfault);
+
+typedef struct {
+	__u16 refdiagc;
+	__u16 reffcode;
+	__u16 refdwlen;
+	__u16 refversn;
+	__u64 refgaddr;
+	__u64 refselmk;
+	__u64 refcmpmk;
+	__u64 reserved;
+} __attribute__ ((packed)) pfault_refbk_t;
+
+int pfault_init(void)
+{
+	pfault_refbk_t refbk =
+	{ 0x258, 0, 5, 2, __LC_KERNEL_STACK, 1ULL << 48, 1ULL << 48, 0ULL };
+        int rc;
+
+	if (pfault_disable)
+		return -1;
+        __asm__ __volatile__(
+                "    diag  %1,%0,0x258\n"
+		"0:  j     2f\n"
+		"1:  la    %0,8\n"
+		"2:\n"
+		".section __ex_table,\"a\"\n"
+		"   .align 4\n"
+		"   .long  0b,1b\n"
+		".previous"
+                : "=d" (rc) : "a" (&refbk) : "cc" );
+        __ctl_set_bit(0, 9);
+        return rc;
+}
+
+void pfault_fini(void)
+{
+	pfault_refbk_t refbk =
+	{ 0x258, 1, 5, 2, 0ULL, 0ULL, 0ULL, 0ULL };
+
+	if (pfault_disable)
+		return;
+	__ctl_clear_bit(0,9);
+        __asm__ __volatile__(
+                "    diag  %0,0,0x258\n"
+		"0:\n"
+		".section __ex_table,\"a\"\n"
+		"   .align 4\n"
+		"   .long  0b,0b\n"
+		".previous"
+		: : "a" (&refbk) : "cc" );
+}
+
+asmlinkage void
+pfault_interrupt(struct pt_regs *regs, __u16 error_code)
+{
+	struct task_struct *tsk;
+	wait_queue_head_t queue;
+	wait_queue_head_t *qp;
+	__u16 subcode;
+
+	/*
+	 * Get the external interruption subcode & pfault
+	 * initial/completion signal bit. VM stores this 
+	 * in the 'cpu address' field associated with the
+         * external interrupt. 
+	 */
+	subcode = S390_lowcore.cpu_addr;
+	if ((subcode & 0xff00) != 0x0200)
+		return;
+
+	/*
+	 * Get the token (= address of kernel stack of affected task).
+	 */
+	tsk = (struct task_struct *)
+		(*((unsigned long *) __LC_PFAULT_INTPARM) - THREAD_SIZE);
+	
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
+	if (subcode & 0x0080) {
+		/* signal bit is set -> a page has been swapped in by VM */
+		qp = (wait_queue_head_t *)
+			xchg(&tsk->thread.pfault_wait, -1);
+		if (qp != NULL) {
+			/* Initial interrupt was faster than the completion
+			 * interrupt. pfault_wait is valid. Set pfault_wait
+			 * back to zero and wake up the process. This can
+			 * safely be done because the task is still sleeping
+			 * and can't procude new pfaults. */
+			tsk->thread.pfault_wait = 0ULL;
+			wake_up(qp);
+		}
+	} else {
+		/* signal bit not set -> a real page is missing. */
+                init_waitqueue_head (&queue);
+		qp = (wait_queue_head_t *)
+			xchg(&tsk->thread.pfault_wait, (addr_t) &queue);
+		if (qp != NULL) {
+			/* Completion interrupt was faster than the initial
+			 * interrupt (swapped in a -1 for pfault_wait). Set
+			 * pfault_wait back to zero and exit. This can be
+			 * done safely because tsk is running in kernel 
+			 * mode and can't produce new pfaults. */
+			tsk->thread.pfault_wait = 0ULL;
+		}
+
+                /* go to sleep */
+                wait_event(queue, tsk->thread.pfault_wait == 0ULL);
+	}
+}
+#endif
+
diff -urN linux/arch/s390/mm/init.c linux-2.4.7/arch/s390/mm/init.c
--- linux/arch/s390/mm/init.c	Thu Apr 26 17:10:16 2001
+++ linux-2.4.7/arch/s390/mm/init.c	Mon Dec 17 13:42:41 2001
@@ -41,44 +41,23 @@
 pgd_t swapper_pg_dir[PTRS_PER_PGD] __attribute__((__aligned__(PAGE_SIZE)));
 char  empty_zero_page[PAGE_SIZE] __attribute__((__aligned__(PAGE_SIZE)));
 
-static int test_access(unsigned long loc)
-{
-	static const int ssm_mask = 0x07000000L;
-	int rc, i;
-
-        rc = 0;
-	for (i=0; i<4; i++) {
-		__asm__ __volatile__(
-                        "    slr   %0,%0\n"
-			"    ssm   %1\n"
-			"    tprot 0(%2),0\n"
-			"0:  jne   1f\n"
-			"    lhi   %0,1\n"
-			"1:  ssm   %3\n"
-                        ".section __ex_table,\"a\"\n"
-                        "   .align 4\n"
-                        "   .long  0b,1b\n"
-                        ".previous"
-			: "+&d" (rc) : "i" (0), "a" (loc), "m" (ssm_mask)
-			: "cc");
-		if (rc == 0)
-			break;
-		loc += 0x100000;
-	}
-	return rc;
-}
-
 int do_check_pgt_cache(int low, int high)
 {
         int freed = 0;
         if(pgtable_cache_size > high) {
                 do {
-                        if(pgd_quicklist)
-                                free_pgd_slow(get_pgd_fast()), freed += 2;
-                        if(pmd_quicklist)
-                                pmd_free_slow(pmd_alloc_one_fast(NULL, 0)), freed++;
-                        if(pte_quicklist)
-                                pte_free_slow(pte_alloc_one_fast(NULL, 0)), freed++;
+                        if(pgd_quicklist) {
+                                free_pgd_slow(get_pgd_fast());
+				freed += 2;
+			}
+                        if(pmd_quicklist) {
+                                pmd_free_slow(pmd_alloc_one_fast(NULL, 0));
+				freed++;
+			}
+                        if(pte_quicklist) {
+                                pte_free_slow(pte_alloc_one_fast(NULL, 0));
+				freed++;
+			}
                 } while(pgtable_cache_size > low);
         }
         return freed;
@@ -197,7 +176,6 @@
 void __init mem_init(void)
 {
 	int codesize, reservedpages, datasize, initsize;
-        int tmp;
 
         max_mapnr = num_physpages = max_low_pfn;
         high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
@@ -208,24 +186,7 @@
 	/* this will put all low memory onto the freelists */
 	totalram_pages += free_all_bootmem();
 
-        /* mark usable pages in the mem_map[] and count reserved pages */
 	reservedpages = 0;
-	tmp = 0;
-	do {
-		if (tmp && (tmp & 0x3ff) == 0 && 
-                    test_access(tmp * PAGE_SIZE) == 0) {
-                        printk("4M Segment %lX not available\n",tmp*PAGE_SIZE);
-			do {
-                                set_bit(PG_reserved, &mem_map[tmp].flags);
-				reservedpages++;
-				tmp++;
-			} while (tmp < max_low_pfn && (tmp & 0x3ff));
-		} else {
-			if (PageReserved(mem_map+tmp))
-				reservedpages++;
-			tmp++;
-		}
-	} while (tmp < max_low_pfn);
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
 	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
diff -urN linux/arch/s390/tools/dasdfmt/Makefile linux-2.4.7/arch/s390/tools/dasdfmt/Makefile
--- linux/arch/s390/tools/dasdfmt/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390/tools/dasdfmt/Makefile	Wed Dec 31 19:00:00 1969
@@ -1,9 +0,0 @@
-all: dasdfmt
-
-dasdfmt: dasdfmt.c
-	$(CC) -o $@ $^
-	$(STRIP) $@
-
-clean:
-	rm -f dasdfmt
-
diff -urN linux/arch/s390/tools/dasdfmt/dasdfmt.8 linux-2.4.7/arch/s390/tools/dasdfmt/dasdfmt.8
--- linux/arch/s390/tools/dasdfmt/dasdfmt.8	Fri Mar  2 14:12:06 2001
+++ linux-2.4.7/arch/s390/tools/dasdfmt/dasdfmt.8	Wed Dec 31 19:00:00 1969
@@ -1,68 +0,0 @@
-.TH DASDFMT 8 "Tue Jan 25 2000"
-.UC 4
-.SH NAME
-dasdfmt \- formatting of DSAD (ECKD) disk drives.
-.SH SYNOPSIS
-\fBdasdfmt\fR [-tvyLV] [-b \fIblockSize\fR] [-l \fIdiskLabel\fR] \fIdiskSpec\fR
-.SH DESCRIPTION
-\fBdasdfmt\fR formats a DASD (ECKD) disk drive to prepare it
-for usage with Linux for S/390. \fBWARNING\fR: Incautious usage of
-\fBdasdfmt\fR can result in \fBLOSS OF DATA\fR.
-
-.SH OPTIONS
-.TP
-\fB-t\fR
-Disables any modification of the disk drive. \fBdasdfmt\fR just prints
-out, what it \fBwould\fR do.
-
-.TP
-\fB-v\fR
-Increases verbosity.
-
-.TP
-\fB-y\fR 
-Start formatting without further user-confirmation.
-
-.TP
-\fB-L\fR 
-Omit the writing of a disk label after formatting.
-
-.TP
-\fB-V\fR 
-Print version number and exit.
-
-.TP
-\fB-b\fR \fIblockSize\fR
-Specify blocksize to be used. \fIblocksize\fR must be a positive integer
-and always be a power of two. Due due some limitations in the driver,
-it is \fBstrongly\fR recommended to use a \fIblockSize\fR of \fI4096\fR.
-
-.TP
-\fB-l\fR \fIdiskLabel\fR
-Specify the label to be written to disk after formatting. If no label is
-specified, a sensible default is used. \fIdiskLabel\fR is interpreted as
-ASCII string and is automatically converted to EBCDIC.
-
-.TP
-\fIdiskSpec\fR
-This parameter specified the device to be formatted. It also can be
-given in two variants:
-.sp
-	\fB-f\fR \fB/dev/dasd\fR\fIX\fR
-.br
-or
-.br
-	\fB-n\fR \fIdevnum\fR
-.sp
-The first form uses the commonly used
-.SM UNIX
-device notation where \fIX\fR is a single lowercase letter.
-The second form uses simply the device number.
-
-.SH BUGS
-None so far ;-)
-
-.SH AUTHOR
-.nf
-This man-page was written by Fritz Elfert <felfert@to.com>
-.fi
diff -urN linux/arch/s390/tools/dasdfmt/dasdfmt.c linux-2.4.7/arch/s390/tools/dasdfmt/dasdfmt.c
--- linux/arch/s390/tools/dasdfmt/dasdfmt.c	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/tools/dasdfmt/dasdfmt.c	Wed Dec 31 19:00:00 1969
@@ -1,839 +0,0 @@
-/*
- *
- * dasdfmt.c
- *
- *  S390 version
- *    Copyright (C) 1999,2000 IBM Corporation
- *    Author(s): Utz Bacher, <utz.bacher@de.ibm.com>
- *
- *  Device-in-use-checks by Fritz Elfert, <felfert@to.com>
- *  Compatible Disk Layout enhancements by Carsten Otte, <cotte@de.ibm.com>
- *
- * Still to do:
- *   detect non-switch parameters ("dasdfmt -n 170 XY") and complain about them 
- */
-
-/* #define _LINUX_BLKDEV_H */
-
-#include <unistd.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <getopt.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dirent.h>
-#include <mntent.h>
-#define __KERNEL__ /* we want to use kdev_t and not have to define it */
-#include <linux/kdev_t.h>
-#undef __KERNEL__
-
-#include <linux/fs.h>
-#include <asm/dasd.h>
-#include <linux/hdreg.h>
-
-#define EXIT_MISUSE 1
-#define EXIT_BUSY 2
-#define TEMPFILENAME "/tmp/ddfXXXXXX"
-#define TEMPFILENAMECHARS 8  /* 8 characters are fixed in all temp filenames */
-#define SLASHDEV "/dev/"
-#define PROC_DASD_DEVICES "/proc/dasd/devices"
-/* _PATH_MOUNTED is /etc/mtab - /proc/mounts does not show root-fs correctly */
-#define PROC_MOUNTS _PATH_MOUNTED
-#define PROC_SWAPS "/proc/swaps"
-#define DASD_DRIVER_NAME "dasd"
-#define LABEL_LENGTH 10
-#define PROC_LINE_LENGTH 80
-#define ERR_LENGTH 80
-
-#define MAX_FILELEN NAME_MAX+PATH_MAX
-
-#define GIVEN_DEVNO 1
-#define GIVEN_MAJOR 2
-#define GIVEN_MINOR 4
-
-#define CHECK_START 1
-#define CHECK_END 2
-#define CHECK_BLKSIZE 4
-#define CHECK_ALL ~0
-
-#define ERRMSG(x...) {fflush(stdout);fprintf(stderr,x);}
-#define ERRMSG_EXIT(ec,x...) {fflush(stdout);fprintf(stderr,x);exit(ec);}
-
-#define CHECK_SPEC_MAX_ONCE(i,str) \
-	{if (i>1) \
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: " str " " \
-			"can only be specified once\n",prog_name);}
-
-#define PARSE_PARAM_INTO(x,param,base,str) \
-	{x=(int)strtol(param,&endptr,base); \
-	if (*endptr) \
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: " str " " \
-			"is in invalid format\n",prog_name);}
-
-char *prog_name;/*="dasdfmt";*/
-char tempfilename[]=TEMPFILENAME;
-
-__u8 _ascebc[256] =
-{
- /*00 NUL   SOH   STX   ETX   EOT   ENQ   ACK   BEL */
-     0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,
- /*08  BS    HT    LF    VT    FF    CR    SO    SI */
- /*              ->NL                               */
-     0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
- /*10 DLE   DC1   DC2   DC3   DC4   NAK   SYN   ETB */
-     0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,
- /*18 CAN    EM   SUB   ESC    FS    GS    RS    US */
- /*                               ->IGS ->IRS ->IUS */
-     0x18, 0x19, 0x3F, 0x27, 0x22, 0x1D, 0x1E, 0x1F,
- /*20  SP     !     "     #     $     %     &     ' */
-     0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,
- /*28   (     )     *     +     ,     -    .      / */
-     0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
- /*30   0     1     2     3     4     5     6     7 */
-     0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
- /*38   8     9     :     ;     <     =     >     ? */
-     0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
- /*40   @     A     B     C     D     E     F     G */
-     0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
- /*48   H     I     J     K     L     M     N     O */
-     0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
- /*50   P     Q     R     S     T     U     V     W */
-     0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
- /*58   X     Y     Z     [     \     ]     ^     _ */
-     0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
- /*60   `     a     b     c     d     e     f     g */
-     0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
- /*68   h     i     j     k     l     m     n     o */
-     0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
- /*70   p     q     r     s     t     u     v     w */
-     0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
- /*78   x     y     z     {     |     }     ~    DL */
-     0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
- /*80*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*88*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*90*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*98*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*A0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*A8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*B0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*B8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*C0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*C8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*D0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*D8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*E0        sz						*/
-     0x3F, 0x59, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*E8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*F0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*F8*/
-     0x90, 0x3F, 0x3F, 0x3F, 0x3F, 0xEA, 0x3F, 0xFF
-};
-
-void convert_label(char *str)
-{
-	int i;
-	for (i=0;i<LABEL_LENGTH;i++) str[i]=_ascebc[str[i]];
-}
-
-void
-exit_usage(int exitcode)
-{
-#ifdef RANGE_FORMATTING
-	printf("Usage: %s [-htvyCLV] [-l <label>] [-b <blocksize>] [<range>] " \
-		"<diskspec>\n\n",prog_name);
-#else /* RANGE_FORMATTING */
-	printf("Usage: %s [-htvyCLV] [-l <label>] [-b <blocksize>] " \
-		"<diskspec>\n\n",prog_name);
-#endif /* RANGE_FORMATTING */
-	printf("       -t means testmode\n");
-	printf("       -v means verbose mode\n");
-	printf("       -C means format compatible disk layout\n");
-	printf("       -V means print version\n");
-	printf("       -L means don't write disk label\n");
-	printf("       <label> is a label which is converted to EBCDIC and " \
-		"written to disk\n");
-	printf("       <blocksize> has to be power of 2 and at least 512\n");
-#ifdef RANGE_FORMATTING
-	printf("       <range> is either\n");
-	printf("           -s <start_track> -e <end_track>\n");
-	printf("       or\n");
-	printf("           -r <start_track>-<end_track>\n");
-#endif /* RANGE_FORMATTING */
-	printf("       and <diskspec> is either\n");
-	printf("           -f /dev/dasdX\n");
-	printf("       or\n");
-	printf("           -n <s390-devnr>\n");
-	exit(exitcode);
-}
-
-void
-get_xno_from_xno(int *devno,kdev_t *major_no,kdev_t *minor_no,int mode)
-{
-	FILE *file;
-	int d,rc;
-	kdev_t mi,ma;
-	int mi_i,ma_i; /* for scanf :-( */
-	char line[PROC_LINE_LENGTH];
-
-	file=fopen(PROC_DASD_DEVICES,"r");
-	if (file==NULL)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to open " \
-			PROC_DASD_DEVICES ": %s (do you have the /proc " \
-			"filesystem enabled?)\n",prog_name,strerror(errno));
-
-	/*	fgets(line,sizeof(line),file); omit first line */ 
-	while (fgets(line,sizeof(line),file)!=NULL) {
-                rc=sscanf(line,"%X %*[(A-Z) ] at (%d:%d)",&d,&ma_i,&mi_i);
-		ma=ma_i;
-		mi=mi_i;
-		if ( (rc==3) &&
-			!((d!=*devno)&&(mode&GIVEN_DEVNO)) &&
-			!((ma!=*major_no)&&(mode&GIVEN_MAJOR)) &&
-			!((mi!=*minor_no)&&(mode&GIVEN_MINOR)) ) {
-			*devno=d;
-			*major_no=ma;
-			*minor_no=mi;
-			/* yes, this is a quick exit, but the easiest way */
-			fclose(file);
-			return;
-		}
-	}
-	fclose(file);
-
-	ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to find device in the /proc " \
-		    "filesystem (are you sure to have the right parameter " \
-		    "dasd=xxx?)\n",
-		prog_name);
-}
-
-char *
-get_devname_from_devno(int devno,int verbosity)
-{
-	kdev_t major_no,minor_no;
-	kdev_t file_major,file_minor;
-	struct stat stat_buf;
-	int rc;
-	int found;
-	char *devname;
-	char tmpname[MAX_FILELEN];
-
-	DIR *dp;
-	struct dirent *direntp;
-
-	/**** get minor number ****/
-	get_xno_from_xno(&devno,&major_no,&minor_no,GIVEN_DEVNO);
-
-	/**** get device file ****/
-	if ((dp=opendir(SLASHDEV)) == NULL)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: unable to read " SLASHDEV \
-			"\n",prog_name);
-	found=0;
-	while ((direntp=readdir(dp)) != NULL) {
-		strcpy(tmpname,SLASHDEV);
-		strcat(tmpname,direntp->d_name);
-		rc=stat(tmpname,&stat_buf);
-		if (!rc) {
-			file_major=MAJOR(stat_buf.st_rdev);
-			file_minor=MINOR(stat_buf.st_rdev);
-			if ((file_major==major_no) && (file_minor==minor_no)) {
-				found=1;
-				break;
-			}
-		}
-	}
-	if (found) {
-		devname=malloc(strlen(direntp->d_name));
-		strcpy(devname,tmpname);
-	}
-	rc=closedir(dp);
-	if (rc<0) ERRMSG("%s: unable to close directory " SLASHDEV \
-		"; continuing\n",prog_name);
-	if (found)
-		return devname;
-
-	if (verbosity>=1)
-		printf("I didn't find device node in " SLASHDEV \
-			"; trying to create a temporary node\n");
-
-	/**** get temp file and create device node *****/
-	rc=mkstemp(tempfilename);
-	if (rc==-1)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to get temporary " \
-			"filename: %s\n",prog_name,strerror(errno));
-	close(rc);
-	rc=unlink(tempfilename);
-	
-	rc=mknod(tempfilename,S_IFBLK|0600,MKDEV(major_no,minor_no));
-	if (rc)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to create temporary " \
-			"device node %s: %s\n",prog_name,tempfilename,
-			strerror(errno));
-	return tempfilename;
-}
-
-char *
-check_param(int mode,format_data_t data)
-{
-	char *s;
-
-	if (NULL==(s=malloc(ERR_LENGTH)))
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: not enough memory.\n",prog_name);
-
-	if ((mode&CHECK_START)&&(data.start_unit<0)) {
-		strcpy(s,"start track must be greater than zero");
-		goto exit;
-	}
-	if ((mode&CHECK_END)&&(data.stop_unit<-1)) {
-		strcpy(s,"end track must be -1 or greater than zero");
-		goto exit;
-	}
-	if ((mode&CHECK_END)&&(data.start_unit>data.stop_unit)&&
-		(data.stop_unit!=-1)) {
-		strcpy(s,"end track must be higher than start track");
-		goto exit;
-	}
-
-	if ((mode&CHECK_BLKSIZE)&&(data.blksize<1)) {
-		strcpy(s,"blocksize must be a positive integer");
-		goto exit;
-	}
-	if (mode&CHECK_BLKSIZE) while (data.blksize>0) {
-		if ((data.blksize%2)&&(data.blksize!=1)) {
-			strcpy(s,"blocksize must be a power of 2");
-			goto exit;
-		}
-		data.blksize/=2;
-	}
-
-	free(s);
-	return NULL;
-exit:
-	return s;
-}
-
-#define ASK_PRINTOUT printf("Please enter %s",output)
-#define ASK_GETBUFFER fgets(buffer,sizeof(buffer),stdin)
-#define ASK_SCANFORNUMBER(var) rc=sscanf(buffer,"%d%c",&var,&c)
-#define ASK_COMPLAIN_FORMAT if ((rc==2)&&(c=='\n')) rc=1; \
-	if (rc==-1) rc=1; /* this happens, if enter is pressed */ \
-	if (rc!=1) printf(" -- wrong input, try again.\n")
-#define ASK_CHECK_PARAM(mode) str=check_param(mode,params); \
-		if (str!=NULL) { printf(" -- %s\n",str); rc=0; free(str); }
-
-format_data_t
-ask_user_for_data(format_data_t params)
-{
-	char buffer[20]; /* should be enough for inputing track numbers */
-	char c;
-	int i,rc;
-	char *str;
-	char output[60],o2[12];
-
-#ifdef RANGE_FORMATTING
-	i=params.start_unit;
-	do {
-		params.start_unit=i;
-		sprintf(output,"the start track of the range to format " \
-			"[%d]: ",i);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		ASK_SCANFORNUMBER(params.start_unit);
-		ASK_COMPLAIN_FORMAT;
-		ASK_CHECK_PARAM(CHECK_START);
-	} while (rc!=1);
-
-	i=params.stop_unit;
-	do {
-		params.stop_unit=i;
-		sprintf(output,"the end track of the range to format [");
-		if (i==-1) sprintf(o2,"END]: "); else
-			sprintf(o2,"%d]: ",i);
-		strcat(output,o2);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		if ( (!strcasecmp(buffer,"end")) ||
-			(!strcasecmp(buffer,"end\n")) ) {
-			rc=1;
-			params.stop_unit=-1;
-		} else {
-			ASK_SCANFORNUMBER(params.stop_unit);
-			ASK_COMPLAIN_FORMAT;
-			ASK_CHECK_PARAM(CHECK_END);
-		}
-	} while (rc!=1);
-#endif /* RANGE_FORMATTING */
-
-	i=params.blksize;
-	do {
-		params.blksize=i;
-		sprintf(output,"the blocksize of the formatting [%d]: ",i);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		ASK_SCANFORNUMBER(params.blksize);
-		ASK_COMPLAIN_FORMAT;
-		ASK_CHECK_PARAM(CHECK_BLKSIZE);
-	} while (rc!=1);
-
-	return params;
-}
-
-/* Check if the device we are going to format is mounted.
- * If true, complain and exit.
- */
-void
-check_mounted(int major, int minor)
-{
-	FILE *f;
-	int ishift = 0;
-	struct mntent *ment;
-	struct stat stbuf;
-	char line[128];
-
-	/* If whole disk to be formatted ... */
-	if ((minor % (1U << DASD_PARTN_BITS)) == 0) {
-		/* ... ignore partition-selector */
-		minor >>= DASD_PARTN_BITS;
-		ishift = DASD_PARTN_BITS;
-	}
-	/*
-	 * first, check filesystems
-	 */
-	if (!(f = fopen(PROC_MOUNTS, "r")))
-		ERRMSG_EXIT(EXIT_FAILURE, "%s: %s\n", PROC_MOUNTS,
-			strerror(errno));
-	while ((ment = getmntent(f))) {
-		if (stat(ment->mnt_fsname, &stbuf) == 0)
-			if ((major == MAJOR(stbuf.st_rdev)) &&
-				(minor == (MINOR(stbuf.st_rdev)>>ishift))) {
-				ERRMSG("%s: device is mounted on %s!!\n",
-					prog_name,ment->mnt_dir);
-				ERRMSG_EXIT(EXIT_BUSY, "If you really want to "
-					"format it, please unmount it.\n");
-			}
-	}
-	fclose(f);
-	/*
-	 * second, check active swap spaces
-	 */
-	if (!(f = fopen(PROC_SWAPS, "r")))
-		ERRMSG_EXIT(EXIT_FAILURE, PROC_SWAPS " %s", strerror(errno));
-	/*
-	 * skip header line
-	 */
-	fgets(line, sizeof(line), f);
-	while (fgets(line, sizeof(line), f)) {
-		char *p;
-		for (p = line; *p && (!isspace(*p)); p++) ;
-		*p = '\0';
-		if (stat(line, &stbuf) == 0)
-			if ((major == MAJOR(stbuf.st_rdev)) &&
-				(minor == (MINOR(stbuf.st_rdev)>>ishift))) {
-				ERRMSG("%s: the device is in use for "
-					"swapping!!\n",prog_name);
-				ERRMSG_EXIT(EXIT_BUSY, "If you really want to "
-					"format it, please use swapoff %s.\n",
-					line);
-			}
-	}
-	fclose(f);
-}
-
-void
-do_format_dasd(char *dev_name,format_data_t format_params,int testmode,
-	int verbosity,int writenolabel,int labelspec,
-	char *label,int withoutprompt,int devno)
-{
-	int fd,rc;
-	struct stat stat_buf;
-	kdev_t minor_no,major_no;
-	int new_blksize;
-	unsigned int label_position;
-	struct hd_geometry new_geometry;
-	char inp_buffer[5]; /* to contain yes */
-
-	fd=open(dev_name,O_RDWR);
-	if (fd==-1)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: error opening device %s: " \
-			"%s\n",prog_name,dev_name,strerror(errno));
-
-	if (verbosity>=1) {
-	}
-
-	rc=stat(dev_name,&stat_buf);
-	if (rc) {
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: error occurred during stat: " \
-			"%s\n",prog_name,strerror(errno));
-	} else {
-		if (!S_ISBLK(stat_buf.st_mode))
-			ERRMSG_EXIT(EXIT_FAILURE,"%s: file is not a " \
-				"blockdevice.\n",prog_name);
-		major_no=MAJOR(stat_buf.st_rdev);
-		minor_no=MINOR(stat_buf.st_rdev);
-	}
-	check_mounted(major_no, minor_no);
-
-	get_xno_from_xno(&devno,&major_no,&minor_no,
-			GIVEN_MAJOR|GIVEN_MINOR);
-	if ((!writenolabel) && (!labelspec)) {
-		sprintf(label,"LNX1 x%04x",devno);
-	}
-	
-	if ( ((withoutprompt)&&(verbosity>=1)) ||
-		(!withoutprompt) ) {
-		printf("\nI am going to format the device %s in the " \
-			"following way:\n",dev_name);
-		printf("   Device number of device : 0x%x\n",devno);
-		printf("   Major number of device  : %u\n",major_no);
-		printf("   Minor number of device  : %u\n",minor_no);
-		printf("   Labelling device        : %s\n",(writenolabel)?
-			"no":"yes");
-		if (!writenolabel)
-			printf("   Disk label              : %s\n",label);
-		if (format_params.intensity != DASD_FORMAT_DEFAULT_INTENSITY)
-			printf("   Compatible Disk Layout  : %s\n",(format_params.intensity&0x08)?
-			       "yes":"no");
-#ifdef RANGE_FORMATTING
-		printf("   Start track             : %d\n" \
-			,format_params.start_unit);
-		printf("   End track               : ");
-		if (format_params.stop_unit==-1)
-			printf("last track of disk\n");
-		else
-			printf("%d\n",format_params.stop_unit);
-#endif /* RANGE_FORMATTING */
-		printf("   Blocksize               : %d\n" \
-			,format_params.blksize);
-		if (testmode) printf("Test mode active, omitting ioctl.\n");
-	}
-
-	while (!testmode) {
-		if (!withoutprompt) {
-			printf("\n--->> ATTENTION! <<---\n");
-			printf("All data in the specified range of that " \
-				"device will be lost.\nType \"yes\" to " \
-				"continue, no will leave the disk untouched: ");
-			fgets(inp_buffer,sizeof(inp_buffer),stdin);
-			if (strcasecmp(inp_buffer,"yes") &&
-				strcasecmp(inp_buffer,"yes\n")) {
-				printf("Omitting ioctl call (disk will " \
-					"NOT be formatted).\n");
-				break;
-			}
-		}
-
-		if ( !(  (withoutprompt)&&(verbosity<1) ))
-			printf("Formatting the device. This may take a " \
-				"while (get yourself a coffee).\n");
-		rc=ioctl(fd,BIODASDFORMAT,format_params);
-		if (rc)
-			ERRMSG_EXIT(EXIT_FAILURE,"%s: the dasd driver " \
-				"returned with the following error " \
-				"message:\n%s\n",prog_name,strerror(errno));
-		printf("Finished formatting the device.\n");
-
-		if (!writenolabel) {
-			if (verbosity>0)
-				printf("Retrieving disk geometry... ");
-
-			rc=ioctl(fd,HDIO_GETGEO,&new_geometry);
-			if (rc) {
-				ERRMSG("%s: the ioctl call to get geometry " \
-					"returned with the following error " \
-					"message:\n%s\n",prog_name,
-					strerror(errno));
-				goto reread;
-			}
-	
-
-			rc=ioctl(fd,BLKSSZGET,&new_blksize);
-			if (rc) {
-				ERRMSG("%s: the ioctl call to get blocksize " \
-					"returned with the following error " \
-					"message:\n%s\n",prog_name,
-					strerror(errno));
-				goto reread;
-			}
-	
-			if (verbosity>0) printf("done\n");
-
-			label_position=new_geometry.start*new_blksize;
-	
-			if (verbosity>0) printf("Writing label... ");
-			convert_label(label);
-			rc=lseek(fd,label_position,SEEK_SET);
-			if (rc!=label_position) {
-				ERRMSG("%s: lseek on the device to %i " \
-					"failed with the following error " \
-					"message:\n%s\n",prog_name,
-					label_position,strerror(errno));
-				goto reread;
-			}
-			rc=write(fd,label,LABEL_LENGTH);
-			if (rc!=LABEL_LENGTH) {
-				ERRMSG("%s: writing the label only wrote %d " \
-					"bytes.\n",prog_name,rc);
-				goto reread;
-			}
-
-			sync();
-			sync();
-
-			if (verbosity>0) printf("done\n");
-		}
- reread:
-		printf("Rereading the partition table... ");
-		rc=ioctl(fd,BLKRRPART,NULL);
-		if (rc) {
-			ERRMSG("%s: error during rereading the partition " \
-			       "table: %s.\n",prog_name,strerror(errno));
-		} else printf("done.\n");
-
-		break;
-	}
-
-	rc=close(fd);
-	if (rc)
-		ERRMSG("%s: error during close: " \
-			"%s; continuing.\n",prog_name,strerror(errno));
-}
-
-
-
-int main(int argc,char *argv[]) {
-	int verbosity;
-	int testmode;
-	int withoutprompt;
-	int writenolabel,labelspec;
-
-	char *dev_name;
-	int devno;
-	char *dev_filename,*devno_param_str,*range_param_str;
-	char *start_param_str,*end_param_str,*blksize_param_str;
-	char label[LABEL_LENGTH+1];
-	
-	format_data_t format_params;
-
-	int rc;
-	int oc;
-	char *endptr;
-
-	char c1,c2,cbuffer[6]; /* should be able to contain -end plus 1 char */
-	int i,i1,i2;
-	char *str;
-
-	int start_specified,end_specified,blksize_specified;
-	int devfile_specified,devno_specified,range_specified;
-
-	/******************* initialization ********************/
-	prog_name=argv[0];
-
-	endptr=NULL;
-
-	/* set default values */
-	format_params.start_unit=DASD_FORMAT_DEFAULT_START_UNIT;
-	format_params.stop_unit=DASD_FORMAT_DEFAULT_STOP_UNIT;
-	format_params.blksize=DASD_FORMAT_DEFAULT_BLOCKSIZE;
-	format_params.intensity=DASD_FORMAT_DEFAULT_INTENSITY;
-	testmode=0;
-	verbosity=0;
-	withoutprompt=0;
-	writenolabel=0;
-	labelspec=0;
-	for (i=0;i<LABEL_LENGTH;i++) label[i]=' ';
-	label[LABEL_LENGTH]=0;
-
-	start_specified=end_specified=blksize_specified=0;
-	devfile_specified=devno_specified=range_specified=0;
-
-	/*************** parse parameters **********************/
-
-	/* avoid error message generated by getopt */
-	opterr=0;
-
-#ifdef RANGE_FORMATTING
-	while ( (oc=getopt(argc,argv,"r:s:e:b:n:l:f:ChLty?vV")) !=EOF) {
-#endif /* RANGE_FORMATTING */
-	while ( (oc=getopt(argc,argv,"b:n:l:f:ChLty?vV")) !=EOF) {
-		switch (oc) {
-		case 'y':
-			withoutprompt=1;
-			break;
-
-		case 't':
-			testmode=1;
-			break;
-
-		case 'v':
-			verbosity++;
-			break;
-
-		case '?': /* fall-through */
-		case ':':
-			exit_usage(EXIT_MISUSE);
-
-		case 'h':
-			exit_usage(0);
-		case 'C':
-                	format_params.intensity&=0x08;
-			break;
-
-		case 'V':
-			printf("%s version 0.99\n",prog_name);
-			exit(0);
-
-		case 'l':
-			strncpy(label,optarg,LABEL_LENGTH);
-			if (strlen(optarg)<LABEL_LENGTH)
-				label[strlen(optarg)]=' ';
-			labelspec++;
-			break;
-
-		case 'L':
-			writenolabel++;
-			break;
-
-#ifdef RANGE_FORMATTING
-		case 's' :
-			start_param_str=optarg;
-			start_specified++;
-			break;
-			
-		case 'e' :
-			end_param_str=optarg;
-			end_specified++;
-			break;
-
-		case 'r' :
-			range_param_str=optarg;
-			range_specified++;
-			break;
-#endif /* RANGE_FORMATTING */
-
-		case 'b' :
-			blksize_param_str=optarg;
-			blksize_specified++;
-			break;
-			
-		case 'n' :
-			devno_param_str=optarg;
-			devno_specified++;
-			break;
-		
-		case 'f' :
-			dev_filename=optarg;
-			devfile_specified++;
-			break;
-		}
-	}
-
-	/******************** checking of parameters **************/
-
-	/* convert range into -s and -e */
-	CHECK_SPEC_MAX_ONCE(range_specified,"formatting range");
-
-	while (range_specified) {
-		start_specified++;
-		end_specified++;
-
-		/* scan for 1 or 2 integers, separated by a dash */
-		rc=sscanf(range_param_str,"%d%c%d%c",&i1,&c1,&i2,&c2);
-		if ((rc==3)&&(c1=='-')) {
-			format_params.start_unit=i1;
-			format_params.stop_unit=i2;
-			break;
-		}
-		if (rc==1) {
-			format_params.start_unit=i1;
-			break;
-		}
-
-		/* scan for integer and -END */
-		rc=sscanf(range_param_str,"%d%s",&i1,cbuffer);
-		if ((rc==2)&&(!strcasecmp(cbuffer,"-END"))) {
-			format_params.start_unit=i1;
-			format_params.stop_unit=-1;
-			break;
-		}
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: specified range " \
-			"is in invalid format\n",prog_name);
-	}
-
-	if ((!devfile_specified)&&(!devno_specified))
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: device to format " \
-			"not specified\n",prog_name);
-
-	if ((devfile_specified+devno_specified)>1)
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: device to format " \
-			"can only be specified once\n",prog_name);
-
-	if ((!start_specified)&&(!end_specified)&&(!range_specified)&&
-		(!blksize_specified)) {
-		format_params=ask_user_for_data(format_params);
-	}
-
-	CHECK_SPEC_MAX_ONCE(start_specified,"start track");
-	CHECK_SPEC_MAX_ONCE(end_specified,"end track");
-	CHECK_SPEC_MAX_ONCE(blksize_specified,"blocksize");
-	CHECK_SPEC_MAX_ONCE(labelspec,"label");
-	CHECK_SPEC_MAX_ONCE(writenolabel,"omit-label-writing flag");
-
-	if (devno_specified)
-		PARSE_PARAM_INTO(devno,devno_param_str,16,"device number");
-	if (start_specified&&!range_specified)
-		PARSE_PARAM_INTO(format_params.start_unit,start_param_str,10,
-			"start track");
-	if (end_specified&&!range_specified)
-		PARSE_PARAM_INTO(format_params.stop_unit,end_param_str,10,
-			"end track");
-	if (blksize_specified)
-		PARSE_PARAM_INTO(format_params.blksize,blksize_param_str,10,
-			"blocksize");
-
-	/***********get dev_name *********************/
-	dev_name=(devno_specified)?
-		get_devname_from_devno(devno,verbosity):
-		dev_filename;
-
-	/*** range checking *********/
-	str=check_param(CHECK_ALL,format_params);
-	if (str!=NULL) ERRMSG_EXIT(EXIT_MISUSE,"%s: %s\n",prog_name,str);
-
-	/******* issue the real command and reread part table *******/
-	do_format_dasd(dev_name,format_params,testmode,verbosity,
-		writenolabel,labelspec,label,withoutprompt,devno);
-
-	/*************** cleanup ********************************/
-	if (strncmp(dev_name,TEMPFILENAME,TEMPFILENAMECHARS)==0) {
-		rc=unlink(dev_name);
-		if ((rc)&&(verbosity>=1))
-			ERRMSG("%s: temporary device node %s could not be " \
-				"removed: %s\n",prog_name,dev_name,
-				strerror(errno));
-	} else {
-		if (devno_specified) {
-			/* so we have allocated space for the filename */
-			free(dev_name);
-		}
-	}
-
-	return 0;
-}
diff -urN linux/arch/s390/tools/silo/Makefile linux-2.4.7/arch/s390/tools/silo/Makefile
--- linux/arch/s390/tools/silo/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390/tools/silo/Makefile	Wed Dec 31 19:00:00 1969
@@ -1,15 +0,0 @@
-all: silo
-
-silo.o: silo.c
-	$(CC) -c -o silo.o -O2 silo.c
-
-cfg.o: cfg.c
-	$(CC) -c -o cfg.o -O2 cfg.c
-
-silo: silo.o cfg.o
-	$(CC) -o $@ $^
-	$(STRIP) $@
-
-clean:
-	rm -f *.o silo
-
diff -urN linux/arch/s390/tools/silo/cfg.c linux-2.4.7/arch/s390/tools/silo/cfg.c
--- linux/arch/s390/tools/silo/cfg.c	Fri May 12 14:41:45 2000
+++ linux-2.4.7/arch/s390/tools/silo/cfg.c	Wed Dec 31 19:00:00 1969
@@ -1,373 +0,0 @@
-/* cfg.c  -  Configuration file parser */
-
-/* Copyright 1992-1997 Werner Almesberger. See file COPYING for details. */
-
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <string.h>
-
-#include "cfg.h"
-
-#define MAX_TOKEN 200
-#define MAX_VAR_NAME MAX_TOKEN
-
-static FILE *file;
-static char flag_set;
-static char *last_token = NULL,*last_item = NULL,*last_value = NULL;
-static int line_num;
-static char *file_name = NULL;
-static int back = 0; /* can go back by one char */
-
-
-void pdie(char *msg)
-{
-    fflush(stdout);
-    perror(msg);
-    exit(1);
-}
-
-
-void die(char *fmt,...)
-{
-    va_list ap;
-
-    fflush(stdout);
-    va_start(ap,fmt);
-    vfprintf(stderr,fmt,ap);
-    va_end(ap);
-    fputc('\n',stderr);
-    exit(1);
-}
-
-char *pstrdup(const char *str)
-{
-    char *this;
-
-    if ((this = strdup(str)) == NULL) pdie("Out of memory");
-    return this;
-}
-
-int cfg_open(char *name)
-{
-    if (!strcmp(name,"-")) file = stdin;
-    else if (!(file = fopen(file_name = name,"r"))) pdie(name);
-    line_num = 1;
-    return fileno(file);
-}
-
-void cfg_error(char *msg,...)
-{
-    va_list ap;
-
-    fflush(stdout);
-    va_start(ap,msg);
-    vfprintf(stderr,msg,ap);
-    va_end(ap);
-    if (!file_name) fputc('\n',stderr);
-    else fprintf(stderr," near line %d in file %s\n",line_num,file_name);
-    exit(1);
-}
-
-
-static int next_raw(void)
-{
-    int ch;
-
-    if (!back) return getc(file);
-    ch = back;
-    back = 0;
-    return ch;
-}
-
-
-static int next(void)
-{
-    static char *var;
-    char buffer[MAX_VAR_NAME+1];
-    int ch,braced;
-    char *put;
-
-    if (back) {
-	ch = back;
-	back = 0;
-	return ch;
-    }
-    if (var && *var) return *var++;
-    ch = getc(file);
-    if (ch == '\\') {
-	ch = getc(file);
-	if (ch == '$') return ch;
-	ungetc(ch,file);
-	return '\\';
-    }
-    if (ch != '$') return ch;
-    ch = getc(file);
-    braced = ch == '{';
-    put = buffer;
-    if (!braced) *put++ = ch;
-    while (1) {
-	ch = getc(file);
-#if 0
-	if (!braced && ch < ' ') {
-	    ungetc(ch,file);
-	    break;
-	}
-#endif
-	if (ch == EOF) cfg_error("EOF in variable name");
-	if (ch < ' ') cfg_error("control character in variable name");
-	if (braced && ch == '}') break;
-	if (!braced && !isalpha(ch) && !isdigit(ch) && ch != '_') {
-	    ungetc(ch,file);
-	    break;
-	}
-	if (put-buffer == MAX_VAR_NAME) cfg_error("variable name too long");
-	*put++ = ch;
-    }
-    *put = 0;
-    if (!(var = getenv(buffer))) cfg_error("unknown variable \"%s\"",buffer);
-    return next();
-}
-
-
-static void again(int ch)
-{
-    if (back) die("internal error: again invoked twice");
-    back = ch;
-}
-
-
-static char *cfg_get_token(void)
-{
-    char buf[MAX_TOKEN+1];
-    char *here;
-    int ch,escaped;
-
-    if (last_token) {
-	here = last_token;
-	last_token = NULL;
-	return here;
-    }
-    while (1) {
-	while ((ch = next()), ch == ' ' || ch == '\t' || ch == '\n')
-	    if (ch == '\n') line_num++;
-	if (ch == EOF) return NULL;
-	if (ch != '#') break;
-	while ((ch = next_raw()), ch != '\n')
-	    if (ch == EOF) return NULL;
-	line_num++;
-    }
-    if (ch == '=') return pstrdup("=");
-    if (ch == '"') {
-	here = buf;
-	while (here-buf < MAX_TOKEN) {
-	    if ((ch = next()) == EOF) cfg_error("EOF in quoted string");
-	    if (ch == '"') {
-		*here = 0;
-		return pstrdup(buf);
-	    }
-	    if (ch == '\\') {
-		ch = next();
-		if (ch != '"' && ch != '\\' && ch != '\n')
-		    cfg_error("Bad use of \\ in quoted string");
-		if (ch == '\n') {
-		    while ((ch = next()), ch == ' ' || ch == '\t');
-		    if (!ch) continue;
-		    again(ch);
-		    ch = ' ';
-		}
-	    }
-	    if (ch == '\n' || ch == '\t')
-		cfg_error("\\n and \\t are not allowed in quoted strings");
-	    *here++ = ch;
-	}
-	cfg_error("Quoted string is too long");
-	return 0; /* not reached */
-    }
-    here = buf;
-    escaped = 0;
-    while (here-buf < MAX_TOKEN) {
-	if (escaped) {
-	    if (ch == EOF) cfg_error("\\ precedes EOF");
-	    if (ch == '\n') line_num++;
-	    else *here++ = ch == '\t' ? ' ' : ch;
-	    escaped = 0;
-	}
-	else {
-	    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '#' ||
-	      ch == '=' || ch == EOF) {
-		again(ch);
-		*here = 0;
-		return pstrdup(buf);
-	    }
-	    if (!(escaped = (ch == '\\'))) *here++ = ch;
-	}
-	ch = next();
-    }
-    cfg_error("Token is too long");
-    return 0; /* not reached */
-}
-
-
-static void cfg_return_token(char *token)
-{
-    last_token = token;
-}
-
-
-static int cfg_next(char **item,char **value)
-{
-    char *this;
-
-    if (last_item) {
-	*item = last_item;
-	*value = last_value;
-	last_item = NULL;
-	return 1;
-    }
-    *value = NULL;
-    if (!(*item = cfg_get_token())) return 0;
-    if (!strcmp(*item,"=")) cfg_error("Syntax error");
-    if (!(this = cfg_get_token())) return 1;
-    if (strcmp(this,"=")) {
-	cfg_return_token(this);
-	return 1;
-    }
-    if (!(*value = cfg_get_token())) cfg_error("Value expected at EOF");
-    if (!strcmp(*value,"=")) cfg_error("Syntax error after %s",*item);
-    return 1;
-}
-
-
-static void cfg_return(char *item,char *value)
-{
-    last_item = item;
-    last_value = value;
-}
-
-
-void cfg_init(CONFIG *table)
-{
-    while (table->type != cft_end) {
-	switch (table->type) {
-	    case cft_strg:
-		if (table->data) free(table->data);
-	    case cft_flag:
-		table->data = NULL;
-		break;
-	    case cft_link:
-		table = ((CONFIG *) table->action)-1;
-		break;
-	    default:
-		die("Unknown syntax code %d",table->type);
-	}
-	table++;
-    }
-}
-
-
-static int cfg_do_set(CONFIG *table,char *item,char *value,int copy,
-    void *context)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (value && walk->type != cft_strg)
-		cfg_error("'%s' doesn't have a value",walk->name);
-	    if (!value && walk->type == cft_strg)
-		cfg_error("Value expected for '%s'",walk->name);
-	    if (walk->data) {
-		if (walk->context == context)
-		    cfg_error("Duplicate entry '%s'",walk->name);
-		else {
-		    fprintf(stderr,"Ignoring entry '%s'\n",walk->name);
-		    if (!copy) free(value);
-		    return 1;
-		}
-	    }
-	    if (walk->type == cft_flag) walk->data = &flag_set;
-	    else if (walk->type == cft_strg) {
-		    if (copy) walk->data = pstrdup(value);
-		    else walk->data = value;
-	    }
-	    walk->context = context;
-	    if (walk->action) ((void (*)(void)) walk->action)();
-	    break;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    if (walk->type != cft_end) return 1;
-    cfg_return(item,value);
-    return 0;
-}
-
-
-void cfg_set(CONFIG *table,char *item,char *value,void *context)
-{
-    if (!cfg_do_set(table,item,value,1,context))
-	cfg_error("cfg_set: Can't set %s",item);
-}
-
-
-void cfg_unset(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++)
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (!walk->data) die("internal error (cfg_unset %s, unset)",item);
-	    if (walk->type == cft_strg) free(walk->data);
-	    walk->data = NULL;
-	    return;
-	}
-    die("internal error (cfg_unset %s, unknown",item);
-}
-
-
-int cfg_parse(CONFIG *table)
-{
-    char *item,*value;
-
-    while (1) {
-	if (!cfg_next(&item,&value)) return 0;
-	if (!cfg_do_set(table,item,value,0,table)) return 1;
-	free(item);
-    }
-}
-
-
-int cfg_get_flag(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (walk->type != cft_flag)
-		die("cfg_get_flag: operating on non-flag %s",item);
-	    return !!walk->data;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    die("cfg_get_flag: unknown item %s",item);
-    return 0; /* not reached */
-}
-
-
-char *cfg_get_strg(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (walk->type != cft_strg)
-		die("cfg_get_strg: operating on non-string %s",item);
-	    return walk->data;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    die("cfg_get_strg: unknown item %s",item);
-    return 0; /* not reached */
-}
diff -urN linux/arch/s390/tools/silo/cfg.h linux-2.4.7/arch/s390/tools/silo/cfg.h
--- linux/arch/s390/tools/silo/cfg.h	Fri May 12 14:41:45 2000
+++ linux-2.4.7/arch/s390/tools/silo/cfg.h	Wed Dec 31 19:00:00 1969
@@ -1,58 +0,0 @@
-/* cfg.h  -  Configuration file parser */
-
-/* Copyright 1992-1996 Werner Almesberger. See file COPYING for details. */
-
-
-#ifndef CFG_H
-#define CFG_H
-
-typedef enum { cft_strg, cft_flag, cft_link, cft_end } CFG_TYPE;
-
-typedef struct {
-    CFG_TYPE type;
-    char *name;
-    void *action;
-    void *data;
-    void *context;
-} CONFIG;
-
-extern int cfg_open(char *name);
-
-/* Opens the configuration file. Returns the file descriptor of the open
-   file. */
-
-extern void cfg_error(char *msg,...);
-
-/* Signals an error while parsing the configuration file and terminates the
-   program. */
-
-extern void cfg_init(CONFIG *table);
-
-/* Initializes the specified table. */
-
-extern void cfg_set(CONFIG *table,char *item,char *value,void *context);
-
-/* Sets the specified variable in table. If the variable has already been set
-   since the last call to cfg_init, a warning message is issued if the context
-   keys don't match or a fatal error is reported if they do. */
-
-extern void cfg_unset(CONFIG *table,char *item);
-
-/* Unsets the specified variable in table. It is a fatal error if the variable
-   was not set. */
-
-extern int cfg_parse(CONFIG *table);
-
-/* Parses the configuration file for variables contained in table. A non-zero
-   value is returned if a variable not found in table has been met. Zero is
-   returned if EOF has been reached. */
-
-extern int cfg_get_flag(CONFIG *table,char *item);
-
-/* Returns one if the specified variable is set, zero if it isn't. */
-
-extern char *cfg_get_strg(CONFIG *table,char *item);
-
-/* Returns the value of the specified variable if it is set, NULL otherwise. */
-
-#endif
diff -urN linux/arch/s390/tools/silo/silo.c linux-2.4.7/arch/s390/tools/silo/silo.c
--- linux/arch/s390/tools/silo/silo.c	Wed Apr 11 22:02:27 2001
+++ linux-2.4.7/arch/s390/tools/silo/silo.c	Wed Dec 31 19:00:00 1969
@@ -1,586 +0,0 @@
-/*
- *  arch/s390/boot/silo.c
- *
- *  S390 version
- *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *
- *    Report bugs to: <linux390@de.ibm.com>
- *
- *    Author(s): Holger Smolinski <Holger.Smolinski@de.ibm.com>
- *               Fritz Elfert <felfert@to.com> contributed support for
- *                	/etc/silo.conf based on Intel's lilo
- *    Changes  :
- *               01/15/01 Holger Smolinski <Holger.Smolinski@de.ibm.com>
- *                 adapted to deal with devices and bootsects of various sizes
- */
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <limits.h>
-#include <dirent.h>
-#include <linux/fs.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <asm/ioctl.h>
-
-#include "cfg.h"
-
-CONFIG cf_options[] = {
-  { cft_strg, "append",		NULL,		NULL,NULL },
-  { cft_strg, "image",		NULL,		NULL,NULL },
-  { cft_strg, "ipldevice",	NULL,		NULL,NULL },
-  { cft_strg, "bootsect",	NULL,		NULL,NULL },
-  { cft_strg, "map",		NULL,		NULL,NULL },
-  { cft_strg, "parmfile",	NULL,		NULL,NULL },
-  { cft_strg, "ramdisk",	NULL,		NULL,NULL },
-  { cft_strg, "root",		NULL,		NULL,NULL },
-  { cft_flag, "readonly",	NULL,		NULL,NULL },
-  { cft_strg, "verbose",	NULL,		NULL,NULL },
-  { cft_strg, "testlevel",	NULL,		NULL,NULL },
-  { cft_end,  NULL,		NULL,		NULL,NULL }
-};
-  
-/* from dasd.h */
-#define DASD_PARTN_BITS 2
-#define BIODASDRWTB _IOWR('D',0,int)
-/* end */
-
-#define SILO_CFG "/etc/silo.conf"
-#define SILO_IMAGE "./image"
-#define SILO_BOOTMAP "./boot.map"
-#define SILO_PARMFILE "./parmfile"
-#define SILO_BOOTSECT "/boot/ipleckd.boot"
-
-#define PRINT_LEVEL(x,y...) if ( silo_options.verbosity >= x ) printf(y)
-#define ERROR_LEVEL(x,y...) if ( silo_options.verbosity >= x ) fprintf(stderr,y)
-#define TOGGLE(x) ((x)=((x)?(0):(1)))
-#define GETARG(x) {int len=strlen(optarg);x=malloc(len);strncpy(x,optarg,len);PRINT_LEVEL(1,"%s set to %s\n",#x,optarg);}
-
-#define ITRY(x) if ( (x) == -1 ) { ERROR_LEVEL(0,"%s (line:%d) '%s' returned %d='%s'\n", __FILE__,__LINE__,#x,errno,strerror(errno)); usage(); exit(1); }
-#define NTRY(x) if ( (x) == 0 ) { ERROR_LEVEL(0,"%s (line:%d) '%s' returned %d='%s'\n", __FILE__,__LINE__,#x,errno,strerror(errno)); usage(); exit(1); }
-
-#define MAX_CLUSTERS 256
-#define PARTN_MASK ((1 << DASD_PARTN_BITS) - 1)
-
-#define SILO_VERSION "1.1"
-
-struct silo_options
-  {
-    short int verbosity;
-    short int testlevel;
-    char *image;
-    char *ipldevice;
-    char *parmfile;
-    char *ramdisk;
-    char *bootsect;
-    char *conffile;
-    char *bootmap;
-  }
-silo_options =
-{
-  1,				/* verbosity */
-  2,				/* testlevel */
-    SILO_IMAGE,			/* image */
-    NULL,			/* ipldevice */
-    SILO_PARMFILE,		/* parmfile */
-    NULL,			/* initrd */
-    SILO_BOOTSECT,		/* bootsector */
-    SILO_CFG,                   /* silo.conf file */
-    SILO_BOOTMAP,               /* boot.map */
-};
-
-struct blockdesc
-  {
-    unsigned long off;
-    unsigned short ct;
-    unsigned long addr;
-  };
-
-struct blocklist
-  {
-    struct blockdesc blk[MAX_CLUSTERS];
-    unsigned short ix;
-  };
-
-void
-usage (void)
-{
-  printf ("Usage:\n");
-  printf ("silo -d ipldevice [additional options]\n");
-  printf ("-d /dev/node : set ipldevice to /dev/node\n");
-  printf ("-f image : set image to image\n");
-  printf ("-F conffile : specify configuration file (/etc/silo.conf)\n");
-  printf ("-p parmfile : set parameter file to parmfile\n");
-  printf ("-b bootsect : set bootsector to bootsect\n");
-  printf ("Additional options\n");
-  printf ("-B bootmap:\n");
-  printf ("-v: increase verbosity level\n");
-  printf ("-v#: set verbosity level to #\n");
-  printf ("-t: decrease testing level\n");
-  printf ("-h: print this message\n");
-  printf ("-?: print this message\n");
-  printf ("-V: print version\n");
-}
-
-int
-read_cfg(struct silo_options *o)
-{
-	char *tmp;
-	if (access(o->conffile, R_OK) && (errno == ENOENT))
-		return 0;
-	/* If errno != ENOENT, let cfg_open report an error */
-	cfg_open(o->conffile);
-	cfg_parse(cf_options);
-	tmp = cfg_get_strg(cf_options, "ipldevice");
-	if ( ! o->ipldevice  && tmp ) 
-		o->ipldevice = tmp;
-	tmp = cfg_get_strg(cf_options, "image");
-	if ( ! strncmp(o-> image,SILO_IMAGE,strlen(SILO_IMAGE)) && tmp ) 
-		o->image = tmp;
-	tmp = cfg_get_strg(cf_options, "parmfile");
-	if ( !strncmp(o->parmfile,SILO_PARMFILE,strlen(SILO_PARMFILE)) && tmp) 
-		o->parmfile = tmp;
-	if ( ! o -> ramdisk ) 
-		o->ramdisk = cfg_get_strg(cf_options, "ramdisk");
-	tmp = cfg_get_strg(cf_options, "bootsect");
-	if ( !strncmp(o -> bootsect,SILO_BOOTSECT,strlen(SILO_BOOTSECT))&&tmp)
-		o->bootsect = tmp;
-	tmp = cfg_get_strg(cf_options, "map") ;
-	if ( !strncmp(o -> bootmap,SILO_BOOTMAP,strlen(SILO_BOOTMAP)) && tmp) 
-		o->bootmap = tmp; 
-	tmp = cfg_get_strg(cf_options, "verbose");
-	if ( tmp ) {
-		unsigned short v;
-		sscanf (tmp, "%hu", &v);
-		o->verbosity = v;
-	}
-	tmp = cfg_get_strg(cf_options, "testlevel");
-	if ( tmp ) {
-		unsigned short t;
-		sscanf (tmp, "%hu", &t);
-		o->testlevel += t;
-	}
-	return 1;
-}
-
-char *
-gen_tmpparm( char *pfile )
-{
-	char *append = cfg_get_strg(cf_options, "append");
-	char *root = cfg_get_strg(cf_options, "root");
-	int ro = cfg_get_flag(cf_options, "readonly");
-	FILE *f,*of;
-	char *fn;
-	char c;
-	char *tmpdir=NULL,*save=NULL;
-
-	if (!append && !root && !ro)
-		return pfile;
-	of = fopen(pfile, "r");
-	if ( of ) {
-		NTRY( fn = tempnam(NULL,"parm."));
-	} else {
-		fn = pfile;
-	}
-	NTRY( f = fopen(fn, "a+"));
-	if ( of ) {
-		while ( ! feof (of) ) {
-		  c=fgetc(of);
-	  	fputc(c,f);
-		}
-	}
-	if (root)
-		fprintf(f, " root=%s", root);
-	if (ro)
-		fprintf(f, " ro");
-	if (append)
-		fprintf(f, " %s", append);
-	fprintf(f, "\n");
-	fclose(f);
-	fclose(of);
-	printf ("tempfile is %s\n",fn);
-	return strdup(fn);
-}
-
-int
-parse_options (struct silo_options *o, int argc, char *argv[])
-{
-  int rc = 0;
-  int oc;
-
-  while ((oc = getopt (argc, argv, "Vf:F:d:p:r:b:B:h?v::t::")) != -1)
-    {
-      switch (oc)
-	{
-	case 'V':
-	  printf("silo version: %s\n",SILO_VERSION);
-	  exit(0);
-	case 'v':
-	  {
-	    unsigned short v;
-	    if (optarg && sscanf (optarg, "%hu", &v))
-	      o->verbosity = v;
-	    else
-	      o->verbosity++;
-	    PRINT_LEVEL (1, "Verbosity value is now %hu\n", o->verbosity);
-	    break;
-	  }
-	case 't':
-	  {
-	    unsigned short t;
-	    if (optarg && sscanf (optarg, "%hu", &t))
-	      o->testlevel -= t;
-	    else
-	      o->testlevel--;
-            PRINT_LEVEL (1, "Testonly flag is now %d\n", o->testlevel);
-	    break;
-	  }
-	case 'h':
-	case '?':
-	  usage ();
-	  exit(0);
-	case 'd':
-	  GETARG (o->ipldevice);
-	  break;
-	case 'f':
-	  GETARG (o->image);
-	  break;
-        case 'F':                         
- 	   GETARG (o->conffile);              
- 	   break;                          
-	case 'p':
-	  GETARG (o->parmfile);
-	  break;
-	case 'r':
-	  GETARG (o->ramdisk);
-	  break;
-	case 'b':
-	  GETARG (o->bootsect);
-	  break;
-	case 'B':
-	  GETARG (o->bootmap);
-	default:
-	  rc = EINVAL;
-	  break;
-	}
-    }
-  read_cfg(o);
-  return rc;
-}
-
-int
-verify_device (char *name)
-{
-  int rc = 0;
-  struct stat dst;
-  struct stat st;
-  ITRY (stat (name, &dst));
-  if (S_ISBLK (dst.st_mode))
-    {
-      if (!(MINOR (dst.st_rdev) & PARTN_MASK))
-	{
-	  rc = dst.st_rdev;
-	}
-      else
-	/* invalid MINOR & PARTN_MASK */
-	{
-	  ERROR_LEVEL (1, "Cannot boot from partition %d %d %d",
-		       (int) PARTN_MASK, (int) MINOR (dst.st_rdev), (int) (PARTN_MASK & MINOR (dst.st_rdev)));
-	  rc = -1;
-	  errno = EINVAL;
-	}
-    }
-  else
-    /* error S_ISBLK */
-    {
-      ERROR_LEVEL (1, "%s is no block device\n", name);
-      rc = -1;
-      errno = EINVAL;
-    }
-  return rc;
-}
-
-int
-verify_file (char *name, int dev)
-{
-  int rc = 0;
-  struct stat dst;
-  struct stat st;
-  int bs = 1024;
-  int l;
-
-  ITRY(stat ( name, &dst ));
-  if (S_ISREG (dst.st_mode))
-    {
-      if ((unsigned) MAJOR (dev) == (unsigned) MAJOR (dst.st_dev) && (unsigned) MINOR (dev) == (unsigned) (MINOR (dst.st_dev) & ~PARTN_MASK))
-	{
-	  /* whatever to do if all is ok... */
-	}
-      else
-	/* devicenumber doesn't match */
-	{
-	  ERROR_LEVEL (1, "%s is not on device (%d/%d) but on (%d/%d)\n", name, (unsigned) MAJOR (dev), (unsigned) MINOR (dev), (unsigned) MAJOR (dst.st_dev), (unsigned) (MINOR (dst.st_dev) & ~PARTN_MASK));
-	  rc = -1;
-	  errno = EINVAL;
-	}
-    }
-  else
-    /* error S_ISREG */
-    {
-      ERROR_LEVEL (1, "%s is neither regular file nor linkto one\n", name);
-      rc = -1;
-      errno = EINVAL;
-    }
-  return rc;
-}
-
-int
-verify_options (struct silo_options *o)
-{
-  int rc = 0;
-  int dev = 0;
-  int crc = 0;
-  if (!o->ipldevice || !o->image || !o->bootsect)
-    {
-     if (!o->ipldevice)
-       fprintf(stderr,"ipldevice\n");
-     if (!o->image)
-       fprintf(stderr,"image\n");
-     if (!o->bootsect)
-       fprintf(stderr,"bootsect\n");
-
-      usage ();
-      exit (1);
-    }
-  PRINT_LEVEL (1, "Testlevel is set to %d\n",o->testlevel);
-
-  PRINT_LEVEL (1, "IPL device is: '%s'", o->ipldevice);
-  ITRY (dev = verify_device (o->ipldevice));
-  PRINT_LEVEL (2, "...ok...(%d/%d)", (unsigned short) MAJOR (dev), (unsigned short) MINOR (dev));
-  PRINT_LEVEL (1, "\n");
-
-  PRINT_LEVEL (0, "bootsector is: '%s'", o->bootsect);
-  ITRY (verify_file (o->bootsect, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  if ( o -> testlevel > 0  && 
-       ! strncmp( o->bootmap, SILO_BOOTMAP,strlen(SILO_BOOTMAP) )) {
-     NTRY( o -> bootmap = tempnam(NULL,"boot."));
-  }
-  PRINT_LEVEL (0, "bootmap is set to: '%s'", o->bootmap);
-  if ( access ( o->bootmap, O_RDWR ) == -1 ) {
-    if ( errno == ENOENT ) {
-      ITRY (creat ( o-> bootmap, O_RDWR ));
-    } else {
-      PRINT_LEVEL(1,"Cannot access bootmap file '%s': %s\n",o->bootmap,
-		  strerror(errno));
-    }
-  }
-  ITRY (verify_file (o->bootmap, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  PRINT_LEVEL (0, "Kernel image is: '%s'", o->image);
-  ITRY (verify_file (o->image, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  PRINT_LEVEL (0, "original parameterfile is: '%s'", o->parmfile);
-  ITRY (verify_file (o->parmfile, dev));
-  PRINT_LEVEL (1, "...ok...");
-  o->parmfile = gen_tmpparm(o->parmfile);
-  PRINT_LEVEL (0, "final parameterfile is: '%s'", o->parmfile);
-  ITRY (verify_file (o->parmfile, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  if (o->ramdisk)
-    {
-      PRINT_LEVEL (0, "initialramdisk is: '%s'", o->ramdisk);
-      ITRY (verify_file (o->ramdisk, dev));
-      PRINT_LEVEL (1, "...ok...");
-      PRINT_LEVEL (0, "\n");
-    }
-
-  return crc;
-}
-
-
-int
-add_file_to_blocklist (char *name, struct blocklist *lst, long addr)
-{
-  int fd;
-  int devfd;
-  struct stat fst;
-  int i;
-  int blk;
-  int bs;
-  int blocks;
-
-  int rc = 0;
-
-  ITRY (fd = open (name, O_RDONLY));
-  ITRY (fstat (fd, &fst));
-  ITRY (mknod ("/tmp/silodev", S_IFBLK | S_IRUSR | S_IWUSR, fst.st_dev));
-  ITRY (devfd = open ("/tmp/silodev", O_RDONLY));
-  ITRY (ioctl (fd, FIGETBSZ, &bs));
-  blocks = (fst.st_size + bs - 1) / bs;
-  for (i = 0; i < blocks; i++)
-    {
-      blk = i;
-      ITRY (ioctl (fd, FIBMAP, &blk));
-      if (blk)
-	{
-	  int oldblk = blk;
-	  ITRY (ioctl (devfd, BIODASDRWTB, &blk));
-	  if (blk <= 0)
-	    {
-	      ERROR_LEVEL (0, "BIODASDRWTB on blk %d returned %d\n", oldblk, blk);
-	      break;
-	    }
-	}
-      else
-	{
-	  PRINT_LEVEL (1, "Filled hole on blk %d\n", i);
-	}
-      if (lst->ix == 0 || i == 0  || 
-	  lst->blk[lst->ix - 1].ct >= 128 ||
-	  (lst->blk[lst->ix - 1].off + lst->blk[lst->ix - 1].ct != blk &&
-	   !(lst->blk[lst->ix - 1].off == 0 && blk == 0)))
-	{
-	  if (lst->ix >= MAX_CLUSTERS)
-	    {
-	      rc = 1;
-	      errno = ENOMEM;
-	      break;
-	    }
-	  lst->blk[lst->ix].off = blk;
-	  lst->blk[lst->ix].ct = 1;
-	  lst->blk[lst->ix].addr = addr + i * bs;
-	  lst->ix++;
-	}
-      else
-	{
-	  lst->blk[lst->ix - 1].ct++;
-	}
-    }
-  ITRY(unlink("/tmp/silodev"));
-  return rc;
-}
-
-int
-write_bootsect (struct silo_options *o, struct blocklist *blklst)
-{
-  int i;
-  int s_fd, d_fd, b_fd, bd_fd;
-  struct stat s_st, d_st, b_st;
-  int rc=0;
-  int bs, boots;
-  char *tmpdev;
-  char buffer[4096]={0,};
-  int blocksize, sectsize;
-  ITRY (d_fd = open (o->ipldevice, O_RDWR | O_SYNC));
-  ITRY (fstat (d_fd, &d_st));
-  ITRY (s_fd = open (o->bootmap, O_RDWR | O_TRUNC | O_CREAT | O_SYNC));
-  ITRY (verify_file (o->bootsect, d_st.st_rdev));
-  for (i = 0; i < blklst->ix; i++)
-    {
-      int offset = blklst->blk[i].off;
-      int addrct = blklst->blk[i].addr | (blklst->blk[i].ct & 0xff);
-      PRINT_LEVEL (1, "ix %i: offset: %06x count: %02x address: 0x%08x\n", i, offset, blklst->blk[i].ct & 0xff, blklst->blk[i].addr);
-	if ( o->testlevel <= 1 ) {
-	      NTRY (write (s_fd, &offset, sizeof (int)));
-	      NTRY (write (s_fd, &addrct, sizeof (int)));
-	}
-    }
-  ITRY (ioctl (s_fd,FIGETBSZ, &bs));
-  ITRY (stat (o->bootmap, &s_st));
-  if (s_st.st_size > bs )
-    {
-      ERROR_LEVEL (0,"%s is larger than one block\n", o->bootmap);
-      rc = -1;
-      errno = EINVAL;
-    }
-  boots=0;
-  NTRY ( tmpdev = tmpnam(NULL) );
-  ITRY (mknod (tmpdev, S_IFBLK | S_IRUSR | S_IWUSR, s_st.st_dev));
-  ITRY (bd_fd = open (tmpdev, O_RDONLY));
-  ITRY (ioctl(bd_fd,BLKSSZGET,&blocksize));
-  ITRY (ioctl(s_fd,FIBMAP,&boots));
-  ITRY (ioctl (bd_fd, BIODASDRWTB, &boots));
-  PRINT_LEVEL (1, "Bootmap is in block no: 0x%08x\n", boots);
-  close (bd_fd);
-  close(s_fd);
-  ITRY (unlink(tmpdev));
-  /* Now patch the bootsector */
-  ITRY (stat (o->bootsect, &b_st));
-  if ((sectsize = b_st.st_size) > blocksize )
-    {
-      ERROR_LEVEL (0,"Bootsector is larger than sectorsize of volume %d vs %d\n", sectsize, blocksize);
-      rc = -1;
-      errno = EINVAL;
-    }
-  ITRY (b_fd = open (o->bootsect, O_RDONLY));
-  ITRY (read (b_fd, buffer, sectsize));
-  memset (buffer + 0xe0, 0, 8);
-  *(int *) (buffer + 0xe0) = boots;
-  if ( o -> testlevel <= 0 ) {
-    ITRY (write (d_fd, buffer, sectsize));
-    ITRY (lseek (d_fd, blocksize, SEEK_SET));
-    ITRY (write (d_fd, buffer, sectsize));
-  }
-  close (b_fd);
-  close (d_fd);
-  return rc;
-}
-
-int
-do_silo (struct silo_options *o)
-{
-  int rc = 0;
-
-  int device_fd;
-  int image_fd;
-  struct blocklist blklist;
-  memset (&blklist, 0, sizeof (struct blocklist));
-  ITRY (add_file_to_blocklist (o->image, &blklist, 0x00000000));
-  if (o->parmfile)
-    {
-      ITRY (add_file_to_blocklist (o->parmfile, &blklist, 0x00008000));
-    }
-  if (o->ramdisk)
-    {
-      ITRY (add_file_to_blocklist (o->ramdisk, &blklist, 0x00800000));
-    }
-  ITRY (write_bootsect (o, &blklist));
-  return rc;
-}
-
-int
-main (int argct, char *argv[])
-{
-  int rc = 0;
-  char *save=NULL;
-  char *tmpdir=getenv("TMPDIR");
-  if (tmpdir) {
-    NTRY( save=(char*)malloc(strlen(tmpdir)));
-    NTRY( strncpy(save,tmpdir,strlen(tmpdir)));
-  }
-  ITRY( setenv("TMPDIR",".",1));
-  ITRY (parse_options (&silo_options, argct, argv));
-  ITRY (verify_options (&silo_options));
-  if ( silo_options.testlevel > 0 ) {
-    printf ("WARNING: silo does not modify your volume. Use -t2 to change IPL records\n");
-  }
-  ITRY (do_silo (&silo_options));
-  if ( save )
-    ITRY( setenv("TMPDIR",save,1)); 
-  return rc;
-}
diff -urN linux/arch/s390/tools/silo/silo.conf linux-2.4.7/arch/s390/tools/silo/silo.conf
--- linux/arch/s390/tools/silo/silo.conf	Fri May 12 14:41:45 2000
+++ linux-2.4.7/arch/s390/tools/silo/silo.conf	Wed Dec 31 19:00:00 1969
@@ -1,7 +0,0 @@
-ipldevice = /dev/dasda 
-image = /boot/image
-bootsect = /boot/ipleckd.boot
-map = /boot/boot.map
-root = /dev/dasd01
-readonly
-append = "dasd=200-20f noinitrd"
diff -urN linux/arch/s390/vmlinux-shared.lds linux-2.4.7/arch/s390/vmlinux-shared.lds
--- linux/arch/s390/vmlinux-shared.lds	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/arch/s390/vmlinux-shared.lds	Mon Dec 17 13:41:18 2001
@@ -0,0 +1,84 @@
+/* ld script to make s390 Linux kernel
+ * Written by Martin Schwidefsky (schwidefsky@de.ibm.com)
+ */
+OUTPUT_FORMAT("elf32-s390", "elf32-s390", "elf32-s390")
+OUTPUT_ARCH(s390)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0x00000000;
+  _text = .;			/* Text and read-only data */
+  .text : {
+	*(.text)
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x0700
+  .text.lock : { *(.text.lock) }	/* out-of-line lock text */
+  .rodata : { *(.rodata) }
+  .kstrtab : { *(.kstrtab) }
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : { *(__ksymtab) }
+  __stop___ksymtab = .;
+
+  __start___kallsyms = .;       /* All kernel symbols */
+  __kallsyms : { *(__kallsyms) }
+  __stop___kallsyms = .;
+
+  . = ALIGN(1048576);		/* VM shared segments are 1MB aligned */
+
+  _etext = .;			/* End of text section */
+
+  .data : {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(8192);		/* init_task */
+  .data.init_task : { *(.data.init_task) }
+
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(4096);
+  __init_end = .;
+
+  __setup_start = .;
+  .setup.init : { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : { *(.initcall.init) }
+  __initcall_end = .;
+  . = ALIGN(4096);
+  __init_end = .;
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
+
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss)
+	}
+  _end = . ;
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -urN linux/arch/s390x/Makefile linux-2.4.7/arch/s390x/Makefile
--- linux/arch/s390x/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/Makefile	Mon Dec 17 13:41:18 2001
@@ -17,7 +17,11 @@
 CPP=$(CC) -E
 OBJCOPY=$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment -S
 LDFLAGS=-e start
+ifeq ($(CONFIG_SHARED_KERNEL),y)
+LINKFLAGS =-T $(TOPDIR)/arch/s390x/vmlinux-shared.lds $(LDFLAGS)
+else
 LINKFLAGS =-T $(TOPDIR)/arch/s390x/vmlinux.lds $(LDFLAGS)
+endif
 MODFLAGS += -fpic
 
 CFLAGS_PIPE := -pipe
@@ -28,8 +32,8 @@
 
 SUBDIRS := $(SUBDIRS) arch/s390x/mm arch/s390x/kernel arch/s390x/lib \
            drivers/s390
-CORE_FILES := arch/s390x/mm/mm.o arch/s390x/kernel/kernel.o $(CORE_FILES) \
-           drivers/s390/io.o
+CORE_FILES := arch/s390x/mm/mm.o arch/s390x/kernel/kernel.o $(CORE_FILES)
+DRIVERS := $(DRIVERS) drivers/s390/io.o
 LIBS := $(TOPDIR)/arch/s390x/lib/lib.a $(LIBS) $(TOPDIR)/arch/s390x/lib/lib.a
 
 all: image listing
@@ -47,16 +51,6 @@
 	$(MAKE) linuxsubdirs SUBDIRS=drivers/s390
 
 MAKEBOOT = $(MAKE) -C arch/$(ARCH)/boot
-
-MAKESILO = $(MAKE) -C arch/$(ARCH)/tools/silo
-
-MAKEDASDFMT = $(MAKE) -C arch/$(ARCH)/tools/dasdfmt
-
-silo:
-	@$(MAKE) -C arch/$(ARCH)/tools/silo
-
-dasdfmt:
-	@$(MAKE) -C arch/$(ARCH)/tools/dasdfmt
 
 image: vmlinux 
 	@$(MAKEBOOT) image
diff -urN linux/arch/s390x/config.in linux-2.4.7/arch/s390x/config.in
--- linux/arch/s390x/config.in	Tue Apr 17 20:19:25 2001
+++ linux-2.4.7/arch/s390x/config.in	Mon Dec 17 13:41:18 2001
@@ -53,6 +53,8 @@
 tristate 'Kernel support for ELF binaries' CONFIG_BINFMT_ELF
 tristate 'Kernel support for MISC binaries' CONFIG_BINFMT_MISC
 bool 'Show crashed user process info' CONFIG_PROCESS_DEBUG
+bool 'Pseudo page fault support' CONFIG_PFAULT
+bool 'VM shared kernel support' CONFIG_SHARED_KERNEL
 endmenu
 
 
diff -urN linux/arch/s390x/defconfig linux-2.4.7/arch/s390x/defconfig
--- linux/arch/s390x/defconfig	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/defconfig	Mon Dec 17 13:41:18 2001
@@ -4,6 +4,8 @@
 # CONFIG_ISA is not set
 # CONFIG_EISA is not set
 # CONFIG_MCA is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
 CONFIG_ARCH_S390=y
 CONFIG_ARCH_S390X=y
 
@@ -41,6 +43,8 @@
 CONFIG_BINFMT_ELF=y
 # CONFIG_BINFMT_MISC is not set
 # CONFIG_PROCESS_DEBUG is not set
+CONFIG_PFAULT=y
+# CONFIG_SHARED_KERNEL is not set
 
 #
 # Block device drivers
@@ -58,7 +62,6 @@
 CONFIG_DASD=y
 CONFIG_DASD_ECKD=y
 CONFIG_DASD_FBA=y
-# CONFIG_DASD_DIAG is not set
 
 #
 # Multi-device support (RAID and LVM)
@@ -80,10 +83,13 @@
 #
 # S/390 character device drivers
 #
-CONFIG_3215=y
-CONFIG_3215_CONSOLE=y
+CONFIG_TN3270=y
+CONFIG_TN3270_CONSOLE=y
+CONFIG_TN3215=y
+CONFIG_TN3215_CONSOLE=y
 CONFIG_HWC=y
 CONFIG_HWC_CONSOLE=y
+CONFIG_HWC_CPI=m
 CONFIG_S390_TAPE=m
 
 #
@@ -103,6 +109,9 @@
 #
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
 CONFIG_NET_ETHERNET=y
 CONFIG_TR=y
 # CONFIG_FDDI is not set
@@ -110,7 +119,8 @@
 #
 # S/390 network device drivers
 #
-# CONFIG_CHANDEV is not set
+CONFIG_CHANDEV=y
+CONFIG_HOTPLUG=y
 CONFIG_CTC=m
 CONFIG_IUCV=m
 
@@ -134,7 +144,8 @@
 # CONFIG_IP_MROUTE is not set
 # CONFIG_INET_ECN is not set
 # CONFIG_SYN_COOKIES is not set
-# CONFIG_IPV6 is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_NETLINK is not set
 # CONFIG_KHTTPD is not set
 # CONFIG_ATM is not set
 
@@ -179,16 +190,18 @@
 # CONFIG_EFS_FS is not set
 # CONFIG_JFFS_FS is not set
 # CONFIG_CRAMFS is not set
+# CONFIG_TMPFS is not set
 # CONFIG_RAMFS is not set
 # CONFIG_ISO9660_FS is not set
 # CONFIG_JOLIET is not set
 # CONFIG_MINIX_FS is not set
+# CONFIG_VXFS_FS is not set
 # CONFIG_NTFS_FS is not set
 # CONFIG_NTFS_RW is not set
 # CONFIG_HPFS_FS is not set
 CONFIG_PROC_FS=y
-# CONFIG_DEVFS_FS is not set
-# CONFIG_DEVFS_MOUNT is not set
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
 # CONFIG_DEVFS_DEBUG is not set
 # CONFIG_DEVPTS_FS is not set
 # CONFIG_QNX4FS_FS is not set
@@ -196,7 +209,6 @@
 # CONFIG_ROMFS_FS is not set
 CONFIG_EXT2_FS=y
 # CONFIG_SYSV_FS is not set
-# CONFIG_SYSV_FS_WRITE is not set
 # CONFIG_UDF_FS is not set
 # CONFIG_UDF_RW is not set
 # CONFIG_UFS_FS is not set
@@ -244,4 +256,4 @@
 #
 # Kernel hacking
 #
-# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_MAGIC_SYSRQ=y
diff -urN linux/arch/s390x/kernel/Makefile linux-2.4.7/arch/s390x/kernel/Makefile
--- linux/arch/s390x/kernel/Makefile	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/Makefile	Mon Dec 17 13:41:18 2001
@@ -15,7 +15,7 @@
 O_TARGET := kernel.o
 
 export-objs	:= debug.o ebcdic.o irq.o s390_ext.o smp.o s390_ksyms.o
-obj-y	:= lowcore.o entry.o bitmap.o traps.o time.o process.o irq.o \
+obj-y	:= entry.o bitmap.o traps.o time.o process.o irq.o \
             setup.o sys_s390.o ptrace.o signal.o cpcmd.o ebcdic.o \
             semaphore.o s390fpu.o reipl.o s390_ext.o debug.o
 
diff -urN linux/arch/s390x/kernel/cpcmd.c linux-2.4.7/arch/s390x/kernel/cpcmd.c
--- linux/arch/s390x/kernel/cpcmd.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/cpcmd.c	Mon Dec 17 13:41:49 2001
@@ -6,21 +6,25 @@
  *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
  */
 
-#include <linux/stddef.h>
-#include <linux/kernel.h>
 #include <linux/string.h>
-#include <asm/ebcdic.h>
+#include <linux/spinlock.h>
 #include <asm/cpcmd.h>
+#include <asm/ebcdic.h>
+#include <asm/system.h>
+
+static spinlock_t cpcmd_lock = SPIN_LOCK_UNLOCKED;
+static char cpcmd_buf[128];
 
 void cpcmd(char *cmd, char *response, int rlen)
 {
         const int mask = 0x40000000L;
-        char obuffer[128];
-        int olen;
+	unsigned long flags;
+        int cmdlen;
 
-        olen = strlen(cmd);
-        strcpy(obuffer, cmd);
-        ASCEBC(obuffer,olen);
+	spin_lock_irqsave(&cpcmd_lock, flags);
+        cmdlen = strlen(cmd);
+        strcpy(cpcmd_buf, cmd);
+        ASCEBC(cpcmd_buf, cmdlen);
 
         if (response != NULL && rlen > 0) {
                 asm volatile ("   lrag  2,0(%0)\n"
@@ -32,7 +36,7 @@
                               "   .long 0x83240008 # Diagnose 83\n"
                               "   sam64"
                               : /* no output */
-                              : "a" (obuffer), "d" (olen),
+                              : "a" (cpcmd_buf), "d" (cmdlen),
                                 "a" (response), "d" (rlen), "m" (mask)
                               : "2", "3", "4", "5" );
                 EBCASC(response, rlen);
@@ -43,8 +47,9 @@
                               "   .long 0x83230008 # Diagnose 83\n"
                               "   sam64"
                               : /* no output */
-                              : "a" (obuffer), "d" (olen)
+                              : "a" (cpcmd_buf), "d" (cmdlen)
                               : "2", "3"  );
         }
+	spin_unlock_irqrestore(&cpcmd_lock, flags);
 }
 
diff -urN linux/arch/s390x/kernel/debug.c linux-2.4.7/arch/s390x/kernel/debug.c
--- linux/arch/s390x/kernel/debug.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/debug.c	Mon Dec 17 13:41:49 2001
@@ -83,6 +83,9 @@
 static int debug_input_level_fn(debug_info_t * id, struct debug_view *view,
 				struct file *file, const char *user_buf,
 				size_t user_buf_size, loff_t * offset);
+static int debug_input_flush_fn(debug_info_t * id, struct debug_view *view,
+                                struct file *file, const char *user_buf,
+                                size_t user_buf_size, loff_t * offset);
 static int debug_hex_ascii_format_fn(debug_info_t * id, struct debug_view *view,
                                 char *out_buf, const char *in_buf);
 static int debug_raw_format_fn(debug_info_t * id,
@@ -123,6 +126,15 @@
 	NULL
 };
 
+struct debug_view debug_flush_view = {
+        "flush",
+        NULL,
+        NULL,
+        NULL,
+        &debug_input_flush_fn,
+        NULL
+};
+
 struct debug_view debug_sprintf_view = {
 	"sprintf",
 	NULL,
@@ -664,6 +676,7 @@
 	if(!rc) 
 		goto out;
 	debug_register_view(rc, &debug_level_view);
+        debug_register_view(rc, &debug_flush_view);
 	printk(KERN_INFO
 	       "debug: reserved %d areas of %d pages for debugging %s\n",
 	       nr_areas, 1 << page_order, rc->name);
@@ -1027,6 +1040,73 @@
       out:
 	*offset += in_buf_size;
 	return rc;		/* number of input characters */
+}
+
+
+/*
+ * flushes debug areas
+ */
+ 
+void debug_flush(debug_info_t* id, int area)
+{
+        unsigned long flags;
+        int i;
+
+        if(!id)
+                return;
+        spin_lock_irqsave(&id->lock,flags);
+        if(area == DEBUG_FLUSH_ALL){
+                id->active_area = 0;
+                memset(id->active_entry, 0, id->nr_areas * sizeof(int));
+                for (i = 0; i < id->nr_areas; i++) 
+                        memset(id->areas[i], 0, PAGE_SIZE << id->page_order);
+                printk(KERN_INFO "debug: %s: all areas flushed\n",id->name);
+        } else if(area >= 0 && area < id->nr_areas) {
+                id->active_entry[area] = 0;
+                memset(id->areas[area], 0, PAGE_SIZE << id->page_order);
+                printk(KERN_INFO
+                        "debug: %s: area %i has been flushed\n",
+                        id->name, area);
+        } else {
+                printk(KERN_INFO
+                        "debug: %s: area %i cannot be flushed (range: %i - %i)\n",
+                        id->name, area, 0, id->nr_areas-1);
+        }
+        spin_unlock_irqrestore(&id->lock,flags);
+}
+
+/*
+ * view function: flushes debug areas 
+ */
+ 
+static int debug_input_flush_fn(debug_info_t * id, struct debug_view *view,
+                                struct file *file, const char *user_buf,
+                                size_t in_buf_size, loff_t * offset)
+{
+        char input_buf[1];
+        int rc = in_buf_size;
+ 
+        if (*offset != 0)
+                goto out;
+        if (copy_from_user(input_buf, user_buf, 1)){
+                rc = -EFAULT;
+                goto out;
+        }
+        if(input_buf[0] == '-') { 
+                debug_flush(id, DEBUG_FLUSH_ALL);
+                goto out;
+        }
+        if (isdigit(input_buf[0])) {
+                int area = ((int) input_buf[0] - (int) '0');
+                debug_flush(id, area);
+                goto out;
+        }
+
+        printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
+
+      out:
+        *offset += in_buf_size;
+        return rc;              /* number of input characters */
 }
 
 /*
diff -urN linux/arch/s390x/kernel/entry.S linux-2.4.7/arch/s390x/kernel/entry.S
--- linux/arch/s390x/kernel/entry.S	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/kernel/entry.S	Mon Dec 17 13:43:29 2001
@@ -14,6 +14,7 @@
 #include <linux/sys.h>
 #include <linux/linkage.h>
 #include <linux/config.h>
+#include <asm/cache.h>
 #include <asm/lowcore.h>
 #include <asm/errno.h>
 #include <asm/smp.h>
@@ -80,7 +81,7 @@
 sigpending   = 16
 need_resched = 32
 tsk_ptrace   = 40
-processor    = 100
+processor    = 92
 
 /*
  * Register usage in interrupt handlers:
@@ -90,17 +91,25 @@
  *    R15 - kernel stack pointer
  */
 
-        .macro  SAVE_ALL psworg          # system entry macro
+        .macro  SAVE_ALL psworg,sync     # system entry macro
         stmg    %r14,%r15,__LC_SAVE_AREA
-        stam    %a2,%a4,__LC_SAVE_AREA+16
         tm      \psworg+1,0x01           # test problem state bit
-        jz      0f                       # skip stack setup save
-        lg      %r15,__LC_KERNEL_STACK   # problem state -> load ksp
-        slr     %r14,%r14
-        sar     %a2,%r14                 # set ac.reg. 2 to primary space
-        lhi     %r14,1
-        sar     %a4,%r14                 # set access reg. 4 to home space
-0:      aghi    %r15,-SP_SIZE            # make room for registers & psw
+	stam    %a2,%a4,__LC_SAVE_AREA+16
+	.if	\sync
+        jz      1f                       # skip stack setup save
+	.else
+	jnz	0f			 # from user -> load kernel stack
+	lg	%r14,__LC_ASYNC_STACK	 # are we already on the async. stack ?
+	slgr	%r14,%r15
+	srag	%r14,%r14,14
+	jz	1f
+	lg	%r15,__LC_ASYNC_STACK	 # load async. stack
+	j	1f
+	.endif
+0:	lg      %r15,__LC_KERNEL_STACK   # problem state -> load ksp
+	larl	%r14,.Lc_ac
+	lam	%a2,%a4,0(%r14)
+1:      aghi    %r15,-SP_SIZE            # make room for registers & psw
         nill    %r15,0xfff8              # align stack pointer to 8
         stmg    %r0,%r14,SP_R0(%r15)     # store gprs 0-14 to kernel stack
         stg     %r2,SP_ORIG_R2(%r15)     # store original content of gpr 2
@@ -113,7 +122,7 @@
         xc      0(8,%r15),0(%r15)        # clear back chain
         .endm
 
-        .macro  RESTORE_ALL              # system exit macro
+        .macro  RESTORE_ALL sync         # system exit macro
         mvc     __LC_RETURN_PSW(16),SP_PSW(%r15) # move user PSW to lowcore
         lam     %a0,%a15,SP_AREGS(%r15)  # load the access registers
         lmg     %r0,%r15,SP_R0(%r15)     # load gprs 0-15 of user
@@ -122,8 +131,8 @@
         .endm
 
         .macro  GET_CURRENT
-        lghi    %r9,-16384               # load pointer to task_struct to %r9
-        ngr     %r9,15
+	lg	%r9,__LC_KERNEL_STACK    # load pointer to task_struct to %r9
+	aghi	%r9,-16384
         .endm
 
 
@@ -162,13 +171,32 @@
         br      %r14
 
 /*
+ * do_softirq calling function. We want to run the softirq functions on the
+ * asynchronous interrupt stack.
+ */
+	.global do_call_softirq
+do_call_softirq:
+	stmg	%r12,%r15,48(%r15)
+	lgr	%r12,%r15
+	lg	%r0,__LC_ASYNC_STACK
+	slgr    %r0,%r15
+	srag	%r0,%r0,14
+	je	0f
+	lg	%r15,__LC_ASYNC_STACK
+0:	aghi	%r15,-STACK_FRAME_OVERHEAD
+	stg	%r12,0(%r15)		# store back chain
+	brasl	%r14,do_softirq
+	lmg	%r12,%r15,48(%r12)
+	br	%r14
+	
+/*
  * SVC interrupt handler routine. System calls are synchronous events and
  * are executed with interrupts enabled.
  */
 
 	.globl  system_call
 system_call:
-        SAVE_ALL __LC_SVC_OLD_PSW
+        SAVE_ALL __LC_SVC_OLD_PSW,1
 	mvi     SP_PGM_OLD_ILC(%r15),1  # mark PGM_OLD_ILC as invalid
 pgm_system_call:
         GET_CURRENT               # load pointer to task_struct to R9
@@ -192,15 +220,8 @@
         tm      SP_PSW+1(%r15),0x01 # returning to user ?
         jno     sysc_leave        # no-> skip bottom half, resched & signal
 #
-# check, if bottom-half has to be done
-#
-        l       %r0,__LC_IRQ_STAT     # get softirq_active
-        n       %r0,__LC_IRQ_STAT+4   # and it with softirq_mask
-        jnz     sysc_handle_bottom_half
-#
 # check, if reschedule is needed
 #
-sysc_return_bh:
 	lg      %r0,need_resched(%r9) # get need_resched from task_struct
 	ltgr    %r0,%r0
         jnz     sysc_reschedule
@@ -210,7 +231,7 @@
         tm      SP_PGM_OLD_ILC(%r15),0xff
         jz      pgm_svcret
 	stnsm   48(%r15),0xfc         # disable I/O and ext. interrupts
-        RESTORE_ALL
+        RESTORE_ALL 1
 
 #
 # call do_signal before return
@@ -228,6 +249,17 @@
 	lghi    %r2,-ENOSYS
 	stg     %r2,SP_R2(%r15)     # give sysc_trace an -ENOSYS retval
         brasl   %r14,syscall_trace
+	lg      %r2,SP_R2(%r15)
+	cghi    %r2,-ENOSYS
+	je      sysc_tracesys_dn1   
+	sllg    %r2,%r2,56          # strace wants to change the syscall
+	srlg    %r2,%r2,53          # zap unused bits & multiply by 8
+	tm      SP_PSW+3(%r15),0x01 # are we running in 31 bit mode ?
+        jo      sysc_tracesys_noemu
+	la      %r2,4(%r2)          # use 31 bit emulation system calls
+sysc_tracesys_noemu:
+	lgf	%r8,0(%r2,%r7)      # load address of system call routine
+sysc_tracesys_dn1:	
 	lmg     %r3,%r6,SP_R3(%r15)
 	lg      %r2,SP_ORIG_R2(%r15)
         basr    %r14,%r8            # call sys_xxx
@@ -235,15 +267,6 @@
 	larl    %r14,sysc_return
         jg      syscall_trace       # return point is sysc_return
 
-
-#
-# call do_softirq and return from syscall, if interrupt-level
-# is zero
-#
-sysc_handle_bottom_half:        
-	larl    %r14,sysc_return_bh
-        jg      do_softirq          # return point is sysc_return_bh
-
 #
 # call schedule with sysc_return as return-address
 #
@@ -259,12 +282,8 @@
         GET_CURRENT               # load pointer to task_struct to R9
         stosm   48(%r15),0x03     # reenable interrupts
 	xc      SP_R2(8,%r15),SP_R2(%r15) # child returns 0
-#ifdef CONFIG_SMP
 	larl    %r14,sysc_return
         jg      schedule_tail     # return to sysc_return
-#else
-        j       sysc_return
-#endif
 
 #
 # clone, fork, vfork, exec and sigreturn need glue,
@@ -582,9 +601,9 @@
 	.long  SYSCALL(sys_mmap2,sys32_mmap2_wrapper)
 	.long  SYSCALL(sys_ni_syscall,sys32_truncate64_wrapper)
         .long  SYSCALL(sys_ni_syscall,sys32_ftruncate64_wrapper)
-        .long  SYSCALL(sys_ni_syscall,sys32_stat64)     /* 195 */
-        .long  SYSCALL(sys_ni_syscall,sys32_lstat64)   
-        .long  SYSCALL(sys_ni_syscall,sys32_fstat64)    
+        .long  SYSCALL(sys_ni_syscall,sys32_stat64_wrapper)     /* 195 */
+        .long  SYSCALL(sys_ni_syscall,sys32_lstat64_wrapper)   
+        .long  SYSCALL(sys_ni_syscall,sys32_fstat64_wrapper)    
 	.long  SYSCALL(sys_lchown,sys32_lchown_wrapper)
 	.long  SYSCALL(sys_getuid,sys_getuid)
 	.long  SYSCALL(sys_getgid,sys_getgid)         /* 200 */
@@ -607,9 +626,12 @@
         .long  SYSCALL(sys_pivot_root,sys32_pivot_root_wrapper)
         .long  SYSCALL(sys_mincore,sys32_mincore_wrapper)
         .long  SYSCALL(sys_madvise,sys32_madvise_wrapper)
-	.long  SYSCALL(sys_ni_syscall,sys32_getdents64_wrapper)/* 220 */
+	.long  SYSCALL(sys_getdents64,sys32_getdents64_wrapper)/* 220 */
 	.long  SYSCALL(sys_ni_syscall,sys32_fcntl64_wrapper)
-        .rept  255-221
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 222 - reserved for posix_acl */
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 223 - reserved for posix_acl */
+	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall) /* 224 - reserved for posix_acl */
+        .rept  255-224
 	.long  SYSCALL(sys_ni_syscall,sys_ni_syscall)
 	.endr
 
@@ -643,7 +665,7 @@
 	lpswe   __LC_PGM_OLD_PSW
 # it was a single stepped SVC that is causing all the trouble
 pgm_svcper:
-	SAVE_ALL __LC_SVC_OLD_PSW
+	SAVE_ALL __LC_SVC_OLD_PSW,1
         mvc     SP_PGM_OLD_ILC(4,%r15),__LC_PGM_ILC # save program check information
         j       pgm_system_call          # now do the svc
 pgm_svcret:
@@ -653,13 +675,12 @@
         mvi     SP_PGM_OLD_ILC(%r15),1   # mark PGM_OLD_ILC as invalid
 	j       pgm_no_sv
 pgm_sv:
-	SAVE_ALL __LC_PGM_OLD_PSW
+	SAVE_ALL __LC_PGM_OLD_PSW,1
         mvi     SP_PGM_OLD_ILC(%r15),1   # mark PGM_OLD_ILC as invalid
         llgh    %r7,__LC_PGM_ILC         # load instruction length
 	GET_CURRENT
 pgm_no_sv:
         llgh    %r8,__LC_PGM_INT_CODE  # N.B. saved int code used later KEEP it
-        stosm   48(%r15),0x03     # reenable interrupts
 	lghi    %r3,0x7f
         nr      %r3,%r8           # clear per-event-bit & move to r3
         je      pgm_dn            # none of Martins exceptions occurred bypass
@@ -685,7 +706,7 @@
  */
         .globl io_int_handler
 io_int_handler:
-        SAVE_ALL __LC_IO_OLD_PSW
+        SAVE_ALL __LC_IO_OLD_PSW,0
         GET_CURRENT                    # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
 	llgh    %r3,__LC_SUBCHANNEL_NR # load subchannel number
@@ -694,16 +715,20 @@
 	brasl   %r14,do_IRQ            # call standard irq handler
 
 io_return:
-        tm      SP_PSW+1(%r15),0x01    # returning to user ?
-        jno     io_leave               # no-> skip resched & signal
-        stosm   48(%r15),0x03          # reenable interrupts
 #
 # check, if bottom-half has to be done
 #
-        l       %r0,__LC_IRQ_STAT     # get softirq_active
-        n       %r0,__LC_IRQ_STAT+4   # and it with softirq_mask
+	lgf     %r1,processor(%r9)    # get cpu number from task struture
+	larl    %r2,irq_stat
+	sll     %r1,L1_CACHE_SHIFT
+	la      %r1,0(%r1,%r2)
+	icm     %r0,15,0(%r1)         # test irq_stat[#cpu].__softirq_pending
         jnz     io_handle_bottom_half
 io_return_bh:	
+
+        tm      SP_PSW+1(%r15),0x01    # returning to user ?
+        jno     io_leave               # no-> skip resched & signal
+        stosm   48(%r15),0x03          # reenable interrupts
 #
 # check, if reschedule is needed
 #
@@ -714,7 +739,7 @@
         jnz     io_signal_return
 io_leave:
         stnsm   48(%r15),0xfc          # disable I/O and ext. interrupts
-        RESTORE_ALL
+        RESTORE_ALL 0
 
 #
 # call do_softirq and return from syscall, if interrupt-level
@@ -745,7 +770,7 @@
  */
         .globl  ext_int_handler
 ext_int_handler:
-        SAVE_ALL __LC_EXT_OLD_PSW
+        SAVE_ALL __LC_EXT_OLD_PSW,0
         GET_CURRENT                    # load pointer to task_struct to R9
         la      %r2,SP_PTREGS(%r15)    # address of register-save area
         llgh    %r3,__LC_EXT_INT_CODE  # error code
@@ -773,10 +798,10 @@
  */
         .globl mcck_int_handler
 mcck_int_handler:
-        SAVE_ALL __LC_MCK_OLD_PSW
+        SAVE_ALL __LC_MCK_OLD_PSW,0
 	brasl   %r14,s390_do_machine_check
 mcck_return:
-        RESTORE_ALL
+        RESTORE_ALL 0
 
 #ifdef CONFIG_SMP
 /*
@@ -784,10 +809,10 @@
  */
         .globl restart_int_handler
 restart_int_handler:
-        lg      %r15,__LC_KERNEL_STACK # load ksp
-        lhi     %r10,__LC_CREGS_SAVE_AREA
+        lg      %r15,__LC_SAVE_AREA+120 # load ksp
+        lghi    %r10,__LC_CREGS_SAVE_AREA
         lctlg   %c0,%c15,0(%r10) # get new ctl regs
-        lhi     %r10,__LC_AREGS_SAVE_AREA
+        lghi    %r10,__LC_AREGS_SAVE_AREA
         lam     %a0,%a15,0(%r10)
         stosm   0(%r15),0x04           # now we can turn dat on
         lmg     %r6,%r15,48(%r15)      # load registers from clone
@@ -807,3 +832,8 @@
 restart_go:
 #endif
 
+/*
+ * Integer constants
+ */
+               .align 4
+.Lc_ac:        .long  0,0,1
diff -urN linux/arch/s390x/kernel/head.S linux-2.4.7/arch/s390x/kernel/head.S
--- linux/arch/s390x/kernel/head.S	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/kernel/head.S	Mon Dec 17 13:42:47 2001
@@ -261,7 +261,7 @@
 	l     %r1,0xb8                         # load ipl subchannel number
         la    %r2,IPL_BS                       # load start address
         bas   %r14,.Lloader                    # load rest of ipl image
-        l     %r12,.Lparm                      # pointer to parameter area
+        larl  %r12,_pstart                     # pointer to parameter area
         st    %r1,IPL_DEVICE+4-PARMAREA(%r12)  # store ipl device number
 
 #
@@ -303,7 +303,6 @@
         slr   %r0,%r0
         b     .Lcntlp
 .Ldelspc:
-        ic    %r0,0(%r3)
         ic    %r0,0(%r2,%r3)
         chi   %r0,0x20                         # is it a space ?
         be    .Lcntlp
@@ -338,12 +337,12 @@
 # reset files in VM reader
 #
         stidp __LC_CPUID                       # store cpuid
-        lh    %r0,__LC_CPUID+4                 # get cpu version
-        chi   %r0,0x7490                       # running on P/390 ?
-        be    start                            #   no -> skip reset
+	tm    __LC_CPUID,0xff                  # running VM ?
+	bno   .Lnoreset
         la    %r2,.Lreset              
         lhi   %r3,26
         .long 0x83230008
+.Lnoreset:
 #endif
 	
 #
@@ -353,7 +352,6 @@
         l     %r1,.Lstartup
         br    %r1
 
-.Lparm:	.long  PARMAREA
 .Lstartup: .long startup
 .Lcvtab:.long  _ebcasc                         # ebcdic to ascii table
 .Lreset:.byte  0xc3,0xc8,0xc1,0xd5,0xc7,0xc5,0x40,0xd9,0xc4,0xd9,0x40
@@ -459,59 +457,103 @@
 #
         .org  0x10000
 startup:basr  %r13,0                     # get base
-.LPG1:  n     %r13,.Lhighoff-.LPG1(%r13) # remove high order bit
+.LPG1:  sll   %r13,1                     # remove high order bit
+        srl   %r13,1
         lhi   %r1,1                      # mode 1 = esame
         slr   %r0,%r0                    # set cpuid to zero
         sigp  %r1,%r0,0x12               # switch to esame mode
 	sam64				 # switch to 64 bit mode
 	lctlg %c0,%c15,.Lctl-.LPG1(%r13) # load control registers
-	lg    %r12,.Lparm1-.LPG1(%r13)   # pointer to parameter area
+	larl  %r12,_pstart               # pointer to parameter area
 					 # move IPL device to lowcore
         mvc   __LC_IPLDEV(4),IPL_DEVICE+4-PARMAREA(%r12)
+					 # set program check new psw mask
+	mvc   __LC_PGM_NEW_PSW(8),.Lpcmsk-.LPG1(%r13)
+
 
 #
-# find out memory size.
+# find memory chunks.
 #
-	mvc   0x1d0(16),.Lpcmem-.LPG1(%r13) # setup program check handler
-        lghi  %r2,1
-        sllg  %r2,%r2,17                 # test in increments of 128KB
-	lgr   %r1,%r2
-	aghi  %r1,-8                     # test last word in the segment
-.Lloop:	
-	lg    %r0,0(%r1)                 # test 128KB segment
-	stg   %r0,0(%r1)
-	agr   %r1,%r2                    # add 128KB
-	bno   .Lloop-.LPG1(%r13)         # r1 < 0x80000000 -> loop
-.Lchkmem:
-	ng    %r1,.L4malign-.LPG1(%r13)  # align to multiples of 4M
-	lg    %r2,.Lmemsize-.LPG1(%r13)  # address of variable memory_size
-	stg   %r1,0(%r2)                 # store memory size
+	larl  %r1,.Lchkmem               # set program check address
+	stg   %r1,__LC_PGM_NEW_PSW+8
+	la    %r1,1                      # test in increments of 128KB
+	sllg  %r1,%r1,17
+	larl  %r3,memory_chunk
+	slgr  %r4,%r4                    # set start of chunk to zero
+	slgr  %r5,%r5                    # set end of chunk to zero
+	slr  %r6,%r6			 # set access code to zero
+.Lloop:
+	tprot 0(%r5),0			 # test protection of first byte
+	ipm   %r7
+	srl   %r7,28
+	clr   %r6,%r7			 # compare cc with last access code
+	je    .Lsame
+	clgr  %r4,%r5			 # chunk size > 0?
+	je    .Lsize0
+	stg   %r4,0(%r3)		 # store start address of chunk
+	lgr   %r0,%r5
+	slgr  %r0,%r4
+	stg   %r0,8(%r3)		 # store size of chunk
+	st    %r6,20(%r3)		 # store type of chunk
+	la    %r3,24(%r3)
+	lgr   %r4,%r5			 # set start to end
+	larl  %r8,memory_size
+	stg   %r5,0(%r8)                 # store memory size
+.Lsize0:
+	lr    %r6,%r7			 # set access code to last cc
+.Lsame:
+	algr  %r5,%r1			 # add 128KB to end of chunk
+	brc   12,.Lloop
+.Lchkmem:				 # > 16EB or tprot got a program check
+	clgr  %r4,%r5			 # chunk size > 0?
+	je    .Ldonemem
+	stg   %r4,0(%r3)		 # store start address of chunk
+	lgr   %r0,%r5
+	slgr  %r0,%r4
+	stg   %r0,8(%r3)		 # store size of chunk
+	st    %r6,20(%r3)		 # store type of chunk
+	la    %r3,24(%r3)
+	lgr   %r4,%r5
+	larl  %r8,memory_size
+	stg   %r5,0(%r8)                 # store memory size
+#
+# Running native the HSA is located at 2GB and we will get an
+# addressing exception trying to access it. We have to restart
+# the scan at 2GB to find out if the machine has more than 2GB.
+#
+	lghi  %r4,1
+	sllg  %r4,%r4,31
+	clgr  %r5,%r4
+	jhe   .Ldonemem
+	lgr   %r5,%r4
+	j     .Lloop
+.Ldonemem:		
 
-	lg    %r12,.Lmflags-.LPG1(%r13)  # get address of machine_flags
+	larl  %r12,machine_flags
 #
 # find out if we are running under VM
 #
         stidp  __LC_CPUID               # store cpuid
 	tm     __LC_CPUID,0xff          # running under VM ?
-	bno    .Lnovm-.LPG1(%r13)
+	bno    0f-.LPG1(%r13)
         oi     7(%r12),1                # set VM flag
-.Lnovm:
-        lh     %r0,__LC_CPUID+4         # get cpu version
+0:      lh     %r0,__LC_CPUID+4         # get cpu version
         chi    %r0,0x7490               # running on a P/390 ?
-        bne    .Lnop390-.LPG1(%r13)
+        bne    1f-.LPG1(%r13)
         oi     7(%r12),4                # set P/390 flag
-.Lnop390:
+1:
 
 #
 # find out if we have the MVPG instruction
 #
-       mvc    __LC_PGM_NEW_PSW(16),.Lpcmvpg-.LPG1(%r13)
-       sgr    %r0,%r0
-       lghi   %r1,0
-       lghi   %r2,0
-       mvpg   %r1,%r2                   # Test CSP instruction
-       oi     7(%r12),16                # set MVPG flag
-.Lchkmvpg:
+	la     %r1,0f-.LPG1(%r13)       # set program check address
+	stg    %r1,__LC_PGM_NEW_PSW+8
+	sgr    %r0,%r0
+	lghi   %r1,0
+	lghi   %r2,0
+	mvpg   %r1,%r2                  # test MVPG instruction
+	oi     7(%r12),16               # set MVPG flag
+0:
 
         lpswe .Lentry-.LPG1(13)         # jump to _stext in primary-space,
                                         # virtual and never return ...
@@ -519,7 +561,7 @@
 .Lentry:.quad  0x0000000180000000,_stext
 .Lctl:  .quad  0x04b50002               # cr0: various things
         .quad  0                        # cr1: primary space segment table
-        .quad  0                        # cr2: access register translation
+        .quad  .Lduct                   # cr2: dispatchable unit control table
         .quad  0                        # cr3: instruction authorization
         .quad  0                        # cr4: instruction authorization
         .quad  0                        # cr5:  various things
@@ -533,21 +575,20 @@
         .quad  0                        # cr13: home space segment table
         .quad  0xc0000000               # cr14: machine check handling off
         .quad  0                        # cr15: linkage stack operations
-.Lpcmem:.quad  0x0000000180000000,.Lchkmem
-.Lpcmvpg:.quad 0x0000000180000000,.Lchkmvpg
-.Lflt0: .double 0
-.Lparm1:.quad  PARMAREA
-.Lhighoff:.long 0x7fffffff
+.Lpcmsk:.quad  0x0000000180000000
 .L4malign:.quad 0xffffffffffc00000
-.Lbigmem:.quad 0x04000000
-.Lmaxchunk:.quad  0x00ffffff
-.Lmemsize:.quad memory_size
-.Lmflags:.quad machine_flags
+.Lscan2g:.quad 0x80000000 + 0x20000 - 8 # 2GB + 128K - 8
+
+	.org PARMAREA-64
+.Lduct:	.long 0,0,0,0,0,0,0,0
+	.long 0,0,0,0,0,0,0,0
 
 #
 # params at 10400 (setup.h)
 #
 	.org   PARMAREA
+	.global _pstart
+_pstart:
 	.quad  0                        # IPL_DEVICE
         .quad  RAMDISK_ORIGIN           # INITRD_START
         .quad  RAMDISK_SIZE             # INITRD_SIZE
@@ -555,32 +596,33 @@
         .org   COMMAND_LINE
     	.byte  "root=/dev/ram0 ro"
         .byte  0
+	.org   0x11000
+	.global _pend
+_pend:	
 
+#ifdef CONFIG_SHARED_KERNEL
+	.org   0x100000
+#endif
+	
 #
 # startup-code, running in virtual mode
 #
-        .org   0x10800
         .globl _stext
 _stext:	basr  %r13,0                    # get base
 .LPG2:
 #
-# Setup lowcore
+# Setup stack
 #
-        l     %r1,__LC_IPLDEV           # load ipl device number
-        spx   .Lprefix-.LPG2(%r13)      # set prefix to linux lowcore
-        st    %r1,__LC_IPLDEV           # store ipl device number
-        lg    %r15,.Linittu-.LPG2(%r13)
+	larl  %r15,init_task_union
         aghi  %r15,16384                # init_task_union + 16384
         stg   %r15,__LC_KERNEL_STACK    # set end of kernel stack
         aghi  %r15,-160
         xc    0(8,%r15),0(%r15)         # set backchain to zero
-        lghi  %r0,-1
-        stg   %r0,__LC_KERNEL_LEVEL     # set interrupt count to -1
 #
 # clear bss memory
 #
-        lg    %r2,.Lbss_bgn-.LPG2(%r13) # start of bss
-        lg    %r3,.Lbss_end-.LPG2(%r13) # end of bss
+	larl  %r2,__bss_start           # start of bss segment
+        larl  %r3,_end                  # end of bss segment
         sgr   %r3,%r2                   # length of bss
         sgr   %r4,%r4                   #
         sgr   %r5,%r5                   # set src,length and pad to zero
@@ -588,8 +630,8 @@
         jo    .-4                       # branch back, if not finish
 # check control registers
         stctg  %c0,%c15,0(%r15)
-        oc     6(1,%r15),.Locbits+5-.LPG2(%r13) # enable sigp external ints.
-        oc     4(1,%r15),.Locbits+4-.LPG2(%r13) # low addresss proctection
+	oi     6(%r15),0x20             # enable sigp external interrupts
+	oi     4(%r15),0x10             # switch on low address proctection
         lctlg  %c0,%c15,0(%r15)
 
 #
@@ -601,15 +643,7 @@
         basr  %r13,0
 	lpswe .Ldw-.(%r13)           # load disabled wait psw
 #
-.Lstart:    .quad  start_kernel
             .align 8
-.Lprefix:   .long  init_S390_lowcore	
-.Linittu:   .quad  init_task_union
-.Lbss_bgn:  .quad  __bss_start
-.Lbss_end:  .quad  _end
-.Locbits:   .quad  0x0102040810204080
-            .align 4
+.Ldw:       .quad  0x0002000180000000,0x0000000000000000
 .Laregs:    .long  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0
-	    .align 8
-.Ldw:      .quad  0x0002000180000000,0x0000000000000000
 
diff -urN linux/arch/s390x/kernel/ioctl32.c linux-2.4.7/arch/s390x/kernel/ioctl32.c
--- linux/arch/s390x/kernel/ioctl32.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/ioctl32.c	Mon Dec 17 13:41:49 2001
@@ -23,9 +23,11 @@
 #include <linux/netdevice.h>
 #include <linux/route.h>
 #include <linux/ext2_fs.h>
+#include <linux/hdreg.h>
 #include <asm/types.h>
 #include <asm/uaccess.h>
 #include <asm/dasd.h>
+#include <asm/sockios.h>
 
 #include "linux32.h"
 
@@ -349,14 +351,14 @@
 	IOCTL32_DEFAULT(FIBMAP),
 	IOCTL32_DEFAULT(FIGETBSZ),
 
+	IOCTL32_DEFAULT(DASDAPIVER),
 	IOCTL32_DEFAULT(BIODASDDISABLE),
 	IOCTL32_DEFAULT(BIODASDENABLE),
 	IOCTL32_DEFAULT(BIODASDRSRV),
 	IOCTL32_DEFAULT(BIODASDRLSE),
 	IOCTL32_DEFAULT(BIODASDSLCK),
-	IOCTL32_DEFAULT(BIODASDRSID),
-	IOCTL32_DEFAULT(BIODASDFORMAT),
-	IOCTL32_DEFAULT(BIODASDRWTB),
+	IOCTL32_DEFAULT(BIODASDINFO),
+	IOCTL32_DEFAULT(BIODASDFMT),
 
 	IOCTL32_DEFAULT(BLKRRPART),
 
@@ -450,6 +452,8 @@
 	IOCTL32_DEFAULT(VT_RESIZEX),
 	IOCTL32_DEFAULT(VT_LOCKSWITCH),
 	IOCTL32_DEFAULT(VT_UNLOCKSWITCH),
+
+	IOCTL32_DEFAULT(SIOCGSTAMP),
 
 	IOCTL32_HANDLER(SIOCGIFNAME, dev_ifname32),
 	IOCTL32_HANDLER(SIOCGIFCONF, dev_ifconf),
diff -urN linux/arch/s390x/kernel/irq.c linux-2.4.7/arch/s390x/kernel/irq.c
--- linux/arch/s390x/kernel/irq.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/kernel/irq.c	Mon Dec 17 13:42:41 2001
@@ -21,7 +21,7 @@
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
 #include <linux/timex.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/random.h>
 #include <linux/smp.h>
@@ -385,6 +385,10 @@
 EXPORT_SYMBOL(__global_sti);
 EXPORT_SYMBOL(__global_save_flags);
 EXPORT_SYMBOL(__global_restore_flags);
+EXPORT_SYMBOL(global_irq_holder);
+EXPORT_SYMBOL(global_irq_lock);
+EXPORT_SYMBOL(global_irq_count);
+EXPORT_SYMBOL(global_bh_count);
 #endif
 
 EXPORT_SYMBOL(global_bh_lock);
diff -urN linux/arch/s390x/kernel/linux32.c linux-2.4.7/arch/s390x/kernel/linux32.c
--- linux/arch/s390x/kernel/linux32.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/kernel/linux32.c	Mon Dec 17 13:42:41 2001
@@ -897,24 +897,24 @@
 	return sys32_fcntl(fd, cmd, arg);
 }
 
-struct mem_dqblk32 {
+struct dqblk32 {
+    __u32 dqb_bhardlimit;
+    __u32 dqb_bsoftlimit;
+    __u32 dqb_curblocks;
     __u32 dqb_ihardlimit;
     __u32 dqb_isoftlimit;
     __u32 dqb_curinodes;
-    __u32 dqb_bhardlimit;
-    __u32 dqb_bsoftlimit;
-    __u64 dqb_curspace;
     __kernel_time_t32 dqb_btime;
     __kernel_time_t32 dqb_itime;
 };
                                 
-extern asmlinkage long sys_quotactl(int cmd, const char *special, int id, __kernel_caddr_t addr);
+extern asmlinkage int sys_quotactl(int cmd, const char *special, int id, caddr_t addr);
 
 asmlinkage int sys32_quotactl(int cmd, const char *special, int id, unsigned long addr)
 {
 	int cmds = cmd >> SUBCMDSHIFT;
 	int err;
-	struct mem_dqblk d;
+	struct dqblk d;
 	mm_segment_t old_fs;
 	char *spec;
 	
@@ -924,35 +924,33 @@
 	case Q_SETQUOTA:
 	case Q_SETUSE:
 	case Q_SETQLIM:
-		if (copy_from_user (&d, (struct mem_dqblk32 *)addr,
-				    sizeof (struct mem_dqblk32)))
+		if (copy_from_user (&d, (struct dqblk32 *)addr,
+				    sizeof (struct dqblk32)))
 			return -EFAULT;
-		d.dqb_itime = ((struct mem_dqblk32 *)&d)->dqb_itime;
-		d.dqb_btime = ((struct mem_dqblk32 *)&d)->dqb_btime;
+		d.dqb_itime = ((struct dqblk32 *)&d)->dqb_itime;
+		d.dqb_btime = ((struct dqblk32 *)&d)->dqb_btime;
 		break;
 	default:
 		return sys_quotactl(cmd, special,
-				    id, (__kernel_caddr_t)addr);
+				    id, (caddr_t)addr);
 	}
 	spec = getname (special);
 	err = PTR_ERR(spec);
 	if (IS_ERR(spec)) return err;
 	old_fs = get_fs ();
 	set_fs (KERNEL_DS);
-	err = sys_quotactl(cmd, (const char *)spec, id, (__kernel_caddr_t)&d);
+	err = sys_quotactl(cmd, (const char *)spec, id, (caddr_t)&d);
 	set_fs (old_fs);
 	putname (spec);
-	if (err)
-		return err;
 	if (cmds == Q_GETQUOTA) {
 		__kernel_time_t b = d.dqb_btime, i = d.dqb_itime;
-		((struct mem_dqblk32 *)&d)->dqb_itime = i;
-		((struct mem_dqblk32 *)&d)->dqb_btime = b;
-		if (copy_to_user ((struct mem_dqblk32 *)addr, &d,
-				  sizeof (struct mem_dqblk32)))
+		((struct dqblk32 *)&d)->dqb_itime = i;
+		((struct dqblk32 *)&d)->dqb_btime = b;
+		if (copy_to_user ((struct dqblk32 *)addr, &d,
+				  sizeof (struct dqblk32)))
 			return -EFAULT;
 	}
-	return 0;
+	return err;
 }
 
 static inline int put_statfs (struct statfs32 *ubuf, struct statfs *kbuf)
@@ -2884,7 +2882,7 @@
 			err = copy_from_user(kaddr + offset, (char *)A(str),
 					     bytes_to_copy);
 			flush_page_to_ram(page);
-			kunmap((unsigned long)kaddr);
+			kunmap(page);
 
 			if (err)
 				return -EFAULT;
@@ -4038,57 +4036,55 @@
 }
 
 struct stat64_emu31 {
-        unsigned short  st_dev;
-        unsigned char   __pad0[6];
-
-        long long	st_ino;
-        unsigned int    st_mode;
-        unsigned int    st_nlink;
-
-        __u32		st_uid;
-        __u32		st_gid;
-
-        unsigned short  st_rdev;
-        unsigned char   __pad3[10];
-
-        long long       st_size;
-        __u32		st_blksize;
-
-        __u32		st_blocks;      /* Number 512-byte blocks allocated. */
-        __u32		__pad4;         /* future possible st_blocks high bits */
-
-        __u32		st_atime;
-        __u32		__pad5;
-
-        __u32		st_mtime;
-        __u32		__pad6;
-
-        __u32		st_ctime;
-        __u32		__pad7;         /* will be high 32 bits of ctime someday */
-
-        __u32		__unused1;
-        __u32		__unused2;
-};
+	unsigned char   __pad0[6];
+	unsigned short  st_dev;
+	unsigned int    __pad1;
+#define STAT64_HAS_BROKEN_ST_INO        1
+	u32             __st_ino;
+	unsigned int    st_mode;
+	unsigned int    st_nlink;
+	u32             st_uid;
+	u32             st_gid;
+	unsigned char   __pad2[6];
+	unsigned short  st_rdev;
+	unsigned int    __pad3;
+	long            st_size;
+	u32             st_blksize;
+	unsigned char   __pad4[4];
+	u32             __pad5;     /* future possible st_blocks high bits */
+	u32             st_blocks;  /* Number 512-byte blocks allocated. */
+	u32             st_atime;
+	u32             __pad6;
+	u32             st_mtime;
+	u32             __pad7;
+	u32             st_ctime;
+	u32             __pad8;     /* will be high 32 bits of ctime someday */
+	unsigned long   st_ino;
+};	
 
 static inline int
 putstat64 (struct stat64_emu31 *ubuf, struct stat *kbuf)
 {
-    int err;
-    
-    err = put_user (kbuf->st_dev, &ubuf->st_dev);
-    err |= __put_user (kbuf->st_ino, &ubuf->st_ino);
-    err |= __put_user (kbuf->st_mode, &ubuf->st_mode);
-    err |= __put_user (kbuf->st_nlink, &ubuf->st_nlink);
-    err |= __put_user (kbuf->st_uid, &ubuf->st_uid);
-    err |= __put_user (kbuf->st_gid, &ubuf->st_gid);
-    err |= __put_user (kbuf->st_rdev, &ubuf->st_rdev);
-    err |= __put_user (kbuf->st_size, &ubuf->st_size);
-    err |= __put_user (kbuf->st_blksize, &ubuf->st_blksize);
-    err |= __put_user (kbuf->st_blocks, &ubuf->st_blocks);
-    err |= __put_user (kbuf->st_atime, &ubuf->st_atime);
-    err |= __put_user (kbuf->st_mtime, &ubuf->st_mtime);
-    err |= __put_user (kbuf->st_ctime, &ubuf->st_ctime);
-    return err;
+    struct stat64_emu31 tmp;
+   
+    memset(&tmp, 0, sizeof(tmp));
+
+    tmp.st_dev = (unsigned short)kbuf->st_dev;
+    tmp.st_ino = kbuf->st_ino;
+    tmp.__st_ino = (u32)kbuf->st_ino;
+    tmp.st_mode = kbuf->st_mode;
+    tmp.st_nlink = (unsigned int)kbuf->st_nlink;
+    tmp.st_uid = kbuf->st_uid;
+    tmp.st_gid = kbuf->st_gid;
+    tmp.st_rdev = (unsigned short)kbuf->st_rdev;
+    tmp.st_size = kbuf->st_size;
+    tmp.st_blksize = (u32)kbuf->st_blksize;
+    tmp.st_blocks = (u32)kbuf->st_blocks;
+    tmp.st_atime = (u32)kbuf->st_atime;
+    tmp.st_mtime = (u32)kbuf->st_mtime;
+    tmp.st_ctime = (u32)kbuf->st_ctime;
+
+    return copy_to_user(ubuf,&tmp,sizeof(tmp)) ? -EFAULT : 0; 
 }
 
 extern asmlinkage long sys_newstat(char * filename, struct stat * statbuf);
@@ -4100,7 +4096,7 @@
     char * tmp;
     int err;
     mm_segment_t old_fs = get_fs();
-    
+   
     tmp = getname(filename);
     err = PTR_ERR(tmp);
     if (IS_ERR(tmp))   
@@ -4131,7 +4127,7 @@
 	    return err;
 
     set_fs (KERNEL_DS);
-    ret = sys_newstat(tmp, &s);
+    ret = sys_newlstat(tmp, &s);
     set_fs (old_fs);
     putname(tmp);
     if (putstat64 (statbuf, &s)) 
@@ -4176,8 +4172,8 @@
 	unsigned long prot, unsigned long flags,
 	unsigned long fd, unsigned long pgoff)
 {
-	int error = -EBADF;
 	struct file * file = NULL;
+	unsigned long error = -EBADF;
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 	if (!(flags & MAP_ANONYMOUS)) {
@@ -4188,6 +4184,11 @@
 
 	down_write(&current->mm->mmap_sem);
 	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	if (!IS_ERR((void *) error) && error + len >= 0x80000000ULL) {
+		/* Result is out of bounds.  */
+		do_munmap(current->mm, addr, len);
+		error = -ENOMEM;
+	}
 	up_write(&current->mm->mmap_sem);
 
 	if (file)
diff -urN linux/arch/s390x/kernel/linux32.h linux-2.4.7/arch/s390x/kernel/linux32.h
--- linux/arch/s390x/kernel/linux32.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/linux32.h	Mon Dec 17 13:41:18 2001
@@ -237,8 +237,8 @@
 	__u32			uc_flags;
 	__u32			uc_link;	/* pointer */	
 	stack_t32		uc_stack;
+	_sigregs32		uc_mcontext;
 	sigset_t32		uc_sigmask;	/* mask last for extensibility */
-	__u32			sc;		/* pointer */
 };
 
 #endif /* !CONFIG_S390_SUPPORT */
diff -urN linux/arch/s390x/kernel/lowcore.S linux-2.4.7/arch/s390x/kernel/lowcore.S
--- linux/arch/s390x/kernel/lowcore.S	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/lowcore.S	Wed Dec 31 19:00:00 1969
@@ -1,28 +0,0 @@
-/*
- *  arch/s390/kernel/lowcore.S
- *    S390 lowcore definition.
- *
- *  S390 64 bit Version
- *    Copyright (C) 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Hartmut Penner (hpenner@de.ibm.com)
- *               Martin Schwidefsky (schwidefsky@de.ibm.com),
- */
-#include <asm/lowcore.h>
-	
-         .align 8192
-         .globl init_S390_lowcore
-init_S390_lowcore:      
-         .fill 0x1a0-0x000,1,0	
-         .quad  _RESTART_PSW_MASK
-         .quad  restart_int_handler 
-         .quad  _EXT_PSW_MASK
-         .quad  ext_int_handler 
-         .quad  _SVC_PSW_MASK
-         .quad  system_call
-         .quad  _PGM_PSW_MASK
-         .quad  pgm_check_handler 
-         .quad  _MCCK_PSW_MASK
-         .quad  mcck_int_handler 
-EXT_PSW: .quad  _IO_PSW_MASK
-         .quad  io_int_handler
-	 .fill  0x2000-0x200,1,0
diff -urN linux/arch/s390x/kernel/mathemu.c linux-2.4.7/arch/s390x/kernel/mathemu.c
--- linux/arch/s390x/kernel/mathemu.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/mathemu.c	Wed Dec 31 19:00:00 1969
@@ -1,920 +0,0 @@
-/*
- *  arch/s390/kernel/mathemu.c
- *
- *  S390 version
- *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com),
- *
- * 'mathemu.c' handles IEEE instructions on a S390 processor
- * that does not have the IEEE fpu
- */
-
-#include <linux/config.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/ptrace.h>
-
-#include <asm/uaccess.h>
-#include <asm/mathemu.h>
-
-#ifdef CONFIG_SYSCTL
-int sysctl_ieee_emulation_warnings=1;
-#endif
-
-static void display_emulation_not_implemented(char *instr)
-{
-	struct pt_regs *regs;
-	__u16 *location;
-	
-#if CONFIG_SYSCTL
-	if(sysctl_ieee_emulation_warnings)
-#endif
-	{
-		regs=current->thread.regs;
-		location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
-		printk("%s ieee fpu instruction not emulated process name: %s pid: %d \n",
-		       instr,
-		       current->comm, current->pid);
-		printk("%s's PSW:    %08lx %08lx\n",instr,
-		       (unsigned long) regs->psw.mask,
-		       (unsigned long) location);
-	}
-}
-
-
-static void set_CC_df(__u64 val1,__u64 val2) {
-        int rc;
-        rc = __cmpdf2(val1,val2);
-        current->thread.regs->psw.mask &= 0xFFFFCFFFFFFFFFFFL;
-        switch (rc) {
-                case -1:
-                        current->thread.regs->psw.mask |= 0x0000100000000000L;
-                        break;
-                case 1:
-                        current->thread.regs->psw.mask |= 0x0000200000000000L;
-                        break;
-        }
-}
-
-static void set_CC_sf(__u32 val1,__u32 val2) {
-        int rc;
-        rc = __cmpsf2(val1,val2);
-        current->thread.regs->psw.mask &= 0xFFFFCFFFFFFFFFFF;
-        switch (rc) {
-                case -1:
-                        current->thread.regs->psw.mask |= 0x0000100000000000L;
-                        break;
-                case 1:
-                        current->thread.regs->psw.mask |= 0x0000200000000000L;
-                        break;
-        }
-}
-
-
-static void emu_adb (int rx, __u64 val) {
-        current->thread.fp_regs.fprs[rx].d = __adddf3(current->thread.fp_regs.fprs[rx].d,val);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_adbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = __adddf3(current->thread.fp_regs.fprs[rx].d,
-                                         current->thread.fp_regs.fprs[ry].d);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_aeb (int rx, __u32 val) {
-        current->thread.fp_regs.fprs[rx].f = __addsf3(current->thread.fp_regs.fprs[rx].f,val);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_aebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __addsf3(current->thread.fp_regs.fprs[rx].f,
-                                        current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_axbr (int rx, int ry) {
-        display_emulation_not_implemented("axbr");
-}
-
-static void emu_cdb (int rx, __u64 val) {
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,val);
-}
-
-static void emu_cdbr (int rx, int ry) {
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,current->thread.fp_regs.fprs[ry].d);
-}
-
-static void emu_cdfbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d =
-                     __floatsidf(current->thread.regs->gprs[ry]);
-}
-
-static void emu_ceb (int rx, __u32 val) {
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,val);
-}
-
-static void emu_cebr (int rx, int ry) {
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,current->thread.fp_regs.fprs[ry].f);
-}
-
-static void emu_cefbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f =
-                     __floatsisf(current->thread.regs->gprs[ry]);
-}
-
-static void emu_cfdbr (int rx, int ry, int mask) {
-        current->thread.regs->gprs[rx] =
-                     __fixdfsi(current->thread.fp_regs.fprs[ry].d);
-}
-
-static void emu_cfebr (int rx, int ry, int mask) {
-        current->thread.regs->gprs[rx] =
-                     __fixsfsi(current->thread.fp_regs.fprs[ry].f);
-}
-
-static void emu_cfxbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("cfxbr");
-}
-
-static void emu_cxbr (int rx, int ry) {
-        display_emulation_not_implemented("cxbr");
-}
-
-static void emu_cxfbr (int rx, int ry) {
-        display_emulation_not_implemented("cxfbr");
-}
-
-static void emu_ddb (int rx, __u64 val) {
-        current->thread.fp_regs.fprs[rx].d = __divdf3(current->thread.fp_regs.fprs[rx].d,val);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_ddbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = __divdf3(current->thread.fp_regs.fprs[rx].d,
-                                         current->thread.fp_regs.fprs[ry].d);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_deb (int rx, __u32 val) {
-        current->thread.fp_regs.fprs[rx].f = __divsf3(current->thread.fp_regs.fprs[rx].f,val);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_debr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __divsf3(current->thread.fp_regs.fprs[rx].f,
-                                         current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_didbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("didbr");
-}
-
-static void emu_diebr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("diebr");
-}
-
-static void emu_dxbr (int rx, int ry) {
-        display_emulation_not_implemented("dxbr");
-}
-
-static void emu_efpc (int rx, int ry) {
-        display_emulation_not_implemented("efpc");
-}
-
-static void emu_fidbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("fidbr");
-}
-
-static void emu_fiebr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("fiebr");
-}
-
-static void emu_fixbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("fixbr");
-}
-
-static void emu_kdb (int rx, __u64 val) {
-        display_emulation_not_implemented("kdb");
-}
-
-static void emu_kdbr (int rx, int ry) {
-        display_emulation_not_implemented("kdbr");
-}
-
-static void emu_keb (int rx, __u32 val) {
-        display_emulation_not_implemented("keb");
-}
-
-static void emu_kebr (int rx, int ry) {
-        display_emulation_not_implemented("kebr");
-}
-
-static void emu_kxbr (int rx, int ry) {
-        display_emulation_not_implemented("kxbr");
-}
-
-static void emu_lcdbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d =
-        __negdf2(current->thread.fp_regs.fprs[ry].d);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_lcebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f =
-        __negsf2(current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_lcxbr (int rx, int ry) {
-        display_emulation_not_implemented("lcxbr");
-}
-
-static void emu_ldeb (int rx, __u32 val) {
-        current->thread.fp_regs.fprs[rx].d = __extendsfdf2(val);
-}
-
-static void emu_ldebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d =
-        __extendsfdf2(current->thread.fp_regs.fprs[ry].f);
-}
-
-static void emu_ldxbr (int rx, int ry) {
-        display_emulation_not_implemented("ldxbr");
-}
-
-static void emu_ledbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __truncdfsf2(current->thread.fp_regs.fprs[ry].d);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_lexbr (int rx, int ry) {
-        display_emulation_not_implemented("lexbr");
-}
-
-static void emu_lndbr (int rx, int ry) {
-        display_emulation_not_implemented("lndbr");
-}
-
-static void emu_lnebr (int rx, int ry) {
-        display_emulation_not_implemented("lnebr");
-}
-
-static void emu_lnxbr (int rx, int ry) {
-        display_emulation_not_implemented("lnxbr");
-}
-
-static void emu_lpdbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = __absdf2(current->thread.fp_regs.fprs[ry].d);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0);
-}
-
-static void emu_lpebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __abssf2(current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_lpxbr (int rx, int ry) {
-        display_emulation_not_implemented("lpxbr");
-}
-
-static void emu_ltdbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = current->thread.fp_regs.fprs[ry].d;
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_ltebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = current->thread.fp_regs.fprs[ry].f;
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_ltxbr (int rx, int ry) {
-        display_emulation_not_implemented("ltxbr");
-}
-
-static void emu_lxdb (int rx, __u64 val) {
-        display_emulation_not_implemented("lxdb");
-}
-
-static void emu_lxdbr (int rx, int ry) {
-        display_emulation_not_implemented("lxdbr");
-}
-
-static void emu_lxeb (int rx, __u32 val) {
-        display_emulation_not_implemented("lxeb");
-}
-
-static void emu_lxebr (int rx, int ry) {
-        display_emulation_not_implemented("lxebr");
-}
-
-static void emu_madb (int rx, __u64 val, int mask) {
-        display_emulation_not_implemented("madb");
-}
-
-static void emu_madbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("madbr");
-}
-
-static void emu_maeb (int rx, __u32 val, int mask) {
-        display_emulation_not_implemented("maeb");
-}
-
-static void emu_maebr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("maebr");
-}
-
-static void emu_mdb (int rx, __u64 val) {
-        current->thread.fp_regs.fprs[rx].d = __muldf3(current->thread.fp_regs.fprs[rx].d,val);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_mdbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = __muldf3(current->thread.fp_regs.fprs[rx].d,
-                                         current->thread.fp_regs.fprs[ry].d);
-        set_CC_df(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_mdeb (int rx, __u32 val) {
-        display_emulation_not_implemented("mdeb");
-}
-
-static void emu_mdebr (int rx, int ry) {
-        display_emulation_not_implemented("mdebr");
-}
-
-static void emu_meeb (int rx, __u32 val) {
-        current->thread.fp_regs.fprs[rx].f = __mulsf3(current->thread.fp_regs.fprs[rx].f,
-                                         val);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_meebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __mulsf3(current->thread.fp_regs.fprs[rx].f,
-                                         current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_msdb (int rx, __u64 val, int mask) {
-        display_emulation_not_implemented("msdb");
-}
-
-static void emu_msdbr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("msdbr");
-}
-
-static void emu_mseb (int rx, __u32 val, int mask) {
-        display_emulation_not_implemented("mseb");
-}
-
-static void emu_msebr (int rx, int ry, int mask) {
-        display_emulation_not_implemented("msebr");
-}
-
-static void emu_mxbr (int rx, int ry) {
-        display_emulation_not_implemented("mxbr");
-}
-
-static void emu_mxdb (int rx, __u64 val) {
-        display_emulation_not_implemented("mxdb");
-}
-
-static void emu_mxdbr (int rx, int ry) {
-        display_emulation_not_implemented("mxdbr");
-}
-
-static void emu_sdb (int rx, __u64 val) {
-        current->thread.fp_regs.fprs[rx].d = __subdf3(current->thread.fp_regs.fprs[rx].d,
-                                         val);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_sdbr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].d = __subdf3(current->thread.fp_regs.fprs[rx].d,
-                                         current->thread.fp_regs.fprs[ry].d);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].d,0ULL);
-}
-
-static void emu_seb (int rx, __u32 val) {
-        current->thread.fp_regs.fprs[rx].f = __subsf3(current->thread.fp_regs.fprs[rx].f,
-                                         val);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_sebr (int rx, int ry) {
-        current->thread.fp_regs.fprs[rx].f = __subsf3(current->thread.fp_regs.fprs[rx].f,
-                                         current->thread.fp_regs.fprs[ry].f);
-        set_CC_sf(current->thread.fp_regs.fprs[rx].f,0);
-}
-
-static void emu_sfpc (int rx, int ry) {
-        display_emulation_not_implemented("sfpc");
-}
-
-static void emu_sqdb (int rx, __u64 val) {
-        display_emulation_not_implemented("sqdb");
-}
-
-static void emu_sqdbr (int rx, int ry) {
-        display_emulation_not_implemented("sqdbr");
-}
-
-static void emu_sqeb (int rx, __u32 val) {
-        display_emulation_not_implemented("sqeb");
-}
-
-static void emu_sqebr (int rx, int ry) {
-        display_emulation_not_implemented("sqebr");
-}
-
-static void emu_sqxbr (int rx, int ry) {
-        display_emulation_not_implemented("sqxbr");
-}
-
-static void emu_sxbr (int rx, int ry) {
-        display_emulation_not_implemented("sxbr");
-}
-
-static void emu_tcdb (int rx, __u64 val) {
-        display_emulation_not_implemented("tcdb");
-}
-
-static void emu_tceb (int rx, __u32 val) {
-        display_emulation_not_implemented("tceb");
-}
-
-static void emu_tcxb (int rx, __u64 val) {
-        display_emulation_not_implemented("tcxb");
-}
-
-
-static inline void emu_load_regd(int reg) {
-        if ((reg&9) == 0) {                /* test if reg in {0,2,4,6} */
-                __asm__ __volatile (       /* load reg from fp_regs.fprs[reg] */
-                        "     bras  1,0f\n"
-                        "     ld    0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].d)
-                        : "1" );
-        }
-}
-
-static inline void emu_load_rege(int reg) {
-        if ((reg&9) == 0) {                /* test if reg in {0,2,4,6} */
-                __asm__ __volatile (       /* load reg from fp_regs.fprs[reg] */
-                        "     bras  1,0f\n"
-                        "     le    0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].f)
-                        : "1" );
-        }
-}
-
-static inline void emu_store_regd(int reg) {
-        if ((reg&9) == 0) {                /* test if reg in {0,2,4,6} */
-                __asm__ __volatile (       /* store reg to fp_regs.fprs[reg] */
-                        "     bras  1,0f\n"
-                        "     std   0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].d)
-                        : "1" );
-        }
-}
-
-
-static inline void emu_store_rege(int reg) {
-        if ((reg&9) == 0) {                /* test if reg in {0,2,4,6} */
-                __asm__ __volatile (       /* store reg to fp_regs.fprs[reg] */
-                        "     bras  1,0f\n"
-                        "     ste   0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (reg<<4), "a" (&current->thread.fp_regs.fprs[reg].f)
-                        : "1" );
-        }
-}
-
-int math_emu_b3(__u8 *opcode, struct pt_regs * regs) {
-        static const __u8 format_table[] = {
-                2, 2, 2, 2, 9, 1, 2, 1, 2, 2, 2, 2, 9, 2, 4, 4,
-                1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 3,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                1, 1, 1, 1,10, 1, 1, 3, 1, 1, 1, 1, 1, 1, 0, 0,
-                0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 3, 0, 0, 0, 3,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,
-                0, 0, 0, 0, 5, 6, 6, 0, 7, 8, 8, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-        };
-        static const void *jump_table[]= {
-                emu_lpebr, emu_lnebr, emu_ltebr, emu_lcebr,
-                emu_ldebr, emu_lxdbr, emu_lxebr, emu_mxdbr,
-                emu_kebr,  emu_cebr,  emu_aebr,  emu_sebr,
-                emu_mdebr, emu_debr,  emu_maebr, emu_msebr,
-                emu_lpdbr, emu_lndbr, emu_ltdbr, emu_lcdbr,
-                emu_sqebr, emu_sqdbr, emu_sqxbr, emu_meebr,
-                emu_kdbr,  emu_cdbr,  emu_adbr,  emu_sdbr,
-                emu_mdbr,  emu_ddbr,  emu_madbr, emu_msdbr,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                emu_lpxbr, emu_lnxbr, emu_ltxbr, emu_lcxbr,
-                emu_ledbr, emu_ldxbr, emu_lexbr, emu_fixbr,
-                emu_kxbr,  emu_cxbr,  emu_axbr,  emu_sxbr,
-                emu_mxbr,  emu_dxbr,  NULL,      NULL,
-                NULL,      NULL,      NULL,      emu_diebr,
-                NULL,      NULL,      NULL,      emu_fiebr,
-                NULL,      NULL,      NULL,      emu_didbr,
-                NULL,      NULL,      NULL,      emu_fidbr,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                emu_sfpc,  NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                emu_efpc,  NULL,      NULL,      NULL,
-                NULL,      NULL,      NULL,      NULL,
-                emu_cefbr, emu_cdfbr, emu_cxfbr, NULL,
-                emu_cfebr, emu_cfdbr, emu_cfxbr
-        };
-
-        switch (format_table[opcode[1]]) {
-        case 1: /* RRE format, double operation */
-                emu_store_regd((opcode[3]>>4)&15);
-                emu_store_regd(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_regd((opcode[3]>>4)&15);
-                emu_load_regd(opcode[3]&15);
-                return 0;
-        case 2: /* RRE format, float operation */
-                emu_store_rege((opcode[3]>>4)&15);
-                emu_store_rege(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_rege((opcode[3]>>4)&15);
-                emu_load_rege(opcode[3]&15);
-                return 0;
-        case 3: /* RRF format, double operation */
-                emu_store_regd((opcode[3]>>4)&15);
-                emu_store_regd(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15,opcode[2]>>4);
-                emu_load_regd((opcode[3]>>4)&15);
-                emu_load_regd(opcode[3]&15);
-                return 0;
-        case 4: /* RRF format, float operation */
-                emu_store_rege((opcode[3]>>4)&15);
-                emu_store_rege(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15,opcode[2]>>4);
-                emu_load_rege((opcode[3]>>4)&15);
-                emu_load_rege(opcode[3]&15);
-                return 0;
-        case 5: /* RRE format, cefbr instruction */
-                emu_store_rege((opcode[3]>>4)&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_rege((opcode[3]>>4)&15);
-                return 0;
-        case 6: /* RRE format, cdfbr & cxfbr instruction */
-                emu_store_regd((opcode[3]>>4)&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_regd((opcode[3]>>4)&15);
-                return 0;
-                /* FIXME !! */
-                return 0;
-        case 7: /* RRF format, cfebr instruction */
-                emu_store_rege(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15,opcode[2]>>4);
-                return 0;
-        case 8: /* RRF format, cfdbr & cfxbr instruction */
-                emu_store_regd(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15,opcode[2]>>4);
-                return 0;
-	case 9: /* RRE format, ldebr & mdebr instruction */
-		/* float store but double load */
-                emu_store_rege((opcode[3]>>4)&15);
-                emu_store_rege(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_regd((opcode[3]>>4)&15);
-                return 0;
-        case 10: /* RRE format, ledbr instruction */
-		/* double store but float load */
-                emu_store_regd((opcode[3]>>4)&15);
-                emu_store_regd(opcode[3]&15);
-                /* call the emulation function */
-                ((void (*)(int, int))jump_table[opcode[1]])
-                        (opcode[3]>>4,opcode[3]&15);
-                emu_load_rege((opcode[3]>>4)&15);
-                return 0;
-        default:
-                return 1;
-        }
-}
-
-static void* calc_addr(struct pt_regs *regs,int rx,int rb,int disp)
-{
-  rx &= 0xf;
-  rb &= 0xf;
-  disp &= 0xfff;
-  return (void*) ((rx != 0 ? regs->gprs[rx] : 0)  + /* index */   
-         (rb != 0 ? regs->gprs[rb] : 0)  + /* base */
-         disp);
-}
-    
-int math_emu_ed(__u8 *opcode, struct pt_regs * regs) {
-        static const __u8 format_table[] = {
-                0, 0, 0, 0, 5, 1, 2, 1, 2, 2, 2, 2, 5, 2, 4, 4,
-                2, 1, 1, 0, 2, 1, 0, 2, 1, 1, 1, 1, 1, 1, 3, 3,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-        };
-        static const void *jump_table[]= {
-                NULL,     NULL,     NULL,     NULL,
-                emu_ldeb, emu_lxdb, emu_lxeb, emu_mxdb,
-                emu_keb,  emu_ceb,  emu_aeb,  emu_seb,
-                emu_mdeb, emu_deb,  emu_maeb, emu_mseb,
-                emu_tceb, emu_tcdb, emu_tcxb, NULL,
-                emu_sqeb, emu_sqdb, NULL,     emu_meeb,
-                emu_kdb,  emu_cdb,  emu_adb,  emu_sdb,
-                emu_mdb,  emu_ddb,  emu_madb, emu_msdb
-        };
-
-        switch (format_table[opcode[5]]) {
-        case 1: /* RXE format, __u64 constant */ {
-                __u64 *dxb, temp;
-                __u32 opc;
-
-                emu_store_regd((opcode[1]>>4)&15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u64 *) calc_addr(regs,opc>>16,opc>>12,opc);
-                /* FIXME: how to react if copy_from_user fails ? */
-                copy_from_user(&temp, dxb, 8);
-                /* call the emulation function */
-                ((void (*)(int, __u64))jump_table[opcode[5]])
-                        (opcode[1]>>4,temp);
-                emu_load_regd((opcode[1]>>4)&15);
-                return 0;
-        }
-        case 2: /* RXE format, __u32 constant */ {
-                __u32 *dxb, temp;
-                __u32 opc;
-
-                emu_store_rege((opcode[1]>>4)&15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-                /* FIXME: how to react if get_user fails ? */
-                get_user(temp, dxb);
-                /* call the emulation function */
-                ((void (*)(int, __u32))jump_table[opcode[5]])
-                        (opcode[1]>>4,temp);
-                emu_load_rege((opcode[1]>>4)&15);
-                return 0;
-        }
-        case 3: /* RXF format, __u64 constant */ {
-                __u32 *dxb, temp;
-                __u32 opc;
-
-                emu_store_regd((opcode[1]>>4)&15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-                /* FIXME: how to react if copy_from_user fails ? */
-                copy_from_user(&temp, dxb, 8);
-                /* call the emulation function */
-                ((void (*)(int, __u32, int))jump_table[opcode[5]])
-                        (opcode[1]>>4,temp,opcode[4]>>4);
-                emu_load_regd((opcode[1]>>4)&15);
-                return 0;
-        }
-        case 4: /* RXF format, __u32 constant */ {
-                __u32 *dxb, temp;
-                __u32 opc;
-
-                emu_store_rege((opcode[1]>>4)&15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-                /* FIXME: how to react if get_user fails ? */
-                get_user(temp, dxb);
-                /* call the emulation function */
-                ((void (*)(int, __u32, int))jump_table[opcode[5]])
-                        (opcode[1]>>4,temp,opcode[4]>>4);
-                emu_load_rege((opcode[1]>>4)&15);
-                return 0;
-        }
-	case 5: /* RXE format, __u32 constant */
-                /* store_rege and load_regd */ 
-		{
-                __u32 *dxb, temp;
-                __u32 opc;
-                emu_store_rege((opcode[1]>>4)&15);
-                opc = *((__u32 *) opcode);
-                dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-                /* FIXME: how to react if get_user fails ? */
-                get_user(temp, dxb);
-                /* call the emulation function */
-                ((void (*)(int, __u32))jump_table[opcode[5]])
-                        (opcode[1]>>4,temp);
-                emu_load_regd((opcode[1]>>4)&15);
-                return 0;
-        }
-        default:
-                return 1;
-        }
-}
-
-/*
- * Emulate LDR Rx,Ry with Rx or Ry not in {0, 2, 4, 6}
- */
-void math_emu_ldr(__u8 *opcode) {
-        __u16 opc = *((__u16 *) opcode);
-
-        if ((opc & 0x0090) == 0) {         /* test if rx in {0,2,4,6} */
-                /* we got an exception therfore ry can't be in {0,2,4,6} */
-                __asm__ __volatile (       /* load rx from fp_regs.fprs[ry] */
-                        "     bras  1,0f\n"
-                        "     ld    0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (opc&0x00f0),
-                          "a" (&current->thread.fp_regs.fprs[opc&0x000f].d)
-                        : "1" );
-        } else if ((opc & 0x0009) == 0) {  /* test if ry in {0,2,4,6} */
-                __asm__ __volatile (       /* store ry to fp_regs.fprs[rx] */
-                        "     bras  1,0f\n"
-                        "     std   0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" ((opc&0x000f)<<4),
-                          "a" (&current->thread.fp_regs.fprs[(opc&0x00f0)>>4].d)
-                        : "1" );
-        } else {                          /* move fp_regs.fprs[ry] to fp_regs.fprs[rx] */
-                current->thread.fp_regs.fprs[(opc&0x00f0)>>4] =
-                        current->thread.fp_regs.fprs[opc&0x000f];
-        }
-}
-
-/*
- * Emulate LER Rx,Ry with Rx or Ry not in {0, 2, 4, 6}
- */
-void math_emu_ler(__u8 *opcode) {
-        __u16 opc = *((__u16 *) opcode);
-
-        if ((opc & 0x0090) == 0) {         /* test if rx in {0,2,4,6} */
-                /* we got an exception therfore ry can't be in {0,2,4,6} */
-                __asm__ __volatile (       /* load rx from fp_regs.fprs[ry] */
-                        "     bras  1,0f\n"
-                        "     le    0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" (opc&0x00f0),
-                          "a" (&current->thread.fp_regs.fprs[opc&0x000f].f)
-                        : "1" );
-        } else if ((opc & 0x0009) == 0) {  /* test if ry in {0,2,4,6} */
-                __asm__ __volatile (       /* store ry to fp_regs.fprs[rx] */
-                        "     bras  1,0f\n"
-                        "     ste   0,0(%1)\n"
-                        "0:   ex    %0,0(1)"
-                        : /* no output */
-                        : "a" ((opc&0x000f)<<4),
-                          "a" (&current->thread.fp_regs.fprs[(opc&0x00f0)>>4].f)
-                        : "1" );
-        } else {                          /* move fp_regs.fprs[ry] to fp_regs.fprs[rx] */
-                current->thread.fp_regs.fprs[(opc&0x00f0)>>4] =
-                        current->thread.fp_regs.fprs[opc&0x000f];
-        }
-}
-
-/*
- * Emulate LD R,D(X,B) with R not in {0, 2, 4, 6}
- */
-void math_emu_ld(__u8 *opcode, struct pt_regs * regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u64 *dxb;
-
-        dxb = (__u64 *) calc_addr(regs,opc>>16,opc>>12,opc);
-        /* FIXME: how to react if copy_from_user fails ? */
-        copy_from_user(&current->thread.fp_regs.fprs[(opc>>20)&15].d, dxb, 8);
-}
-
-/*
- * Emulate LE R,D(X,B) with R not in {0, 2, 4, 6}
- */
-void math_emu_le(__u8 *opcode, struct pt_regs * regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *mem, *dxb;
-
-        dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-        /* FIXME: how to react if get_user fails ? */
-        mem = (__u32 *) (&current->thread.fp_regs.fprs[(opc>>20)&15].f);
-        get_user(mem[0], dxb);
-}
-
-/*
- * Emulate STD R,D(X,B) with R not in {0, 2, 4, 6}
- */
-void math_emu_std(__u8 *opcode, struct pt_regs * regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u64 *dxb;
-        dxb = (__u64 *) calc_addr(regs,opc>>16,opc>>12,opc);
-        /* FIXME: how to react if copy_to_user fails ? */
-        copy_to_user(dxb, &current->thread.fp_regs.fprs[(opc>>20)&15].d, 8);
-}
-
-/*
- * Emulate STE R,D(X,B) with R not in {0, 2, 4, 6}
- */
-void math_emu_ste(__u8 *opcode, struct pt_regs * regs) {
-        __u32 opc = *((__u32 *) opcode);
-        __u32 *mem, *dxb;
-        dxb = (__u32 *) calc_addr(regs,opc>>16,opc>>12,opc);
-        /* FIXME: how to react if put_user fails ? */
-        mem = (__u32 *) (&current->thread.fp_regs.fprs[(opc>>20)&15].f);
-        put_user(mem[0], dxb);
-}
-
-/*
- * Emulate LFPC D(B)
- */
-int math_emu_lfpc(__u8 *opcode, struct pt_regs *regs) {
-        /* FIXME: how to do that ?!? */
-        return 0;
-}
-
-/*
- * Emulate STFPC D(B)
- */
-int math_emu_stfpc(__u8 *opcode, struct pt_regs *regs) {
-        /* FIXME: how to do that ?!? */
-        return 0;
-}
-
-/*
- * Emulate SRNM D(B)
- */
-int math_emu_srnm(__u8 *opcode, struct pt_regs *regs) {
-        /* FIXME: how to do that ?!? */
-        return 0;
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff -urN linux/arch/s390x/kernel/process.c linux-2.4.7/arch/s390x/kernel/process.c
--- linux/arch/s390x/kernel/process.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/process.c	Mon Dec 17 13:42:41 2001
@@ -44,8 +44,6 @@
 #include <asm/processor.h>
 #include <asm/irq.h>
 
-spinlock_t semaphore_wake_lock = SPIN_LOCK_UNLOCKED;
-
 asmlinkage void ret_from_fork(void) __asm__("ret_from_fork");
 
 /*
@@ -63,13 +61,6 @@
 	wait_psw.mask = _WAIT_PSW_MASK;
 	wait_psw.addr = (unsigned long) &&idle_wakeup;
 	while(1) {
-                if (softirq_active(smp_processor_id()) &
-		    softirq_mask(smp_processor_id())) {
-                        do_softirq();
-                        __sti();
-                        if (!current->need_resched)
-                                continue;
-                }
                 if (current->need_resched) {
                         schedule();
                         check_pgt_cache();
@@ -216,7 +207,7 @@
 void show_regs(struct pt_regs *regs)
 {
 	char buff[80];
-	int line;
+	int i, line;
 
         printk("CPU:    %d\n",smp_processor_id());
         printk("Process %s (pid: %d, stackpage=%016lX)\n",
@@ -224,6 +215,17 @@
 	
 	for (line = 0; sprintf_regs(line, buff, current, regs); line++)
 		printk(buff);
+
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+	{
+		printk("User Code:\n");
+		memset(buff, 0, 20);
+		copy_from_user(buff,
+			       (char *) (regs->psw.addr & PSW_ADDR_MASK), 20);
+		for (i = 0; i < 20; i++)
+			printk("%02x ", buff[i]);
+		printk("\n");
+	}
 }
 
 char *task_show_regs(struct task_struct *task, char *buffer)
@@ -311,7 +313,7 @@
         p->thread.ksp = (unsigned long) frame;
         frame->childregs = *regs;
         frame->childregs.gprs[15] = new_stackp;
-        frame->eos = 0;
+        frame->back_chain = frame->eos = 0;
 
         /* new return point is ret_from_sys_call */
         frame->gprs[8] = (unsigned long) &ret_from_fork;
@@ -329,28 +331,19 @@
 
 asmlinkage int sys_fork(struct pt_regs regs)
 {
-        int ret;
-
-        lock_kernel();
-        ret = do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
-        unlock_kernel();
-        return ret;
+        return do_fork(SIGCHLD, regs.gprs[15], &regs, 0);
 }
 
 asmlinkage int sys_clone(struct pt_regs regs)
 {
         unsigned long clone_flags;
         unsigned long newsp;
-        int ret;
 
-        lock_kernel();
         clone_flags = regs.gprs[3];
         newsp = regs.orig_gpr2;
         if (!newsp)
                 newsp = regs.gprs[15];
-        ret = do_fork(clone_flags, newsp, &regs, 0);
-        unlock_kernel();
-        return ret;
+        return do_fork(clone_flags, newsp, &regs, 0);
 }
 
 /*
@@ -460,54 +453,3 @@
 #undef last_sched
 #undef first_sched
 
-/*
- * This should be safe even if called from tq_scheduler
- * A typical mask would be sigmask(SIGKILL)|sigmask(SIGINT)|sigmask(SIGTERM) or 0.
- *
- */
-void s390_daemonize(char *name,unsigned long mask,int use_init_fs)
-{
-	struct fs_struct *fs;
-	extern struct task_struct *child_reaper;
-	struct task_struct *this_process=current;
-	
-	/*
-	 * If we were started as result of loading a module, close all of the
-	 * user space pages.  We don't need them, and if we didn't close them
-	 * they would be locked into memory.
-	 */
-	exit_mm(current);
-
-	this_process->session = 1;
-	this_process->pgrp = 1;
-	if(name)
-	{
-		strncpy(current->comm,name,15);
-		current->comm[15]=0;
-	}
-	else
-		current->comm[0]=0;
-	/* set signal mask to what we want to respond */
-        siginitsetinv(&current->blocked,mask);
-	/* exit_signal isn't set up */
-        /* if we inherit from cpu idle  */
-	this_process->exit_signal=SIGCHLD;
-	/* if priority=0 schedule can go into a tight loop */
-	this_process->policy= SCHED_OTHER;
-	/* nice goes priority=20-nice; */
-	this_process->nice=10;
-	if(use_init_fs)
-	{
-		exit_fs(this_process);	/* current->fs->count--; */
-		fs = init_task.fs;
-		current->fs = fs;
-		atomic_inc(&fs->count);
-		exit_files(current);
-	}
-	write_lock_irq(&tasklist_lock);
-	/* We want init as our parent */
-	REMOVE_LINKS(this_process);
-	this_process->p_opptr=this_process->p_pptr=child_reaper;
-	SET_LINKS(this_process);
-	write_unlock_irq(&tasklist_lock);
-}
diff -urN linux/arch/s390x/kernel/s390_ext.c linux-2.4.7/arch/s390x/kernel/s390_ext.c
--- linux/arch/s390x/kernel/s390_ext.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/s390_ext.c	Mon Dec 17 13:42:41 2001
@@ -9,7 +9,7 @@
 
 #include <linux/module.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <asm/lowcore.h>
 #include <asm/s390_ext.h>
 
@@ -17,12 +17,13 @@
  * Simple hash strategy: index = code & 0xff;
  * ext_int_hash[index] is the start of the list for all external interrupts
  * that hash to this index. With the current set of external interrupts 
- * (0x1202 external call, 0x1004 cpu timer, 0x2401 hwc console and 0x4000
- * iucv) this is always the first element. 
+ * (0x1202 external call, 0x1004 cpu timer, 0x2401 hwc console, 0x4000
+ * iucv and 0x2603 pfault) this is always the first element. 
  */
 ext_int_info_t *ext_int_hash[256] = { 0, };
 ext_int_info_t ext_int_info_timer;
 ext_int_info_t ext_int_info_hwc;
+ext_int_info_t ext_int_pfault;
 
 int register_external_interrupt(__u16 code, ext_int_handler_t handler) {
         ext_int_info_t *p;
@@ -39,6 +40,8 @@
                 p = &ext_int_info_timer;
         else if (code == 0x2401) /* hwc_init is done too early too */
                 p = &ext_int_info_hwc;
+        else if (code == 0x2603) /* pfault_init is done too early too */
+                p = &ext_int_pfault;
         else
                 p = (ext_int_info_t *)
                           kmalloc(sizeof(ext_int_info_t), GFP_ATOMIC);
@@ -70,7 +73,7 @@
                 q->next = p->next;
         else
                 ext_int_hash[index] = p->next;
-        if (code != 0x1004 && code != 0x2401)
+        if (code != 0x1004 && code != 0x2401 && code != 0x2603)
                 kfree(p);
         return 0;
 }
diff -urN linux/arch/s390x/kernel/s390_ksyms.c linux-2.4.7/arch/s390x/kernel/s390_ksyms.c
--- linux/arch/s390x/kernel/s390_ksyms.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/s390_ksyms.c	Mon Dec 17 13:42:41 2001
@@ -18,11 +18,11 @@
 /*
  * memory management
  */
-EXPORT_SYMBOL(_oi_bitmap);
-EXPORT_SYMBOL(_ni_bitmap);
-EXPORT_SYMBOL(_zb_findmap);
-EXPORT_SYMBOL(__copy_from_user_fixup);
-EXPORT_SYMBOL(__copy_to_user_fixup);
+EXPORT_SYMBOL_NOVERS(_oi_bitmap);
+EXPORT_SYMBOL_NOVERS(_ni_bitmap);
+EXPORT_SYMBOL_NOVERS(_zb_findmap);
+EXPORT_SYMBOL_NOVERS(__copy_from_user_fixup);
+EXPORT_SYMBOL_NOVERS(__copy_to_user_fixup);
 
 /*
  * semaphore ops
@@ -41,12 +41,12 @@
 EXPORT_SYMBOL_NOVERS(strlen);
 EXPORT_SYMBOL_NOVERS(strchr);
 EXPORT_SYMBOL_NOVERS(strcmp);
-EXPORT_SYMBOL_NOVERS(strcat);
 EXPORT_SYMBOL_NOVERS(strncat);
 EXPORT_SYMBOL_NOVERS(strncmp);
 EXPORT_SYMBOL_NOVERS(strncpy);
 EXPORT_SYMBOL_NOVERS(strnlen);
 EXPORT_SYMBOL_NOVERS(strrchr);
+EXPORT_SYMBOL_NOVERS(strstr);
 EXPORT_SYMBOL_NOVERS(strtok);
 EXPORT_SYMBOL_NOVERS(strpbrk);
 
@@ -64,8 +64,11 @@
 EXPORT_SYMBOL(machine_flags);
 EXPORT_SYMBOL(__udelay);
 EXPORT_SYMBOL(kernel_thread);
+EXPORT_SYMBOL(console_mode);
+EXPORT_SYMBOL(console_device);
+EXPORT_SYMBOL_NOVERS(do_call_softirq);
 
 #if CONFIG_IP_MULTICAST
-/* Required for lcs gigibit ethernet multicast support */
+/* Required for lcs gigabit ethernet multicast support */
 EXPORT_SYMBOL(arp_mc_map);
 #endif
diff -urN linux/arch/s390x/kernel/setup.c linux-2.4.7/arch/s390x/kernel/setup.c
--- linux/arch/s390x/kernel/setup.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/setup.c	Mon Dec 17 13:42:41 2001
@@ -43,8 +43,13 @@
 /*
  * Machine setup..
  */
+unsigned int console_mode = 0;
+unsigned int console_device = -1;
 unsigned long memory_size = 0;
 unsigned long machine_flags = 0;
+struct { unsigned long addr, size, type; } memory_chunk[16];
+#define CHUNK_READ_WRITE 0
+#define CHUNK_READ_ONLY 1
 __u16 boot_cpu_addr;
 int cpus_initialized = 0;
 unsigned long cpu_initialized = 0;
@@ -141,6 +146,93 @@
 __setup("vmpoff=", vmpoff_setup);
 
 /*
+ * condev= and conmode= setup parameter.
+ */
+
+static int __init condev_setup(char *str)
+{
+	int vdev;
+
+	vdev = simple_strtoul(str, &str, 0);
+	if (vdev >= 0 && vdev < 65536)
+		console_device = vdev;
+	return 1;
+}
+
+__setup("condev=", condev_setup);
+
+static int __init conmode_setup(char *str)
+{
+#if defined(CONFIG_HWC_CONSOLE)
+	if (strncmp(str, "hwc", 4) == 0 && !MACHINE_IS_P390)
+                SET_CONSOLE_HWC;
+#endif
+#if defined(CONFIG_TN3215_CONSOLE)
+	if (strncmp(str, "3215", 5) == 0 && (MACHINE_IS_VM || MACHINE_IS_P390))
+		SET_CONSOLE_3215;
+#endif
+#if defined(CONFIG_TN3270_CONSOLE)
+	if (strncmp(str, "3270", 5) == 0 && (MACHINE_IS_VM || MACHINE_IS_P390))
+		SET_CONSOLE_3270;
+#endif
+        return 1;
+}
+
+__setup("conmode=", conmode_setup);
+
+static void __init conmode_default(void)
+{
+	char query_buffer[1024];
+	char *ptr;
+
+        if (MACHINE_IS_VM) {
+		cpcmd("QUERY TERM", query_buffer, 1024);
+		ptr = strstr(query_buffer, "CONMODE");
+		/*
+		 * Set the conmode to 3215 so that the device recognition 
+		 * will set the cu_type of the console to 3215. If the
+		 * conmode is 3270 and we don't set it back then both
+		 * 3215 and the 3270 driver will try to access the console
+		 * device (3215 as console and 3270 as normal tty).
+		 */
+		cpcmd("TERM CONMODE 3215", NULL, 0);
+		if (ptr == NULL) {
+#if defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+			return;
+		}
+		if (strncmp(ptr + 8, "3270", 4) == 0) {
+#if defined(CONFIG_TN3270_CONSOLE)
+			SET_CONSOLE_3270;
+#elif defined(CONFIG_TN3215_CONSOLE)
+			SET_CONSOLE_3215;
+#elif defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+		} else if (strncmp(ptr + 8, "3215", 4) == 0) {
+#if defined(CONFIG_TN3215_CONSOLE)
+			SET_CONSOLE_3215;
+#elif defined(CONFIG_TN3270_CONSOLE)
+			SET_CONSOLE_3270;
+#elif defined(CONFIG_HWC_CONSOLE)
+			SET_CONSOLE_HWC;
+#endif
+		}
+        } else if (MACHINE_IS_P390) {
+#if defined(CONFIG_TN3215_CONSOLE)
+		SET_CONSOLE_3215;
+#elif defined(CONFIG_TN3270_CONSOLE)
+		SET_CONSOLE_3270;
+#endif
+	} else {
+#if defined(CONFIG_HWC_CONSOLE)
+		SET_CONSOLE_HWC;
+#endif
+	}
+}
+
+/*
  * Reboot, halt and power_off routines for non SMP.
  */
 #ifndef CONFIG_SMP
@@ -168,6 +260,8 @@
  * Setup function called from init/main.c just after the banner
  * was printed.
  */
+extern char _pstart, _pend, _stext;
+
 void __init setup_arch(char **cmdline_p)
 {
         unsigned long bootmap_size;
@@ -177,21 +271,13 @@
 	unsigned long start_pfn, end_pfn;
         static unsigned int smptrap=0;
         unsigned long delay = 0;
-        int len = 0;
+	struct _lowcore *lowcore;
+	int i;
 
         if (smptrap)
                 return;
         smptrap=1;
 
-        printk("Command line is: %s\n", COMMAND_LINE);
-
-        /*
-         * Setup lowcore information for boot cpu
-         */
-        cpu_init();
-        boot_cpu_addr = S390_lowcore.cpu_data.cpu_addr;
-        __cpu_logical_map[0] = boot_cpu_addr;
-
         /*
          * print what head.S has found out about the machine 
          */
@@ -201,7 +287,7 @@
 
         ROOT_DEV = to_kdev_t(0x0100);
         memory_start = (unsigned long) &_end;    /* fixit if use $CODELO etc*/
-	memory_end = memory_size;                /* detected in head.s */
+	memory_end = memory_size & ~0x200000UL;  /* detected in head.s */
         init_mm.start_code = PAGE_OFFSET;
         init_mm.end_code = (unsigned long) &_etext;
         init_mm.end_data = (unsigned long) &_edata;
@@ -221,7 +307,6 @@
                  * "mem=XXX[kKmM]" sets memsize 
                  */
                 if (c == ' ' && strncmp(from, "mem=", 4) == 0) {
-                        if (to != command_line) to--;
                         memory_end = simple_strtoul(from+4, &from, 0);
                         if ( *from == 'K' || *from == 'k' ) {
                                 memory_end = memory_end << 10;
@@ -235,7 +320,6 @@
                  * "ipldelay=XXX[sm]" sets ipl delay in seconds or minutes
                  */
                 if (c == ' ' && strncmp(from, "ipldelay=", 9) == 0) {
-			if (to != command_line) to--;
                         delay = simple_strtoul(from+9, &from, 0);
 			if (*from == 's' || *from == 'S') {
 				delay = delay*1000000;
@@ -244,7 +328,7 @@
 				delay = delay*60*1000000;
 				from++;
 			}
-			/* now wait for the requestion amount of time */
+			/* now wait for the requested amount of time */
 			udelay(delay);
                 }
                 cn = *(from++);
@@ -252,10 +336,12 @@
                         break;
                 if (cn == '\n')
                         cn = ' ';  /* replace newlines with space */
+		if (cn == 0x0d)
+			cn = ' ';  /* replace 0x0d with space */
                 if (cn == ' ' && c == ' ')
                         continue;  /* remove additional spaces */
                 c = cn;
-                if (COMMAND_LINE_SIZE <= ++len)
+                if (to - command_line >= COMMAND_LINE_SIZE)
                         break;
                 *(to++) = c;
         }
@@ -276,11 +362,26 @@
 	bootmap_size = init_bootmem(start_pfn, end_pfn);
 
 	/*
-	 * Register RAM pages with the bootmem allocator.
+	 * Register RAM areas with the bootmem allocator.
 	 */
-	free_bootmem(start_pfn << PAGE_SHIFT, 
-		     (end_pfn - start_pfn) << PAGE_SHIFT);
+	for (i = 0; i < 16 && memory_chunk[i].size > 0; i++) {
+		unsigned long start_chunk, end_chunk;
 
+		if (memory_chunk[i].type != CHUNK_READ_WRITE)
+			continue;
+		start_chunk = (memory_chunk[i].addr + PAGE_SIZE - 1);
+		start_chunk >>= PAGE_SHIFT;
+		end_chunk = (memory_chunk[i].addr + memory_chunk[i].size);
+		end_chunk >>= PAGE_SHIFT;
+		if (start_chunk < start_pfn)
+			start_chunk = start_pfn;
+		if (end_chunk > end_pfn)
+			end_chunk = end_pfn;
+		if (start_chunk < end_chunk)
+			free_bootmem(start_chunk << PAGE_SHIFT,
+				     (end_chunk - start_chunk) << PAGE_SHIFT);
+	}
+	
         /*
          * Reserve the bootmem bitmap itself as well. We do this in two
          * steps (first step was init_bootmem()) because this catches
@@ -304,6 +405,36 @@
         }
 #endif
 
+        /*
+         * Setup lowcore for boot cpu
+         */
+	lowcore = (struct _lowcore *) 
+		__alloc_bootmem(2*PAGE_SIZE, 2*PAGE_SIZE, 0);
+	memset(lowcore, 0, 2*PAGE_SIZE);
+	lowcore->restart_psw.mask = _RESTART_PSW_MASK;
+	lowcore->restart_psw.addr = (addr_t) &restart_int_handler;
+	lowcore->external_new_psw.mask = _EXT_PSW_MASK;
+	lowcore->external_new_psw.addr = (addr_t) &ext_int_handler;
+	lowcore->svc_new_psw.mask = _SVC_PSW_MASK;
+	lowcore->svc_new_psw.addr = (addr_t) &system_call;
+	lowcore->program_new_psw.mask = _PGM_PSW_MASK;
+	lowcore->program_new_psw.addr = (addr_t) &pgm_check_handler;
+	lowcore->mcck_new_psw.mask = _MCCK_PSW_MASK;
+	lowcore->mcck_new_psw.addr = (addr_t) &mcck_int_handler;
+	lowcore->io_new_psw.mask = _IO_PSW_MASK;
+	lowcore->io_new_psw.addr = (addr_t) &io_int_handler;
+	lowcore->ipl_device = S390_lowcore.ipl_device;
+	lowcore->kernel_stack = ((__u32) &init_task_union) + 16384;
+	lowcore->async_stack = (__u64)
+		__alloc_bootmem(4*PAGE_SIZE, 4*PAGE_SIZE, 0) + 16384;
+	set_prefix((__u32)(__u64) lowcore);
+        cpu_init();
+        boot_cpu_addr = S390_lowcore.cpu_data.cpu_addr;
+        __cpu_logical_map[0] = boot_cpu_addr;
+
+	/*
+	 * Create kernel page tables and switch to virtual addressing.
+	 */
         paging_init();
 
 	res = alloc_bootmem_low(sizeof(struct resource));
@@ -313,6 +444,9 @@
 	request_resource(&iomem_resource, res);
 	request_resource(res, &code_resource);
 	request_resource(res, &data_resource);
+
+        /* Setup default console */
+	conmode_default();
 }
 
 void print_cpu_info(struct cpuinfo_S390 *cpuinfo)
diff -urN linux/arch/s390x/kernel/signal.c linux-2.4.7/arch/s390x/kernel/signal.c
--- linux/arch/s390x/kernel/signal.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/signal.c	Mon Dec 17 13:41:19 2001
@@ -27,28 +27,21 @@
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 
-#define DEBUG_SIG 0
-
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-/* pretcode & sig are used to store the return addr on Intel
-   & the signal no as the first parameter we do this differently
-   using gpr14 & gpr2. */
-
-#define SIGFRAME_COMMON \
-__u8     callee_used_stack[__SIGNAL_FRAMESIZE]; \
-struct sigcontext sc; \
-_sigregs sregs; \
-__u8 retcode[S390_SYSCALL_SIZE];
 
 typedef struct 
 {
-	SIGFRAME_COMMON
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE];
+	struct sigcontext sc;
+	_sigregs sregs;
+	__u8 retcode[S390_SYSCALL_SIZE];
 } sigframe;
 
 typedef struct 
 {
-	SIGFRAME_COMMON
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE];
+	__u8 retcode[S390_SYSCALL_SIZE];
 	struct siginfo info;
 	struct ucontext uc;
 } rt_sigframe;
@@ -206,7 +199,7 @@
 	err=__copy_from_user(regs,&sregs->regs,sizeof(_s390_regs_common));
 	if(!err)
 	{
-		regs->orig_gpr2 = -1;		/* disable syscall checks */
+		regs->trap = -1;		/* disable syscall checks */
 		regs->psw.mask=(saved_psw.mask&~PSW_MASK_DEBUGCHANGE)|
 		(regs->psw.mask&PSW_MASK_DEBUGCHANGE);
 		regs->psw.addr=(saved_psw.addr&~PSW_ADDR_DEBUGCHANGE)|
@@ -218,53 +211,51 @@
 	return(err);
 }
 
-static int
-restore_sigcontext(struct sigcontext *sc, struct pt_regs *regs,
-		 _sigregs *sregs,sigset_t *set)
-{
-	unsigned int err;
-
-	err=restore_sigregs(regs,sregs);
-	if(!err)
-		err=__copy_from_user(&set->sig,&sc->oldmask,_SIGMASK_COPY_SIZE);
-		return(err);
-}
-
-int sigreturn_common(struct pt_regs *regs,int framesize)
+asmlinkage long sys_sigreturn(struct pt_regs *regs)
 {
 	sigframe *frame = (sigframe *)regs->gprs[15];
 	sigset_t set;
 
 	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
-		return -1;
-	if (restore_sigcontext(&frame->sc,regs,&frame->sregs,&set))
-	        return -1;
+		goto badframe;
+	if (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE))
+		goto badframe;
+
 	sigdelsetmask(&set, ~_BLOCKABLE);
 	spin_lock_irq(&current->sigmask_lock);
 	current->blocked = set;
 	recalc_sigpending(current);
 	spin_unlock_irq(&current->sigmask_lock);
-	return 0;
-}
 
-asmlinkage long sys_sigreturn(struct pt_regs *regs)
-{
-
-	if (sigreturn_common(regs,sizeof(sigframe)))
+	if (restore_sigregs(regs, &frame->sregs))
 		goto badframe;
+
 	return regs->gprs[2];
 
 badframe:
 	force_sig(SIGSEGV, current);
 	return 0;
-}	
+}
 
 asmlinkage long sys_rt_sigreturn(struct pt_regs *regs)
 {
 	rt_sigframe *frame = (rt_sigframe *)regs->gprs[15];
+	sigset_t set;
 
-	if (sigreturn_common(regs,sizeof(rt_sigframe)))
+	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
 		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sigmask_lock);
+	current->blocked = set;
+	recalc_sigpending(current);
+	spin_unlock_irq(&current->sigmask_lock);
+
+	if (restore_sigregs(regs, &frame->uc.uc_mcontext))
+		goto badframe;
+
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
 	do_sigaltstack(&frame->uc.uc_stack, NULL, regs->gprs[15]);
@@ -273,7 +264,7 @@
 badframe:
 	force_sig(SIGSEGV, current);
 	return 0;
-}	
+}
 
 /*
  * Set up a signal frame.
@@ -307,58 +298,54 @@
 	return (void *)((sp - frame_size) & -8ul);
 }
 
-static void *setup_frame_common(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs,
-				int frame_size,u16 retcode)
+static inline int map_signal(int sig)
 {
-	sigframe *frame;
-	int err;
+	if (current->exec_domain
+	    && current->exec_domain->signal_invmap
+	    && sig < 32)
+		return current->exec_domain->signal_invmap[sig];
+	else
+		return sig;
+}
 
-	frame = get_sigframe(ka, regs,frame_size);
-	if (!access_ok(VERIFY_WRITE, frame,frame_size))
-		return 0;
-	err = save_sigregs(regs,&frame->sregs);
-	if(!err)
-		err=__put_user(&frame->sregs,&frame->sc.sregs);
-	if(!err)
+static void setup_frame(int sig, struct k_sigaction *ka,
+			sigset_t *set, struct pt_regs * regs)
+{
+	sigframe *frame = get_sigframe(ka, regs, sizeof(sigframe));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(sigframe)))
+		goto give_sigsegv;
+
+	if (__copy_to_user(&frame->sc.oldmask, &set->sig, _SIGMASK_COPY_SIZE))
+		goto give_sigsegv;
+
+	if (save_sigregs(regs, &frame->sregs))
+		goto give_sigsegv;
+	if (__put_user(&frame->sregs, &frame->sc.sregs))
+		goto give_sigsegv;
 
-		err=__copy_to_user(&frame->sc.oldmask,&set->sig,_SIGMASK_COPY_SIZE);
-	if(!err)
-	{
-		regs->gprs[2]=(current->exec_domain
-		           && current->exec_domain->signal_invmap
-		           && sig < 32
-		           ? current->exec_domain->signal_invmap[sig]
-		           : sig);
-		/* Set up registers for signal handler */
-		regs->gprs[15] = (addr_t)frame;
-		regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
-	}
 	/* Set up to return from userspace.  If provided, use a stub
 	   already in userspace.  */
 	if (ka->sa.sa_flags & SA_RESTORER) {
                 regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
 	} else {
                 regs->gprs[14] = FIX_PSW(frame->retcode);
-		err |= __put_user(retcode, (u16 *)(frame->retcode));
+		if (__put_user(S390_SYSCALL_OPCODE | __NR_sigreturn, 
+	                       (u16 *)(frame->retcode)))
+			goto give_sigsegv;
 	}
-	return(err ? 0:frame);
-}
 
-static void setup_frame(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs)
-{
-	sigframe *frame;
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK;
 
-	if((frame=setup_frame_common(sig,ka,set,regs,sizeof(sigframe),
-		    (S390_SYSCALL_OPCODE|__NR_sigreturn)))==0)
-		goto give_sigsegv;
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
-	/* Martin wants this for pthreads */
+	regs->gprs[2] = map_signal(sig);
 	regs->gprs[3] = (addr_t)&frame->sc;
+
+	/* We forgot to include these in the sigcontext.
+	   To avoid breaking binary compatibility, they are passed as args. */
+	regs->gprs[4] = current->thread.trap_no;
+	regs->gprs[5] = current->thread.prot_addr;
 	return;
 
 give_sigsegv:
@@ -370,34 +357,44 @@
 static void setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info,
 			   sigset_t *set, struct pt_regs * regs)
 {
-	rt_sigframe *frame;
-	addr_t      orig_sp=regs->gprs[15];
-	int err;
+	int err = 0;
+	rt_sigframe *frame = get_sigframe(ka, regs, sizeof(rt_sigframe));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(rt_sigframe)))
+		goto give_sigsegv;
 
-	if((frame=setup_frame_common(sig,ka,set,regs,sizeof(rt_sigframe),
-		    (S390_SYSCALL_OPCODE|__NR_rt_sigreturn)))==0)
+	if (copy_siginfo_to_user(&frame->info, info))
 		goto give_sigsegv;
-	
-	err = copy_siginfo_to_user(&frame->info, info);
 
 	/* Create the ucontext.  */
 	err |= __put_user(0, &frame->uc.uc_flags);
 	err |= __put_user(0, &frame->uc.uc_link);
 	err |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
-	err |= __put_user(sas_ss_flags(orig_sp),
+	err |= __put_user(sas_ss_flags(regs->gprs[15]),
 			  &frame->uc.uc_stack.ss_flags);
 	err |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);
-	err |= __put_user(&frame->sc,&frame->uc.sc);
-	regs->gprs[3] = (addr_t)&frame->info;
-	regs->gprs[4] = (addr_t)&frame->uc;
-
+	err |= save_sigregs(regs, &frame->uc.uc_mcontext);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 	if (err)
 		goto give_sigsegv;
 
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
+	/* Set up to return from userspace.  If provided, use a stub
+	   already in userspace.  */
+	if (ka->sa.sa_flags & SA_RESTORER) {
+                regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
+	} else {
+                regs->gprs[14] = FIX_PSW(frame->retcode);
+		err |= __put_user(S390_SYSCALL_OPCODE | __NR_rt_sigreturn, 
+	                          (u16 *)(frame->retcode));
+	}
+
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK;
+
+	regs->gprs[2] = map_signal(sig);
+	regs->gprs[3] = (addr_t)&frame->info;
+	regs->gprs[4] = (addr_t)&frame->uc;
 	return;
 
 give_sigsegv:
@@ -415,7 +412,7 @@
 	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
 {
 	/* Are we from a system call? */
-	if (regs->orig_gpr2 >= 0) {
+	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
 		switch (regs->gprs[2]) {
 			case -ERESTARTNOHAND:
@@ -568,7 +565,6 @@
                                 /* FALLTHRU */
 
 			default:
-				lock_kernel();
 				sigaddset(&current->pending.signal, signr);
 				recalc_sigpending(current);
 				current->flags |= PF_SIGNALED;
diff -urN linux/arch/s390x/kernel/signal32.c linux-2.4.7/arch/s390x/kernel/signal32.c
--- linux/arch/s390x/kernel/signal32.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/kernel/signal32.c	Mon Dec 17 13:41:49 2001
@@ -11,6 +11,7 @@
  *  1997-11-28  Modified for POSIX.1b signals by Richard Henderson
  */
 
+#include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
@@ -26,28 +27,22 @@
 #include <asm/uaccess.h>
 #include "linux32.h"
 
-#define DEBUG_SIG 0
-
 #define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
 
-/* pretcode & sig are used to store the return addr on Intel
-   & the signal no as the first parameter we do this differently
-   using gpr14 & gpr2. */
-
-#define SIGFRAME_COMMON32 \
-__u8     callee_used_stack[__SIGNAL_FRAMESIZE32]; \
-struct sigcontext32 sc; \
-_sigregs32 sregs; \
-__u8 retcode[S390_SYSCALL_SIZE];
+#define _USER_PSW_MASK32 0x0701C00080000000
 
 typedef struct 
 {
-	SIGFRAME_COMMON32
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE32];
+	struct sigcontext32 sc;
+	_sigregs32 sregs;
+	__u8 retcode[S390_SYSCALL_SIZE];
 } sigframe32;
 
 typedef struct 
 {
-	SIGFRAME_COMMON32
+	__u8 callee_used_stack[__SIGNAL_FRAMESIZE32];
+	__u8 retcode[S390_SYSCALL_SIZE];
 	struct siginfo32 info;
 	struct ucontext32 uc;
 } rt_sigframe32;
@@ -328,7 +323,7 @@
 
 	if(!err)
 	{
-		regs->orig_gpr2 = -1;		/* disable syscall checks */
+		regs->trap = -1;		/* disable syscall checks */
 		regs->psw.mask=(saved_psw.mask&~PSW_MASK_DEBUGCHANGE)|
 		(regs->psw.mask&PSW_MASK_DEBUGCHANGE);
 		regs->psw.addr=(saved_psw.addr&~PSW_ADDR_DEBUGCHANGE)|
@@ -342,40 +337,25 @@
 	return(err);
 }
 
-static int
-restore_sigcontext32(struct sigcontext32 *sc, struct pt_regs *regs,
-		 _sigregs32 *sregs,sigset_t *set)
-{
-	unsigned int err;
-
-	err=restore_sigregs32(regs,sregs);
-	if(!err)
-		err=__copy_from_user(&set->sig,&sc->oldmask,_SIGMASK_COPY_SIZE32);
-	return(err);
-}
-
-int sigreturn_common32(struct pt_regs *regs)
+asmlinkage long sys32_sigreturn(struct pt_regs *regs)
 {
 	sigframe32 *frame = (sigframe32 *)regs->gprs[15];
 	sigset_t set;
 
 	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
-		return -1;
-	if (restore_sigcontext32(&frame->sc,regs,&frame->sregs,&set))
-	        return -1;
+		goto badframe;
+	if (__copy_from_user(&set.sig, &frame->sc.oldmask, _SIGMASK_COPY_SIZE32))
+		goto badframe;
+
 	sigdelsetmask(&set, ~_BLOCKABLE);
 	spin_lock_irq(&current->sigmask_lock);
 	current->blocked = set;
 	recalc_sigpending(current);
 	spin_unlock_irq(&current->sigmask_lock);
-	return 0;
-}
 
-asmlinkage long sys32_sigreturn(struct pt_regs *regs)
-{
-
-	if (sigreturn_common32(regs))
+	if (restore_sigregs32(regs, &frame->sregs))
 		goto badframe;
+
 	return regs->gprs[2];
 
 badframe:
@@ -386,11 +366,23 @@
 asmlinkage long sys32_rt_sigreturn(struct pt_regs *regs)
 {
 	rt_sigframe32 *frame = (rt_sigframe32 *)regs->gprs[15];
+	sigset_t set;
 	stack_t st;
 	int err;
 	mm_segment_t old_fs = get_fs();
 
-	if (sigreturn_common32(regs))
+	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sigmask_lock);
+	current->blocked = set;
+	recalc_sigpending(current);
+	spin_unlock_irq(&current->sigmask_lock);
+
+	if (restore_sigregs32(regs, &frame->uc.uc_mcontext))
 		goto badframe;
 
 	err = __get_user(st.ss_sp, &frame->uc.uc_stack.ss_sp);
@@ -399,17 +391,18 @@
 	err |= __get_user(st.ss_flags, &frame->uc.uc_stack.ss_flags);
 	if (err)
 		goto badframe; 
-	set_fs (KERNEL_DS);   
+
 	/* It is more difficult to avoid calling this function than to
 	   call it and ignore errors.  */
+	set_fs (KERNEL_DS);   
 	do_sigaltstack(&st, NULL, regs->gprs[15]);
 	set_fs (old_fs);
 
 	return regs->gprs[2];
 
 badframe:
-	force_sig(SIGSEGV, current);
-	return 0;
+        force_sig(SIGSEGV, current);
+        return 0;
 }	
 
 /*
@@ -444,58 +437,54 @@
 	return (void *)((sp - frame_size) & -8ul);
 }
 
-static void *setup_frame_common32(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs,
-				int frame_size,u16 retcode)
+static inline int map_signal(int sig)
 {
-	sigframe32 *frame;
-	int err;
+	if (current->exec_domain
+	    && current->exec_domain->signal_invmap
+	    && sig < 32)
+		return current->exec_domain->signal_invmap[sig];
+        else
+		return sig;
+}
 
-	frame = get_sigframe(ka, regs,frame_size);
-	if (!access_ok(VERIFY_WRITE, frame,frame_size))
-		return 0;
-	err = save_sigregs32(regs,&frame->sregs);
-	if(!err)
-		err=__put_user(&frame->sregs,&frame->sc.sregs);
-	if(!err)
+static void setup_frame32(int sig, struct k_sigaction *ka,
+			sigset_t *set, struct pt_regs * regs)
+{
+	sigframe32 *frame = get_sigframe(ka, regs, sizeof(sigframe32));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(sigframe32)))
+		goto give_sigsegv;
+
+	if (__copy_to_user(&frame->sc.oldmask, &set->sig, _SIGMASK_COPY_SIZE32))
+		goto give_sigsegv;
+
+	if (save_sigregs32(regs, &frame->sregs))
+		goto give_sigsegv;
+	if (__put_user(&frame->sregs, &frame->sc.sregs))
+		goto give_sigsegv;
 
-		err=__copy_to_user(&frame->sc.oldmask,&set->sig,_SIGMASK_COPY_SIZE32);
-	if(!err)
-	{
-		regs->gprs[2]=(current->exec_domain
-		           && current->exec_domain->signal_invmap
-		           && sig < 32
-		           ? current->exec_domain->signal_invmap[sig]
-		           : sig);
-		/* Set up registers for signal handler */
-		regs->gprs[15] = (addr_t)frame;
-		regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
-	}
 	/* Set up to return from userspace.  If provided, use a stub
 	   already in userspace.  */
 	if (ka->sa.sa_flags & SA_RESTORER) {
-                regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
+		regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
 	} else {
-                regs->gprs[14] = FIX_PSW(frame->retcode);
-		err |= __put_user(retcode, (u16 *)(frame->retcode));
-	}
-	return(err ? 0:frame);
-}
+		regs->gprs[14] = FIX_PSW(frame->retcode);
+		if (__put_user(S390_SYSCALL_OPCODE | __NR_sigreturn,
+		               (u16 *)(frame->retcode)))
+			goto give_sigsegv;
+        }
 
-static void setup_frame32(int sig, struct k_sigaction *ka,
-			sigset_t *set, struct pt_regs * regs)
-{
-	sigframe32 *frame;
-         
-	if((frame=setup_frame_common32(sig,ka,set,regs,sizeof(sigframe32),
-		    (S390_SYSCALL_OPCODE|__NR_sigreturn)))==0)
-		goto give_sigsegv;
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
-	 /* Martin wants this for pthreads */
-	regs->gprs[3] = (addr_t)&frame->sc;   
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK32;
+
+	regs->gprs[2] = map_signal(sig);
+	regs->gprs[3] = (addr_t)&frame->sc;
+
+	/* We forgot to include these in the sigcontext.
+	   To avoid breaking binary compatibility, they are passed as args. */
+	regs->gprs[4] = current->thread.trap_no;
+	regs->gprs[5] = current->thread.prot_addr;
 	return;
 
 give_sigsegv:
@@ -507,33 +496,44 @@
 static void setup_rt_frame32(int sig, struct k_sigaction *ka, siginfo_t *info,
 			   sigset_t *set, struct pt_regs * regs)
 {
-	rt_sigframe32 *frame;
-	addr_t      orig_sp=regs->gprs[15];
-	int err;
+	int err = 0;
+	rt_sigframe32 *frame = get_sigframe(ka, regs, sizeof(rt_sigframe32));
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(rt_sigframe32)))
+		goto give_sigsegv;
 
-	if((frame=setup_frame_common32(sig,ka,set,regs,sizeof(rt_sigframe32),
-		    (S390_SYSCALL_OPCODE|__NR_rt_sigreturn)))==0)
+	if (copy_siginfo_to_user32(&frame->info, info))
 		goto give_sigsegv;
-	
-	err = copy_siginfo_to_user32(&frame->info, info);
 
 	/* Create the ucontext.  */
 	err |= __put_user(0, &frame->uc.uc_flags);
 	err |= __put_user(0, &frame->uc.uc_link);
 	err |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
-	err |= __put_user(sas_ss_flags(orig_sp),
-			  &frame->uc.uc_stack.ss_flags);
+	err |= __put_user(sas_ss_flags(regs->gprs[15]),
+	                  &frame->uc.uc_stack.ss_flags);
 	err |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);
-	regs->gprs[3] = (addr_t)&frame->info;
-	regs->gprs[4] = (addr_t)&frame->uc;
-
+	err |= save_sigregs32(regs, &frame->uc.uc_mcontext);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
 	if (err)
 		goto give_sigsegv;
 
-#if DEBUG_SIG
-	printk("SIG deliver (%s:%d): sp=%p pc=%p ra=%p\n",
-		current->comm, current->pid, frame, regs->eip, frame->pretcode);
-#endif
+	/* Set up to return from userspace.  If provided, use a stub
+	   already in userspace.  */
+	if (ka->sa.sa_flags & SA_RESTORER) {
+		regs->gprs[14] = FIX_PSW(ka->sa.sa_restorer);
+	} else {
+		regs->gprs[14] = FIX_PSW(frame->retcode);
+		err |= __put_user(S390_SYSCALL_OPCODE | __NR_rt_sigreturn,
+		                  (u16 *)(frame->retcode));
+	}
+
+	/* Set up registers for signal handler */
+	regs->gprs[15] = (addr_t)frame;
+	regs->psw.addr = FIX_PSW(ka->sa.sa_handler);
+	regs->psw.mask = _USER_PSW_MASK32;
+
+	regs->gprs[2] = map_signal(sig);
+	regs->gprs[3] = (addr_t)&frame->info;
+	regs->gprs[4] = (addr_t)&frame->uc;
 	return;
 
 give_sigsegv:
@@ -551,7 +551,7 @@
 	      siginfo_t *info, sigset_t *oldset, struct pt_regs * regs)
 {
 	/* Are we from a system call? */
-	if (regs->orig_gpr2 >= 0) {
+	if (regs->trap == __LC_SVC_OLD_PSW) {
 		/* If so, check system call restarting.. */
 		switch (regs->gprs[2]) {
 			case -ERESTARTNOHAND:
@@ -692,12 +692,12 @@
 
 			case SIGQUIT: case SIGILL: case SIGTRAP:
 			case SIGABRT: case SIGFPE: case SIGSEGV:
+			case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
                                 if (do_coredump(signr, regs))
                                         exit_code |= 0x80;
                                 /* FALLTHRU */
 
 			default:
-				lock_kernel();
 				sigaddset(&current->pending.signal, signr);
 				recalc_sigpending(current);
 				current->flags |= PF_SIGNALED;
@@ -712,7 +712,7 @@
 	}
 
 	/* Did we come from a system call? */
-	if ( regs->trap ==  __LC_SVC_OLD_PSW /* System Call! */ ) {
+	if ( regs->trap == __LC_SVC_OLD_PSW /* System Call! */ ) {
 		/* Restart the system call - no handlers present */
 		if (regs->gprs[2] == -ERESTARTNOHAND ||
 		    regs->gprs[2] == -ERESTARTSYS ||
diff -urN linux/arch/s390x/kernel/smp.c linux-2.4.7/arch/s390x/kernel/smp.c
--- linux/arch/s390x/kernel/smp.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/kernel/smp.c	Mon Dec 17 13:42:41 2001
@@ -92,6 +92,95 @@
 
 extern void reipl(unsigned long devno);
 
+static sigp_ccode smp_ext_bitcall(int, ec_bit_sig);
+static void smp_ext_bitcall_others(ec_bit_sig);
+
+/*
+ * Structure and data for smp_call_function(). This is designed to minimise
+ * static memory requirements. It also looks cleaner.
+ */
+static spinlock_t call_lock = SPIN_LOCK_UNLOCKED;
+
+struct call_data_struct {
+	void (*func) (void *info);
+	void *info;
+	atomic_t started;
+	atomic_t finished;
+	int wait;
+};
+
+static struct call_data_struct * call_data;
+
+/*
+ * 'Call function' interrupt callback
+ */
+static void do_call_function(void)
+{
+	void (*func) (void *info) = call_data->func;
+	void *info = call_data->info;
+	int wait = call_data->wait;
+
+	atomic_inc(&call_data->started);
+	(*func)(info);
+	if (wait)
+		atomic_inc(&call_data->finished);
+}
+
+/*
+ * this function sends a 'generic call function' IPI to all other CPUs
+ * in the system.
+ */
+
+int smp_call_function (void (*func) (void *info), void *info, int nonatomic,
+			int wait)
+/*
+ * [SUMMARY] Run a function on all other CPUs.
+ * <func> The function to run. This must be fast and non-blocking.
+ * <info> An arbitrary pointer to pass to the function.
+ * <nonatomic> currently unused.
+ * <wait> If true, wait (atomically) until function has completed on other CPUs.
+ * [RETURNS] 0 on success, else a negative status code. Does not return until
+ * remote CPUs are nearly ready to execute <<func>> or are or have executed.
+ *
+ * You must not call this function with disabled interrupts or from a
+ * hardware interrupt handler, you may call it from a bottom half handler.
+ */
+{
+	struct call_data_struct data;
+	int cpus = smp_num_cpus-1;
+
+	if (!cpus || !atomic_read(&smp_commenced))
+		return 0;
+
+	data.func = func;
+	data.info = info;
+	atomic_set(&data.started, 0);
+	data.wait = wait;
+	if (wait)
+		atomic_set(&data.finished, 0);
+
+	spin_lock_bh(&call_lock);
+	call_data = &data;
+	/* Send a message to all other CPUs and wait for them to respond */
+        smp_ext_bitcall_others(ec_call_function);
+
+	/* Wait for response */
+	while (atomic_read(&data.started) != cpus)
+		barrier();
+
+	if (wait)
+		while (atomic_read(&data.finished) != cpus)
+			barrier();
+	spin_unlock_bh(&call_lock);
+
+	return 0;
+}
+
+
+/*
+ * Various special callbacks
+ */
+
 void do_machine_restart(void)
 {
         smp_send_stop();
@@ -148,7 +237,6 @@
 
 void do_ext_call_interrupt(struct pt_regs *regs, __u16 code)
 {
-        ec_ext_call *ec, *next;
         unsigned long bits;
 
         /*
@@ -167,138 +255,15 @@
 		do_machine_halt();
         if (test_bit(ec_power_off, &bits))
 		do_machine_power_off();
-
-        /*
-         * Handle external call commands with a parameter area
-         */
-	ec = (ec_ext_call *) xchg(&S390_lowcore.ext_call_queue, 0);
-        if (ec == NULL)
-                return;   /* no command signals */
-
-        /* Make a fifo out of the lifo */
-        next = ec->next;
-        ec->next = NULL;
-        while (next != NULL) {
-                ec_ext_call *tmp = next->next;
-                next->next = ec;
-                ec = next;
-                next = tmp;
-        }
-
-        /* Execute every sigp command on the queue */
-        while (ec != NULL) {
-                switch (ec->cmd) {
-                case ec_callback_async: {
-                        void (*func)(void *info);
-                        void *info;
-
-                        func = ec->func;
-                        info = ec->info;
-                        atomic_set(&ec->status,ec_executing);
-                        (func)(info);
-                        return;
-                }
-                case ec_callback_sync:
-                        atomic_set(&ec->status,ec_executing);
-                        (ec->func)(ec->info);
-                        atomic_set(&ec->status,ec_done);
-                        return;
-                default:
-                }
-                ec = ec->next;
-        }
-}
-
-/*
- * Swap in a new request to external call queue 
- */
-static inline void smp_add_ext_call(ec_ext_call *ec, struct _lowcore *lowcore)
-{
-	int success;
-
-	while (1) {
-		ec->next = (ec_ext_call*) lowcore->ext_call_queue;
-		__asm__ __volatile__ (
-                        "   lgr 0,%2\n"
-			"   csg 0,%3,%1\n"
-			"   ipm %0\n"
-			"   srl %0,28\n"
-			: "=d" (success), "+m" (lowcore->ext_call_queue)
-			: "d" (ec->next), "d" (ec)
-			: "cc", "0" );
-		if (success == 0) break;
-	}
-}
-
-/*
- * Send an external call sigp to another cpu and wait for its completion.
- */
-sigp_ccode
-smp_ext_call(int cpu, void (*func)(void *info), void *info, int wait)
-{
-        sigp_ccode ccode;
-        ec_ext_call ec;
-
-        ec.cmd = wait ? ec_callback_sync:ec_callback_async;
-        atomic_set(&ec.status, ec_pending);
-        ec.func = func;
-	ec.info = info;
-	/* swap in new request to external call queue */
-	smp_add_ext_call(&ec, &get_cpu_lowcore(cpu));
-        /*
-         * We try once to deliver the signal. There are four possible
-         * return codes:
-         * 0) Order code accepted - can't show up on an external call
-         * 1) Status stored - fine, wait for completion.
-         * 2) Busy - there is another signal pending. Thats fine too, because
-         *    do_ext_call from the pending signal will execute all signals on
-         *    the queue. We wait for completion.
-         * 3) Not operational - something very bad has happened to the cpu.
-         *    do not wait for completion.
-         */
-        ccode = signal_processor(cpu, sigp_external_call);
-
-        if (ccode != sigp_not_operational)
-                /* wait for completion, FIXME: possible seed of a deadlock */
-                while (atomic_read(&ec.status) != (wait?ec_done:ec_executing));
-
-        return ccode;
-}
-
-/*
- * Send a callback sigp to every other cpu in the system.
- */
-void smp_ext_call_others(void (*func)(void *info), void *info, int wait)
-{
-        ec_ext_call ec[NR_CPUS];
-        sigp_ccode ccode;
-        int i;
-
-        for (i = 0; i < smp_num_cpus; i++) {
-                if (smp_processor_id() == i)
-                        continue;
-		ec[i].cmd = wait ? ec_callback_sync : ec_callback_async;
-		atomic_set(&ec[i].status, ec_pending);
-		ec[i].func = func;
-		ec[i].info = info;
-		smp_add_ext_call(ec+i, &get_cpu_lowcore(i));
-                ccode = signal_processor(i, sigp_external_call);
-        }
-
-        /* wait for completion, FIXME: possible seed of a deadlock */
-        for (i = 0; i < smp_num_cpus; i++) {
-                if (smp_processor_id() == i)
-                        continue;
-                while (atomic_read(&ec[i].status) != 
-		       (wait ? ec_done:ec_executing));
-        }
+        if (test_bit(ec_call_function, &bits))
+		do_call_function();
 }
 
 /*
  * Send an external call sigp to another cpu and return without waiting
  * for its completion.
  */
-sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig)
+static sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig)
 {
         sigp_ccode ccode;
 
@@ -314,7 +279,7 @@
  * Send an external call sigp to every other cpu in the system and
  * return without waiting for its completion.
  */
-void smp_ext_bitcall_others(ec_bit_sig sig)
+static void smp_ext_bitcall_others(ec_bit_sig sig)
 {
         sigp_ccode ccode;
         int i;
@@ -331,51 +296,6 @@
 }
 
 /*
- * cycles through all the cpus,
- * returns early if info is not NULL & the processor has something
- * of intrest to report in the info structure.
- * it returns the next cpu to check if it returns early.
- * i.e. it should be used as follows if you wish to receive info.
- * next_cpu=0;
- * do
- * {
- *    info->cpu=next_cpu;
- *    next_cpu=smp_signal_others(order_code,parameter,1,info);
- *    ... check info here
- * } while(next_cpu<=smp_num_cpus)
- *
- *  if you are lazy just use it like
- * smp_signal_others(order_code,parameter,0,1,NULL);
- */
-int smp_signal_others(sigp_order_code order_code, u32 parameter,
-                      int spin, sigp_info *info)
-{
-        sigp_ccode   ccode;
-        u32          dummy;
-        u16          i;
-
-        if (info)
-                info->intresting = 0;
-        for (i = (info ? info->cpu : 0); i < smp_num_cpus; i++) {
-                if (smp_processor_id() != i) {
-                        do {
-                                ccode = signal_processor_ps(
-                                        (info ? &info->status : &dummy),
-                                        parameter, i, order_code);
-                        } while(spin && ccode == sigp_busy);
-                        if (info && ccode != sigp_order_code_accepted) {
-                                info->intresting = 1;
-                                info->cpu = i;
-                                info->ccode = ccode;
-                                i++;
-                                break;
-                        }
-                }
-        }
-        return i;
-}
-
-/*
  * this function sends a 'stop' sigp to all other CPUs in the system.
  * it goes straight through.
  */
@@ -392,7 +312,18 @@
 
         /* stop all processors */
 
-        smp_signal_others(sigp_stop, 0, 1, NULL);
+        for (i =  0; i < smp_num_cpus; i++) {
+                if (smp_processor_id() != i) {
+                        int ccode;
+                        do {
+                                ccode = signal_processor_ps(
+                                   &dummy,
+                                   0,
+                                   i,
+                                   sigp_stop);
+                        } while(ccode == sigp_busy);
+                }
+        }
 
         /* store status of all processors in their lowcores (real 0) */
 
@@ -469,7 +400,7 @@
                 parms.end_ctl = cr;
                 parms.orvals[cr] = 1 << bit;
                 parms.andvals[cr] = -1L;
-                smp_ext_call_others(smp_ctl_bit_callback, &parms, 1);
+                smp_call_function(smp_ctl_bit_callback, &parms, 0, 1);
         }
         __ctl_set_bit(cr, bit);
 }
@@ -485,34 +416,11 @@
                 parms.end_ctl = cr;
                 parms.orvals[cr] = 0;
                 parms.andvals[cr] = ~(1L << bit);
-                smp_ext_call_others(smp_ctl_bit_callback, &parms, 1);
+                smp_call_function(smp_ctl_bit_callback, &parms, 0, 1);
         }
         __ctl_clear_bit(cr, bit);
 }
 
-/*
- * Call a function on all other processors
- */
-
-int
-smp_call_function(void (*func)(void *info), void *info, int retry, int wait)
-/*
- * [SUMMARY] Run a function on all other CPUs.
- * <func> The function to run. This must be fast and non-blocking.
- * <info> An arbitrary pointer to pass to the function.
- * <retry> currently unused.
- * <wait> If true, wait (atomically) until function has completed on other CPUs.
- * [RETURNS] 0 on success, else a negative status code. Does not return until
- * remote CPUs are nearly ready to execute <<func>> or are or have executed.
- *
- * You must not call this function with disabled interrupts or from a
- * hardware interrupt handler, you may call it from a bottom half handler.
- */
-{
-        if (atomic_read(&smp_commenced) != 0)
-                smp_ext_call_others(func, info, wait);
-        return 0;
-}
 
 /*
  * Lets check how many CPUs we have.
@@ -543,6 +451,7 @@
  *      Activate a secondary processor.
  */
 extern void init_100hz_timer(void);
+extern int pfault_init(void);
 
 int __init start_secondary(void *cpuvoid)
 {
@@ -555,6 +464,10 @@
                 /* nothing */ ;
         /* init per CPU 100 hz timer */
         init_100hz_timer();
+#ifdef CONFIG_PFAULT
+	/* Enable pfault pseudo page faults on this cpu. */
+	pfault_init();
+#endif
         /* cpu_idle will call schedule for us */
         return cpu_idle(NULL);
 }
@@ -602,12 +515,15 @@
         init_tasks[cpu] = idle;
 
         cpu_lowcore=&get_cpu_lowcore(cpu);
-        cpu_lowcore->kernel_stack=idle->thread.ksp;
-        __asm__ __volatile__("stctg 0,15,%0\n\t"
-                             "stam  0,15,%1"
+	cpu_lowcore->save_area[15] = idle->thread.ksp;
+	cpu_lowcore->kernel_stack = (idle->thread.ksp | 16383) + 1;
+        __asm__ __volatile__("la    1,%0\n\t"
+			     "stctg 0,15,0(1)\n\t"
+			     "la    1,%1\n\t"
+                             "stam  0,15,0(1)"
                              : "=m" (cpu_lowcore->cregs_save_area[0]),
                                "=m" (cpu_lowcore->access_regs_save_area[0])
-                             : : "memory");
+                             : : "1", "memory");
 
         eieio();
         signal_processor(cpu,sigp_restart);
@@ -638,6 +554,7 @@
 void __init smp_boot_cpus(void)
 {
         struct _lowcore *curr_lowcore;
+	unsigned long async_stack;
         sigp_ccode   ccode;
         int i;
 
@@ -668,8 +585,16 @@
                         printk("smp_boot_cpus failed to allocate prefix memory\n");
                         break;
                 }
+		async_stack = __get_free_pages(GFP_KERNEL,2);
+		if (async_stack == 0) {
+			printk("smp_boot_cpus failed to allocate asyncronous"
+			       " interrupt stack\n");
+			free_page((unsigned long) curr_lowcore);
+			break;
+		}
                 lowcore_ptr[i] = curr_lowcore;
                 memcpy(curr_lowcore, &S390_lowcore, sizeof(struct _lowcore));
+		curr_lowcore->async_stack = async_stack + (4 * PAGE_SIZE);
                 /*
                  * Most of the parameters are set up when the cpu is
                  * started up.
@@ -728,8 +653,6 @@
                 s390_do_profile(regs->psw.addr);
 
         if (!--prof_counter[cpu]) {
-                int system = 1-user;
-                struct task_struct * p = current;
 
                 /*
                  * The multiplier may have changed since the last time we got
@@ -751,9 +674,7 @@
                  * WrongThing (tm) to do.
                  */
 
-                irq_enter(cpu, 0);
 		update_process_times(user);
-                irq_exit(cpu, 0);
         }
 }
 
diff -urN linux/arch/s390x/kernel/time.c linux-2.4.7/arch/s390x/kernel/time.c
--- linux/arch/s390x/kernel/time.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/time.c	Mon Dec 17 13:42:41 2001
@@ -101,9 +101,10 @@
 {
 	unsigned long flags;
 	unsigned long usec, sec;
-	unsigned long lost_ticks = jiffies - wall_jiffies;
+	unsigned long lost_ticks;
 
 	read_lock_irqsave(&xtime_lock, flags);
+	lost_ticks = jiffies - wall_jiffies;
 	usec = do_gettimeoffset();
 	if (lost_ticks)
 		usec +=(USECS_PER_JIFFY*lost_ticks);
@@ -154,17 +155,16 @@
 extern __u16 boot_cpu_addr;
 #endif
 
-void do_timer_interrupt(struct pt_regs *regs,int error_code)
+void do_timer_interrupt(struct pt_regs *regs, __u16 error_code)
 {
-        unsigned long flags;
+	int cpu = smp_processor_id();
+
+	irq_enter(cpu, 0);
 
         /*
          * reset timer to 10ms minus time already elapsed
          * since timer-interrupt pending
          */
- 
-        save_flags(flags);
-        cli();
 #ifdef CONFIG_SMP
 	if(S390_lowcore.cpu_data.cpu_addr==boot_cpu_addr) {
 		write_lock(&xtime_lock);
@@ -200,8 +200,8 @@
 		write_unlock(&xtime_lock);
 #endif
 	}
-        restore_flags(flags);
 
+	irq_exit(cpu, 0);
 }
 
 /*
@@ -255,4 +255,7 @@
         init_timer_cc -= 0x8126d60e46000000LL -
                          (0x3c26700LL*1000000*4096);
         tod_to_timeval(init_timer_cc, &xtime);
+
+	/* Set do_get_fast_time function pointer.  */
+	do_get_fast_time = do_gettimeofday;
 }
diff -urN linux/arch/s390x/kernel/traps.c linux-2.4.7/arch/s390x/kernel/traps.c
--- linux/arch/s390x/kernel/traps.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/traps.c	Mon Dec 17 13:42:41 2001
@@ -31,10 +31,11 @@
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/atomic.h>
-#include <asm/mathemu.h>
 #if CONFIG_REMOTE_DEBUG
 #include <asm/gdb-stub.h>
 #endif
+#include <asm/cpcmd.h>
+#include <asm/s390_ext.h>
 
 /* Called from entry.S only */
 extern void handle_per_exception(struct pt_regs *regs);
@@ -51,6 +52,11 @@
 #endif
 
 extern pgm_check_handler_t do_page_fault;
+#ifdef CONFIG_PFAULT
+extern int pfault_init(void);
+extern void pfault_fini(void);
+extern void pfault_interrupt(struct pt_regs *regs, __u16 error_code);
+#endif
 
 spinlock_t die_lock;
 
@@ -84,6 +90,13 @@
 static void inline do_trap(long interruption_code, int signr, char *str,
                            struct pt_regs *regs, siginfo_t *info)
 {
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
         if (regs->psw.mask & PSW_PROBLEM_STATE) {
                 struct task_struct *tsk = current;
                 tsk->thread.trap_no = interruption_code;
@@ -152,8 +165,15 @@
 	__u16 *location;
 	int do_sig = 0;
 
-        lock_kernel();
 	location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
 	/* WARNING don't change this check back to */
 	/* int problem_state=(regs->psw.mask & PSW_PROBLEM_STATE); */
 	/* & then doing if(problem_state) an int is too small for this */
@@ -171,7 +191,6 @@
 		do_sig = 1;
 	if (do_sig)
 		do_trap(interruption_code, SIGILL, "illegal operation", regs, NULL);
-        unlock_kernel();
 }
 
 asmlinkage void data_exception(struct pt_regs * regs, long interruption_code)
@@ -179,8 +198,15 @@
 	__u16 *location;
 	int do_sig = 0;
 
-        lock_kernel();
 	location = (__u16 *)(regs->psw.addr-S390_lowcore.pgm_ilc);
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
 	__asm__ volatile ("stfpc %0\n\t" 
 			  : "=m" (current->thread.fp_regs.fpc));
 	/* Same code should work when we implement fpu emulation */
@@ -194,7 +220,6 @@
 		do_sig = 1;
         if (do_sig)
                 do_trap(interruption_code, SIGILL, "data exception", regs, NULL);
-        unlock_kernel();
 }
 
 
@@ -223,6 +248,21 @@
         pgm_check_table[0x1C] = &privileged_op;
         pgm_check_table[0x38] = &addressing_exception;
         pgm_check_table[0x3B] = &do_page_fault;
+#ifdef CONFIG_PFAULT
+	if (MACHINE_IS_VM) {
+		/* request the 0x2603 external interrupt */
+		if (register_external_interrupt(0x2603, pfault_interrupt) != 0)
+			panic("Couldn't request external interrupt 0x2603");
+		/*
+		 * Try to get pfault pseudo page faults going.
+		 */
+		if (pfault_init() != 0) {
+			/* Tough luck, no pfault. */
+			unregister_external_interrupt(0x2603,
+						      pfault_interrupt);
+		}
+	}
+#endif
 }
 
 
diff -urN linux/arch/s390x/kernel/wrapper32.S linux-2.4.7/arch/s390x/kernel/wrapper32.S
--- linux/arch/s390x/kernel/wrapper32.S	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/kernel/wrapper32.S	Mon Dec 17 13:42:47 2001
@@ -629,8 +629,10 @@
 	.globl  sys32_llseek_wrapper 
 sys32_llseek_wrapper:
 	llgfr	%r2,%r2			# unsigned int
-	lgfr	%r3,%r3			# off_t
-	llgfr	%r4,%r4			# unsigned int
+	llgfr	%r3,%r3			# unsigned long
+	llgfr	%r4,%r4			# unsigned long
+	llgtr	%r5,%r5			# loff_t *
+	llgfr	%r6,%r6			# unsigned int
 	jg	sys_llseek		# branch to system call
 
 	.globl  sys32_getdents_wrapper 
@@ -1069,3 +1071,23 @@
 	llgfr	%r4,%r4			# unsigned long
 	jg	sys32_fcntl64		# branch to system call
 
+	.globl	sys32_stat64_wrapper
+sys32_stat64_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# struct stat64 *
+	llgfr	%r4,%r4			# long
+	jg	sys32_stat64		# branch to system call
+
+	.globl	sys32_lstat64_wrapper
+sys32_lstat64_wrapper:
+	llgtr	%r2,%r2			# char *
+	llgtr	%r3,%r3			# struct stat64 *
+	llgfr	%r4,%r4			# long
+	jg	sys32_lstat64		# branch to system call
+
+	.globl	sys32_fstat64_wrapper
+sys32_fstat64_wrapper:
+	llgfr	%r2,%r2			# unsigned long
+	llgtr	%r3,%r3			# struct stat64 *
+	llgfr	%r4,%r4			# long
+	jg	sys32_fstat64		# branch to system call
diff -urN linux/arch/s390x/mm/extable.c linux-2.4.7/arch/s390x/mm/extable.c
--- linux/arch/s390x/mm/extable.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/mm/extable.c	Mon Dec 17 13:41:49 2001
@@ -10,6 +10,7 @@
 
 #include <linux/config.h>
 #include <linux/module.h>
+#include <linux/spinlock.h>
 #include <asm/uaccess.h>
 
 extern const struct exception_table_entry __start___ex_table[];
@@ -36,26 +37,32 @@
         return 0;
 }
 
+extern spinlock_t modlist_lock;
+
 unsigned long
 search_exception_table(unsigned long addr)
 {
-	unsigned long ret;
+	unsigned long ret = 0;
+	unsigned long flags;
 
 #ifndef CONFIG_MODULES
 	/* There is only the kernel to search.  */
 	ret = search_one_table(__start___ex_table, __stop___ex_table-1, addr);
-	if (ret) return FIX_PSW(ret);
+	return ret;
 #else
 	/* The kernel is the last "module" -- no need to treat it special.  */
 	struct module *mp;
+
+	spin_lock_irqsave(&modlist_lock, flags);
 	for (mp = module_list; mp != NULL; mp = mp->next) {
-		if (mp->ex_table_start == NULL)
+		if (mp->ex_table_start == NULL || !(mp->flags&(MOD_RUNNING|MOD_INITIALIZING)))
 			continue;
 		ret = search_one_table(mp->ex_table_start,
 				       mp->ex_table_end - 1, addr);
-		if (ret) return FIX_PSW(ret);
+		if (ret) 
+			break;
 	}
+	spin_unlock_irqrestore(&modlist_lock, flags);
+	return ret;
 #endif
-
-	return 0;
 }
diff -urN linux/arch/s390x/mm/fault.c linux-2.4.7/arch/s390x/mm/fault.c
--- linux/arch/s390x/mm/fault.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/arch/s390x/mm/fault.c	Mon Dec 17 13:42:41 2001
@@ -4,6 +4,7 @@
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
  *    Author(s): Hartmut Penner (hp@de.ibm.com)
+ *               Ulrich Weigand (uweigand@de.ibm.com)
  *
  *  Derived from "arch/i386/mm/fault.c"
  *    Copyright (C) 1995  Linus Torvalds
@@ -21,6 +22,7 @@
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/init.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -32,34 +34,7 @@
 #endif
 
 extern void die(const char *,struct pt_regs *,long);
-
-extern spinlock_t timerlist_lock;
-
-/*
- * Unlock any spinlocks which will prevent us from getting the
- * message out
- */
-void bust_spinlocks(int yes)
-{
-        spin_lock_init(&timerlist_lock);
-        if (yes) {
-                oops_in_progress = 1;
-#ifdef CONFIG_SMP
-                atomic_set(&global_irq_lock,0);
-#endif
-        } else {
-                int loglevel_save = console_loglevel;
-                oops_in_progress = 0;
-                /*
-                 * OK, the message is on the console.  Now we call printk()
-                 * without oops_in_progress set so that printk will give klogd
-                 * a poke.  Hold onto your hats...
-                 */
-                console_loglevel = 15;          /* NMI oopser may have shut the console up */
-                printk(" ");
-                console_loglevel = loglevel_save;
-        }
-}
+static void force_sigsegv(struct task_struct *tsk, int code, void *address);
 
 /*
  * This routine handles page faults.  It determines the address,
@@ -80,18 +55,31 @@
         unsigned long address;
         unsigned long fixup;
         int write;
-        unsigned long psw_mask;
-        unsigned long psw_addr;
 	int si_code = SEGV_MAPERR;
 	int kernel_address = 0;
 
-        /*
-         *  get psw mask of Program old psw to find out,
-         *  if user or kernel mode
-         */
+        tsk = current;
+        mm = tsk->mm;
+	
+	/* 
+         * Check for low-address protection.  This needs to be treated
+	 * as a special case because the translation exception code 
+	 * field is not guaranteed to contain valid data in this case.
+	 */
+	if ((error_code & 0xff) == 4 && !(S390_lowcore.trans_exc_code & 4)) {
 
-        psw_mask = S390_lowcore.program_old_psw.mask;
-        psw_addr = S390_lowcore.program_old_psw.addr;
+		/* Low-address protection hit in kernel mode means 
+		   NULL pointer write access in kernel mode.  */
+ 		if (!(regs->psw.mask & PSW_PROBLEM_STATE)) {
+			address = 0;
+			kernel_address = 1;
+			goto no_context;
+		}
+
+		/* Low-address protection hit in user mode 'cannot happen'.  */
+		die ("Low-address protection", regs, error_code);
+        	do_exit(SIGKILL);
+	}
 
         /* 
          * get the failing address 
@@ -101,11 +89,6 @@
 
         address = S390_lowcore.trans_exc_code&-4096L;
 
-        tsk = current;
-        mm = tsk->mm;
-
-        if (in_interrupt() || !mm)
-                goto no_context;
 
 	/*
 	 * Check which address space the address belongs to
@@ -136,6 +119,7 @@
 			}
 		}
 		die("page fault via unknown access register", regs, error_code);
+        	do_exit(SIGKILL);
 		break;
 
 	case 2: /* Secondary Segment Table Descriptor */
@@ -144,19 +128,25 @@
 		break;
 	}
 
+	/*
+	 * Check whether we have a user MM in the first place.
+	 */
+        if (in_interrupt() || !mm || !(regs->psw.mask & _PSW_IO_MASK_BIT))
+                goto no_context;
 
 	/*
 	 * When we get here, the fault happened in the current
-	 * task's user address space, so we search the VMAs
+	 * task's user address space, so we can switch on the
+	 * interrupts again and then search the VMAs
 	 */
 
+	__sti();
+
         down_read(&mm->mmap_sem);
 
         vma = find_vma(mm, address);
-        if (!vma) {
-	        printk("no vma for address %lX\n",address);
+        if (!vma)
                 goto bad_area;
-        }
         if (vma->vm_start <= address) 
                 goto good_area;
         if (!(vma->vm_flags & VM_GROWSDOWN))
@@ -215,8 +205,7 @@
         up_read(&mm->mmap_sem);
 
         /* User mode accesses just cause a SIGSEGV */
-        if (psw_mask & PSW_PROBLEM_STATE) {
-		struct siginfo si;
+        if (regs->psw.mask & PSW_PROBLEM_STATE) {
                 tsk->thread.prot_addr = address;
                 tsk->thread.trap_no = error_code;
 #ifndef CONFIG_SYSCTL
@@ -233,10 +222,8 @@
 			show_regs(regs);
 		}
 #endif
-		si.si_signo = SIGSEGV;
-		si.si_code = si_code;
-		si.si_addr = (void*) address;
-		force_sig_info(SIGSEGV, &si, tsk);
+
+		force_sigsegv(tsk, si_code, (void *)address);
                 return;
 	}
 
@@ -251,6 +238,7 @@
  * Oops. The kernel tried to access some bad page. We'll have to
  * terminate things with extreme prejudice.
  */
+
         if (kernel_address)
                 printk(KERN_ALERT "Unable to handle kernel pointer dereference"
         	       " at virtual kernel address %016lx\n", address);
@@ -258,10 +246,6 @@
                 printk(KERN_ALERT "Unable to handle kernel paging request"
 		       " at virtual user address %016lx\n", address);
 
-/*
- * need to define, which information is useful here
- */
-
         die("Oops", regs, error_code);
         do_exit(SIGKILL);
 
@@ -273,7 +257,7 @@
 out_of_memory:
 	up_read(&mm->mmap_sem);
 	printk("VM: killing process %s\n", tsk->comm);
-	if (psw_mask & PSW_PROBLEM_STATE)
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
 		do_exit(SIGKILL);
 	goto no_context;
 
@@ -289,6 +273,158 @@
 	force_sig(SIGBUS, tsk);
 
 	/* Kernel mode? Handle exceptions or die */
-	if (!(psw_mask & PSW_PROBLEM_STATE))
+	if (!(regs->psw.mask & PSW_PROBLEM_STATE))
 		goto no_context;
 }
+
+/*
+ * Send SIGSEGV to task.  This is an external routine
+ * to keep the stack usage of do_page_fault small.
+ */
+static void force_sigsegv(struct task_struct *tsk, int code, void *address)
+{
+	struct siginfo si;
+	si.si_signo = SIGSEGV;
+	si.si_code = code;
+	si.si_addr = address;
+	force_sig_info(SIGSEGV, &si, tsk);
+}
+
+
+#ifdef CONFIG_PFAULT
+/*
+ * 'pfault' pseudo page faults routines.
+ */
+static int pfault_disable = 0;
+
+static int __init nopfault(char *str)
+{
+	pfault_disable = 1;
+	return 1;
+}
+
+__setup("nopfault", nopfault);
+
+typedef struct {
+	__u16 refdiagc;
+	__u16 reffcode;
+	__u16 refdwlen;
+	__u16 refversn;
+	__u64 refgaddr;
+	__u64 refselmk;
+	__u64 refcmpmk;
+	__u64 reserved;
+} __attribute__ ((packed)) pfault_refbk_t;
+
+typedef struct _pseudo_wait_t {
+       struct _pseudo_wait_t *next;
+       wait_queue_head_t queue;
+       unsigned long address;
+       int resolved;
+} pseudo_wait_t;
+
+int pfault_init(void)
+{
+	pfault_refbk_t refbk =
+	{ 0x258, 0, 5, 2, __LC_KERNEL_STACK, 1ULL << 48, 1ULL << 48,
+          0x8000000000000000ULL };
+        int rc;
+
+	if (pfault_disable)
+		return -1;
+        __asm__ __volatile__(
+                "    diag  %1,%0,0x258\n"
+		"0:  j     2f\n"
+		"1:  la    %0,8\n"
+		"2:\n"
+		".section __ex_table,\"a\"\n"
+		"   .align 4\n"
+		"   .quad  0b,1b\n"
+		".previous"
+                : "=d" (rc) : "a" (&refbk) : "cc" );
+	__ctl_set_bit(0, 9);
+        return rc;
+}
+
+void pfault_fini(void)
+{
+	pfault_refbk_t refbk =
+	{ 0x258, 1, 5, 2, 0ULL, 0ULL, 0ULL, 0ULL };
+
+	if (pfault_disable)
+		return;
+	__ctl_clear_bit(0, 9);
+        __asm__ __volatile__(
+                "    diag  %0,0,0x258\n"
+		"0:\n"
+		".section __ex_table,\"a\"\n"
+		"   .align 4\n"
+		"   .quad  0b,0b\n"
+		".previous"
+		: : "a" (&refbk) : "cc" );
+}
+
+asmlinkage void
+pfault_interrupt(struct pt_regs *regs, __u16 error_code)
+{
+	struct task_struct *tsk;
+	wait_queue_head_t queue;
+	wait_queue_head_t *qp;
+	__u16 subcode;
+
+	/*
+	 * Get the external interruption subcode & pfault
+	 * initial/completion signal bit. VM stores this 
+	 * in the 'cpu address' field associated with the
+         * external interrupt. 
+	 */
+	subcode = S390_lowcore.cpu_addr;
+	if ((subcode & 0xff00) != 0x0600)
+		return;
+
+	/*
+	 * Get the token (= address of kernel stack of affected task).
+	 */
+	tsk = (struct task_struct *)
+		(*((unsigned long *) __LC_PFAULT_INTPARM) - THREAD_SIZE);
+
+	/*
+	 * We got all needed information from the lowcore and can
+	 * now safely switch on interrupts.
+	 */
+	if (regs->psw.mask & PSW_PROBLEM_STATE)
+		__sti();
+
+	if (subcode & 0x0080) {
+		/* signal bit is set -> a page has been swapped in by VM */
+		qp = (wait_queue_head_t *)
+			xchg(&tsk->thread.pfault_wait, -1);
+		if (qp != NULL) {
+			/* Initial interrupt was faster than the completion
+			 * interrupt. pfault_wait is valid. Set pfault_wait
+			 * back to zero and wake up the process. This can
+			 * safely be done because the task is still sleeping
+			 * and can't procude new pfaults. */
+			tsk->thread.pfault_wait = 0ULL;
+			wake_up(qp);
+		}
+	} else {
+		/* signal bit not set -> a real page is missing. */
+                init_waitqueue_head (&queue);
+		qp = (wait_queue_head_t *)
+			xchg(&tsk->thread.pfault_wait, (addr_t) &queue);
+		if (qp != NULL) {
+			/* Completion interrupt was faster than the initial
+			 * interrupt (swapped in a -1 for pfault_wait). Set
+			 * pfault_wait back to zero and exit. This can be
+			 * done safely because tsk is running in kernel 
+			 * mode and can't produce new pfaults. */
+			tsk->thread.pfault_wait = 0ULL;
+		}
+
+                /* go to sleep */
+                wait_event(queue, tsk->thread.pfault_wait == 0ULL);
+	}
+}
+#endif
+
diff -urN linux/arch/s390x/mm/init.c linux-2.4.7/arch/s390x/mm/init.c
--- linux/arch/s390x/mm/init.c	Thu Apr 26 17:10:16 2001
+++ linux-2.4.7/arch/s390x/mm/init.c	Mon Dec 17 13:42:41 2001
@@ -41,44 +41,23 @@
 pgd_t swapper_pg_dir[PTRS_PER_PGD] __attribute__((__aligned__(PAGE_SIZE)));
 char  empty_zero_page[PAGE_SIZE] __attribute__((__aligned__(PAGE_SIZE)));
 
-static int test_access(unsigned long loc)
-{
-	static const int ssm_mask = 0x07000000L;
-	int rc, i;
-
-        rc = 0;
-	for (i=0; i<2; i++) {
-		__asm__ __volatile__(
-                        "    slgr  %0,%0\n"
-			"    ssm   %1\n"
-			"    tprot 0(%2),0\n"
-			"0:  jne   1f\n"
-			"    lghi  %0,1\n"
-			"1:  ssm   %3\n"
-                        ".section __ex_table,\"a\"\n"
-                        "   .align 8\n"
-                        "   .quad  0b,1b\n"
-                        ".previous"
-			: "+&d" (rc) : "i" (0), "a" (loc), "m" (ssm_mask)
-			: "cc");
-		if (rc == 0)
-			break;
-		loc += 0x100000;
-	}
-	return rc;
-}
-
 int do_check_pgt_cache(int low, int high)
 {
         int freed = 0;
         if(pgtable_cache_size > high) {
                 do {
-                        if(pgd_quicklist)
-                                free_pgd_slow(get_pgd_fast()), freed += 4;
-                        if(pmd_quicklist)
-                                pmd_free_slow(pmd_alloc_one_fast(NULL, 0)), freed += 4;
-                        if(pte_quicklist)
-                                pte_free_slow(pte_alloc_one_fast(NULL, 0)), freed++;
+                        if(pgd_quicklist) {
+				free_pgd_slow(get_pgd_fast());
+				freed += 4;
+			}
+                        if(pmd_quicklist) {
+				pmd_free_slow(pmd_alloc_one_fast(NULL, 0));
+				freed += 4;
+			}
+                        if(pte_quicklist) {
+				pte_free_slow(pte_alloc_one_fast(NULL, 0));
+				freed += 1;
+			}
                 } while(pgtable_cache_size > low);
         }
         return freed;
@@ -136,7 +115,7 @@
 	int     i,j,k;
         unsigned long address=0;
         unsigned long pgdir_k = (__pa(swapper_pg_dir) & PAGE_MASK) |
-          _REGION_TABLE;
+          _KERN_REGION_TABLE;
 	unsigned long end_mem = (unsigned long) __va(max_low_pfn*PAGE_SIZE);
 	static const int ssm_mask = 0x04000000L;
 
@@ -209,7 +188,6 @@
 void __init mem_init(void)
 {
 	unsigned long codesize, reservedpages, datasize, initsize;
-        unsigned long tmp;
 
         max_mapnr = num_physpages = max_low_pfn;
         high_memory = (void *) __va(max_low_pfn * PAGE_SIZE);
@@ -220,25 +198,7 @@
 	/* this will put all low memory onto the freelists */
 	totalram_pages += free_all_bootmem();
 
-        /* mark usable pages in the mem_map[] and count reserved pages */
 	reservedpages = 0;
-	tmp = 0;
-	do {
-		if (tmp && (tmp & 0x1ff) == 0 && 
-                    test_access(tmp * PAGE_SIZE) == 0) {
-                        printk("2M Segment 0x%016lX not available\n",
-                               tmp * PAGE_SIZE);
-			do {
-                                set_bit(PG_reserved, &mem_map[tmp].flags);
-				reservedpages++;
-				tmp++;
-			} while (tmp < max_low_pfn && (tmp & 0x1ff));
-		} else {
-			if (PageReserved(mem_map+tmp))
-				reservedpages++;
-			tmp++;
-		}
-	} while (tmp < max_low_pfn);
 
 	codesize =  (unsigned long) &_etext - (unsigned long) &_text;
 	datasize =  (unsigned long) &_edata - (unsigned long) &_etext;
diff -urN linux/arch/s390x/tools/dasdfmt/Makefile linux-2.4.7/arch/s390x/tools/dasdfmt/Makefile
--- linux/arch/s390x/tools/dasdfmt/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/tools/dasdfmt/Makefile	Wed Dec 31 19:00:00 1969
@@ -1,9 +0,0 @@
-all: dasdfmt
-
-dasdfmt: dasdfmt.c
-	$(CC) -o $@ $^
-	$(STRIP) $@
-
-clean:
-	rm -f dasdfmt
-
diff -urN linux/arch/s390x/tools/dasdfmt/dasdfmt.8 linux-2.4.7/arch/s390x/tools/dasdfmt/dasdfmt.8
--- linux/arch/s390x/tools/dasdfmt/dasdfmt.8	Fri Mar  2 14:12:06 2001
+++ linux-2.4.7/arch/s390x/tools/dasdfmt/dasdfmt.8	Wed Dec 31 19:00:00 1969
@@ -1,68 +0,0 @@
-.TH DASDFMT 8 "Tue Jan 25 2000"
-.UC 4
-.SH NAME
-dasdfmt \- formatting of DSAD (ECKD) disk drives.
-.SH SYNOPSIS
-\fBdasdfmt\fR [-tvyLV] [-b \fIblockSize\fR] [-l \fIdiskLabel\fR] \fIdiskSpec\fR
-.SH DESCRIPTION
-\fBdasdfmt\fR formats a DASD (ECKD) disk drive to prepare it
-for usage with Linux for S/390. \fBWARNING\fR: Incautious usage of
-\fBdasdfmt\fR can result in \fBLOSS OF DATA\fR.
-
-.SH OPTIONS
-.TP
-\fB-t\fR
-Disables any modification of the disk drive. \fBdasdfmt\fR just prints
-out, what it \fBwould\fR do.
-
-.TP
-\fB-v\fR
-Increases verbosity.
-
-.TP
-\fB-y\fR 
-Start formatting without further user-confirmation.
-
-.TP
-\fB-L\fR 
-Omit the writing of a disk label after formatting.
-
-.TP
-\fB-V\fR 
-Print version number and exit.
-
-.TP
-\fB-b\fR \fIblockSize\fR
-Specify blocksize to be used. \fIblocksize\fR must be a positive integer
-and always be a power of two. Due due some limitations in the driver,
-it is \fBstrongly\fR recommended to use a \fIblockSize\fR of \fI4096\fR.
-
-.TP
-\fB-l\fR \fIdiskLabel\fR
-Specify the label to be written to disk after formatting. If no label is
-specified, a sensible default is used. \fIdiskLabel\fR is interpreted as
-ASCII string and is automatically converted to EBCDIC.
-
-.TP
-\fIdiskSpec\fR
-This parameter specified the device to be formatted. It also can be
-given in two variants:
-.sp
-	\fB-f\fR \fB/dev/dasd\fR\fIX\fR
-.br
-or
-.br
-	\fB-n\fR \fIdevnum\fR
-.sp
-The first form uses the commonly used
-.SM UNIX
-device notation where \fIX\fR is a single lowercase letter.
-The second form uses simply the device number.
-
-.SH BUGS
-None so far ;-)
-
-.SH AUTHOR
-.nf
-This man-page was written by Fritz Elfert <felfert@to.com>
-.fi
diff -urN linux/arch/s390x/tools/dasdfmt/dasdfmt.c linux-2.4.7/arch/s390x/tools/dasdfmt/dasdfmt.c
--- linux/arch/s390x/tools/dasdfmt/dasdfmt.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/tools/dasdfmt/dasdfmt.c	Wed Dec 31 19:00:00 1969
@@ -1,839 +0,0 @@
-/*
- *
- * dasdfmt.c
- *
- *  S390 version
- *    Copyright (C) 1999,2000 IBM Corporation
- *    Author(s): Utz Bacher, <utz.bacher@de.ibm.com>
- *
- *  Device-in-use-checks by Fritz Elfert, <felfert@to.com>
- *  Compatible Disk Layout enhancements by Carsten Otte, <cotte@de.ibm.com>
- *
- * Still to do:
- *   detect non-switch parameters ("dasdfmt -n 170 XY") and complain about them 
- */
-
-/* #define _LINUX_BLKDEV_H */
-
-#include <unistd.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <getopt.h>
-#include <limits.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dirent.h>
-#include <mntent.h>
-#define __KERNEL__ /* we want to use kdev_t and not have to define it */
-#include <linux/kdev_t.h>
-#undef __KERNEL__
-
-#include <linux/fs.h>
-#include <asm/dasd.h>
-#include <linux/hdreg.h>
-
-#define EXIT_MISUSE 1
-#define EXIT_BUSY 2
-#define TEMPFILENAME "/tmp/ddfXXXXXX"
-#define TEMPFILENAMECHARS 8  /* 8 characters are fixed in all temp filenames */
-#define SLASHDEV "/dev/"
-#define PROC_DASD_DEVICES "/proc/dasd/devices"
-/* _PATH_MOUNTED is /etc/mtab - /proc/mounts does not show root-fs correctly */
-#define PROC_MOUNTS _PATH_MOUNTED
-#define PROC_SWAPS "/proc/swaps"
-#define DASD_DRIVER_NAME "dasd"
-#define LABEL_LENGTH 10
-#define PROC_LINE_LENGTH 80
-#define ERR_LENGTH 80
-
-#define MAX_FILELEN NAME_MAX+PATH_MAX
-
-#define GIVEN_DEVNO 1
-#define GIVEN_MAJOR 2
-#define GIVEN_MINOR 4
-
-#define CHECK_START 1
-#define CHECK_END 2
-#define CHECK_BLKSIZE 4
-#define CHECK_ALL ~0
-
-#define ERRMSG(x...) {fflush(stdout);fprintf(stderr,x);}
-#define ERRMSG_EXIT(ec,x...) {fflush(stdout);fprintf(stderr,x);exit(ec);}
-
-#define CHECK_SPEC_MAX_ONCE(i,str) \
-	{if (i>1) \
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: " str " " \
-			"can only be specified once\n",prog_name);}
-
-#define PARSE_PARAM_INTO(x,param,base,str) \
-	{x=(int)strtol(param,&endptr,base); \
-	if (*endptr) \
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: " str " " \
-			"is in invalid format\n",prog_name);}
-
-char *prog_name;/*="dasdfmt";*/
-char tempfilename[]=TEMPFILENAME;
-
-__u8 _ascebc[256] =
-{
- /*00 NUL   SOH   STX   ETX   EOT   ENQ   ACK   BEL */
-     0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,
- /*08  BS    HT    LF    VT    FF    CR    SO    SI */
- /*              ->NL                               */
-     0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
- /*10 DLE   DC1   DC2   DC3   DC4   NAK   SYN   ETB */
-     0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,
- /*18 CAN    EM   SUB   ESC    FS    GS    RS    US */
- /*                               ->IGS ->IRS ->IUS */
-     0x18, 0x19, 0x3F, 0x27, 0x22, 0x1D, 0x1E, 0x1F,
- /*20  SP     !     "     #     $     %     &     ' */
-     0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,
- /*28   (     )     *     +     ,     -    .      / */
-     0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
- /*30   0     1     2     3     4     5     6     7 */
-     0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
- /*38   8     9     :     ;     <     =     >     ? */
-     0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
- /*40   @     A     B     C     D     E     F     G */
-     0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
- /*48   H     I     J     K     L     M     N     O */
-     0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
- /*50   P     Q     R     S     T     U     V     W */
-     0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
- /*58   X     Y     Z     [     \     ]     ^     _ */
-     0xE7, 0xE8, 0xE9, 0xBA, 0xE0, 0xBB, 0xB0, 0x6D,
- /*60   `     a     b     c     d     e     f     g */
-     0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
- /*68   h     i     j     k     l     m     n     o */
-     0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
- /*70   p     q     r     s     t     u     v     w */
-     0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
- /*78   x     y     z     {     |     }     ~    DL */
-     0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
- /*80*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*88*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*90*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*98*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*A0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*A8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*B0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*B8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*C0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*C8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*D0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*D8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*E0        sz						*/
-     0x3F, 0x59, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*E8*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*F0*/
-     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
- /*F8*/
-     0x90, 0x3F, 0x3F, 0x3F, 0x3F, 0xEA, 0x3F, 0xFF
-};
-
-void convert_label(char *str)
-{
-	int i;
-	for (i=0;i<LABEL_LENGTH;i++) str[i]=_ascebc[str[i]];
-}
-
-void
-exit_usage(int exitcode)
-{
-#ifdef RANGE_FORMATTING
-	printf("Usage: %s [-htvyCLV] [-l <label>] [-b <blocksize>] [<range>] " \
-		"<diskspec>\n\n",prog_name);
-#else /* RANGE_FORMATTING */
-	printf("Usage: %s [-htvyCLV] [-l <label>] [-b <blocksize>] " \
-		"<diskspec>\n\n",prog_name);
-#endif /* RANGE_FORMATTING */
-	printf("       -t means testmode\n");
-	printf("       -v means verbose mode\n");
-	printf("       -C means format compatible disk layout\n");
-	printf("       -V means print version\n");
-	printf("       -L means don't write disk label\n");
-	printf("       <label> is a label which is converted to EBCDIC and " \
-		"written to disk\n");
-	printf("       <blocksize> has to be power of 2 and at least 512\n");
-#ifdef RANGE_FORMATTING
-	printf("       <range> is either\n");
-	printf("           -s <start_track> -e <end_track>\n");
-	printf("       or\n");
-	printf("           -r <start_track>-<end_track>\n");
-#endif /* RANGE_FORMATTING */
-	printf("       and <diskspec> is either\n");
-	printf("           -f /dev/dasdX\n");
-	printf("       or\n");
-	printf("           -n <s390-devnr>\n");
-	exit(exitcode);
-}
-
-void
-get_xno_from_xno(int *devno,kdev_t *major_no,kdev_t *minor_no,int mode)
-{
-	FILE *file;
-	int d,rc;
-	kdev_t mi,ma;
-	int mi_i,ma_i; /* for scanf :-( */
-	char line[PROC_LINE_LENGTH];
-
-	file=fopen(PROC_DASD_DEVICES,"r");
-	if (file==NULL)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to open " \
-			PROC_DASD_DEVICES ": %s (do you have the /proc " \
-			"filesystem enabled?)\n",prog_name,strerror(errno));
-
-	/*	fgets(line,sizeof(line),file); omit first line */ 
-	while (fgets(line,sizeof(line),file)!=NULL) {
-                rc=sscanf(line,"%X %*[(A-Z) ] at (%d:%d)",&d,&ma_i,&mi_i);
-		ma=ma_i;
-		mi=mi_i;
-		if ( (rc==3) &&
-			!((d!=*devno)&&(mode&GIVEN_DEVNO)) &&
-			!((ma!=*major_no)&&(mode&GIVEN_MAJOR)) &&
-			!((mi!=*minor_no)&&(mode&GIVEN_MINOR)) ) {
-			*devno=d;
-			*major_no=ma;
-			*minor_no=mi;
-			/* yes, this is a quick exit, but the easiest way */
-			fclose(file);
-			return;
-		}
-	}
-	fclose(file);
-
-	ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to find device in the /proc " \
-		    "filesystem (are you sure to have the right parameter " \
-		    "dasd=xxx?)\n",
-		prog_name);
-}
-
-char *
-get_devname_from_devno(int devno,int verbosity)
-{
-	kdev_t major_no,minor_no;
-	kdev_t file_major,file_minor;
-	struct stat stat_buf;
-	int rc;
-	int found;
-	char *devname;
-	char tmpname[MAX_FILELEN];
-
-	DIR *dp;
-	struct dirent *direntp;
-
-	/**** get minor number ****/
-	get_xno_from_xno(&devno,&major_no,&minor_no,GIVEN_DEVNO);
-
-	/**** get device file ****/
-	if ((dp=opendir(SLASHDEV)) == NULL)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: unable to read " SLASHDEV \
-			"\n",prog_name);
-	found=0;
-	while ((direntp=readdir(dp)) != NULL) {
-		strcpy(tmpname,SLASHDEV);
-		strcat(tmpname,direntp->d_name);
-		rc=stat(tmpname,&stat_buf);
-		if (!rc) {
-			file_major=MAJOR(stat_buf.st_rdev);
-			file_minor=MINOR(stat_buf.st_rdev);
-			if ((file_major==major_no) && (file_minor==minor_no)) {
-				found=1;
-				break;
-			}
-		}
-	}
-	if (found) {
-		devname=malloc(strlen(direntp->d_name));
-		strcpy(devname,tmpname);
-	}
-	rc=closedir(dp);
-	if (rc<0) ERRMSG("%s: unable to close directory " SLASHDEV \
-		"; continuing\n",prog_name);
-	if (found)
-		return devname;
-
-	if (verbosity>=1)
-		printf("I didn't find device node in " SLASHDEV \
-			"; trying to create a temporary node\n");
-
-	/**** get temp file and create device node *****/
-	rc=mkstemp(tempfilename);
-	if (rc==-1)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to get temporary " \
-			"filename: %s\n",prog_name,strerror(errno));
-	close(rc);
-	rc=unlink(tempfilename);
-	
-	rc=mknod(tempfilename,S_IFBLK|0600,MKDEV(major_no,minor_no));
-	if (rc)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: failed to create temporary " \
-			"device node %s: %s\n",prog_name,tempfilename,
-			strerror(errno));
-	return tempfilename;
-}
-
-char *
-check_param(int mode,format_data_t data)
-{
-	char *s;
-
-	if (NULL==(s=malloc(ERR_LENGTH)))
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: not enough memory.\n",prog_name);
-
-	if ((mode&CHECK_START)&&(data.start_unit<0)) {
-		strcpy(s,"start track must be greater than zero");
-		goto exit;
-	}
-	if ((mode&CHECK_END)&&(data.stop_unit<-1)) {
-		strcpy(s,"end track must be -1 or greater than zero");
-		goto exit;
-	}
-	if ((mode&CHECK_END)&&(data.start_unit>data.stop_unit)&&
-		(data.stop_unit!=-1)) {
-		strcpy(s,"end track must be higher than start track");
-		goto exit;
-	}
-
-	if ((mode&CHECK_BLKSIZE)&&(data.blksize<1)) {
-		strcpy(s,"blocksize must be a positive integer");
-		goto exit;
-	}
-	if (mode&CHECK_BLKSIZE) while (data.blksize>0) {
-		if ((data.blksize%2)&&(data.blksize!=1)) {
-			strcpy(s,"blocksize must be a power of 2");
-			goto exit;
-		}
-		data.blksize/=2;
-	}
-
-	free(s);
-	return NULL;
-exit:
-	return s;
-}
-
-#define ASK_PRINTOUT printf("Please enter %s",output)
-#define ASK_GETBUFFER fgets(buffer,sizeof(buffer),stdin)
-#define ASK_SCANFORNUMBER(var) rc=sscanf(buffer,"%d%c",&var,&c)
-#define ASK_COMPLAIN_FORMAT if ((rc==2)&&(c=='\n')) rc=1; \
-	if (rc==-1) rc=1; /* this happens, if enter is pressed */ \
-	if (rc!=1) printf(" -- wrong input, try again.\n")
-#define ASK_CHECK_PARAM(mode) str=check_param(mode,params); \
-		if (str!=NULL) { printf(" -- %s\n",str); rc=0; free(str); }
-
-format_data_t
-ask_user_for_data(format_data_t params)
-{
-	char buffer[20]; /* should be enough for inputing track numbers */
-	char c;
-	int i,rc;
-	char *str;
-	char output[60],o2[12];
-
-#ifdef RANGE_FORMATTING
-	i=params.start_unit;
-	do {
-		params.start_unit=i;
-		sprintf(output,"the start track of the range to format " \
-			"[%d]: ",i);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		ASK_SCANFORNUMBER(params.start_unit);
-		ASK_COMPLAIN_FORMAT;
-		ASK_CHECK_PARAM(CHECK_START);
-	} while (rc!=1);
-
-	i=params.stop_unit;
-	do {
-		params.stop_unit=i;
-		sprintf(output,"the end track of the range to format [");
-		if (i==-1) sprintf(o2,"END]: "); else
-			sprintf(o2,"%d]: ",i);
-		strcat(output,o2);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		if ( (!strcasecmp(buffer,"end")) ||
-			(!strcasecmp(buffer,"end\n")) ) {
-			rc=1;
-			params.stop_unit=-1;
-		} else {
-			ASK_SCANFORNUMBER(params.stop_unit);
-			ASK_COMPLAIN_FORMAT;
-			ASK_CHECK_PARAM(CHECK_END);
-		}
-	} while (rc!=1);
-#endif /* RANGE_FORMATTING */
-
-	i=params.blksize;
-	do {
-		params.blksize=i;
-		sprintf(output,"the blocksize of the formatting [%d]: ",i);
-		ASK_PRINTOUT;
-		ASK_GETBUFFER;
-		ASK_SCANFORNUMBER(params.blksize);
-		ASK_COMPLAIN_FORMAT;
-		ASK_CHECK_PARAM(CHECK_BLKSIZE);
-	} while (rc!=1);
-
-	return params;
-}
-
-/* Check if the device we are going to format is mounted.
- * If true, complain and exit.
- */
-void
-check_mounted(int major, int minor)
-{
-	FILE *f;
-	int ishift = 0;
-	struct mntent *ment;
-	struct stat stbuf;
-	char line[128];
-
-	/* If whole disk to be formatted ... */
-	if ((minor % (1U << DASD_PARTN_BITS)) == 0) {
-		/* ... ignore partition-selector */
-		minor >>= DASD_PARTN_BITS;
-		ishift = DASD_PARTN_BITS;
-	}
-	/*
-	 * first, check filesystems
-	 */
-	if (!(f = fopen(PROC_MOUNTS, "r")))
-		ERRMSG_EXIT(EXIT_FAILURE, "%s: %s\n", PROC_MOUNTS,
-			strerror(errno));
-	while ((ment = getmntent(f))) {
-		if (stat(ment->mnt_fsname, &stbuf) == 0)
-			if ((major == MAJOR(stbuf.st_rdev)) &&
-				(minor == (MINOR(stbuf.st_rdev)>>ishift))) {
-				ERRMSG("%s: device is mounted on %s!!\n",
-					prog_name,ment->mnt_dir);
-				ERRMSG_EXIT(EXIT_BUSY, "If you really want to "
-					"format it, please unmount it.\n");
-			}
-	}
-	fclose(f);
-	/*
-	 * second, check active swap spaces
-	 */
-	if (!(f = fopen(PROC_SWAPS, "r")))
-		ERRMSG_EXIT(EXIT_FAILURE, PROC_SWAPS " %s", strerror(errno));
-	/*
-	 * skip header line
-	 */
-	fgets(line, sizeof(line), f);
-	while (fgets(line, sizeof(line), f)) {
-		char *p;
-		for (p = line; *p && (!isspace(*p)); p++) ;
-		*p = '\0';
-		if (stat(line, &stbuf) == 0)
-			if ((major == MAJOR(stbuf.st_rdev)) &&
-				(minor == (MINOR(stbuf.st_rdev)>>ishift))) {
-				ERRMSG("%s: the device is in use for "
-					"swapping!!\n",prog_name);
-				ERRMSG_EXIT(EXIT_BUSY, "If you really want to "
-					"format it, please use swapoff %s.\n",
-					line);
-			}
-	}
-	fclose(f);
-}
-
-void
-do_format_dasd(char *dev_name,format_data_t format_params,int testmode,
-	int verbosity,int writenolabel,int labelspec,
-	char *label,int withoutprompt,int devno)
-{
-	int fd,rc;
-	struct stat stat_buf;
-	kdev_t minor_no,major_no;
-	int new_blksize;
-	unsigned int label_position;
-	struct hd_geometry new_geometry;
-	char inp_buffer[5]; /* to contain yes */
-
-	fd=open(dev_name,O_RDWR);
-	if (fd==-1)
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: error opening device %s: " \
-			"%s\n",prog_name,dev_name,strerror(errno));
-
-	if (verbosity>=1) {
-	}
-
-	rc=stat(dev_name,&stat_buf);
-	if (rc) {
-		ERRMSG_EXIT(EXIT_FAILURE,"%s: error occurred during stat: " \
-			"%s\n",prog_name,strerror(errno));
-	} else {
-		if (!S_ISBLK(stat_buf.st_mode))
-			ERRMSG_EXIT(EXIT_FAILURE,"%s: file is not a " \
-				"blockdevice.\n",prog_name);
-		major_no=MAJOR(stat_buf.st_rdev);
-		minor_no=MINOR(stat_buf.st_rdev);
-	}
-	check_mounted(major_no, minor_no);
-
-	get_xno_from_xno(&devno,&major_no,&minor_no,
-			GIVEN_MAJOR|GIVEN_MINOR);
-	if ((!writenolabel) && (!labelspec)) {
-		sprintf(label,"LNX1 x%04x",devno);
-	}
-	
-	if ( ((withoutprompt)&&(verbosity>=1)) ||
-		(!withoutprompt) ) {
-		printf("\nI am going to format the device %s in the " \
-			"following way:\n",dev_name);
-		printf("   Device number of device : 0x%x\n",devno);
-		printf("   Major number of device  : %u\n",major_no);
-		printf("   Minor number of device  : %u\n",minor_no);
-		printf("   Labelling device        : %s\n",(writenolabel)?
-			"no":"yes");
-		if (!writenolabel)
-			printf("   Disk label              : %s\n",label);
-		if (format_params.intensity != DASD_FORMAT_DEFAULT_INTENSITY)
-			printf("   Compatible Disk Layout  : %s\n",(format_params.intensity&0x08)?
-			       "yes":"no");
-#ifdef RANGE_FORMATTING
-		printf("   Start track             : %d\n" \
-			,format_params.start_unit);
-		printf("   End track               : ");
-		if (format_params.stop_unit==-1)
-			printf("last track of disk\n");
-		else
-			printf("%d\n",format_params.stop_unit);
-#endif /* RANGE_FORMATTING */
-		printf("   Blocksize               : %d\n" \
-			,format_params.blksize);
-		if (testmode) printf("Test mode active, omitting ioctl.\n");
-	}
-
-	while (!testmode) {
-		if (!withoutprompt) {
-			printf("\n--->> ATTENTION! <<---\n");
-			printf("All data in the specified range of that " \
-				"device will be lost.\nType \"yes\" to " \
-				"continue, no will leave the disk untouched: ");
-			fgets(inp_buffer,sizeof(inp_buffer),stdin);
-			if (strcasecmp(inp_buffer,"yes") &&
-				strcasecmp(inp_buffer,"yes\n")) {
-				printf("Omitting ioctl call (disk will " \
-					"NOT be formatted).\n");
-				break;
-			}
-		}
-
-		if ( !(  (withoutprompt)&&(verbosity<1) ))
-			printf("Formatting the device. This may take a " \
-				"while (get yourself a coffee).\n");
-		rc=ioctl(fd,BIODASDFORMAT,format_params);
-		if (rc)
-			ERRMSG_EXIT(EXIT_FAILURE,"%s: the dasd driver " \
-				"returned with the following error " \
-				"message:\n%s\n",prog_name,strerror(errno));
-		printf("Finished formatting the device.\n");
-
-		if (!writenolabel) {
-			if (verbosity>0)
-				printf("Retrieving disk geometry... ");
-
-			rc=ioctl(fd,HDIO_GETGEO,&new_geometry);
-			if (rc) {
-				ERRMSG("%s: the ioctl call to get geometry " \
-					"returned with the following error " \
-					"message:\n%s\n",prog_name,
-					strerror(errno));
-				goto reread;
-			}
-	
-
-			rc=ioctl(fd,BLKSSZGET,&new_blksize);
-			if (rc) {
-				ERRMSG("%s: the ioctl call to get blocksize " \
-					"returned with the following error " \
-					"message:\n%s\n",prog_name,
-					strerror(errno));
-				goto reread;
-			}
-	
-			if (verbosity>0) printf("done\n");
-
-			label_position=new_geometry.start*new_blksize;
-	
-			if (verbosity>0) printf("Writing label... ");
-			convert_label(label);
-			rc=lseek(fd,label_position,SEEK_SET);
-			if (rc!=label_position) {
-				ERRMSG("%s: lseek on the device to %i " \
-					"failed with the following error " \
-					"message:\n%s\n",prog_name,
-					label_position,strerror(errno));
-				goto reread;
-			}
-			rc=write(fd,label,LABEL_LENGTH);
-			if (rc!=LABEL_LENGTH) {
-				ERRMSG("%s: writing the label only wrote %d " \
-					"bytes.\n",prog_name,rc);
-				goto reread;
-			}
-
-			sync();
-			sync();
-
-			if (verbosity>0) printf("done\n");
-		}
- reread:
-		printf("Rereading the partition table... ");
-		rc=ioctl(fd,BLKRRPART,NULL);
-		if (rc) {
-			ERRMSG("%s: error during rereading the partition " \
-			       "table: %s.\n",prog_name,strerror(errno));
-		} else printf("done.\n");
-
-		break;
-	}
-
-	rc=close(fd);
-	if (rc)
-		ERRMSG("%s: error during close: " \
-			"%s; continuing.\n",prog_name,strerror(errno));
-}
-
-
-
-int main(int argc,char *argv[]) {
-	int verbosity;
-	int testmode;
-	int withoutprompt;
-	int writenolabel,labelspec;
-
-	char *dev_name;
-	int devno;
-	char *dev_filename,*devno_param_str,*range_param_str;
-	char *start_param_str,*end_param_str,*blksize_param_str;
-	char label[LABEL_LENGTH+1];
-	
-	format_data_t format_params;
-
-	int rc;
-	int oc;
-	char *endptr;
-
-	char c1,c2,cbuffer[6]; /* should be able to contain -end plus 1 char */
-	int i,i1,i2;
-	char *str;
-
-	int start_specified,end_specified,blksize_specified;
-	int devfile_specified,devno_specified,range_specified;
-
-	/******************* initialization ********************/
-	prog_name=argv[0];
-
-	endptr=NULL;
-
-	/* set default values */
-	format_params.start_unit=DASD_FORMAT_DEFAULT_START_UNIT;
-	format_params.stop_unit=DASD_FORMAT_DEFAULT_STOP_UNIT;
-	format_params.blksize=DASD_FORMAT_DEFAULT_BLOCKSIZE;
-	format_params.intensity=DASD_FORMAT_DEFAULT_INTENSITY;
-	testmode=0;
-	verbosity=0;
-	withoutprompt=0;
-	writenolabel=0;
-	labelspec=0;
-	for (i=0;i<LABEL_LENGTH;i++) label[i]=' ';
-	label[LABEL_LENGTH]=0;
-
-	start_specified=end_specified=blksize_specified=0;
-	devfile_specified=devno_specified=range_specified=0;
-
-	/*************** parse parameters **********************/
-
-	/* avoid error message generated by getopt */
-	opterr=0;
-
-#ifdef RANGE_FORMATTING
-	while ( (oc=getopt(argc,argv,"r:s:e:b:n:l:f:ChLty?vV")) !=EOF) {
-#endif /* RANGE_FORMATTING */
-	while ( (oc=getopt(argc,argv,"b:n:l:f:ChLty?vV")) !=EOF) {
-		switch (oc) {
-		case 'y':
-			withoutprompt=1;
-			break;
-
-		case 't':
-			testmode=1;
-			break;
-
-		case 'v':
-			verbosity++;
-			break;
-
-		case '?': /* fall-through */
-		case ':':
-			exit_usage(EXIT_MISUSE);
-
-		case 'h':
-			exit_usage(0);
-		case 'C':
-                	format_params.intensity&=0x08;
-			break;
-
-		case 'V':
-			printf("%s version 0.99\n",prog_name);
-			exit(0);
-
-		case 'l':
-			strncpy(label,optarg,LABEL_LENGTH);
-			if (strlen(optarg)<LABEL_LENGTH)
-				label[strlen(optarg)]=' ';
-			labelspec++;
-			break;
-
-		case 'L':
-			writenolabel++;
-			break;
-
-#ifdef RANGE_FORMATTING
-		case 's' :
-			start_param_str=optarg;
-			start_specified++;
-			break;
-			
-		case 'e' :
-			end_param_str=optarg;
-			end_specified++;
-			break;
-
-		case 'r' :
-			range_param_str=optarg;
-			range_specified++;
-			break;
-#endif /* RANGE_FORMATTING */
-
-		case 'b' :
-			blksize_param_str=optarg;
-			blksize_specified++;
-			break;
-			
-		case 'n' :
-			devno_param_str=optarg;
-			devno_specified++;
-			break;
-		
-		case 'f' :
-			dev_filename=optarg;
-			devfile_specified++;
-			break;
-		}
-	}
-
-	/******************** checking of parameters **************/
-
-	/* convert range into -s and -e */
-	CHECK_SPEC_MAX_ONCE(range_specified,"formatting range");
-
-	while (range_specified) {
-		start_specified++;
-		end_specified++;
-
-		/* scan for 1 or 2 integers, separated by a dash */
-		rc=sscanf(range_param_str,"%d%c%d%c",&i1,&c1,&i2,&c2);
-		if ((rc==3)&&(c1=='-')) {
-			format_params.start_unit=i1;
-			format_params.stop_unit=i2;
-			break;
-		}
-		if (rc==1) {
-			format_params.start_unit=i1;
-			break;
-		}
-
-		/* scan for integer and -END */
-		rc=sscanf(range_param_str,"%d%s",&i1,cbuffer);
-		if ((rc==2)&&(!strcasecmp(cbuffer,"-END"))) {
-			format_params.start_unit=i1;
-			format_params.stop_unit=-1;
-			break;
-		}
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: specified range " \
-			"is in invalid format\n",prog_name);
-	}
-
-	if ((!devfile_specified)&&(!devno_specified))
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: device to format " \
-			"not specified\n",prog_name);
-
-	if ((devfile_specified+devno_specified)>1)
-		ERRMSG_EXIT(EXIT_MISUSE,"%s: device to format " \
-			"can only be specified once\n",prog_name);
-
-	if ((!start_specified)&&(!end_specified)&&(!range_specified)&&
-		(!blksize_specified)) {
-		format_params=ask_user_for_data(format_params);
-	}
-
-	CHECK_SPEC_MAX_ONCE(start_specified,"start track");
-	CHECK_SPEC_MAX_ONCE(end_specified,"end track");
-	CHECK_SPEC_MAX_ONCE(blksize_specified,"blocksize");
-	CHECK_SPEC_MAX_ONCE(labelspec,"label");
-	CHECK_SPEC_MAX_ONCE(writenolabel,"omit-label-writing flag");
-
-	if (devno_specified)
-		PARSE_PARAM_INTO(devno,devno_param_str,16,"device number");
-	if (start_specified&&!range_specified)
-		PARSE_PARAM_INTO(format_params.start_unit,start_param_str,10,
-			"start track");
-	if (end_specified&&!range_specified)
-		PARSE_PARAM_INTO(format_params.stop_unit,end_param_str,10,
-			"end track");
-	if (blksize_specified)
-		PARSE_PARAM_INTO(format_params.blksize,blksize_param_str,10,
-			"blocksize");
-
-	/***********get dev_name *********************/
-	dev_name=(devno_specified)?
-		get_devname_from_devno(devno,verbosity):
-		dev_filename;
-
-	/*** range checking *********/
-	str=check_param(CHECK_ALL,format_params);
-	if (str!=NULL) ERRMSG_EXIT(EXIT_MISUSE,"%s: %s\n",prog_name,str);
-
-	/******* issue the real command and reread part table *******/
-	do_format_dasd(dev_name,format_params,testmode,verbosity,
-		writenolabel,labelspec,label,withoutprompt,devno);
-
-	/*************** cleanup ********************************/
-	if (strncmp(dev_name,TEMPFILENAME,TEMPFILENAMECHARS)==0) {
-		rc=unlink(dev_name);
-		if ((rc)&&(verbosity>=1))
-			ERRMSG("%s: temporary device node %s could not be " \
-				"removed: %s\n",prog_name,dev_name,
-				strerror(errno));
-	} else {
-		if (devno_specified) {
-			/* so we have allocated space for the filename */
-			free(dev_name);
-		}
-	}
-
-	return 0;
-}
diff -urN linux/arch/s390x/tools/silo/Makefile linux-2.4.7/arch/s390x/tools/silo/Makefile
--- linux/arch/s390x/tools/silo/Makefile	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/tools/silo/Makefile	Wed Dec 31 19:00:00 1969
@@ -1,15 +0,0 @@
-all: silo
-
-silo.o: silo.c
-	$(CC) -c -o silo.o -O2 silo.c
-
-cfg.o: cfg.c
-	$(CC) -c -o cfg.o -O2 cfg.c
-
-silo: silo.o cfg.o
-	$(CC) -o $@ $^
-	$(STRIP) $@
-
-clean:
-	rm -f *.o silo
-
diff -urN linux/arch/s390x/tools/silo/cfg.c linux-2.4.7/arch/s390x/tools/silo/cfg.c
--- linux/arch/s390x/tools/silo/cfg.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/tools/silo/cfg.c	Wed Dec 31 19:00:00 1969
@@ -1,373 +0,0 @@
-/* cfg.c  -  Configuration file parser */
-
-/* Copyright 1992-1997 Werner Almesberger. See file COPYING for details. */
-
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include <string.h>
-
-#include "cfg.h"
-
-#define MAX_TOKEN 200
-#define MAX_VAR_NAME MAX_TOKEN
-
-static FILE *file;
-static char flag_set;
-static char *last_token = NULL,*last_item = NULL,*last_value = NULL;
-static int line_num;
-static char *file_name = NULL;
-static int back = 0; /* can go back by one char */
-
-
-void pdie(char *msg)
-{
-    fflush(stdout);
-    perror(msg);
-    exit(1);
-}
-
-
-void die(char *fmt,...)
-{
-    va_list ap;
-
-    fflush(stdout);
-    va_start(ap,fmt);
-    vfprintf(stderr,fmt,ap);
-    va_end(ap);
-    fputc('\n',stderr);
-    exit(1);
-}
-
-char *pstrdup(const char *str)
-{
-    char *this;
-
-    if ((this = strdup(str)) == NULL) pdie("Out of memory");
-    return this;
-}
-
-int cfg_open(char *name)
-{
-    if (!strcmp(name,"-")) file = stdin;
-    else if (!(file = fopen(file_name = name,"r"))) pdie(name);
-    line_num = 1;
-    return fileno(file);
-}
-
-void cfg_error(char *msg,...)
-{
-    va_list ap;
-
-    fflush(stdout);
-    va_start(ap,msg);
-    vfprintf(stderr,msg,ap);
-    va_end(ap);
-    if (!file_name) fputc('\n',stderr);
-    else fprintf(stderr," near line %d in file %s\n",line_num,file_name);
-    exit(1);
-}
-
-
-static int next_raw(void)
-{
-    int ch;
-
-    if (!back) return getc(file);
-    ch = back;
-    back = 0;
-    return ch;
-}
-
-
-static int next(void)
-{
-    static char *var;
-    char buffer[MAX_VAR_NAME+1];
-    int ch,braced;
-    char *put;
-
-    if (back) {
-	ch = back;
-	back = 0;
-	return ch;
-    }
-    if (var && *var) return *var++;
-    ch = getc(file);
-    if (ch == '\\') {
-	ch = getc(file);
-	if (ch == '$') return ch;
-	ungetc(ch,file);
-	return '\\';
-    }
-    if (ch != '$') return ch;
-    ch = getc(file);
-    braced = ch == '{';
-    put = buffer;
-    if (!braced) *put++ = ch;
-    while (1) {
-	ch = getc(file);
-#if 0
-	if (!braced && ch < ' ') {
-	    ungetc(ch,file);
-	    break;
-	}
-#endif
-	if (ch == EOF) cfg_error("EOF in variable name");
-	if (ch < ' ') cfg_error("control character in variable name");
-	if (braced && ch == '}') break;
-	if (!braced && !isalpha(ch) && !isdigit(ch) && ch != '_') {
-	    ungetc(ch,file);
-	    break;
-	}
-	if (put-buffer == MAX_VAR_NAME) cfg_error("variable name too long");
-	*put++ = ch;
-    }
-    *put = 0;
-    if (!(var = getenv(buffer))) cfg_error("unknown variable \"%s\"",buffer);
-    return next();
-}
-
-
-static void again(int ch)
-{
-    if (back) die("internal error: again invoked twice");
-    back = ch;
-}
-
-
-static char *cfg_get_token(void)
-{
-    char buf[MAX_TOKEN+1];
-    char *here;
-    int ch,escaped;
-
-    if (last_token) {
-	here = last_token;
-	last_token = NULL;
-	return here;
-    }
-    while (1) {
-	while ((ch = next()), ch == ' ' || ch == '\t' || ch == '\n')
-	    if (ch == '\n') line_num++;
-	if (ch == EOF) return NULL;
-	if (ch != '#') break;
-	while ((ch = next_raw()), ch != '\n')
-	    if (ch == EOF) return NULL;
-	line_num++;
-    }
-    if (ch == '=') return pstrdup("=");
-    if (ch == '"') {
-	here = buf;
-	while (here-buf < MAX_TOKEN) {
-	    if ((ch = next()) == EOF) cfg_error("EOF in quoted string");
-	    if (ch == '"') {
-		*here = 0;
-		return pstrdup(buf);
-	    }
-	    if (ch == '\\') {
-		ch = next();
-		if (ch != '"' && ch != '\\' && ch != '\n')
-		    cfg_error("Bad use of \\ in quoted string");
-		if (ch == '\n') {
-		    while ((ch = next()), ch == ' ' || ch == '\t');
-		    if (!ch) continue;
-		    again(ch);
-		    ch = ' ';
-		}
-	    }
-	    if (ch == '\n' || ch == '\t')
-		cfg_error("\\n and \\t are not allowed in quoted strings");
-	    *here++ = ch;
-	}
-	cfg_error("Quoted string is too long");
-	return 0; /* not reached */
-    }
-    here = buf;
-    escaped = 0;
-    while (here-buf < MAX_TOKEN) {
-	if (escaped) {
-	    if (ch == EOF) cfg_error("\\ precedes EOF");
-	    if (ch == '\n') line_num++;
-	    else *here++ = ch == '\t' ? ' ' : ch;
-	    escaped = 0;
-	}
-	else {
-	    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '#' ||
-	      ch == '=' || ch == EOF) {
-		again(ch);
-		*here = 0;
-		return pstrdup(buf);
-	    }
-	    if (!(escaped = (ch == '\\'))) *here++ = ch;
-	}
-	ch = next();
-    }
-    cfg_error("Token is too long");
-    return 0; /* not reached */
-}
-
-
-static void cfg_return_token(char *token)
-{
-    last_token = token;
-}
-
-
-static int cfg_next(char **item,char **value)
-{
-    char *this;
-
-    if (last_item) {
-	*item = last_item;
-	*value = last_value;
-	last_item = NULL;
-	return 1;
-    }
-    *value = NULL;
-    if (!(*item = cfg_get_token())) return 0;
-    if (!strcmp(*item,"=")) cfg_error("Syntax error");
-    if (!(this = cfg_get_token())) return 1;
-    if (strcmp(this,"=")) {
-	cfg_return_token(this);
-	return 1;
-    }
-    if (!(*value = cfg_get_token())) cfg_error("Value expected at EOF");
-    if (!strcmp(*value,"=")) cfg_error("Syntax error after %s",*item);
-    return 1;
-}
-
-
-static void cfg_return(char *item,char *value)
-{
-    last_item = item;
-    last_value = value;
-}
-
-
-void cfg_init(CONFIG *table)
-{
-    while (table->type != cft_end) {
-	switch (table->type) {
-	    case cft_strg:
-		if (table->data) free(table->data);
-	    case cft_flag:
-		table->data = NULL;
-		break;
-	    case cft_link:
-		table = ((CONFIG *) table->action)-1;
-		break;
-	    default:
-		die("Unknown syntax code %d",table->type);
-	}
-	table++;
-    }
-}
-
-
-static int cfg_do_set(CONFIG *table,char *item,char *value,int copy,
-    void *context)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (value && walk->type != cft_strg)
-		cfg_error("'%s' doesn't have a value",walk->name);
-	    if (!value && walk->type == cft_strg)
-		cfg_error("Value expected for '%s'",walk->name);
-	    if (walk->data) {
-		if (walk->context == context)
-		    cfg_error("Duplicate entry '%s'",walk->name);
-		else {
-		    fprintf(stderr,"Ignoring entry '%s'\n",walk->name);
-		    if (!copy) free(value);
-		    return 1;
-		}
-	    }
-	    if (walk->type == cft_flag) walk->data = &flag_set;
-	    else if (walk->type == cft_strg) {
-		    if (copy) walk->data = pstrdup(value);
-		    else walk->data = value;
-	    }
-	    walk->context = context;
-	    if (walk->action) ((void (*)(void)) walk->action)();
-	    break;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    if (walk->type != cft_end) return 1;
-    cfg_return(item,value);
-    return 0;
-}
-
-
-void cfg_set(CONFIG *table,char *item,char *value,void *context)
-{
-    if (!cfg_do_set(table,item,value,1,context))
-	cfg_error("cfg_set: Can't set %s",item);
-}
-
-
-void cfg_unset(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++)
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (!walk->data) die("internal error (cfg_unset %s, unset)",item);
-	    if (walk->type == cft_strg) free(walk->data);
-	    walk->data = NULL;
-	    return;
-	}
-    die("internal error (cfg_unset %s, unknown",item);
-}
-
-
-int cfg_parse(CONFIG *table)
-{
-    char *item,*value;
-
-    while (1) {
-	if (!cfg_next(&item,&value)) return 0;
-	if (!cfg_do_set(table,item,value,0,table)) return 1;
-	free(item);
-    }
-}
-
-
-int cfg_get_flag(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (walk->type != cft_flag)
-		die("cfg_get_flag: operating on non-flag %s",item);
-	    return !!walk->data;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    die("cfg_get_flag: unknown item %s",item);
-    return 0; /* not reached */
-}
-
-
-char *cfg_get_strg(CONFIG *table,char *item)
-{
-    CONFIG *walk;
-
-    for (walk = table; walk->type != cft_end; walk++) {
-	if (walk->name && !strcasecmp(walk->name,item)) {
-	    if (walk->type != cft_strg)
-		die("cfg_get_strg: operating on non-string %s",item);
-	    return walk->data;
-	}
-	if (walk->type == cft_link) walk = ((CONFIG *) walk->action)-1;
-    }
-    die("cfg_get_strg: unknown item %s",item);
-    return 0; /* not reached */
-}
diff -urN linux/arch/s390x/tools/silo/cfg.h linux-2.4.7/arch/s390x/tools/silo/cfg.h
--- linux/arch/s390x/tools/silo/cfg.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/tools/silo/cfg.h	Wed Dec 31 19:00:00 1969
@@ -1,58 +0,0 @@
-/* cfg.h  -  Configuration file parser */
-
-/* Copyright 1992-1996 Werner Almesberger. See file COPYING for details. */
-
-
-#ifndef CFG_H
-#define CFG_H
-
-typedef enum { cft_strg, cft_flag, cft_link, cft_end } CFG_TYPE;
-
-typedef struct {
-    CFG_TYPE type;
-    char *name;
-    void *action;
-    void *data;
-    void *context;
-} CONFIG;
-
-extern int cfg_open(char *name);
-
-/* Opens the configuration file. Returns the file descriptor of the open
-   file. */
-
-extern void cfg_error(char *msg,...);
-
-/* Signals an error while parsing the configuration file and terminates the
-   program. */
-
-extern void cfg_init(CONFIG *table);
-
-/* Initializes the specified table. */
-
-extern void cfg_set(CONFIG *table,char *item,char *value,void *context);
-
-/* Sets the specified variable in table. If the variable has already been set
-   since the last call to cfg_init, a warning message is issued if the context
-   keys don't match or a fatal error is reported if they do. */
-
-extern void cfg_unset(CONFIG *table,char *item);
-
-/* Unsets the specified variable in table. It is a fatal error if the variable
-   was not set. */
-
-extern int cfg_parse(CONFIG *table);
-
-/* Parses the configuration file for variables contained in table. A non-zero
-   value is returned if a variable not found in table has been met. Zero is
-   returned if EOF has been reached. */
-
-extern int cfg_get_flag(CONFIG *table,char *item);
-
-/* Returns one if the specified variable is set, zero if it isn't. */
-
-extern char *cfg_get_strg(CONFIG *table,char *item);
-
-/* Returns the value of the specified variable if it is set, NULL otherwise. */
-
-#endif
diff -urN linux/arch/s390x/tools/silo/silo.c linux-2.4.7/arch/s390x/tools/silo/silo.c
--- linux/arch/s390x/tools/silo/silo.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/arch/s390x/tools/silo/silo.c	Wed Dec 31 19:00:00 1969
@@ -1,586 +0,0 @@
-/*
- *  arch/s390/boot/silo.c
- *
- *  S390 version
- *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *
- *    Report bugs to: <linux390@de.ibm.com>
- *
- *    Author(s): Holger Smolinski <Holger.Smolinski@de.ibm.com>
- *               Fritz Elfert <felfert@to.com> contributed support for
- *                	/etc/silo.conf based on Intel's lilo
- *    Changes  :
- *               01/15/01 Holger Smolinski <Holger.Smolinski@de.ibm.com>
- *                 adapted to deal with devices and bootsects of various sizes
- */
-
-#include <stddef.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <limits.h>
-#include <dirent.h>
-#include <linux/fs.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <asm/ioctl.h>
-
-#include "cfg.h"
-
-CONFIG cf_options[] = {
-  { cft_strg, "append",		NULL,		NULL,NULL },
-  { cft_strg, "image",		NULL,		NULL,NULL },
-  { cft_strg, "ipldevice",	NULL,		NULL,NULL },
-  { cft_strg, "bootsect",	NULL,		NULL,NULL },
-  { cft_strg, "map",		NULL,		NULL,NULL },
-  { cft_strg, "parmfile",	NULL,		NULL,NULL },
-  { cft_strg, "ramdisk",	NULL,		NULL,NULL },
-  { cft_strg, "root",		NULL,		NULL,NULL },
-  { cft_flag, "readonly",	NULL,		NULL,NULL },
-  { cft_strg, "verbose",	NULL,		NULL,NULL },
-  { cft_strg, "testlevel",	NULL,		NULL,NULL },
-  { cft_end,  NULL,		NULL,		NULL,NULL }
-};
-  
-/* from dasd.h */
-#define DASD_PARTN_BITS 2
-#define BIODASDRWTB _IOWR('D',0,int)
-/* end */
-
-#define SILO_CFG "/etc/silo.conf"
-#define SILO_IMAGE "./image"
-#define SILO_BOOTMAP "./boot.map"
-#define SILO_PARMFILE "./parmfile"
-#define SILO_BOOTSECT "/boot/ipleckd.boot"
-
-#define PRINT_LEVEL(x,y...) if ( silo_options.verbosity >= x ) printf(y)
-#define ERROR_LEVEL(x,y...) if ( silo_options.verbosity >= x ) fprintf(stderr,y)
-#define TOGGLE(x) ((x)=((x)?(0):(1)))
-#define GETARG(x) {int len=strlen(optarg);x=malloc(len);strncpy(x,optarg,len);PRINT_LEVEL(1,"%s set to %s\n",#x,optarg);}
-
-#define ITRY(x) if ( (x) == -1 ) { ERROR_LEVEL(0,"%s (line:%d) '%s' returned %d='%s'\n", __FILE__,__LINE__,#x,errno,strerror(errno)); usage(); exit(1); }
-#define NTRY(x) if ( (x) == 0 ) { ERROR_LEVEL(0,"%s (line:%d) '%s' returned %d='%s'\n", __FILE__,__LINE__,#x,errno,strerror(errno)); usage(); exit(1); }
-
-#define MAX_CLUSTERS 256
-#define PARTN_MASK ((1 << DASD_PARTN_BITS) - 1)
-
-#define SILO_VERSION "1.1"
-
-struct silo_options
-  {
-    short int verbosity;
-    short int testlevel;
-    char *image;
-    char *ipldevice;
-    char *parmfile;
-    char *ramdisk;
-    char *bootsect;
-    char *conffile;
-    char *bootmap;
-  }
-silo_options =
-{
-  1,				/* verbosity */
-  2,				/* testlevel */
-    SILO_IMAGE,			/* image */
-    NULL,			/* ipldevice */
-    SILO_PARMFILE,		/* parmfile */
-    NULL,			/* initrd */
-    SILO_BOOTSECT,		/* bootsector */
-    SILO_CFG,                   /* silo.conf file */
-    SILO_BOOTMAP,               /* boot.map */
-};
-
-struct blockdesc
-  {
-    unsigned long off;
-    unsigned short ct;
-    unsigned long addr;
-  };
-
-struct blocklist
-  {
-    struct blockdesc blk[MAX_CLUSTERS];
-    unsigned short ix;
-  };
-
-void
-usage (void)
-{
-  printf ("Usage:\n");
-  printf ("silo -d ipldevice [additional options]\n");
-  printf ("-d /dev/node : set ipldevice to /dev/node\n");
-  printf ("-f image : set image to image\n");
-  printf ("-F conffile : specify configuration file (/etc/silo.conf)\n");
-  printf ("-p parmfile : set parameter file to parmfile\n");
-  printf ("-b bootsect : set bootsector to bootsect\n");
-  printf ("Additional options\n");
-  printf ("-B bootmap:\n");
-  printf ("-v: increase verbosity level\n");
-  printf ("-v#: set verbosity level to #\n");
-  printf ("-t: decrease testing level\n");
-  printf ("-h: print this message\n");
-  printf ("-?: print this message\n");
-  printf ("-V: print version\n");
-}
-
-int
-read_cfg(struct silo_options *o)
-{
-	char *tmp;
-	if (access(o->conffile, R_OK) && (errno == ENOENT))
-		return 0;
-	/* If errno != ENOENT, let cfg_open report an error */
-	cfg_open(o->conffile);
-	cfg_parse(cf_options);
-	tmp = cfg_get_strg(cf_options, "ipldevice");
-	if ( ! o->ipldevice  && tmp ) 
-		o->ipldevice = tmp;
-	tmp = cfg_get_strg(cf_options, "image");
-	if ( ! strncmp(o-> image,SILO_IMAGE,strlen(SILO_IMAGE)) && tmp ) 
-		o->image = tmp;
-	tmp = cfg_get_strg(cf_options, "parmfile");
-	if ( !strncmp(o->parmfile,SILO_PARMFILE,strlen(SILO_PARMFILE)) && tmp) 
-		o->parmfile = tmp;
-	if ( ! o -> ramdisk ) 
-		o->ramdisk = cfg_get_strg(cf_options, "ramdisk");
-	tmp = cfg_get_strg(cf_options, "bootsect");
-	if ( !strncmp(o -> bootsect,SILO_BOOTSECT,strlen(SILO_BOOTSECT))&&tmp)
-		o->bootsect = tmp;
-	tmp = cfg_get_strg(cf_options, "map") ;
-	if ( !strncmp(o -> bootmap,SILO_BOOTMAP,strlen(SILO_BOOTMAP)) && tmp) 
-		o->bootmap = tmp; 
-	tmp = cfg_get_strg(cf_options, "verbose");
-	if ( tmp ) {
-		unsigned short v;
-		sscanf (tmp, "%hu", &v);
-		o->verbosity = v;
-	}
-	tmp = cfg_get_strg(cf_options, "testlevel");
-	if ( tmp ) {
-		unsigned short t;
-		sscanf (tmp, "%hu", &t);
-		o->testlevel += t;
-	}
-	return 1;
-}
-
-char *
-gen_tmpparm( char *pfile )
-{
-	char *append = cfg_get_strg(cf_options, "append");
-	char *root = cfg_get_strg(cf_options, "root");
-	int ro = cfg_get_flag(cf_options, "readonly");
-	FILE *f,*of;
-	char *fn;
-	char c;
-	char *tmpdir=NULL,*save=NULL;
-
-	if (!append && !root && !ro)
-		return pfile;
-	of = fopen(pfile, "r");
-	if ( of ) {
-		NTRY( fn = tempnam(NULL,"parm."));
-	} else {
-		fn = pfile;
-	}
-	NTRY( f = fopen(fn, "a+"));
-	if ( of ) {
-		while ( ! feof (of) ) {
-		  c=fgetc(of);
-	  	fputc(c,f);
-		}
-	}
-	if (root)
-		fprintf(f, " root=%s", root);
-	if (ro)
-		fprintf(f, " ro");
-	if (append)
-		fprintf(f, " %s", append);
-	fprintf(f, "\n");
-	fclose(f);
-	fclose(of);
-	printf ("tempfile is %s\n",fn);
-	return strdup(fn);
-}
-
-int
-parse_options (struct silo_options *o, int argc, char *argv[])
-{
-  int rc = 0;
-  int oc;
-
-  while ((oc = getopt (argc, argv, "Vf:F:d:p:r:b:B:h?v::t::")) != -1)
-    {
-      switch (oc)
-	{
-	case 'V':
-	  printf("silo version: %s\n",SILO_VERSION);
-	  exit(0);
-	case 'v':
-	  {
-	    unsigned short v;
-	    if (optarg && sscanf (optarg, "%hu", &v))
-	      o->verbosity = v;
-	    else
-	      o->verbosity++;
-	    PRINT_LEVEL (1, "Verbosity value is now %hu\n", o->verbosity);
-	    break;
-	  }
-	case 't':
-	  {
-	    unsigned short t;
-	    if (optarg && sscanf (optarg, "%hu", &t))
-	      o->testlevel -= t;
-	    else
-	      o->testlevel--;
-            PRINT_LEVEL (1, "Testonly flag is now %d\n", o->testlevel);
-	    break;
-	  }
-	case 'h':
-	case '?':
-	  usage ();
-	  exit(0);
-	case 'd':
-	  GETARG (o->ipldevice);
-	  break;
-	case 'f':
-	  GETARG (o->image);
-	  break;
-        case 'F':                         
- 	   GETARG (o->conffile);              
- 	   break;                          
-	case 'p':
-	  GETARG (o->parmfile);
-	  break;
-	case 'r':
-	  GETARG (o->ramdisk);
-	  break;
-	case 'b':
-	  GETARG (o->bootsect);
-	  break;
-	case 'B':
-	  GETARG (o->bootmap);
-	default:
-	  rc = EINVAL;
-	  break;
-	}
-    }
-  read_cfg(o);
-  return rc;
-}
-
-int
-verify_device (char *name)
-{
-  int rc = 0;
-  struct stat dst;
-  struct stat st;
-  ITRY (stat (name, &dst));
-  if (S_ISBLK (dst.st_mode))
-    {
-      if (!(MINOR (dst.st_rdev) & PARTN_MASK))
-	{
-	  rc = dst.st_rdev;
-	}
-      else
-	/* invalid MINOR & PARTN_MASK */
-	{
-	  ERROR_LEVEL (1, "Cannot boot from partition %d %d %d",
-		       (int) PARTN_MASK, (int) MINOR (dst.st_rdev), (int) (PARTN_MASK & MINOR (dst.st_rdev)));
-	  rc = -1;
-	  errno = EINVAL;
-	}
-    }
-  else
-    /* error S_ISBLK */
-    {
-      ERROR_LEVEL (1, "%s is no block device\n", name);
-      rc = -1;
-      errno = EINVAL;
-    }
-  return rc;
-}
-
-int
-verify_file (char *name, int dev)
-{
-  int rc = 0;
-  struct stat dst;
-  struct stat st;
-  int bs = 1024;
-  int l;
-
-  ITRY(stat ( name, &dst ));
-  if (S_ISREG (dst.st_mode))
-    {
-      if ((unsigned) MAJOR (dev) == (unsigned) MAJOR (dst.st_dev) && (unsigned) MINOR (dev) == (unsigned) (MINOR (dst.st_dev) & ~PARTN_MASK))
-	{
-	  /* whatever to do if all is ok... */
-	}
-      else
-	/* devicenumber doesn't match */
-	{
-	  ERROR_LEVEL (1, "%s is not on device (%d/%d) but on (%d/%d)\n", name, (unsigned) MAJOR (dev), (unsigned) MINOR (dev), (unsigned) MAJOR (dst.st_dev), (unsigned) (MINOR (dst.st_dev) & ~PARTN_MASK));
-	  rc = -1;
-	  errno = EINVAL;
-	}
-    }
-  else
-    /* error S_ISREG */
-    {
-      ERROR_LEVEL (1, "%s is neither regular file nor linkto one\n", name);
-      rc = -1;
-      errno = EINVAL;
-    }
-  return rc;
-}
-
-int
-verify_options (struct silo_options *o)
-{
-  int rc = 0;
-  int dev = 0;
-  int crc = 0;
-  if (!o->ipldevice || !o->image || !o->bootsect)
-    {
-     if (!o->ipldevice)
-       fprintf(stderr,"ipldevice\n");
-     if (!o->image)
-       fprintf(stderr,"image\n");
-     if (!o->bootsect)
-       fprintf(stderr,"bootsect\n");
-
-      usage ();
-      exit (1);
-    }
-  PRINT_LEVEL (1, "Testlevel is set to %d\n",o->testlevel);
-
-  PRINT_LEVEL (1, "IPL device is: '%s'", o->ipldevice);
-  ITRY (dev = verify_device (o->ipldevice));
-  PRINT_LEVEL (2, "...ok...(%d/%d)", (unsigned short) MAJOR (dev), (unsigned short) MINOR (dev));
-  PRINT_LEVEL (1, "\n");
-
-  PRINT_LEVEL (0, "bootsector is: '%s'", o->bootsect);
-  ITRY (verify_file (o->bootsect, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  if ( o -> testlevel > 0  && 
-       ! strncmp( o->bootmap, SILO_BOOTMAP,strlen(SILO_BOOTMAP) )) {
-     NTRY( o -> bootmap = tempnam(NULL,"boot."));
-  }
-  PRINT_LEVEL (0, "bootmap is set to: '%s'", o->bootmap);
-  if ( access ( o->bootmap, O_RDWR ) == -1 ) {
-    if ( errno == ENOENT ) {
-      ITRY (creat ( o-> bootmap, O_RDWR ));
-    } else {
-      PRINT_LEVEL(1,"Cannot access bootmap file '%s': %s\n",o->bootmap,
-		  strerror(errno));
-    }
-  }
-  ITRY (verify_file (o->bootmap, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  PRINT_LEVEL (0, "Kernel image is: '%s'", o->image);
-  ITRY (verify_file (o->image, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  PRINT_LEVEL (0, "original parameterfile is: '%s'", o->parmfile);
-  ITRY (verify_file (o->parmfile, dev));
-  PRINT_LEVEL (1, "...ok...");
-  o->parmfile = gen_tmpparm(o->parmfile);
-  PRINT_LEVEL (0, "final parameterfile is: '%s'", o->parmfile);
-  ITRY (verify_file (o->parmfile, dev));
-  PRINT_LEVEL (1, "...ok...");
-  PRINT_LEVEL (0, "\n");
-
-  if (o->ramdisk)
-    {
-      PRINT_LEVEL (0, "initialramdisk is: '%s'", o->ramdisk);
-      ITRY (verify_file (o->ramdisk, dev));
-      PRINT_LEVEL (1, "...ok...");
-      PRINT_LEVEL (0, "\n");
-    }
-
-  return crc;
-}
-
-
-int
-add_file_to_blocklist (char *name, struct blocklist *lst, long addr)
-{
-  int fd;
-  int devfd;
-  struct stat fst;
-  int i;
-  int blk;
-  int bs;
-  int blocks;
-
-  int rc = 0;
-
-  ITRY (fd = open (name, O_RDONLY));
-  ITRY (fstat (fd, &fst));
-  ITRY (mknod ("/tmp/silodev", S_IFBLK | S_IRUSR | S_IWUSR, fst.st_dev));
-  ITRY (devfd = open ("/tmp/silodev", O_RDONLY));
-  ITRY (ioctl (fd, FIGETBSZ, &bs));
-  blocks = (fst.st_size + bs - 1) / bs;
-  for (i = 0; i < blocks; i++)
-    {
-      blk = i;
-      ITRY (ioctl (fd, FIBMAP, &blk));
-      if (blk)
-	{
-	  int oldblk = blk;
-	  ITRY (ioctl (devfd, BIODASDRWTB, &blk));
-	  if (blk <= 0)
-	    {
-	      ERROR_LEVEL (0, "BIODASDRWTB on blk %d returned %d\n", oldblk, blk);
-	      break;
-	    }
-	}
-      else
-	{
-	  PRINT_LEVEL (1, "Filled hole on blk %d\n", i);
-	}
-      if (lst->ix == 0 || i == 0  || 
-	  lst->blk[lst->ix - 1].ct >= 128 ||
-	  (lst->blk[lst->ix - 1].off + lst->blk[lst->ix - 1].ct != blk &&
-	   !(lst->blk[lst->ix - 1].off == 0 && blk == 0)))
-	{
-	  if (lst->ix >= MAX_CLUSTERS)
-	    {
-	      rc = 1;
-	      errno = ENOMEM;
-	      break;
-	    }
-	  lst->blk[lst->ix].off = blk;
-	  lst->blk[lst->ix].ct = 1;
-	  lst->blk[lst->ix].addr = addr + i * bs;
-	  lst->ix++;
-	}
-      else
-	{
-	  lst->blk[lst->ix - 1].ct++;
-	}
-    }
-  ITRY(unlink("/tmp/silodev"));
-  return rc;
-}
-
-int
-write_bootsect (struct silo_options *o, struct blocklist *blklst)
-{
-  int i;
-  int s_fd, d_fd, b_fd, bd_fd;
-  struct stat s_st, d_st, b_st;
-  int rc=0;
-  int bs, boots;
-  char *tmpdev;
-  char buffer[4096]={0,};
-  int blocksize, sectsize;
-  ITRY (d_fd = open (o->ipldevice, O_RDWR | O_SYNC));
-  ITRY (fstat (d_fd, &d_st));
-  ITRY (s_fd = open (o->bootmap, O_RDWR | O_TRUNC | O_CREAT | O_SYNC));
-  ITRY (verify_file (o->bootsect, d_st.st_rdev));
-  for (i = 0; i < blklst->ix; i++)
-    {
-      int offset = blklst->blk[i].off;
-      int addrct = blklst->blk[i].addr | (blklst->blk[i].ct & 0xff);
-      PRINT_LEVEL (1, "ix %i: offset: %06x count: %02x address: 0x%08x\n", i, offset, blklst->blk[i].ct & 0xff, blklst->blk[i].addr);
-	if ( o->testlevel <= 1 ) {
-	      NTRY (write (s_fd, &offset, sizeof (int)));
-	      NTRY (write (s_fd, &addrct, sizeof (int)));
-	}
-    }
-  ITRY (ioctl (s_fd,FIGETBSZ, &bs));
-  ITRY (stat (o->bootmap, &s_st));
-  if (s_st.st_size > bs )
-    {
-      ERROR_LEVEL (0,"%s is larger than one block\n", o->bootmap);
-      rc = -1;
-      errno = EINVAL;
-    }
-  boots=0;
-  NTRY ( tmpdev = tmpnam(NULL) );
-  ITRY (mknod (tmpdev, S_IFBLK | S_IRUSR | S_IWUSR, s_st.st_dev));
-  ITRY (bd_fd = open (tmpdev, O_RDONLY));
-  ITRY (ioctl(bd_fd,BLKSSZGET,&blocksize));
-  ITRY (ioctl(s_fd,FIBMAP,&boots));
-  ITRY (ioctl (bd_fd, BIODASDRWTB, &boots));
-  PRINT_LEVEL (1, "Bootmap is in block no: 0x%08x\n", boots);
-  close (bd_fd);
-  close(s_fd);
-  ITRY (unlink(tmpdev));
-  /* Now patch the bootsector */
-  ITRY (stat (o->bootsect, &b_st));
-  if ((sectsize = b_st.st_size) > blocksize )
-    {
-      ERROR_LEVEL (0,"Bootsector is larger than sectorsize of volume %d vs %d\n", sectsize, blocksize);
-      rc = -1;
-      errno = EINVAL;
-    }
-  ITRY (b_fd = open (o->bootsect, O_RDONLY));
-  ITRY (read (b_fd, buffer, sectsize));
-  memset (buffer + 0xe0, 0, 8);
-  *(int *) (buffer + 0xe0) = boots;
-  if ( o -> testlevel <= 0 ) {
-    ITRY (write (d_fd, buffer, sectsize));
-    ITRY (lseek (d_fd, blocksize, SEEK_SET));
-    ITRY (write (d_fd, buffer, sectsize));
-  }
-  close (b_fd);
-  close (d_fd);
-  return rc;
-}
-
-int
-do_silo (struct silo_options *o)
-{
-  int rc = 0;
-
-  int device_fd;
-  int image_fd;
-  struct blocklist blklist;
-  memset (&blklist, 0, sizeof (struct blocklist));
-  ITRY (add_file_to_blocklist (o->image, &blklist, 0x00000000));
-  if (o->parmfile)
-    {
-      ITRY (add_file_to_blocklist (o->parmfile, &blklist, 0x00008000));
-    }
-  if (o->ramdisk)
-    {
-      ITRY (add_file_to_blocklist (o->ramdisk, &blklist, 0x00800000));
-    }
-  ITRY (write_bootsect (o, &blklist));
-  return rc;
-}
-
-int
-main (int argct, char *argv[])
-{
-  int rc = 0;
-  char *save=NULL;
-  char *tmpdir=getenv("TMPDIR");
-  if (tmpdir) {
-    NTRY( save=(char*)malloc(strlen(tmpdir)));
-    NTRY( strncpy(save,tmpdir,strlen(tmpdir)));
-  }
-  ITRY( setenv("TMPDIR",".",1));
-  ITRY (parse_options (&silo_options, argct, argv));
-  ITRY (verify_options (&silo_options));
-  if ( silo_options.testlevel > 0 ) {
-    printf ("WARNING: silo does not modify your volume. Use -t2 to change IPL records\n");
-  }
-  ITRY (do_silo (&silo_options));
-  if ( save )
-    ITRY( setenv("TMPDIR",save,1)); 
-  return rc;
-}
diff -urN linux/arch/s390x/tools/silo/silo.conf linux-2.4.7/arch/s390x/tools/silo/silo.conf
--- linux/arch/s390x/tools/silo/silo.conf	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/arch/s390x/tools/silo/silo.conf	Wed Dec 31 19:00:00 1969
@@ -1,7 +0,0 @@
-ipldevice = /dev/dasda 
-image = /boot/image
-bootsect = /boot/ipleckd.boot
-map = /boot/boot.map
-root = /dev/dasd01
-readonly
-append = "dasd=200-20f noinitrd"
diff -urN linux/arch/s390x/vmlinux-shared.lds linux-2.4.7/arch/s390x/vmlinux-shared.lds
--- linux/arch/s390x/vmlinux-shared.lds	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/arch/s390x/vmlinux-shared.lds	Mon Dec 17 13:41:19 2001
@@ -0,0 +1,84 @@
+/* ld script to make s390 Linux kernel
+ * Written by Martin Schwidefsky (schwidefsky@de.ibm.com)
+ */
+OUTPUT_FORMAT("elf64-s390", "elf64-s390", "elf64-s390")
+OUTPUT_ARCH(s390)
+ENTRY(_start)
+SECTIONS
+{
+  . = 0x00000000;
+  _text = .;			/* Text and read-only data */
+  .text : {
+	*(.text)
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x0700
+  .text.lock : { *(.text.lock) }	/* out-of-line lock text */
+  .rodata : { *(.rodata) }
+  .kstrtab : { *(.kstrtab) }
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  __start___ksymtab = .;	/* Kernel symbol table */
+  __ksymtab : { *(__ksymtab) }
+  __stop___ksymtab = .;
+
+  __start___kallsyms = .;       /* All kernel symbols */
+  __kallsyms : { *(__kallsyms) }
+  __stop___kallsyms = .;
+
+  . = ALIGN(1048576);		/* VM shared segments are 1MB aligned */
+
+  _etext = .;			/* End of text section */
+
+  .data : {			/* Data */
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(16384);		/* init_task */
+  .data.init_task : { *(.data.init_task) }
+
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .text.init : { *(.text.init) }
+  .data.init : { *(.data.init) }
+  . = ALIGN(4096);
+  __init_end = .;
+
+  __setup_start = .;
+  .setup.init : { *(.setup.init) }
+  __setup_end = .;
+  __initcall_start = .;
+  .initcall.init : { *(.initcall.init) }
+  __initcall_end = .;
+  . = ALIGN(4096);
+  __init_end = .;
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
+
+  __bss_start = .;		/* BSS */
+  .bss : {
+	*(.bss)
+	}
+  _end = . ;
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -urN linux/drivers/block/Makefile linux-2.4.7/drivers/block/Makefile
--- linux/drivers/block/Makefile	Fri Dec 29 17:07:21 2000
+++ linux-2.4.7/drivers/block/Makefile	Mon Dec 17 13:41:19 2001
@@ -10,7 +10,7 @@
 
 O_TARGET := block.o
 
-export-objs	:= ll_rw_blk.o blkpg.o loop.o DAC960.o
+export-objs	:= ll_rw_blk.o blkpg.o elevator.o loop.o DAC960.o
 
 obj-y	:= ll_rw_blk.o blkpg.o genhd.o elevator.o
 
diff -urN linux/drivers/block/elevator.c linux-2.4.7/drivers/block/elevator.c
--- linux/drivers/block/elevator.c	Thu Jul 19 23:59:41 2001
+++ linux-2.4.7/drivers/block/elevator.c	Mon Dec 17 13:41:19 2001
@@ -220,3 +220,11 @@
 	*elevator = type;
 	elevator->queue_ID = queue_ID++;
 }
+
+EXPORT_SYMBOL(elevator_init);
+EXPORT_SYMBOL(elevator_linus_merge);
+EXPORT_SYMBOL(elevator_linus_merge_cleanup);
+EXPORT_SYMBOL(elevator_linus_merge_req);
+EXPORT_SYMBOL(elevator_noop_merge);
+EXPORT_SYMBOL(elevator_noop_merge_cleanup);
+EXPORT_SYMBOL(elevator_noop_merge_req);
diff -urN linux/drivers/block/loop.c linux-2.4.7/drivers/block/loop.c
--- linux/drivers/block/loop.c	Fri Jun 29 19:16:56 2001
+++ linux-2.4.7/drivers/block/loop.c	Mon Dec 17 13:41:19 2001
@@ -176,6 +176,8 @@
 	unsigned size, offset;
 	int len;
 
+	down(&(file->f_dentry->d_inode->i_sem));
+
 	index = pos >> PAGE_CACHE_SHIFT;
 	offset = pos & (PAGE_CACHE_SIZE - 1);
 	len = bh->b_size;
@@ -206,6 +208,7 @@
 		deactivate_page(page);
 		page_cache_release(page);
 	}
+	up(&(file->f_dentry->d_inode->i_sem));
 	return 0;
 
 write_fail:
@@ -217,6 +220,7 @@
 	deactivate_page(page);
 	page_cache_release(page);
 fail:
+	up(&(file->f_dentry->d_inode->i_sem));
 	return -1;
 }
 
diff -urN linux/drivers/char/Makefile linux-2.4.7/drivers/char/Makefile
--- linux/drivers/char/Makefile	Wed Jul  4 17:41:33 2001
+++ linux-2.4.7/drivers/char/Makefile	Mon Dec 17 13:41:19 2001
@@ -48,20 +48,6 @@
   SERIAL   =
 endif
 
-ifeq ($(ARCH),s390)
-  KEYMAP   =
-  KEYBD    =
-  CONSOLE  =
-  SERIAL   =
-endif
-
-ifeq ($(ARCH),s390x)
-  KEYMAP   =
-  KEYBD    =
-  CONSOLE  =
-  SERIAL   =
-endif
-
 ifeq ($(ARCH),m68k)
    ifdef CONFIG_AMIGA
       KEYBD = amikeyb.o
diff -urN linux/drivers/char/tty_io.c linux-2.4.7/drivers/char/tty_io.c
--- linux/drivers/char/tty_io.c	Sun Jul 15 19:15:44 2001
+++ linux-2.4.7/drivers/char/tty_io.c	Mon Dec 17 13:41:19 2001
@@ -154,7 +154,7 @@
 extern void con3215_init(void);
 extern void tty3215_init(void);
 extern void tub3270_con_init(void);
-extern void tub3270_initfunc(void);
+extern void tub3270_init(void);
 extern void rs285_console_init(void);
 extern void sa1100_rs_console_init(void);
 extern void sgi_serial_console_init(void);
@@ -2061,8 +2061,63 @@
 #endif /* CONFIG_DEVFS_FS */
 }
 
+/*
+ * Register a tty device described by <driver>, with minor number <minor>,
+ * device name <name> and in the /dev directory given by <dir>.
+ */
+void tty_register_devfs_name (struct tty_driver *driver, unsigned int flags,
+			      unsigned minor, devfs_handle_t dir,
+			      const char *name)
+{
+#ifdef CONFIG_DEVFS_FS
+	umode_t mode = S_IFCHR | S_IRUSR | S_IWUSR;
+	kdev_t device = MKDEV (driver->major, minor);
+
+	switch (device) {
+		case TTY_DEV:
+		case PTMX_DEV:
+			mode |= S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+			break;
+		default:
+			if (driver->major == PTY_MASTER_MAJOR)
+				flags |= DEVFS_FL_AUTO_OWNER;
+			break;
+	}
+	if ( (minor <  driver->minor_start) || 
+	     (minor >= driver->minor_start + driver->num) ) {
+		printk(KERN_ERR "Attempt to register invalid minor number "
+		       "with devfs (%d:%d).\n", (int)driver->major,(int)minor);
+		return;
+	}
+#  ifdef CONFIG_UNIX98_PTYS
+	if ( (driver->major >= UNIX98_PTY_SLAVE_MAJOR) &&
+	     (driver->major < UNIX98_PTY_SLAVE_MAJOR + UNIX98_NR_MAJORS) )
+		flags |= DEVFS_FL_CURRENT_OWNER;
+#  endif
+	devfs_register (dir, name, flags | DEVFS_FL_DEFAULT,
+			driver->major, minor, mode, &tty_fops, NULL);
+#endif /* CONFIG_DEVFS_FS */
+}
+
+void tty_unregister_devfs_name (struct tty_driver *driver, unsigned minor,
+				devfs_handle_t dir, const char *name)
+{
+#ifdef CONFIG_DEVFS_FS
+	void * handle;
+
+	handle = devfs_find_handle (dir, name, driver->major, minor,
+				    DEVFS_SPECIAL_CHR, 0);
+	devfs_unregister (handle);
+#endif /* CONFIG_DEVFS_FS */
+}
+
+extern void tty_unregister_devfs_name (struct tty_driver *driver,
+				       unsigned minor, devfs_handle_t dir,
+				       const char *name);
 EXPORT_SYMBOL(tty_register_devfs);
 EXPORT_SYMBOL(tty_unregister_devfs);
+EXPORT_SYMBOL(tty_register_devfs_name);
+EXPORT_SYMBOL(tty_unregister_devfs_name);
 
 /*
  * Called by a tty driver to register itself.
@@ -2211,12 +2266,12 @@
 	sci_console_init();
 #endif
 #endif
-#ifdef CONFIG_3215
-        con3215_init();
-#endif
-#ifdef CONFIG_3270_CONSOLE
+#ifdef CONFIG_TN3270_CONSOLE
 	tub3270_con_init();
 #endif
+#ifdef CONFIG_TN3215
+	con3215_init();
+#endif
 #ifdef CONFIG_HWC
         hwc_console_init();
 #endif
@@ -2358,10 +2413,10 @@
 #ifdef CONFIG_VT
 	vcs_init();
 #endif
-#ifdef CONFIG_3270
-	tub3270_initfunc();
+#ifdef CONFIG_TN3270
+	tub3270_init();
 #endif
-#ifdef CONFIG_3215
+#ifdef CONFIG_TN3215
 	tty3215_init();
 #endif
 #ifdef CONFIG_HWC
diff -urN linux/drivers/s390/Config.in linux-2.4.7/drivers/s390/Config.in
--- linux/drivers/s390/Config.in	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/Config.in	Mon Dec 17 13:41:19 2001
@@ -14,12 +14,21 @@
 
 tristate 'Support for DASD devices' CONFIG_DASD
 if [ "$CONFIG_DASD" != "n"  ]; then
-  bool '   Support for ECKD Disks' CONFIG_DASD_ECKD
-  bool '   Support for FBA  Disks' CONFIG_DASD_FBA
-#  bool '   Support for CKD  Disks' CONFIG_DASD_CKD
-  if [ "$CONFIG_ARCH_S390" = "y" ]; then
-    bool '   Support for DIAG access to CMS reserved Disks' CONFIG_DASD_DIAG
+  dep_tristate '   Support for ECKD Disks' CONFIG_DASD_ECKD $CONFIG_DASD
+  if [ "$CONFIG_DASD_ECKD" = "m" ]; then
+    bool     '   Automatic activation of ECKD module' CONFIG_DASD_AUTO_ECKD
   fi;
+  dep_tristate '   Support for FBA  Disks' CONFIG_DASD_FBA $CONFIG_DASD
+  if [ "$CONFIG_DASD_FBA" = "m" ]; then
+    bool     '   Automatic activation of FBA  module' CONFIG_DASD_AUTO_FBA
+  fi;
+#  dep_tristate '   Support for CKD  Disks' CONFIG_DASD_CKD $CONFIG_DASD
+  if [ "$CONFIG_ARCH_S390X" != "y" ]; then
+    dep_tristate '   Support for DIAG access to CMS reserved Disks' CONFIG_DASD_DIAG $CONFIG_DASD
+    if [ "$CONFIG_DASD_DIAG" = "m" ]; then
+      bool     '   Automatic activation of DIAG module' CONFIG_DASD_AUTO_DIAG
+    fi;
+  fi; 
 fi
 
 endmenu
@@ -35,19 +44,18 @@
 
 comment 'S/390 character device drivers'
 
-tristate 'Support for locally attached 3270 tubes' CONFIG_3270
-if [ "$CONFIG_3270" = "y" ]; then
-  bool 'Support for console on 3270 line mode terminal' CONFIG_3270_CONSOLE
-fi
-if [ "$CONFIG_3270_CONSOLE" != "y" ]; then
-  bool 'Support for 3215 line mode terminal' CONFIG_3215
-  if [ "$CONFIG_3215" = "y" ]; then
-    bool 'Support for console on 3215 line mode terminal' CONFIG_3215_CONSOLE
-  fi
+tristate 'Support for locally attached 3270 tubes' CONFIG_TN3270
+if [ "$CONFIG_TN3270" = "y" ]; then
+  bool 'Support for console on 3270 line mode terminal' CONFIG_TN3270_CONSOLE
+fi
+bool 'Support for 3215 line mode terminal' CONFIG_TN3215
+if [ "$CONFIG_TN3215" = "y" ]; then
+  bool 'Support for console on 3215 line mode terminal' CONFIG_TN3215_CONSOLE
 fi
 bool 'Support for HWC line mode terminal' CONFIG_HWC
 if [ "$CONFIG_HWC" = "y" ]; then
-  bool 'console on HWC line mode terminal' CONFIG_HWC_CONSOLE
+  bool '   console on HWC line mode terminal' CONFIG_HWC_CONSOLE
+  tristate '   Control-Program Identification' CONFIG_HWC_CPI
 fi
 tristate 'S/390 tape device support' CONFIG_S390_TAPE
 if [ "$CONFIG_S390_TAPE" != "n" ]; then
@@ -67,11 +75,18 @@
 
   if [ "$CONFIG_NETDEVICES" = "y" ]; then
     tristate 'Dummy net driver support' CONFIG_DUMMY
+    tristate 'Bonding driver support' CONFIG_BONDING
+    tristate 'EQL (serial line load balancing) support' CONFIG_EQUALIZER
+    tristate 'Universal TUN/TAP device driver support' CONFIG_TUN
     bool 'Ethernet (10 or 100Mbit)' CONFIG_NET_ETHERNET
     bool 'Token Ring driver support' CONFIG_TR
     bool 'FDDI driver support' CONFIG_FDDI
     comment 'S/390 network device drivers'
-    bool 'Channel Device Configuration (Temporary Option)' CONFIG_CHANDEV
+    bool 'Channel Device Configuration' CONFIG_CHANDEV
+    if [ "$CONFIG_CHANDEV" = "y" ]; then
+	define_bool CONFIG_HOTPLUG y
+    fi
+
     tristate 'CTC device support' CONFIG_CTC
     tristate 'IUCV device support (VM only)' CONFIG_IUCV
   fi
diff -urN linux/drivers/s390/Makefile linux-2.4.7/drivers/s390/Makefile
--- linux/drivers/s390/Makefile	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/Makefile	Mon Dec 17 13:43:29 2001
@@ -6,9 +6,10 @@
 
 subdir-y := block char misc net
 subdir-m := $(subdir-y)
-obj-y := $(foreach dir,$(subdir-y),$(dir)/s390-$(dir).o)
 
-obj-y += s390io.o s390mach.o s390dyn.o idals.o ccwcache.o
+obj-y := s390io.o s390mach.o s390dyn.o idals.o ccwcache.o sysinfo.o
 export-objs += ccwcache.o idals.o s390dyn.o s390io.o
+
+obj-y += $(foreach dir,$(subdir-y),$(dir)/s390-$(dir).o)
 
 include $(TOPDIR)/Rules.make
diff -urN linux/drivers/s390/block/Makefile linux-2.4.7/drivers/s390/block/Makefile
--- linux/drivers/s390/block/Makefile	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/Makefile	Mon Dec 17 13:41:19 2001
@@ -4,19 +4,31 @@
 
 O_TARGET := s390-block.o
 
-list-multi := dasd_mod.o
+list-multi := dasd_mod.o dasd_eckd_mod.o dasd_fba_mod.o dasd_diag_mod.o
 export-objs := dasd.o
 
-dasd_mod-$(CONFIG_DASD_ECKD) += dasd_eckd.o dasd_3990_erp.o dasd_9343_erp.o
-dasd_mod-$(CONFIG_DASD_FBA) += dasd_fba.o dasd_3370_erp.o dasd_9336_erp.o
-dasd_mod-$(CONFIG_DASD_DIAG) += dasd_diag.o
-dasd_mod-objs := dasd.o $(dasd_mod-y)
+dasd_eckd_mod-objs := dasd_eckd.o dasd_3990_erp.o dasd_9343_erp.o
+dasd_fba_mod-objs  := dasd_fba.o dasd_3370_erp.o dasd_9336_erp.o
+dasd_diag_mod-objs := dasd_diag.o
+dasd_mod-objs      := dasd.o
 
 obj-$(CONFIG_DASD) += dasd_mod.o
+obj-$(CONFIG_DASD_ECKD) += dasd_eckd_mod.o
+obj-$(CONFIG_DASD_FBA)  += dasd_fba_mod.o
+obj-$(CONFIG_DASD_DIAG) += dasd_diag_mod.o
 obj-$(CONFIG_BLK_DEV_XPRAM) += xpram.o
 
 include $(TOPDIR)/Rules.make
 
 dasd_mod.o: $(dasd_mod-objs)
 	$(LD) -r -o $@ $(dasd_mod-objs)
+
+dasd_eckd_mod.o: $(dasd_eckd_mod-objs)
+	$(LD) -r -o $@ $(dasd_eckd_mod-objs)
+
+dasd_fba_mod.o: $(dasd_fba_mod-objs)
+	$(LD) -r -o $@ $(dasd_fba_mod-objs)
+
+dasd_diag_mod.o: $(dasd_diag_mod-objs)
+	$(LD) -r -o $@ $(dasd_diag_mod-objs)
 
diff -urN linux/drivers/s390/block/dasd.c linux-2.4.7/drivers/s390/block/dasd.c
--- linux/drivers/s390/block/dasd.c	Tue May 15 04:29:34 2001
+++ linux-2.4.7/drivers/s390/block/dasd.c	Mon Dec 17 13:43:29 2001
@@ -1,14 +1,13 @@
-/* 
+/*
  * File...........: linux/drivers/s390/block/dasd.c
  * Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
- *                  Horst Hummel <Horst.Hummel@de.ibm.com>  
+ *                  Horst Hummel <Horst.Hummel@de.ibm.com> 
  *                  Carsten Otte <Cotte@de.ibm.com>
  * Bugreports.to..: <Linux390@de.ibm.com>
- * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
+ * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999-2001
  *
  * History of changes (starts July 2000)
  * 11/09/00 complete redesign after code review
- * 02/01/01 removed some warnings
  * 02/01/01 added dynamic registration of ioctls
  *          fixed bug in registration of new majors
  *          fixed handling of request during dasd_end_request
@@ -18,20 +17,34 @@
  *          fixed some race conditions related to modules
  *          added devfs suupport
  * 03/06/01 refined dynamic attach/detach for leaving devices which are online.
- * 06/09/01 refined dynamic modifiaction of devices
- *          renewed debug feature exploitation
+ * 03/09/01 refined dynamic modifiaction of devices
+ * 03/12/01 moved policy in dasd_format to dasdfmt (renamed BIODASDFORMAT)
+ * 03/19/01 added BIODASDINFO-ioctl
+ *          removed 2.2 compatibility
+ * 04/27/01 fixed PL030119COT (dasd_disciplines does not work)
+ * 04/30/01 fixed PL030146HSM (module locking with dynamic ioctls)
+ *          fixed PL030130SBA (handling of invalid ranges)
+ * 05/02/01 fixed PL030145SBA (killing dasdmt)
+ *          fixed PL030149SBA (status of 'accepted' devices)
+ *          fixed PL030146SBA (BUG in ibm.c after adding device)
+ *          added BIODASDPRRD ioctl interface
+ * 05/11/01 fixed  PL030164MVE (trap in probeonly mode)
+ * 05/15/01 fixed devfs support for unformatted devices
+ * 06/26/01 hopefully fixed PL030172SBA,PL030234SBA
+ * 07/09/01 fixed PL030324MSH (wrong statistics output)
+ * 07/16/01 merged in new fixes for handling low-mem situations
  */
 
-#include <linux/module.h>
 #include <linux/config.h>
 #include <linux/version.h>
+#include <linux/kmod.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/stddef.h>
 #include <linux/kernel.h>
 #include <linux/tqueue.h>
 #include <linux/timer.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/genhd.h>
 #include <linux/hdreg.h>
 #include <linux/interrupt.h>
@@ -42,9 +55,9 @@
 #include <linux/spinlock.h>
 #include <linux/devfs_fs_kernel.h>
 #include <linux/blkpg.h>
+#include <linux/wait.h>
 
 #include <asm/ccwcache.h>
-#include <asm/dasd.h>
 #include <asm/debug.h>
 
 #include <asm/atomic.h>
@@ -57,6 +70,9 @@
 #include <asm/s390_ext.h>
 #include <asm/s390dyn.h>
 #include <asm/idals.h>
+#include <asm/dasd.h>
+
+#include "dasd_int.h"
 
 #ifdef CONFIG_DASD_ECKD
 #include "dasd_eckd.h"
@@ -68,25 +84,43 @@
 #include "dasd_diag.h"
 #endif				/*  CONFIG_DASD_DIAG */
 
+/* SECTION: exported variables of dasd.c */
+
+debug_info_t *dasd_debug_area;
+
 MODULE_AUTHOR ("Holger Smolinski <Holger.Smolinski@de.ibm.com>");
 MODULE_DESCRIPTION ("Linux on S/390 DASD device driver,"
 		    " Copyright 2000 IBM Corporation");
 MODULE_SUPPORTED_DEVICE ("dasd");
 MODULE_PARM (dasd, "1-" __MODULE_STRING (256) "s");
-EXPORT_SYMBOL (dasd_discipline_enq);
-EXPORT_SYMBOL (dasd_discipline_deq);
+MODULE_PARM (dasd_disciplines, "1-" __MODULE_STRING (8) "s");
+EXPORT_SYMBOL (dasd_chanq_enq_head);
+EXPORT_SYMBOL (dasd_debug_area);
+EXPORT_SYMBOL (dasd_chanq_enq);
+EXPORT_SYMBOL (dasd_chanq_deq);
+EXPORT_SYMBOL (dasd_discipline_add);
+EXPORT_SYMBOL (dasd_discipline_del);
 EXPORT_SYMBOL (dasd_start_IO);
+EXPORT_SYMBOL (dasd_term_IO);
+EXPORT_SYMBOL (dasd_schedule_bh);
 EXPORT_SYMBOL (dasd_int_handler);
+EXPORT_SYMBOL (dasd_oper_handler);
 EXPORT_SYMBOL (dasd_alloc_request);
 EXPORT_SYMBOL (dasd_free_request);
-EXPORT_SYMBOL(dasd_ioctl_no_register);  
-EXPORT_SYMBOL(dasd_ioctl_no_unregister);
+EXPORT_SYMBOL (dasd_ioctl_no_register);
+EXPORT_SYMBOL (dasd_ioctl_no_unregister);
+EXPORT_SYMBOL (dasd_default_erp_action);
+EXPORT_SYMBOL (dasd_default_erp_postaction);
+EXPORT_SYMBOL (dasd_sleep_on_req);
+EXPORT_SYMBOL (dasd_set_normalized_cda);
+EXPORT_SYMBOL (dasd_device_from_kdev);
 
 /* SECTION: Constant definitions to be used within this file */
 
-#define PRINTK_HEADER DASD_NAME": "
+#define PRINTK_HEADER DASD_NAME":"
+#undef  DASD_PROFILE            /* fill profile information - used for */
+                                /* statistics and perfomance           */
 
-#define DASD_EMERGENCY_REQUESTS 16
 #define DASD_MIN_SIZE_FOR_QUEUE 32
 #undef CONFIG_DYNAMIC_QUEUE_MIN_SIZE
 #define DASD_CHANQ_MAX_SIZE 6
@@ -94,27 +128,38 @@
 /* SECTION: prototypes for static functions of dasd.c */
 
 static request_fn_proc do_dasd_request;
-static int dasd_set_device_level (unsigned int, int, dasd_discipline_t *, int);
+static int dasd_set_device_level (unsigned int, dasd_discipline_t *, int);
 static request_queue_t *dasd_get_queue (kdev_t kdev);
 static void cleanup_dasd (void);
-int dasd_fillgeo(int kdev,struct hd_geometry *geo);
-
+static void dasd_plug_device (dasd_device_t * device);
+static int dasd_fillgeo (int kdev, struct hd_geometry *geo);
+static void dasd_enable_ranges (dasd_range_t *, dasd_discipline_t *, int); 
+static void dasd_disable_ranges (dasd_range_t *, dasd_discipline_t *, int, int); 
+static void dasd_enable_single_device ( unsigned long);
+static inline int dasd_state_init_to_ready(dasd_device_t*);
+static inline void dasd_setup_partitions ( dasd_device_t *);
+static inline void dasd_destroy_partitions ( dasd_device_t *);
+static inline int dasd_setup_blkdev(dasd_device_t*);
+static void dasd_deactivate_queue (dasd_device_t *);
+static inline int dasd_disable_blkdev(dasd_device_t*);
+static void dasd_flush_chanq ( dasd_device_t * device, int destroy ); 
+static void dasd_flush_request_queues ( dasd_device_t * device, int destroy );
 static struct block_device_operations dasd_device_operations;
-
+static inline dasd_device_t ** dasd_device_from_devno (int);
+static void dasd_process_queues (dasd_device_t * device);
 /* SECTION: static variables of dasd.c */
 
 static devfs_handle_t dasd_devfs_handle;
-
-/* SECTION: exported variables of dasd.c */
-
-debug_info_t *dasd_debug_area;
+static wait_queue_head_t dasd_init_waitq;
+static atomic_t dasd_init_pending = ATOMIC_INIT (0);
 
 #ifdef CONFIG_DASD_DYNAMIC
+
 /* SECTION: managing dynamic configuration of dasd_driver */
 
-static struct list_head dasd_devreg_head = LIST_HEAD_INIT(dasd_devreg_head);
+static struct list_head dasd_devreg_head = LIST_HEAD_INIT (dasd_devreg_head);
 
-/* 
+/*
  * function: dasd_create_devreg
  * creates a dasd_devreg_t related to a devno
  */
@@ -131,7 +176,7 @@
 	return r;
 }
 
-/* 
+/*
  * function: dasd_destroy_devreg
  * destroys the dasd_devreg_t given as argument
  */
@@ -149,44 +194,52 @@
 static int dasd_probeonly = 1;	/* is true, when probeonly mode is active */
 static int dasd_autodetect = 1;	/* is true, when autodetection is active */
 
-/* dasd_range_t are used for ordering the DASD devices */
-typedef struct dasd_range_t {
-	unsigned int from;	/* first DASD in range */
-	unsigned int to;	/* last DASD in range */
-	char discipline[4];	/* placeholder to force discipline */
-	struct dasd_range_t *next;	/* next one in linked list */
-} dasd_range_t;
-
-static dasd_range_t *dasd_range_head = NULL;	/* anchor for list of ranges */
+static dasd_range_t dasd_range_head =
+    { list:LIST_HEAD_INIT (dasd_range_head.list) };
 static spinlock_t range_lock = SPIN_LOCK_UNLOCKED;
-static spinlock_t dasd_open_count_lock;
 
-/* 
+/*
  * function: dasd_create_range
- * creates a dasd_range_t according to the arguments 
+ * creates a dasd_range_t according to the arguments
  * FIXME: no check is performed for reoccurrence of a devno
  */
 static inline dasd_range_t *
-dasd_create_range (int from, int to)
+dasd_create_range (int from, int to, int features)
 {
 	dasd_range_t *range = NULL;
+        int i;
+
+	if ( from > to ) {
+                printk (KERN_WARNING PRINTK_HEADER 
+                        "Adding device range %04x-%04x: range invalid, ignoring.\n",
+                        from,
+                        to);
+
+		return NULL;
+	}
+	for (i=from;i<=to;i++) {
+                if (dasd_device_from_devno(i)) {
+                        printk (KERN_WARNING PRINTK_HEADER 
+                                "device range %04x-%04x: device %04x is already in a range.\n",
+                                from,
+                                to,
+                                i);
+                }
+        }
 	range = (dasd_range_t *) kmalloc (sizeof (dasd_range_t), GFP_KERNEL);
 	if (range == NULL)
 		return NULL;
 	memset (range, 0, sizeof (dasd_range_t));
 	range->from = from;
-	if (to == 0) {		/* single devno ? */
-		range->to = from;
-	} else {
-		range->to = to;
-	}
+        range->to = to;
+        range->features = features;
 	return range;
 }
 
-/* 
+/*
  * function dasd_destroy_range
  * destroy a range allocated wit dasd_crate_range
- * CAUTION: must not be callen in arunning sysztem, because it destroys 
+ * CAUTION: must not be callen in arunning sysztem, because it destroys
  * the mapping of DASDs
  */
 static inline void
@@ -195,68 +248,50 @@
 	kfree (range);
 }
 
-/* 
+/*
  * function: dasd_append_range
- * appends the range given as argument to the list anchored at dasd_range_head. 
+ * appends the range given as argument to the list anchored at dasd_range_head.
  */
 static inline void
 dasd_append_range (dasd_range_t * range)
 {
-	dasd_range_t *temp;
 	long flags;
 
 	spin_lock_irqsave (&range_lock, flags);
-	if (dasd_range_head == NULL) {
-		dasd_range_head = range;
-	} else {
-		for (temp = dasd_range_head;
-		     temp && temp->next;
-		     temp = temp->next) ;
-		temp->next = range;
-	}
+	list_add_tail (&range->list, &dasd_range_head.list);
 	spin_unlock_irqrestore (&range_lock, flags);
 }
 
 /*
  * function dasd_dechain_range
  * removes a range from the chain of ranges
- * CAUTION: must not be called in a running system because it destroys 
+ * CAUTION: must not be called in a running system because it destroys
  * the mapping of devices
  */
 static inline void
 dasd_dechain_range (dasd_range_t * range)
 {
-	dasd_range_t *temp, *prev = NULL;
 	unsigned long flags;
 
 	spin_lock_irqsave (&range_lock, flags);
-	for (temp = dasd_range_head; temp != NULL; temp = temp->next) {
-		if (temp == range)
-			break;
-		prev = temp;
-	}
-	if (!temp)
-		BUG ();
-	if (prev) {
-		prev->next = temp->next;
-	} else {
-		dasd_range_head = temp->next;
-	}
+	list_del (&range->list);
 	spin_unlock_irqrestore (&range_lock, flags);
 }
 
-/* 
+/*
  * function: dasd_add_range
  * creates a dasd_range_t according to the arguments and
  * appends it to the list of ranges
- * additionally a devreg_t is created and added to the list of devregs 
+ * additionally a devreg_t is created and added to the list of devregs
  */
-static inline dasd_range_t*
-dasd_add_range (int from, int to)
+static inline dasd_range_t *
+dasd_add_range (int from, int to, int features)
 {
 	dasd_range_t *range;
-	range = dasd_create_range (from, to);
-	if (!range) return NULL;
+
+	range = dasd_create_range (from, to, features);
+	if (!range)
+		return NULL;
 
 	dasd_append_range (range);
 #ifdef CONFIG_DASD_DYNAMIC
@@ -266,14 +301,14 @@
 		for (i = range->from; i <= range->to; i++) {
 			dasd_devreg_t *reg = dasd_create_devreg (i);
 			s390_device_register (&reg->devreg);
-                        list_add(&reg->list,&dasd_devreg_head);
+			list_add (&reg->list, &dasd_devreg_head);
 		}
 	}
 #endif				/* CONFIG_DASD_DYNAMIC */
 	return range;
 }
 
-/* 
+/*
  * function: dasd_remove_range
  * removes a range and the corresponding devregs from all of the chains
  * CAUTION: must not be called in a running system because it destroys
@@ -287,10 +322,10 @@
 	{
 		int i;
 		for (i = range->from; i <= range->to; i++) {
-                        struct list_head *l;
-                        dasd_devreg_t *reg = NULL;
+			struct list_head *l;
+			dasd_devreg_t *reg = NULL;
 			list_for_each (l, &dasd_devreg_head) {
-                                reg = list_entry(l,dasd_devreg_t,list);
+				reg = list_entry (l, dasd_devreg_t, list);
 				if (reg->devreg.flag == DEVREG_TYPE_DEVNO &&
 				    reg->devreg.ci.devno == i &&
 				    reg->devreg.oper_func == dasd_oper_handler)
@@ -319,9 +354,11 @@
 	dasd_range_t *temp;
 	int devindex = 0;
 	unsigned long flags;
+	struct list_head *l;
 
 	spin_lock_irqsave (&range_lock, flags);
-	for (temp = dasd_range_head; temp; temp = temp->next) {
+	list_for_each (l, &dasd_range_head.list) {
+		temp = list_entry (l, dasd_range_t, list);
 		if (devno >= temp->from && devno <= temp->to) {
 			spin_unlock_irqrestore (&range_lock, flags);
 			return devindex + devno - temp->from;
@@ -332,19 +369,43 @@
 	return -ENODEV;
 }
 
+/*
+ * function: dasd_devno_from_devindex
+ */
+static int
+dasd_devno_from_devindex (int devindex)
+{
+	dasd_range_t *temp;
+	unsigned long flags;
+	struct list_head *l;
+
+	spin_lock_irqsave (&range_lock, flags);
+	list_for_each (l, &dasd_range_head.list) {
+		temp = list_entry (l, dasd_range_t, list);
+                if ( devindex < temp->to - temp->from + 1) {
+			spin_unlock_irqrestore (&range_lock, flags);
+			return temp->from + devindex;
+		}
+		devindex -= temp->to - temp->from + 1;
+	}
+	spin_unlock_irqrestore (&range_lock, flags);
+	return -ENODEV;
+}
+
 /* SECTION: parsing the dasd= parameter of the parmline/insmod cmdline */
 
-/* 
+/*
  * char *dasd[] is intended to hold the ranges supplied by the dasd= statement
  * it is named 'dasd' to directly be filled by insmod with the comma separated
  * strings when running as a module.
  * a maximum of 256 ranges can be supplied, as the parmline is limited to
  * <1024 Byte anyway.
  */
-char *dasd[256] = {NULL,};
+char *dasd[256];
+char *dasd_disciplines[8];
 
 #ifndef MODULE
-/* 
+/*
  * function: dasd_split_parm_string
  * splits the parmline given to the kernel into comma separated strings
  * which are filled into the 'dasd[]' array, to be parsed later on
@@ -354,7 +415,7 @@
 {
 	char *tmp = str;
 	int count = 0;
-	do {
+	while (tmp != NULL && *tmp != '\0') {
 		char *end;
 		int len;
 		end = strchr (tmp, ',');
@@ -366,27 +427,28 @@
 			end++;
 		}
 		dasd[count] = kmalloc (len * sizeof (char), GFP_ATOMIC);
-		if (dasd == NULL) {
+		if (dasd[count] == NULL) {
 			printk (KERN_WARNING PRINTK_HEADER
-			    "can't store dasd= parameter no %d\n", count + 1);
+				"can't store dasd= parameter no %d\n",
+				count + 1);
 			break;
 		}
 		memset (dasd[count], 0, len * sizeof (char));
 		memcpy (dasd[count], tmp, len * sizeof (char));
 		count++;
 		tmp = end;
-	} while (tmp != NULL && *tmp != '\0');
+	};
 }
 
-/* 
+/*
  * dasd_parm_string holds a concatenated version of all 'dasd=' parameters
- * supplied in the parmline, which is later to be split by 
+ * supplied in the parmline, which is later to be split by
  * dasd_split_parm_string
  * FIXME: why first concatenate then split ?
  */
-static char dasd_parm_string[1024] __initdata = {0,};
+static char dasd_parm_string[1024] __initdata = { 0, };
 
-/* 
+/*
  * function: dasd_setup
  * is invoked for any single 'dasd=' parameter supplied in the parmline
  * it merges all the arguments into dasd_parm_string
@@ -400,53 +462,112 @@
 	}
 	strcat (dasd_parm_string, str);
 }
-/* 
- * function: dasd_call_setup 
+
+/*
+ * function: dasd_call_setup
  * is the 2.4 version of dasd_setup and
  * is invoked for any single 'dasd=' parameter supplied in the parmline
  */
 int __init
 dasd_call_setup (char *str)
 {
-        int dummy;
-        dasd_setup(str,&dummy);
+	int dummy;
+	dasd_setup (str, &dummy);
+	return 1;
+}
+
+int __init
+dasd_disciplines_setup (char *str)
+{
 	return 1;
 }
 
 __setup ("dasd=", dasd_call_setup);
+__setup ("dasd_disciplines=", dasd_disciplines_setup);
 
-#endif /* MODULE */
+#endif				/* MODULE */
 
-/* 
+/*
  * function: dasd_strtoul
  * provides a wrapper to simple_strtoul to strip leading '0x' and
  * interpret any argument to dasd=[range,...] as hexadecimal
  */
 static inline int
-dasd_strtoul (char *str, char **stra)
+dasd_strtoul (char *str, char **stra, int* features)
 {
-	char *temp = str;
-	int val;
-	if (*temp == '0') {
-		temp++;		/* strip leading zero */
-		if (*temp == 'x')
-			temp++;	/* strip leading x */
-	}
-	val = simple_strtoul (temp, &temp, 16);		/* interpret anything as hex */
-	*stra = temp;
-	return val;
+        char *temp=str;
+        char *buffer;
+        int val,i,start;
+
+        buffer=(char*)kmalloc((strlen(str)+1)*sizeof(char),GFP_ATOMIC);
+        if (buffer==NULL) {
+            printk (KERN_WARNING PRINTK_HEADER
+                    "can't parse dasd= parameter %s due to low memory\n",
+                    str);
+        }
+
+        /* remove leading '0x' */
+        if (*temp == '0') {
+                temp++;         /* strip leading zero */
+                if (*temp == 'x')
+                        temp++; /* strip leading x */
+        }
+
+        /* copy device no to buffer and convert to decimal */
+        for (i=0; temp[i]!='\0' && temp[i]!='(' && 
+                  temp[i]!='-'  && temp[i]!=' '; i++){
+                if (isxdigit(temp[i])) {
+                        buffer[i]=temp[i];
+                } else {
+                        return -EINVAL;
+                }
+        }
+
+        buffer[i]='\0';
+
+        val = simple_strtoul (buffer, &buffer, 16);
+
+        /* check for features - e.g. (ro) ; the '\0', ')' and '-' stops check */
+        *features = DASD_DEFAULT_FEATURES;
+
+        if (temp[i]=='(') {
+
+                while (temp[i]!='\0' && temp[i]!=')'&&temp[i]!='-') { 
+                        start=++i;      
+        
+                        /* move next feature to buffer */
+                        for (;temp[i]!='\0'&&temp[i]!=':'&&temp[i]!=')'&&temp[i]!='-';i++)
+                                buffer[i-start]=temp[i];
+                        buffer[i-start]='\0';
+
+                        if (strlen(buffer)) { 
+                                if (!strcmp(buffer,"ro")) { /* handle 'ro' feature */
+                                        (*features) |= DASD_FEATURE_READONLY;
+                                        break;
+                                }
+                                printk (KERN_WARNING PRINTK_HEADER 
+                                        "unsupported feature: %s, ignoring setting",
+                                        buffer);
+                        }
+                }
+        }
+
+        *stra = temp+i;
+        return val;
 }
 
-/* 
+/*
  * function: dasd_parse
  * examines the strings given in the string array str and
  * creates and adds the ranges to the apropriate lists
  */
-static inline void
+static int
 dasd_parse (char **str)
 {
 	char *temp;
 	int from, to;
+        int features;
+        int rc = 0;
 
 	if (*str) {
 		/* turn off probeonly mode, if any dasd parameter is present */
@@ -468,33 +589,40 @@
 		} else {
 			/* turn off autodetect mode, if any range is present */
 			dasd_autodetect = 0;
-			from = dasd_strtoul (temp, &temp);
+			from = dasd_strtoul (temp, &temp, &features);
+                        to = from;
 			if (*temp == '-') {
 				temp++;
-				to = dasd_strtoul (temp, &temp);
+				to = dasd_strtoul (temp, &temp, &features);
 			}
-			dasd_add_range (from, to);
-		}
+                        if (from == -EINVAL ||
+                            to   == -EINVAL    ) {
+                                rc = -EINVAL;
+                                break;
+                        } else {
+                                dasd_add_range (from, to ,features);
+                        }
+                }
 		str++;
 	}
+
+        return rc;
 }
 
 /* SECTION: Dealing with devices registered to multiple major numbers */
 
 static spinlock_t dasd_major_lock = SPIN_LOCK_UNLOCKED;
 
-static major_info_t dasd_major_info[] =
-{
+static major_info_t dasd_major_info[] = {
 	{
-		list: LIST_HEAD_INIT(dasd_major_info[1].list )
-	},
+	      list:LIST_HEAD_INIT (dasd_major_info[1].list)
+	 },
 	{
-		list: LIST_HEAD_INIT(dasd_major_info[0].list ),
-		gendisk: {
-                        INIT_GENDISK(94,DASD_NAME,DASD_PARTN_BITS,DASD_PER_MAJOR)
-		},
-		flags : DASD_MAJOR_INFO_IS_STATIC
-	}
+	      list:LIST_HEAD_INIT (dasd_major_info[0].list),
+	      gendisk:{
+	  INIT_GENDISK (94, DASD_NAME, DASD_PARTN_BITS, DASD_PER_MAJOR)
+	  },
+      flags:DASD_MAJOR_INFO_IS_STATIC}
 };
 
 static major_info_t *
@@ -504,17 +632,21 @@
 
 	major_info = kmalloc (sizeof (major_info_t), GFP_KERNEL);
 	if (major_info) {
-		static major_info_t temp_major_info =
-		{
-			gendisk: {
-				INIT_GENDISK(0,DASD_NAME,DASD_PARTN_BITS,DASD_PER_MAJOR)
-			}
+		static major_info_t temp_major_info = {
+			gendisk:{
+				 INIT_GENDISK (0, DASD_NAME, DASD_PARTN_BITS,
+					       DASD_PER_MAJOR)}
 		};
 		memcpy (major_info, &temp_major_info, sizeof (major_info_t));
 	}
 	return major_info;
 }
 
+/*
+ * register major number
+ * is called with the 'static' major_info during init of the driver or 'NULL' to
+ * allocate an additional dynamic major.
+ */
 static int
 dasd_register_major (major_info_t * major_info)
 {
@@ -522,67 +654,88 @@
 	int major;
 	unsigned long flags;
 
+        /* allocate dynamic major */
 	if (major_info == NULL) {
 		major_info = get_new_major_info ();
 		if (!major_info) {
 			printk (KERN_WARNING PRINTK_HEADER
 				"Cannot get memory to allocate another major number\n");
 			return -ENOMEM;
-		} else {
-			printk (KERN_INFO PRINTK_HEADER
-				"Created another major number\n");
 		}
 	}
+
 	major = major_info->gendisk.major;
-	major_info->gendisk.de_arr = (devfs_handle_t*)
-		kmalloc(DASD_PER_MAJOR * sizeof(devfs_handle_t), GFP_KERNEL);
-	memset(major_info->gendisk.de_arr,0,DASD_PER_MAJOR * sizeof(devfs_handle_t));
-	major_info->gendisk.flags = (char*)
-		kmalloc(DASD_PER_MAJOR * sizeof(char), GFP_KERNEL);
-	memset(major_info->gendisk.flags,0,DASD_PER_MAJOR * sizeof(char));
 
+        /* init devfs array */
+	major_info->gendisk.de_arr = (devfs_handle_t *)
+	    kmalloc (DASD_PER_MAJOR * sizeof (devfs_handle_t), GFP_KERNEL);
+	memset (major_info->gendisk.de_arr, 0,
+		DASD_PER_MAJOR * sizeof (devfs_handle_t));
+
+        /* init flags */
+	major_info->gendisk.flags = (char *)
+	    kmalloc (DASD_PER_MAJOR * sizeof (char), GFP_KERNEL);
+	memset (major_info->gendisk.flags, 0, DASD_PER_MAJOR * sizeof (char));
+
+        /* register blockdevice */
 	rc = devfs_register_blkdev (major, DASD_NAME, &dasd_device_operations);
 	if (rc < 0) {
 		printk (KERN_WARNING PRINTK_HEADER
-		      "Cannot register to major no %d, rc = %d\n", major, rc);
-		return rc;
+			"Cannot register to major no %d, rc = %d\n",
+                        major, 
+                        rc);
+		goto out_reg_blkdev; 
 	} else {
 		major_info->flags |= DASD_MAJOR_INFO_REGISTERED;
 	}
-        /* Insert the new major info into dasd_major_info if needed */
-        if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC) ){
-                spin_lock_irqsave (&dasd_major_lock, flags);
-		list_add_tail(&major_info->list,&dasd_major_info[0].list);
+
+	/* Insert the new major info into dasd_major_info if needed (dynamic major) */
+	if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC)) {
+		spin_lock_irqsave (&dasd_major_lock, flags);
+		list_add_tail (&major_info->list, &dasd_major_info[0].list);
 		spin_unlock_irqrestore (&dasd_major_lock, flags);
-        }
+	}
+
 	if (major == 0) {
 		major = rc;
 		rc = 0;
 	}
-	major_info->dasd_device = (dasd_device_t **) kmalloc (DASD_PER_MAJOR * sizeof (dasd_device_t *),
-							      GFP_ATOMIC);
+
+        /* init array of devices */
+	major_info->dasd_device =
+	    (dasd_device_t **) kmalloc (DASD_PER_MAJOR *
+					sizeof (dasd_device_t *), GFP_ATOMIC);
 	if (!major_info->dasd_device)
-		goto out_devfs;
-	memset (major_info->dasd_device, 0, DASD_PER_MAJOR * sizeof (dasd_device_t *));
+		goto out_devices;
+	memset (major_info->dasd_device, 0,
+		DASD_PER_MAJOR * sizeof (dasd_device_t *));
+
+        /* init blk_size */
 	blk_size[major] =
 	    (int *) kmalloc ((1 << MINORBITS) * sizeof (int), GFP_ATOMIC);
 	if (!blk_size[major])
-		goto out_dasd_device;
+		goto out_blk_size;
 	memset (blk_size[major], 0, (1 << MINORBITS) * sizeof (int));
+
+        /* init blksize_size */
 	blksize_size[major] =
 	    (int *) kmalloc ((1 << MINORBITS) * sizeof (int), GFP_ATOMIC);
 	if (!blksize_size[major])
-		goto out_blk_size;
+		goto out_blksize_size;
 	memset (blksize_size[major], 0, (1 << MINORBITS) * sizeof (int));
+
+        /* init_hardsect_size */
 	hardsect_size[major] =
 	    (int *) kmalloc ((1 << MINORBITS) * sizeof (int), GFP_ATOMIC);
 	if (!hardsect_size[major])
-		goto out_blksize_size;
+		goto out_hardsect_size;
 	memset (hardsect_size[major], 0, (1 << MINORBITS) * sizeof (int));
+
+        /* init max_sectors */
 	max_sectors[major] =
 	    (int *) kmalloc ((1 << MINORBITS) * sizeof (int), GFP_ATOMIC);
 	if (!max_sectors[major])
-		goto out_hardsect_size;
+		goto out_max_sectors;
 	memset (max_sectors[major], 0, (1 << MINORBITS) * sizeof (int));
 
 	/* finally do the gendisk stuff */
@@ -590,29 +743,66 @@
 					    sizeof (struct hd_struct),
 					    GFP_ATOMIC);
 	if (!major_info->gendisk.part)
-		goto out_max_sectors;
+		goto out_gendisk;
 	memset (major_info->gendisk.part, 0, (1 << MINORBITS) *
 		sizeof (struct hd_struct));
 
-	INIT_BLK_DEV(major,do_dasd_request,dasd_get_queue,NULL);
+	INIT_BLK_DEV (major, do_dasd_request, dasd_get_queue, NULL);
 
 	major_info->gendisk.major = major;
 	major_info->gendisk.next = gendisk_head;
 	major_info->gendisk.sizes = blk_size[major];
 	gendisk_head = &major_info->gendisk;
 	return major;
-out_max_sectors:
-	kfree(max_sectors[major]);
-out_hardsect_size:
-	kfree(hardsect_size[major]);
-out_blksize_size:
-	kfree(blksize_size[major]);
-out_blk_size:
-	kfree(blk_size[major]);
-out_dasd_device:
-	kfree(major_info->dasd_device);
-out_devfs:
-	devfs_unregister_blkdev(major, DASD_NAME);
+
+        /* error handling - free the prior allocated memory */  
+      out_gendisk:
+	kfree (max_sectors[major]);
+	max_sectors[major] = NULL;
+
+      out_max_sectors:
+	kfree (hardsect_size[major]);
+	hardsect_size[major] = NULL;
+
+      out_hardsect_size:
+	kfree (blksize_size[major]);
+	blksize_size[major] = NULL;
+
+      out_blksize_size:
+	kfree (blk_size[major]);
+	blk_size[major] = NULL;
+
+      out_blk_size:
+	kfree (major_info->dasd_device);
+
+      out_devices:
+	/* Delete the new major info from dasd_major_info list if needed (dynamic) +*/
+	if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC)) {
+		spin_lock_irqsave (&dasd_major_lock, flags);
+		list_del (&major_info->list);
+		spin_unlock_irqrestore (&dasd_major_lock, flags);
+	}
+
+        /* unregister blockdevice */
+	rc = devfs_unregister_blkdev (major, DASD_NAME);
+	if (rc < 0) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"Unable to unregister from major no %d, rc = %d\n", 
+                        major,
+			rc);
+	} else {
+		major_info->flags &= ~DASD_MAJOR_INFO_REGISTERED;
+	}
+
+      out_reg_blkdev:
+        kfree (major_info->gendisk.flags);
+        kfree (major_info->gendisk.de_arr);
+
+	/* Delete the new major info from dasd_major_info if needed */
+	if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC)) {
+		kfree (major_info);
+	}
+
 	return -ENOMEM;
 }
 
@@ -628,11 +818,7 @@
 		return -EINVAL;
 	}
 	major = major_info->gendisk.major;
-        INIT_BLK_DEV(major,NULL,NULL,NULL);
-	blk_size[major] = NULL;
-	blksize_size[major] = NULL;
-	hardsect_size[major] = NULL;
-	max_sectors[major] = NULL;
+	INIT_BLK_DEV (major, NULL, NULL, NULL);
 
 	/* do the gendisk stuff */
 	for (dd = gendisk_head; dd; dd = dd->next) {
@@ -648,39 +834,49 @@
 	if (dd == NULL) {
 		return -ENOENT;
 	}
-	kfree (major_info->gendisk.de_arr);
-	kfree (major_info->gendisk.flags);
 	kfree (major_info->dasd_device);
+	kfree (major_info->gendisk.part);
+
 	kfree (blk_size[major]);
 	kfree (blksize_size[major]);
 	kfree (hardsect_size[major]);
 	kfree (max_sectors[major]);
-	kfree (major_info->gendisk.part);
+
+	blk_size[major]      = NULL;
+	blksize_size[major]  = NULL;
+	hardsect_size[major] = NULL;
+	max_sectors[major]   = NULL;
 
 	rc = devfs_unregister_blkdev (major, DASD_NAME);
 	if (rc < 0) {
 		printk (KERN_WARNING PRINTK_HEADER
-		  "Cannot unregister from major no %d, rc = %d\n", major, rc);
+			"Cannot unregister from major no %d, rc = %d\n",
+                        major,
+			rc);
 		return rc;
 	} else {
 		major_info->flags &= ~DASD_MAJOR_INFO_REGISTERED;
 	}
-        /* Delete the new major info from dasd_major_info if needed */
-        if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC)) {
-                spin_lock_irqsave (&dasd_major_lock, flags);
-		list_del(&major_info->list);
+
+	kfree (major_info->gendisk.flags);
+	kfree (major_info->gendisk.de_arr);
+
+	/* Delete the new major info from dasd_major_info if needed */
+	if (!(major_info->flags & DASD_MAJOR_INFO_IS_STATIC)) {
+		spin_lock_irqsave (&dasd_major_lock, flags);
+		list_del (&major_info->list);
 		spin_unlock_irqrestore (&dasd_major_lock, flags);
 		kfree (major_info);
-        }
+	}
 	return rc;
 }
 
-/* 
+/*
  * function: dasd_device_from_kdev
  * finds the device structure corresponding to the kdev supplied as argument
  * in the major_info structures and returns it or NULL when not found
  */
-static inline dasd_device_t *
+dasd_device_t *
 dasd_device_from_kdev (kdev_t kdev)
 {
 	major_info_t *major_info = NULL;
@@ -688,9 +884,9 @@
 	unsigned long flags;
 
 	spin_lock_irqsave (&dasd_major_lock, flags);
-	list_for_each(l,&dasd_major_info[0].list) {
-		major_info = list_entry(l,major_info_t,list);
-		if ( major_info->gendisk.major == MAJOR(kdev) )
+	list_for_each (l, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
+		if (major_info->gendisk.major == MAJOR (kdev))
 			break;
 	}
 	spin_unlock_irqrestore (&dasd_major_lock, flags);
@@ -699,10 +895,10 @@
 	return NULL;
 }
 
-/* 
+/*
  * function: dasd_device_from_devno
- * finds the address of the device structure corresponding to the devno 
- * supplied as argument in the major_info structures and returns 
+ * finds the address of the device structure corresponding to the devno
+ * supplied as argument in the major_info structures and returns
  * it or NULL when not found
  */
 static inline dasd_device_t **
@@ -714,8 +910,8 @@
 	unsigned long flags;
 
 	spin_lock_irqsave (&dasd_major_lock, flags);
-	list_for_each(l,&dasd_major_info[0].list) {
-		major_info = list_entry(l,major_info_t,list);
+	list_for_each (l, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
 		if (devindex < DASD_PER_MAJOR) {
 			spin_unlock_irqrestore (&dasd_major_lock, flags);
 			return &major_info->dasd_device[devindex];
@@ -726,76 +922,112 @@
 	return NULL;
 }
 
+/*
+ * function: dasd_features_from_devno
+ * finds the device range corresponding to the devno
+ * supplied as argument in the major_info structures and returns
+ * the features set for it
+ */
+
+static int
+dasd_features_from_devno (int devno)
+{
+	dasd_range_t *temp;
+	int devindex = 0;
+	unsigned long flags;
+	struct list_head *l;
+
+	spin_lock_irqsave (&range_lock, flags);
+	list_for_each (l, &dasd_range_head.list) {
+		temp = list_entry (l, dasd_range_t, list);
+		if (devno >= temp->from && devno <= temp->to) {
+			spin_unlock_irqrestore (&range_lock, flags);
+			return temp->features;
+		}
+		devindex += temp->to - temp->from + 1;
+	}
+	spin_unlock_irqrestore (&range_lock, flags);
+	return -ENODEV;
+}
+
+
+
 /* SECTION: managing dasd disciplines */
 
 /* anchor and spinlock for list of disciplines */
-static dasd_discipline_t *dasd_disciplines;
+static struct list_head dasd_disc_head = LIST_HEAD_INIT(dasd_disc_head);
 static spinlock_t discipline_lock = SPIN_LOCK_UNLOCKED;
 
-/* 
- * function dasd_discipline_enq 
+/*
+ * function dasd_discipline_enq
  * chains the discpline given as argument to the head of disiplines
  * head chaining policy is required to allow module disciplines to
  * be preferred against those, who are statically linked
  */
-void
+static inline void
 dasd_discipline_enq (dasd_discipline_t * d)
 {
-	spin_lock (&discipline_lock);
-	d->next = dasd_disciplines;
-	dasd_disciplines = d;
-	spin_unlock (&discipline_lock);
+    list_add(&d->list, &dasd_disc_head);
 }
 
-/* 
- * function dasd_discipline_deq 
+/*
+ * function dasd_discipline_deq
  * removes the discipline given as argument from the list of disciplines
  */
-int
+static inline void
 dasd_discipline_deq (dasd_discipline_t * d)
 {
-	int rc = 0;
-	spin_lock (&discipline_lock);
-	if (dasd_disciplines == d) {
-		dasd_disciplines = dasd_disciplines->next;
-	} else {
-		dasd_discipline_t *b;
-		b = dasd_disciplines;
-		while (b && b->next != d)
-			b = b->next;
-		if (b != NULL) {
-			b->next = b->next->next;
-		} else {
-			rc = -ENOENT;
-		}
-	}
-	spin_unlock (&discipline_lock);
-	return rc;
+        list_del(&d->list);
+}
+
+void
+dasd_discipline_add (dasd_discipline_t * d)
+{
+        unsigned long flags;
+        MOD_INC_USE_COUNT;
+	spin_lock_irqsave (&discipline_lock,flags);
+        dasd_discipline_enq (d);
+	spin_unlock_irqrestore (&discipline_lock,flags);
+        dasd_enable_ranges (&dasd_range_head, d, DASD_STATE_ONLINE);
+}
+
+void dasd_discipline_del (dasd_discipline_t * d)
+{
+        unsigned long flags;
+	spin_lock_irqsave (&discipline_lock,flags);
+        dasd_disable_ranges(&dasd_range_head, d, DASD_STATE_DEL, 1);
+        dasd_discipline_deq (d);
+	spin_unlock_irqrestore (&discipline_lock,flags);
+        MOD_DEC_USE_COUNT;
 }
 
 static inline dasd_discipline_t *
-dasd_find_discipline (dasd_device_t * device)
+dasd_find_disc (dasd_device_t * device, dasd_discipline_t *d)
 {
-	dasd_discipline_t *temp;
-	for (temp = dasd_disciplines; temp != NULL; temp = temp->next) {
-		if (temp->id_check)
-			if (temp->id_check (&device->devinfo)) {
-				continue;
-                        }
-		if (temp->check_characteristics) {
-			if (temp->check_characteristics (device)) {
-				continue;
-                        }
-		}
-		break;
-	}
-	return temp;
+        dasd_discipline_t *t;
+        struct list_head *l = d ? &d->list : dasd_disc_head.next;
+        do {
+                t = list_entry(l,dasd_discipline_t,list);
+                if ( ( t->id_check == NULL ||
+                       t->id_check (&device->devinfo) == 0 ) &&
+                     ( t->check_characteristics == NULL ||
+                       t->check_characteristics (device) == 0 ) )
+                        break;
+                l = l->next;
+                if ( d || 
+                     l == &dasd_disc_head ) {
+                        t = NULL;
+                        break;
+                }
+         } while ( 1 );
+	return t;
 }
 
 /* SECTION: profiling stuff */
 
 static dasd_profile_info_t dasd_global_profile;
 
+#ifdef DASD_PROFILE
 /*
  * macro: dasd_profile_add_counter
  * increments counter in global and local profiling structures
@@ -813,20 +1045,27 @@
 }
 
 /*
- * function dasd_profile_add 
+ * function dasd_profile_add
  * adds the profiling information from the cqr given as argument to the
- * global and device specific profiling information 
+ * global and device specific profiling information
  */
 void
 dasd_profile_add (ccw_req_t * cqr)
 {
-	long strtime, irqtime, endtime, tottime;
+	long strtime, irqtime, endtime, tottime; /* in microsecnds*/
 	long tottimeps, sectors;
 	dasd_device_t *device = cqr->device;
 
 	if (!cqr->req)		/* safeguard against abnormal cqrs */
 		return;
-	sectors = ((struct request *) (cqr->req))->nr_sectors;
+
+        if ((!cqr->buildclk) ||
+            (!cqr->startclk) ||
+            (!cqr->stopclk ) ||
+            (!cqr->endclk  ) ||
+            (!(sectors = ((struct request *) (cqr->req))->nr_sectors)))
+                return;
+
 	strtime = ((cqr->startclk - cqr->buildclk) >> 12);
 	irqtime = ((cqr->stopclk - cqr->startclk) >> 12);
 	endtime = ((cqr->endclk - cqr->stopclk) >> 12);
@@ -840,8 +1079,10 @@
 		memset (&device->profile, 0, sizeof (dasd_profile_info_t));
 	};
 
-        dasd_global_profile.dasd_io_reqs++;
-        device->profile.dasd_io_reqs++;
+	dasd_global_profile.dasd_io_reqs++;
+	device->profile.dasd_io_reqs++;
+	dasd_global_profile.dasd_io_sects+=sectors;
+	device->profile.dasd_io_sects+=sectors;
 	dasd_profile_add_counter (sectors, dasd_io_secs, device);
 	dasd_profile_add_counter (tottime, dasd_io_times, device);
 	dasd_profile_add_counter (tottimeps, dasd_io_timps, device);
@@ -850,15 +1091,151 @@
 	dasd_profile_add_counter (irqtime / sectors, dasd_io_time2ps, device);
 	dasd_profile_add_counter (endtime, dasd_io_time3, device);
 }
+#endif
+
+/* SECTION: All the gendisk stuff */
+
+
+/* SECTION: Managing wrappers for ccwcache */
+
+/*
+ * function dasd_alloc_request
+ * tries to return space for a channel program of length cplength with
+ * additional data of size datasize.
+ * If the ccwcache cannot fulfill the request it tries the emergeny requests
+ * before giving up finally
+ * FIXME: initialization of ccw_req_t should be done by function of ccwcache
+ */
+ccw_req_t *
+dasd_alloc_request (char *magic, int cplength, int datasize, dasd_device_t* device)
+{
+	ccw_req_t *rv = NULL;
+
+	if ((rv = ccw_alloc_request (magic, cplength, datasize)) != NULL) {
+		return rv;
+	}
+	if ((((sizeof (ccw_req_t) + 7) & -8) +
+	     cplength * sizeof (ccw1_t) + datasize) > PAGE_SIZE) {
+		BUG ();
+		}
+        if (device->lowmem_cqr==NULL) {
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_alloc_request,
+                                         "(%04x) Low memory! Using emergency request %p.",
+                                         device->devinfo.devno,
+                                         device->lowmem_ccws);
+
+                device->lowmem_cqr=device->lowmem_ccws;
+                rv = device->lowmem_ccws;
+		memset (rv, 0, PAGE_SIZE);
+		strncpy ((char *) (&rv->magic), magic, 4);
+		ASCEBC ((char *) (&rv->magic), 4);
+		rv->cplength = cplength;
+		rv->datasize = datasize;
+		rv->data = (void *) ((long) rv + PAGE_SIZE - datasize);
+		rv->cpaddr = (ccw1_t *) ((long) rv + sizeof (ccw_req_t));
+        } else {
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_alloc_request,
+                                         "(%04x) Refusing emergency mem for request "
+                                         "NULL, already in use at %p.",
+                                         device->devinfo.devno,
+                                         device->lowmem_ccws);
+	}
+	return rv;
+}
+
+/*
+ * function dasd_free_request
+ * returns a ccw_req_t to the appropriate cache or emergeny request line
+ */
+void
+dasd_free_request (ccw_req_t * request, dasd_device_t* device)
+{
+#ifdef CONFIG_ARCH_S390X
+        ccw1_t* ccw;
+        /* clear any idals used for chain */
+        ccw=request->cpaddr-1;
+        do {
+                ccw++;
+                if ((ccw->cda < (unsigned long) device->lowmem_idals           ) || 
+                    (ccw->cda >= (unsigned long) device->lowmem_idals+PAGE_SIZE)   )
+                        clear_normalized_cda (ccw);
+                else {
+                        if (device->lowmem_idal_ptr != device->lowmem_idals)
+                                DASD_MESSAGE (KERN_WARNING, device,
+                                              "Freeing emergency idals from request at %p.",
+                                              request);
+                        device->lowmem_idal_ptr = device->lowmem_idals;
+                        device->lowmem_cqr=NULL;
+                }
+        } while ((ccw->flags & CCW_FLAG_CC) || 
+                 (ccw->flags & CCW_FLAG_DC)   );
+#endif
+        if (request != device->lowmem_ccws) { 
+                /* compare to lowmem_ccws to protect usage of lowmem_cqr for IDAL only ! */
+		ccw_free_request (request);
+        } else {
+                DASD_MESSAGE (KERN_WARNING, device,
+                              "Freeing emergency request at %p",
+                              request);
+                device->lowmem_cqr=NULL;
+	}
+}
+
+int
+dasd_set_normalized_cda (ccw1_t * cp, unsigned long address, 
+                         ccw_req_t* request, dasd_device_t* device )
+{
+#ifdef CONFIG_ARCH_S390X
+	int nridaws;
+        int count = cp->count;
+        
+        if (set_normalized_cda (cp, address)!=-ENOMEM) {
+                return 0;
+        }
+
+        if ((device->lowmem_cqr!=NULL) && (device->lowmem_cqr!=request)) {
+                DASD_MESSAGE (KERN_WARNING, device, 
+                              "Refusing emergency idals for request %p, memory"
+                              " is already in use for request %p",
+                              request,
+                              device->lowmem_cqr);
+                return -ENOMEM;
+        }
+        device->lowmem_cqr=request;
+        if (device->lowmem_idal_ptr == device->lowmem_idals) {
+            DASD_MESSAGE (KERN_WARNING,device, 
+                          "Low memory! Using emergency IDALs for request %p.\n",
+                          request);
+        }
+        nridaws = ((address & (IDA_BLOCK_SIZE-1)) + count + 
+		   (IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
+	if ( device->lowmem_idal_ptr>=device->lowmem_idals + PAGE_SIZE ) {
+		/* Ouch! No Idals left for emergency request */
+		BUG();
+	}
+	cp->flags |= CCW_FLAG_IDA;
+	cp->cda = (__u32)(unsigned long)device->lowmem_idal_ptr;
+        do {
+		*((long*)device->lowmem_idal_ptr) = address;
+		address = (address & -(IDA_BLOCK_SIZE)) + (IDA_BLOCK_SIZE);
+		nridaws --;
+                device->lowmem_idal_ptr += sizeof(unsigned long);
+        } while ( nridaws > 0 );
+#else 
+        cp -> cda = address;
+#endif
+	return 0;
+}
+
 
 /* SECTION: (de)queueing of requests to channel program queues */
 
-/* 
- * function dasd_chanq_enq 
+/*
+ * function dasd_chanq_enq
  * appends the cqr given as argument to the queue
  * has to be called with the queue lock (namely the s390_irq_lock) acquired
  */
-static inline void
+inline void
 dasd_chanq_enq (dasd_chanq_t * q, ccw_req_t * cqr)
 {
 	if (q->head != NULL) {
@@ -867,38 +1244,58 @@
 		q->head = cqr;
 	cqr->next = NULL;
 	q->tail = cqr;
-	check_then_set (&cqr->status, CQR_STATUS_FILLED, CQR_STATUS_QUEUED);
+	check_then_set (&cqr->status, 
+                        CQR_STATUS_FILLED, 
+                        CQR_STATUS_QUEUED);
+
+       
+#ifdef DASD_PROFILE
+        /* save profile information for non erp cqr */
+        if (cqr->refers == NULL) {
+                unsigned int  counter = 0;
+                ccw_req_t     *ptr;
+                dasd_device_t *device = cqr->device;
+
+                /* count the length of the chanq for statistics */
+                for (ptr = q->head; 
+                     ptr->next != NULL && counter <=31; 
+                     ptr = ptr->next) {
+                        counter++;
+                }                
+                
+                dasd_global_profile.dasd_io_nr_req[counter]++;
+                device->profile.dasd_io_nr_req[counter]++;
+        }
+#endif 
 }
 
-/* 
+/*
  * function dasd_chanq_enq_head
  * chains the cqr given as argument to the queue head
  * has to be called with the queue lock (namely the s390_irq_lock) acquired
  */
-static inline void
+inline void
 dasd_chanq_enq_head (dasd_chanq_t * q, ccw_req_t * cqr)
 {
 	cqr->next = q->head;
 	q->head = cqr;
 	if (q->tail == NULL)
 		q->tail = cqr;
-	check_then_set (&cqr->status,
-		       CQR_STATUS_FILLED,
-		       CQR_STATUS_QUEUED);
+	check_then_set (&cqr->status, CQR_STATUS_FILLED, CQR_STATUS_QUEUED);
 }
 
-/* 
+/*
  * function dasd_chanq_deq
  * dechains the cqr given as argument from the queue
  * has to be called with the queue lock (namely the s390_irq_lock) acquired
  */
-int
+inline void
 dasd_chanq_deq (dasd_chanq_t * q, ccw_req_t * cqr)
 {
 	ccw_req_t *prev;
 
 	if (cqr == NULL)
-                BUG ();
+		BUG ();
 
 	if (cqr == q->head) {
 		q->head = cqr->next;
@@ -910,138 +1307,90 @@
 		while (prev && prev->next != cqr)
 			prev = prev->next;
 		if (prev == NULL)
-			return -ENOENT;
+			return;
 		prev->next = cqr->next;
 		if (prev->next == NULL)
 			q->tail = prev;
 	}
 	cqr->next = NULL;
-	return 0;
 }
 
-/* SECTION: All the gendisk stuff */
+/* SECTION: Managing the device queues etc. */
 
-/* 
- * function dasd_partn_detect
- * calls the function in genhd, which is appropriate to setup a partitioned disk
+/*
+ * DASD_TERM_IO
+ *
+ * attempts to terminate the the current IO and set it to failed if termination
+ * was successful.
+ * returns an appropriate return code
  */
-static void
-dasd_partn_detect (dasd_device_t * dev)
+int
+dasd_term_IO (ccw_req_t * cqr)
 {
-	major_info_t *major_info = dev->major_info;
-	struct gendisk *dd = &major_info->gendisk;
-	int minor = MINOR (dev->kdev);
-
-	register_disk (dd,
-		       MKDEV (dd->major, minor),
-		       1 << DASD_PARTN_BITS,
-		       &dasd_device_operations,
-		       (dev->sizes.blocks << dev->sizes.s2b_shift));
-}
-
-/* SECTION: Managing wrappers for ccwcache */
-
-/* array and spinlock of emergency requests */
-static ccw_req_t *dasd_emergency_req[DASD_EMERGENCY_REQUESTS];
-static spinlock_t dasd_emergency_req_lock = SPIN_LOCK_UNLOCKED;
+	int rc = 0;
+	dasd_device_t *device = cqr->device;
+	int irq;
+        int retries = 0;
 
-/* 
- * function dasd_init_emergeny_req
- * allocates emergeny requests
- */
-static inline void __init
-dasd_init_emergency_req (void)
-{
-	int i;
-	for (i = 0; i < DASD_EMERGENCY_REQUESTS; i++) {
-		dasd_emergency_req[i] = (ccw_req_t *) get_free_page (GFP_KERNEL);
-		memset (dasd_emergency_req[i], 0, PAGE_SIZE);
+	if (!cqr) {
+		BUG ();
 	}
-}
-
-/* 
- * function dasd_cleanup_emergeny_req
- * tries to free emergeny requests skipping those, which are currently in use
- */
-static inline void
-dasd_cleanup_emergency_req (void)
-{
-	int i;
-	for (i = 0; i < DASD_EMERGENCY_REQUESTS; i++) {
-		if (dasd_emergency_req[i])
-			free_page ((long) (dasd_emergency_req[i]));
-		else
-			printk (KERN_WARNING PRINTK_HEADER
-				"losing page for emergency request in use\n");
+	irq = device->devinfo.irq;
+	if (strncmp ((char *) &cqr->magic, device->discipline->ebcname, 4)) {
+		DASD_MESSAGE (KERN_WARNING, device,
+			      " ccw_req_t 0x%08x magic doesn't match"
+			      " discipline 0x%08x\n",
+			      cqr->magic,
+			      *(unsigned int *) device->discipline->name);
+		return -EINVAL;
 	}
-}
+        
+        while ((retries < 5                    ) &&
+               (cqr->status == CQR_STATUS_IN_IO)   ) {
 
-/* 
- * function dasd_alloc_request
- * tries to return space for a channel program of length cplength with
- * additional data of size datasize. 
- * If the ccwcache cannot fulfill the request it tries the emergeny requests
- * before giving up finally
- * FIXME: initialization of ccw_req_t should be done by function of ccwcache
- */
-ccw_req_t *
-dasd_alloc_request (char *magic, int cplength, int datasize)
-{
-	ccw_req_t *rv = NULL;
-	int i;
-	unsigned long flags;
+                if ( retries < 2 )
+                        rc = halt_IO(irq, (long)cqr, 
+                                     cqr->options | DOIO_WAIT_FOR_INTERRUPT);
+                else
+                        rc = clear_IO(irq, (long)cqr, 
+                                      cqr->options | DOIO_WAIT_FOR_INTERRUPT);
+
+                switch (rc) {
+                case 0:         /* termination successful */
+                        check_then_set (&cqr->status,
+                                        CQR_STATUS_IN_IO, 
+                                        CQR_STATUS_FAILED);
+                        
+                        asm volatile ("STCK %0":"=m" (cqr->stopclk));
+                        break;
+                case -ENODEV:
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "device gone, retry\n");
+                        break;
+                case -EIO:
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "I/O error, retry\n");
+                        break;
+                case -EBUSY:
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "device busy, retry later\n");
+                        break;
+                default:
+                        DASD_MESSAGE (KERN_ERR, device,
+                                      "line %d unknown RC=%d, please report"
+                                      " to linux390@de.ibm.com\n", 
+                                      __LINE__, 
+                                      rc);
+                        BUG ();
+                        break;
+                }
 
-	if ((rv = ccw_alloc_request (magic, cplength, datasize)) != NULL) {
-		return rv;
-	}
-	if ((((sizeof (ccw_req_t) + 7) & -8) + 
-             cplength*sizeof(ccw1_t) + datasize) > PAGE_SIZE) {
-            BUG();
+                retries ++;
         }
-	spin_lock_irqsave (&dasd_emergency_req_lock, flags);
-	for (i = 0; i < DASD_EMERGENCY_REQUESTS; i++) {
-		if (dasd_emergency_req[i] != NULL) {
-			rv = dasd_emergency_req[i];
-			dasd_emergency_req[i] = NULL;
-			break;
-		}
-	}
-	spin_unlock_irqrestore (&dasd_emergency_req_lock, flags);
-	if (rv) {
-		memset (rv, 0, PAGE_SIZE);
-		rv->cache = (kmem_cache_t *) (dasd_emergency_req + i);
-		strncpy ((char *) (&rv->magic), magic, 4);
-		ASCEBC ((char *) (&rv->magic), 4);
-		rv->cplength = cplength;
-		rv->datasize = datasize;
-		rv->data = (void *) ((long) rv + PAGE_SIZE - datasize);
-		rv->cpaddr = (ccw1_t *) ((long) rv + sizeof (ccw_req_t));
-	} else {
-		panic ("No way to fulfill request for I/O request\n");
-	}
-	return rv;
+	return rc;
 }
 
-/* 
- * function dasd_free_request
- * returns a ccw_req_t to the appropriate cache or emergeny request line
- */
-void
-dasd_free_request (ccw_req_t * request)
-{
-	if ((request->cache >= (kmem_cache_t *) dasd_emergency_req) &&
-	    (request->cache < (kmem_cache_t *) (dasd_emergency_req +
-						DASD_EMERGENCY_REQUESTS))) {
-		*((ccw_req_t **) (request->cache)) = request;
-	} else {
-		ccw_free_request (request);
-	}
-}			
-
-/* SECTION: Managing the device queues etc. */
-
-
-/* 
+/*
  * function dasd_start_IO
  * attempts to start the IO and returns an appropriate return code
  */
@@ -1051,7 +1400,7 @@
 	int rc = 0;
 	dasd_device_t *device = cqr->device;
 	int irq;
-        unsigned long long now;
+	unsigned long long now;
 
 	if (!cqr) {
 		BUG ();
@@ -1059,82 +1408,107 @@
 	irq = device->devinfo.irq;
 	if (strncmp ((char *) &cqr->magic, device->discipline->ebcname, 4)) {
 		DASD_MESSAGE (KERN_WARNING, device,
-			      " ccw_req_t 0x%08X magic doesn't match"
-			      " discipline 0x%08X\n",
+			      " ccw_req_t 0x%08x magic doesn't match"
+			      " discipline 0x%08x\n",
 			      cqr->magic,
 			      *(unsigned int *) device->discipline->name);
 		return -EINVAL;
 	}
 
-        asm volatile ("STCK %0":"=m" (now));
-        rc = do_IO (irq, cqr->cpaddr, (long) cqr, cqr->lpm, cqr->options);
-        switch (rc) {
-        case 0:
-            break;
-        case -ENODEV:
-                check_then_set (&cqr->status, 
-                               CQR_STATUS_QUEUED, CQR_STATUS_FAILED);
-            break;
-        case -EIO:
-                check_then_set (&cqr->status, 
-                               CQR_STATUS_QUEUED, CQR_STATUS_FAILED);
-            break;
-        case -EBUSY:
-                DASD_MESSAGE (KERN_WARNING, device,"%s",
-                              "device busy, retry later\n");
-                break;
-        default:
-                DASD_MESSAGE (KERN_ERR, device,
-                              "line %d unknown RC=%d, please report"
-                              " to linux390@de.ibm.com\n",
-                              __LINE__, rc);
-                BUG();
-            break;
-        }
-	if (rc == 0) {
-                check_then_set (&cqr->status, 
-                               CQR_STATUS_QUEUED, CQR_STATUS_IN_IO);
-                cqr->startclk = now;
+	asm volatile ("STCK %0":"=m" (now));
+        cqr->startclk = now;
+
+	rc = do_IO (irq, cqr->cpaddr, (long) cqr, cqr->lpm, cqr->options);
+
+	switch (rc) {
+	case 0:
+                if (cqr->options & DOIO_WAIT_FOR_INTERRUPT) {
+                        /* request already finished (synchronous IO) */
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      " do_IO finished request... "
+                                      "DOIO_WAIT_FOR_INTERRUPT was set");
+                        check_then_set (&cqr->status,
+                                        CQR_STATUS_QUEUED, 
+                                        CQR_STATUS_DONE);
+
+                        cqr->stopclk = now;
+                        dasd_schedule_bh (device);
+                        
+                } else {
+                        check_then_set (&cqr->status,
+                                        CQR_STATUS_QUEUED, 
+                                        CQR_STATUS_IN_IO);
+                }
+		break;
+	case -EBUSY:
+		DASD_MESSAGE (KERN_WARNING, device, "%s",
+			      "device busy, retry later\n");
+		break;
+	case -ETIMEDOUT: 
+		DASD_MESSAGE (KERN_WARNING, device, "%s",
+			      "request timeout - terminated\n");
+	case -ENODEV:
+	case -EIO:
+		check_then_set (&cqr->status,
+				CQR_STATUS_QUEUED, 
+                                CQR_STATUS_FAILED);
+
+                cqr->stopclk = now;
+                dasd_schedule_bh (device);
+		break;
+	default:
+		DASD_MESSAGE (KERN_ERR, device,
+			      "line %d unknown RC=%d, please report"
+			      " to linux390@de.ibm.com\n", __LINE__, rc);
+		BUG ();
+		break;
 	}
+
 	return rc;
 }
 
-/* 
- * function sleep_on_req
+/*
+ * function dasd_sleep_on_req
  * attempts to start the IO and waits for completion
  * FIXME: replace handmade sleeping by wait_event
  */
-static int
-sleep_on_req (ccw_req_t * req)
+int
+dasd_sleep_on_req (ccw_req_t * req)
 {
 	unsigned long flags;
 	int cs;
 	int rc = 0;
 	dasd_device_t *device = (dasd_device_t *) req->device;
 
+        if ( signal_pending(current) ) {
+                return -ERESTARTSYS;
+        }
 	s390irq_spin_lock_irqsave (device->devinfo.irq, flags);
 	dasd_chanq_enq (&device->queue, req);
-        /* let the bh start the request to keep them in order */
-	dasd_schedule_bh (device); 
-        
+	/* let the bh start the request to keep them in order */
+	dasd_schedule_bh (device);
 	do {
 		s390irq_spin_unlock_irqrestore (device->devinfo.irq, flags);
-                wait_event (device->wait_q,
-                            (((cs=req->status)==CQR_STATUS_DONE)||
-                            (cs==CQR_STATUS_FAILED)));
+		wait_event ( device->wait_q,
+			     (((cs = req->status) == CQR_STATUS_DONE) ||
+			     (cs == CQR_STATUS_FAILED) ||
+                             signal_pending(current)));
 		s390irq_spin_lock_irqsave (device->devinfo.irq, flags);
-		cs = req->status;
+                if ( signal_pending(current) ) {
+                        rc = -ERESTARTSYS;
+		     	if (req->status == CQR_STATUS_IN_IO ) 
+                        	device->discipline->term_IO(req);
+                        break;
+                } else if ( req->status == CQR_STATUS_FAILED) {
+                        rc = -EIO;
+                        break;
+                }
 	} while (cs != CQR_STATUS_DONE && cs != CQR_STATUS_FAILED);
-
 	s390irq_spin_unlock_irqrestore (device->devinfo.irq, flags);
-	if (cs == CQR_STATUS_FAILED) {
-		rc = -EIO;
-	}
 	return rc;
+}				/* end dasd_sleep_on_req */
 
-}				/* end sleep_on_req */
-
-/* 
+/*
  * function dasd_end_request
  * posts the buffer_cache about a finalized request
  * FIXME: for requests splitted to serveral cqrs
@@ -1142,7 +1516,8 @@
 static inline void
 dasd_end_request (struct request *req, int uptodate)
 {
-	while (end_that_request_first (req, uptodate, DASD_NAME)) {}
+	while (end_that_request_first (req, uptodate, DASD_NAME)) {
+	}
 #ifndef DEVICE_NO_RANDOM
 	add_blkdev_randomness (MAJOR (req->rq_dev));
 #endif
@@ -1150,7 +1525,7 @@
 	return;
 }
 
-/* 
+/*
  * function dasd_get_queue
  * returns the queue corresponding to a device behind a kdev
  */
@@ -1158,13 +1533,18 @@
 dasd_get_queue (kdev_t kdev)
 {
 	dasd_device_t *device = dasd_device_from_kdev (kdev);
-	return &device->request_queue;
+
+	if (!device) {
+		return NULL;
+	}
+
+	return device->request_queue;
 }
 
-/* 
+/*
  * function dasd_check_expire_time
  * check the request given as argument for expiration
- * and returns 0 if not yet expired, nonzero else
+ * and returns 0 if not yet expired, EIO else
  */
 static inline int
 dasd_check_expire_time (ccw_req_t * cqr)
@@ -1173,18 +1553,18 @@
 	int rc = 0;
 
 	asm volatile ("STCK %0":"=m" (now));
-	if ( cqr->expires && 
-             cqr->expires + cqr->startclk <  now) {
-		DASD_MESSAGE (KERN_ERR, ((dasd_device_t*)cqr->device),
+	if (cqr->expires && cqr->expires + cqr->startclk < now) {
+		DASD_MESSAGE (KERN_ERR, ((dasd_device_t *) cqr->device),
 			      "IO timeout 0x%08lx%08lx usecs in req %p\n",
-			      (long) (cqr->expires >> 44), 
-                              (long) (cqr->expires >> 12), cqr);
-		cqr->expires <<=1;
+			      (long) (cqr->expires >> 44),
+			      (long) (cqr->expires >> 12), cqr);
+		cqr->expires <<= 1;
+                rc = -EIO;
 	}
 	return rc;
 }
 
-/* 
+/*
  * function dasd_finalize_request
  * implemets the actions to perform, when a request is finally finished
  * namely in status CQR_STATUS_DONE || CQR_STATUS_FAILED
@@ -1192,190 +1572,237 @@
 static inline void
 dasd_finalize_request (ccw_req_t * cqr)
 {
-        dasd_device_t *device = cqr->device;
-        
+	dasd_device_t *device = cqr->device;
+
 	asm volatile ("STCK %0":"=m" (cqr->endclk));
 	if (cqr->req) {
-                dasd_end_request (cqr->req, (cqr->status == CQR_STATUS_DONE));
-                dasd_profile_add (cqr);
+#ifdef DASD_PROFILE
+		dasd_profile_add (cqr);
+#endif
+		dasd_end_request (cqr->req, (cqr->status == CQR_STATUS_DONE));
 		/* free request if nobody is waiting on it */
-		dasd_free_request (cqr);
+		dasd_free_request (cqr, cqr->device);
 	} else {
-		/* during format we don't have the request structure */
+                if ( cqr == device->init_cqr && /* bring late devices online */
+                     device->level <= DASD_STATE_ONLINE ) { 
+                        device->timer.function = dasd_enable_single_device; 
+                        device->timer.data     = (unsigned long) device;
+                        device->timer.expires  = jiffies;
+                        add_timer(&device->timer);
+                }
 		/* notify sleeping task about finished postprocessing */
 		wake_up (&device->wait_q);
+                
 	}
 	return;
 }
 
-/* 
+/*
  * function dasd_process_queues
  * transfers the requests on the queue given as argument to the chanq
  * if possible, the request ist started on a fastpath
  */
 static void
-dasd_process_queues (dasd_device_t *device)
+dasd_process_queues (dasd_device_t * device)
 {
-        unsigned long flags;
-        struct request *req;
-        request_queue_t * queue = &device->request_queue;
+	unsigned long flags;
+	struct request *req;
+	request_queue_t *queue = device->request_queue;
 	dasd_chanq_t *qp = &device->queue;
-        int irq = device -> devinfo.irq;
-        ccw_req_t *final_requests= NULL;
-        static int chanq_min_size = DASD_MIN_SIZE_FOR_QUEUE;
-        int chanq_max_size = DASD_CHANQ_MAX_SIZE;
-        ccw_req_t * cqr=NULL,*temp;
-        dasd_erp_postaction_fn_t erp_postaction;
-
-        s390irq_spin_lock_irqsave (irq, flags);
-        /* First we dechain the requests, processed with completed status */
-        while ( qp -> head && 
-                ((qp -> head -> status == CQR_STATUS_DONE) || 
-                 (qp -> head -> status == CQR_STATUS_FAILED) ||
-		 (qp -> head -> status == CQR_STATUS_ERROR) ) ) {
+	int irq = device->devinfo.irq;
+	ccw_req_t *final_requests = NULL;
+	static int chanq_min_size = DASD_MIN_SIZE_FOR_QUEUE;
+	int chanq_max_size = DASD_CHANQ_MAX_SIZE;
+	ccw_req_t *cqr = NULL, *temp;
+	dasd_erp_postaction_fn_t erp_postaction;
+
+
+	s390irq_spin_lock_irqsave (irq, flags);
+
+	/* First we dechain the requests, processed with completed status */
+	while (qp->head &&
+	       ((qp->head->status == CQR_STATUS_DONE  ) ||
+		(qp->head->status == CQR_STATUS_FAILED) ||
+		(qp->head->status == CQR_STATUS_ERROR )   )) {
+
 		dasd_erp_action_fn_t erp_action;
-		ccw_req_t *erp_cqr = NULL;
+		ccw_req_t            *erp_cqr = NULL;
+
 		/*  preprocess requests with CQR_STATUS_ERROR */
-		if (qp -> head -> status == CQR_STATUS_ERROR) {
-			if ((qp -> head -> dstat -> flag & DEVSTAT_HALT_FUNCTION) ||
-			    (qp->head->retries-- == 0 ) ||
-			    (device->discipline->erp_action==NULL) ||
-			    ((erp_action=device->discipline->erp_action(qp->head))==NULL)||
-			    ((erp_cqr = erp_action(qp->head))== NULL)) {
-				check_then_set (&qp->head->status,
+		if (qp->head->status == CQR_STATUS_ERROR) {
+
+                        qp->head->retries--; 
+
+			if (qp->head->dstat->flag & DEVSTAT_HALT_FUNCTION) {
+
+                                check_then_set (&qp->head->status,
                                                 CQR_STATUS_ERROR,
                                                 CQR_STATUS_FAILED);
-                                continue;
+
+                                asm volatile ("STCK %0":"=m" (qp->head->stopclk));
+
+                        } else if ((device->discipline->erp_action == NULL                          ) ||
+                                   ((erp_action = device->discipline->erp_action (qp->head)) == NULL)   ) {
+                                
+				erp_cqr = dasd_default_erp_action (qp->head);
+
+			} else { /* call discipline ERP action */
+
+                                erp_cqr = erp_action (qp->head);
+                        }
+                        continue;
+
+		} else if (qp->head->refers) {	/* we deal with a finished ERP */
+
+			if (qp->head->status == CQR_STATUS_DONE) {
+
+                                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                                              "ERP successful");
 			} else {
-                                if (erp_cqr != qp->head){
-                                        dasd_chanq_enq_head (qp, erp_cqr);
-                                }
-				/* chain of completed requests is now broken */
-				continue; 
+
+                                DASD_MESSAGE (KERN_ERR, device, "%s",
+                                              "ERP unsuccessful");
 			}
-		} else if ( qp -> head -> refers ) { /* we deal with an ERP */
-                        char *uptodatestr;
-                        if ( qp -> head -> status == CQR_STATUS_DONE) {
-                                uptodatestr = "ERP successful";
-                        } else {
-                                uptodatestr = "ERP unsuccessful";
-                        }
-                        
-                        if (device->discipline->erp_postaction == NULL ||
-                            ((erp_postaction = device->discipline->erp_postaction (qp->head)) == NULL)) {
-                                /* 
-                                                         * maybe we shoud set it to FAILED, 
-                                                         * because we are very paranoid ;) 
-                                                         */
-                                erp_postaction = default_erp_postaction;
+
+			if ((device->discipline->erp_postaction == NULL                              )||
+			    ((erp_postaction = device->discipline->erp_postaction (qp->head)) == NULL)  ) {
+
+                                dasd_default_erp_postaction (qp->head);
+
+			} else {  /* call ERP postaction of discipline */
+
+                                erp_postaction (qp->head);
                         }
-                        DASD_MESSAGE (KERN_INFO, device,
-                                      "%s: postaction [<%p>]\n",
-                                      uptodatestr, erp_postaction);
-                        erp_postaction (qp->head);
-                        continue;
-                }
-                
+
+			continue;
+		}
+
 		/* dechain request now */
-                if ( final_requests == NULL )
-                        final_requests = qp -> head;
-                cqr = qp -> head;
-                qp -> head = qp -> head -> next;
+		if (final_requests == NULL)
+			final_requests = qp->head;
+
+		cqr      = qp->head;
+		qp->head = qp->head->next;
+
 		if (qp->head == NULL)
 			qp->tail = NULL;
-        }
-        if ( cqr )
-            cqr -> next = NULL;
-        /* Now we try to fetch requests from the request queue */
-        for (temp = cqr; temp != NULL ;temp=temp-> next )
-                if ( temp ->status == CQR_STATUS_QUEUED)
-                        chanq_max_size --;
-	while ( (! queue->plugged) &&
-		(! list_empty(&queue->queue_head)) && 
-                (req=dasd_next_request(queue)) != NULL) {
-                /* queue empty or certain critera fulfilled -> transfer */
-                if ( qp -> head == NULL ||
-                     chanq_max_size > 0 ||
-                     (req->nr_sectors >= chanq_min_size)) {
-                        ccw_req_t *cqr;
-                        /* relocate request according to partition table */
-                        req->sector += device->major_info->gendisk.part[MINOR (req->rq_dev)].start_sect;
-                        cqr = device->discipline->build_cp_from_req (device, req);
-                        if (cqr == NULL) {
-                                DASD_MESSAGE (KERN_WARNING, device,
-                                              "CCW creation failed on request %p\n", req);
-				/* revert relocation of request */
-                                req->sector -= device->major_info->gendisk.part[MINOR (req->rq_dev)].start_sect;
-                                break; /* terminate request queue loop */
-                                
-                        } 
+
+	} /* end while over completed requests */
+
+	if (cqr)
+		cqr->next = NULL;
+	/* Now clean the requests with final status */
+	while (final_requests) { 
+		temp = final_requests;
+		final_requests = temp->next;
+		dasd_finalize_request (temp);
+	}
+	/* Now we try to fetch requests from the request queue */
+	for (temp = cqr; temp != NULL; temp = temp->next)
+		if (temp->status == CQR_STATUS_QUEUED)
+			chanq_max_size--;
+	while ((atomic_read(&device->plugged) == 0) &&
+               (!queue->plugged) &&
+	       (!list_empty (&queue->queue_head)) &&
+	       (req = dasd_next_request (queue)) != NULL) {
+		/* queue empty or certain critera fulfilled -> transfer */
+		if (qp->head == NULL ||
+		    chanq_max_size > 0 || (req->nr_sectors >= chanq_min_size)) {
+			ccw_req_t *cqr = NULL;
+                        if (is_read_only(device->kdev) && req->cmd == WRITE) {
+
+                                DASD_DRIVER_DEBUG_EVENT (3, dasd_int_handler,
+                                                         "(%04x) Rejecting write request %p\n",
+                                                         device->devinfo.devno,
+                                                         req);
+
+                                dasd_end_request (req, 0);
+                                dasd_dequeue_request (queue,req);
+                        } else {
+                            /* relocate request according to partition table */
+                            req->sector +=
+                                device->major_info->gendisk.
+                                part[MINOR (req->rq_dev)].start_sect;
+                            cqr = device->discipline->build_cp_from_req (device, req);
+                            if (cqr == NULL) {
+
+                                    DASD_DRIVER_DEBUG_EVENT (3, dasd_int_handler,
+                                                             "(%04x) CCW creation failed "
+                                                             "on request %p\n",
+                                                             device->devinfo.devno,
+                                                             req);
+                                    /* revert relocation of request */
+                                    req->sector -=
+                                        device->major_info->gendisk.
+                                        part[MINOR (req->rq_dev)].start_sect;
+                                    break;	/* terminate request queue loop */
+                                    
+                            }
 #ifdef CONFIG_DYNAMIC_QUEUE_MIN_SIZE
-                        chanq_min_size = (chanq_min_size + req->nr_sectors)>>1; 
-#endif /* CONFIG_DYNAMIC_QUEUE_MIN_SIZE */
-                        dasd_dequeue_request(queue,req);
-			dasd_chanq_enq (qp, cqr);
-                } else { /* queue not empty OR criteria not met */
-                        break; /* terminate request queue loop */
-                }
-        }
-        /* we process the requests with non-final status */
-        if ( qp -> head ) {
-                switch ( qp->head->status ) {
-                case CQR_STATUS_QUEUED:
-                        /* try to start the first I/O that can be started */
-                        if ( device->discipline->start_IO (qp->head) != 0) 
-                                BUG();
-                        break;
-                case CQR_STATUS_IN_IO:
-                        /* Check, if to invoke the missing interrupt handler */
-                        if ( dasd_check_expire_time (qp->head) ) {
-                                /* to be filled with MIH */
+                            chanq_min_size =
+                                (chanq_min_size + req->nr_sectors) >> 1;
+#endif				/* CONFIG_DYNAMIC_QUEUE_MIN_SIZE */
+                            dasd_dequeue_request (queue, req);
+                            dasd_chanq_enq (qp, cqr);
                         }
-                        break;
+		} else {	/* queue not empty OR criteria not met */
+			break;	/* terminate request queue loop */
+		}
+	}
+	/* we process the requests with non-final status */
+	if (qp->head) {
+		switch (qp->head->status) {
+		case CQR_STATUS_QUEUED:
+			/* try to start the first I/O that can be started */
+			if (device->discipline->start_IO == NULL)
+				BUG ();
+                        device->discipline->start_IO(qp->head);
+			break;
+		case CQR_STATUS_IN_IO:
+			/* Check, if to invoke the missing interrupt handler */
+			if (dasd_check_expire_time (qp->head)) {
+				/* to be filled with MIH */
+			}
+			break;
 
-                case CQR_STATUS_PENDING:
-                        /* just wait */
-                        break;
-                default: 
-                        BUG();
-                }
-        }
-        /* Now clean the requests with final status */
-        while ( final_requests ) {
-                cqr = final_requests;
-                final_requests = cqr-> next;
-                dasd_finalize_request( cqr );
-        }
-        s390irq_spin_unlock_irqrestore (irq, flags);
-}
+		case CQR_STATUS_PENDING:
+			/* just wait */
+			break;
+		default:
+			BUG ();
+		}
+	}
+	s390irq_spin_unlock_irqrestore (irq, flags);
 
-/* 
+} /* end dasd_process_queues */
+
+/*
  * function dasd_run_bh
  * acquires the locks needed and then runs the bh
  */
 static void
-dasd_run_bh (dasd_device_t *device)
+dasd_run_bh (dasd_device_t * device)
 {
 	long flags;
 	spin_lock_irqsave (&io_request_lock, flags);
-	atomic_set(&device->bh_scheduled,0);
+	atomic_set (&device->bh_scheduled, 0);
 	dasd_process_queues (device);
 	spin_unlock_irqrestore (&io_request_lock, flags);
 }
 
-/* 
+/*
  * function dasd_schedule_bh
  * schedules the request_fn to run with next run_bh cycle
  */
 void
-dasd_schedule_bh (dasd_device_t *device)
+dasd_schedule_bh (dasd_device_t * device)
 {
 	/* Protect against rescheduling, when already running */
-        if (atomic_compare_and_swap(0,1,&device->bh_scheduled)) {
-                return;
-        }
+	if (atomic_compare_and_swap (0, 1, &device->bh_scheduled)) {
+		return;
+	}
 
-	INIT_LIST_HEAD(&device->bh_tq.list);
+	INIT_LIST_HEAD (&device->bh_tq.list);
 	device->bh_tq.sync = 0;
 	device->bh_tq.routine = (void *) (void *) dasd_run_bh;
 	device->bh_tq.data = device;
@@ -1385,46 +1812,24 @@
 	return;
 }
 
-/* 
+/*
  * function do_dasd_request
- * is called from ll_rw_blk.c and provides the caller of 
+ * is called from ll_rw_blk.c and provides the caller of
  * dasd_process_queues
  */
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 static void
 do_dasd_request (request_queue_t * queue)
 {
-        dasd_device_t *device = (dasd_device_t *)
-                ((long)queue-(long)offsetof (dasd_device_t, request_queue));
+        dasd_device_t *device = (dasd_device_t *)queue->queuedata;
 	dasd_process_queues (device);
 }
-#else
-static void
-do_dasd_request (void)
-{
-	major_info_t *major_info;
-	dasd_device_t *device;
-	int i;
-
-	for (major_info = dasd_major_info;
-	     major_info != NULL;
-	     major_info = major_info->next) {
-		for (i = 0; i < DASD_PER_MAJOR; i++) {
-			device = major_info->dasd_device[i];
-			if (!device)
-				continue;	/* remove indentation level */
-			dasd_process_queues (device);
-		}
-	}
-}
-#endif				/* LINUX_IS_24 */
 
 /*
- * DASD_HANDLE_STATE_CHANGE_PENDING 
+ * DASD_HANDLE_STATE_CHANGE_PENDING
  *
  * DESCRIPTION
  *   Handles the state change pending interrupt.
- *   Search for the device related request queue and check if the first 
+ *   Search for the device related request queue and check if the first
  *   cqr in queue in in status 'CQR_STATUE_PENDING'.
  *   If so the status is set to 'CQR_STATUS_QUEUED' to reactivate
  *   the device.
@@ -1432,43 +1837,44 @@
  *  PARAMETER
  *   stat               device status of state change pending interrupt.
  */
-void 
-dasd_handle_state_change_pending (devstat_t *stat)
+void
+dasd_handle_state_change_pending (devstat_t * stat)
 {
-        dasd_device_t **device_addr;
-        ccw_req_t     *cqr;
+	dasd_device_t **device_addr;
+	ccw_req_t *cqr;
 
 	device_addr = dasd_device_from_devno (stat->devno);
 
-        if (device_addr == NULL) {
-		printk (KERN_INFO PRINTK_HEADER
-                        "unable to find device for state change pending "
-                        "interrupt: devno%04X\n",
-                        stat->devno);
-        } else {
-                /* re-activate first request in queue */
-                cqr = (*device_addr)->queue.head;
-
-                if (cqr->status == CQR_STATUS_PENDING) {
-
-                        DASD_MESSAGE (KERN_INFO, (*device_addr),
-                                      "%s",
-                                      "device request queue restarted by "
-                                      "state change pending interrupt\n");
-
-                        del_timer(&(*device_addr)->timer);
-
-                        check_then_set(&cqr->status, 
-                                       CQR_STATUS_PENDING, 
-                                       CQR_STATUS_QUEUED);
+	if (device_addr == NULL) {
 
-                        dasd_schedule_bh(*device_addr);
+		printk (KERN_DEBUG PRINTK_HEADER
+			"unable to find device for state change pending "
+			"interrupt: devno%04x\n", 
+                        stat->devno);
+                return;
+	} 
 
-                }
+        /* re-activate first request in queue */
+        cqr = (*device_addr)->queue.head;
+        
+        if (cqr->status == CQR_STATUS_PENDING) {
+                
+                DASD_MESSAGE (KERN_DEBUG, (*device_addr), "%s",
+                              "device request queue restarted by "
+                              "state change pending interrupt\n");
+                
+                del_timer (&(*device_addr)->timer);
+                
+                check_then_set (&cqr->status,
+                                CQR_STATUS_PENDING, CQR_STATUS_QUEUED);
+                
+                dasd_schedule_bh (*device_addr);
+                
         }
+
 } /* end dasd_handle_state_change_pending */
 
-/* 
+/*
  * function dasd_int_handler
  * is the DASD driver's default interrupt handler for SSCH-IO
  */
@@ -1476,166 +1882,161 @@
 dasd_int_handler (int irq, void *ds, struct pt_regs *regs)
 {
 	int ip;
-        int devno;
 	ccw_req_t *cqr;
 	dasd_device_t *device;
         unsigned long long now;
-#ifdef ERP_DEBUG
-	static int counter = 0;
-#endif
 	dasd_era_t era = dasd_era_none; /* default is everything is okay */
 	devstat_t *stat = (devstat_t *)ds;
 
+        DASD_DRIVER_DEBUG_EVENT (6, dasd_int_handler,
+                                 "Interrupt: IRQ %02x, stat %02x, devno %04x",
+                                 irq,
+                                 stat->dstat,
+                                 stat->devno);
         asm volatile ("STCK %0":"=m" (now));
         if (stat == NULL) {
                 BUG();
 	}
 
         /* first of all check for state change pending interrupt */
-        if (stat->dstat & (DEV_STAT_ATTENTION | 
-                           DEV_STAT_DEV_END   |
-                           DEV_STAT_UNIT_EXCEP )) {
-
+        if ((stat->dstat & DEV_STAT_ATTENTION ) && 
+            (stat->dstat & DEV_STAT_DEV_END   ) &&
+            (stat->dstat & DEV_STAT_UNIT_EXCEP)   ) {
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_int_handler,
+                                         "State change Interrupt: %04x",
+                                         stat->devno);
                 dasd_handle_state_change_pending (stat);
-                //return; /* TBD */
+                return;
         }
 
 	ip = stat->intparm;
 	if (!ip) {		/* no intparm: unsolicited interrupt */
-		printk (KERN_INFO PRINTK_HEADER
-                        "unsolicited interrupt: irq0x%x devno%04X\n",
-                        irq,stat->devno);
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_int_handler,
+                                         "Unsolicited Interrupt: %04x",
+                                         stat->devno);
+		printk (KERN_DEBUG PRINTK_HEADER
+                        "unsolicited interrupt: irq 0x%x devno %04x\n",
+                        irq,
+                        stat->devno);
 		return;
 	}
 	if (ip & 0x80000001) {
-		printk (KERN_INFO PRINTK_HEADER
-                        "spurious interrupt: irq0x%x devno%04X, parm %08x\n",
-                        irq,stat->devno,ip);
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_int_handler,
+                                         "spurious Interrupt: %04x",
+                                         stat->devno);
+		printk (KERN_DEBUG PRINTK_HEADER
+                        "spurious interrupt: irq 0x%x devno %04x, parm %08x\n",
+                        irq,
+                        stat->devno,ip);
 		return;
 	}
+
 	cqr = (ccw_req_t *)(long)ip;
+
+        /* check status - the request might have been killed because of dyn dettach */
+	if (cqr->status != CQR_STATUS_IN_IO) {
+                DASD_DRIVER_DEBUG_EVENT (2, dasd_int_handler,
+                                         "invalid status %02x on device %04x",
+                                         cqr->status,
+                                         stat->devno);
+
+		printk (KERN_DEBUG PRINTK_HEADER
+                        "invalid status: irq 0x%x devno %04x, status %02x\n",
+                        irq,
+                        stat->devno,
+                        cqr->status);
+		return;
+	}
+
 	device = (dasd_device_t *) cqr->device;
-	if (device == NULL || device != ds-offsetof(dasd_device_t,dev_status)) {
+	if (device == NULL || 
+            device != ds-offsetof(dasd_device_t,dev_status)) {
                 BUG();
 	}
-	devno = device->devinfo.devno;
 	if (device->devinfo.irq != irq) {
                 BUG();
 	}
 	if (strncmp (device->discipline->ebcname, (char *) &cqr->magic, 4)) {
                 BUG();
 	}
-#ifdef ERP_DEBUG
-                if ((++counter % 937 >= 0) &&
-                    (  counter % 937 <= 10) &&
-                    (  counter < 5000    ) &&
-                    (  counter > 2000    )   ){
-                        static int fake_count = 0;
-                        printk ( KERN_INFO PRINTK_HEADER "***********************************************\n");
-                        printk ( KERN_INFO PRINTK_HEADER "Faking I/O error to recover from; cntr=%i / %02X\n",counter,++fake_count);
-                        printk ( KERN_INFO PRINTK_HEADER "***********************************************\n");
-                        era = dasd_era_recover;
-                        stat->flag |= DEVSTAT_FLAG_SENSE_AVAIL;
-                        stat->dstat |= 0x02;
-// sense 32
-                        {
-                                char *sense = stat->ii.sense.data;
-                                sense [25] = 0x1D;
-                                sense [27] = 0x00;
-                                //sense [25] = (fake_count % 256); //0x1B;
-                                //sense [27] = 0x00;
-                        }
-// sense 24
-//                        {
-//                                char *sense = stat->ii.sense.data;
-//                                sense [0] = (counter % 0xFF); //0x1B;
-//                                sense [1] = ((counter * 7) % 0xFF); //0x1B;
-//                                sense [2] = (fake_count % 0xFF); //0x1B;
-//                                sense [27] = 0x80;
-//                        }
-
-/*
-                memset(stat->ii.sense.data,0,32);
-                stat->ii.sense.data[2] = 0x06;
-                stat->ii.sense.data[4] = 0x04;
-                stat->ii.sense.data[5] = 0x60;
-                stat->ii.sense.data[6] = 0x41;
-                stat->ii.sense.data[8] = 0xff;
-                stat->ii.sense.data[9] = 0xff;
-                stat->ii.sense.data[15] = 0x05;
-                stat->ii.sense.data[16] = 0x21;
-                stat->ii.sense.data[18] = 0x60;
-                stat->ii.sense.data[19] = 0x3b;
-                stat->ii.sense.data[20] = 0x24;
-                stat->ii.sense.data[21] = 0x61;
-                stat->ii.sense.data[22] = 0x65;
-                stat->ii.sense.data[23] = 0x03;
-                stat->ii.sense.data[24] = 0x04;
-                stat->ii.sense.data[25] = 0x10;
-                stat->ii.sense.data[26] = 0x4e;
-*/
-        }
-#endif
+
         /* first of all lets try to find out the appropriate era_action */
-        if ( stat->flag & DEVSTAT_FLAG_SENSE_AVAIL ||
-             stat->dstat & ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END) ) {
-                /* anything abnormal ? */
-                if ( device->discipline->examine_error == NULL ||
-                     stat->flag & DEVSTAT_HALT_FUNCTION ) {
-                        era = dasd_era_fatal;
-                } else {
-                        era = device->discipline->examine_error (cqr, stat);
-                }
-        }
+        DASD_DEVICE_DEBUG_EVENT (4, device," Int: CS/DS 0x%04x",
+                                 ((stat->cstat<<8)|stat->dstat));
+
+	/* first of all lets try to find out the appropriate era_action */
+	if (stat->flag & DEVSTAT_FLAG_SENSE_AVAIL ||
+	    stat->dstat & ~(DEV_STAT_CHN_END | DEV_STAT_DEV_END)) {
+		/* anything abnormal ? */
+		if (device->discipline->examine_error == NULL ||
+		    stat->flag & DEVSTAT_HALT_FUNCTION) {
+			era = dasd_era_fatal;
+		} else {
+			era = device->discipline->examine_error (cqr, stat);
+		}
+                DASD_DRIVER_DEBUG_EVENT (1, dasd_int_handler," era_code %d",
+                                         era);
+	}
         if ( era == dasd_era_none ) {
-		if (device->level == DASD_DEVICE_LEVEL_ANALYSIS_PENDING)
-			device->level = DASD_DEVICE_LEVEL_ANALYSIS_PREPARED;
                 check_then_set(&cqr->status, 
-                               CQR_STATUS_IN_IO, CQR_STATUS_DONE);
+                               CQR_STATUS_IN_IO, 
+                               CQR_STATUS_DONE);
+
                 cqr->stopclk=now;
-                cqr=cqr->next;
 		/* start the next queued request if possible -> fast_io */
-                if (cqr->status == CQR_STATUS_QUEUED) {
-                        if (device->discipline->start_IO (cqr) != 0) {
+                if (cqr->next &&
+                    cqr->next->status == CQR_STATUS_QUEUED) {
+                        if (device->discipline->start_IO (cqr->next) != 0) {
                                 printk (KERN_WARNING PRINTK_HEADER
                                         "Interrupt fastpath failed!\n");
                         } 
                 }
         } else { /* error */
-                if (cqr->dstat == NULL)
-                        cqr->dstat = kmalloc (sizeof (devstat_t), GFP_ATOMIC);
-                if (cqr->dstat) {
-                        memcpy (cqr->dstat, stat, sizeof (devstat_t));
-                } else {
-                        PRINT_ERR ("no memory for dstat...ignoring\n");
-                }
-                /* dump sense data */
-                if (device->discipline &&
-                    device->discipline->dump_sense) {
-                        char *errmsg = device->discipline->dump_sense (device, cqr);
-                        if (errmsg != NULL) {
-                                printk ("Sense data:\n%s", errmsg);
-                                free_page ((unsigned long) errmsg);
-                        } else {
-                                printk (KERN_WARNING PRINTK_HEADER
-                                        "No memory to dump error message\n");
-                        }
-                }
-                switch(era) {
-                case dasd_era_fatal:
-                        check_then_set (&cqr->status,CQR_STATUS_IN_IO,
-                                        CQR_STATUS_FAILED);
-                        break;
-                case dasd_era_recover:
-                        check_then_set (&cqr->status,CQR_STATUS_IN_IO,
-                                        CQR_STATUS_ERROR);
-                        break;
-                default:
-                        BUG();
-                }
-        }                
+		if (cqr->dstat == NULL)
+			cqr->dstat = kmalloc (sizeof (devstat_t), GFP_ATOMIC);
+		if (cqr->dstat) {
+			memcpy (cqr->dstat, stat, sizeof (devstat_t));
+		} else {
+			PRINT_ERR ("no memory for dstat...ignoring\n");
+		}
+
+#ifdef ERP_DEBUG
+		/* dump sense data */
+		if (device->discipline            && 
+                    device->discipline->dump_sense  ) {
+
+                        device->discipline->dump_sense (device, 
+                                                        cqr);
+		}
+#endif
+
+		switch (era) {
+		case dasd_era_fatal:
+			check_then_set (&cqr->status, 
+                                        CQR_STATUS_IN_IO,
+					CQR_STATUS_FAILED);
+
+                        cqr->stopclk = now;
+			break;
+		case dasd_era_recover:
+			check_then_set (&cqr->status, 
+                                        CQR_STATUS_IN_IO,
+					CQR_STATUS_ERROR);
+			break;
+		default:
+			BUG ();
+		}
+	}
+        if ( cqr == device->init_cqr &&
+             ( cqr->status == CQR_STATUS_DONE ||
+               cqr->status == CQR_STATUS_FAILED )){
+                dasd_state_init_to_ready(device);
+                if ( atomic_read(&dasd_init_pending) == 0)
+                        wake_up (&dasd_init_waitq);
+        }
 	dasd_schedule_bh (device);
-}
+
+} /* end dasd_int_handler */
 
 /* SECTION: Some stuff related to error recovery */
 
@@ -1653,19 +2054,31 @@
  *   erp                CQR performing the ERP
  */
 ccw_req_t *
-default_erp_action (ccw_req_t * cqr)
+dasd_default_erp_action (ccw_req_t * cqr)
 {
-	ccw_req_t *erp = dasd_alloc_request ((char *) &cqr->magic, 1, 0);
 
-	printk (KERN_WARNING PRINTK_HEADER
-		"Default ERP called... \n");
+        dasd_device_t *device = cqr->device;
+	ccw_req_t     *erp    = dasd_alloc_request ((char *) &cqr->magic, 1, 0, cqr->device);
+
+	printk (KERN_DEBUG PRINTK_HEADER "Default ERP called... \n");
+
+	if (!erp) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate ERP request");
+                
+                check_then_set (&cqr->status,
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_FAILED);
+
+                asm volatile ("STCK %0":"=m" (cqr->stopclk));
 
-        if (erp == NULL)
-               return NULL;
+                return cqr;
+	}
 
 	erp->cpaddr->cmd_code = CCW_CMD_TIC;
-	erp->cpaddr->cda = (__u32)(void *)cqr->cpaddr;
-	erp->function = default_erp_action;
+	erp->cpaddr->cda = (__u32) (addr_t) cqr->cpaddr;
+	erp->function = dasd_default_erp_action;
 	erp->refers = cqr;
 	erp->device = cqr->device;
 	erp->magic = cqr->magic;
@@ -1673,8 +2086,12 @@
 
 	erp->status = CQR_STATUS_FILLED;
 
+        dasd_chanq_enq_head (&device->queue,
+                             erp);
+
 	return erp;
-}
+
+} /* end dasd_default_erp_action */
 
 /*
  * DEFAULT_ERP_POSTACTION
@@ -1683,6 +2100,8 @@
  *   Frees all ERPs of the current ERP Chain and set the status
  *   of the original CQR either to CQR_STATUS_DONE if ERP was successful
  *   or to CQR_STATUS_FAILED if ERP was NOT successful.
+ *   NOTE: This function is only called if no discipline postaction
+ *         is available
  *
  * PARAMETER
  *   erp                current erp_head
@@ -1691,96 +2110,65 @@
  *   cqr                pointer to the original CQR
  */
 ccw_req_t *
-default_erp_postaction (ccw_req_t * erp)
+dasd_default_erp_postaction (ccw_req_t *erp)
 {
-	ccw_req_t *cqr = NULL, *free_erp = NULL;
-	dasd_device_t *device = NULL;
-        int success;
-        
-	device = (dasd_device_t *) (erp->device);
+
+	ccw_req_t     *cqr      = NULL, 
+                      *free_erp = NULL;
+	dasd_device_t *device   = erp->device;
+	int           success;
+
+	if (erp->refers   == NULL || 
+            erp->function == NULL   ) {
+
+		BUG ();
+	}
 
 	if (erp->status == CQR_STATUS_DONE)
 		success = 1;
 	else
 		success = 0;
 
-#ifdef ERP_DEBUG
-
-	/* print current erp_chain */
-        printk (KERN_WARNING PRINTK_HEADER
-                "default ERP postaction called for erp chain:\n");
-        {
-                ccw_req_t *temp_erp = NULL;
-                for (temp_erp = erp; temp_erp != NULL; temp_erp = temp_erp->refers){
-                        printk(KERN_WARNING PRINTK_HEADER 
-                               "       erp %p refers to %p with erp function %p\n",
-                               temp_erp,
-                               temp_erp->refers,
-                               temp_erp->function );
-                }
-        }
-
-#endif /* ERP_DEBUG*/
-
-	if (erp->refers == NULL || erp->function == NULL) {
-                BUG();
-	}
-	if (erp->function != default_erp_action) {
-                printk (KERN_WARNING PRINTK_HEADER
-                        "default ERP postaction called ERP action [<%p>]\n",
-                        erp->function);
-	}
 	/* free all ERPs - but NOT the original cqr */
-        
 	while (erp->refers != NULL) {
-                free_erp = erp;
-		erp = erp->refers;
+
+		free_erp = erp;
+		erp      = erp->refers;
+
 		/* remove the request from the device queue */
-		dasd_chanq_deq (&device->queue,	free_erp);
+		dasd_chanq_deq (&device->queue,
+                                free_erp);
+
 		/* free the finished erp request */
-		dasd_free_request (free_erp);
+		dasd_free_request (free_erp, free_erp->device);
 	}
-        
+
 	/* save ptr to original cqr */
 	cqr = erp;
 
-#ifdef ERP_DEBUG
-	printk (KERN_INFO PRINTK_HEADER
-		"default_erp_postaction - left original request = %p \n",cqr);
-#endif /* ERP_DEBUG */
-
 	/* set corresponding status to original cqr */
 	if (success) {
+
 		check_then_set (&cqr->status, 
-                                CQR_STATUS_ERROR, 
-                                CQR_STATUS_DONE);
+                                CQR_STATUS_ERROR,
+				CQR_STATUS_DONE);
 	} else {
+
 		check_then_set (&cqr->status,
-                                CQR_STATUS_ERROR,
+				CQR_STATUS_ERROR, 
                                 CQR_STATUS_FAILED);
-	}
 
-#ifdef ERP_DEBUG
-	/* print current erp_chain */
-	printk (KERN_WARNING PRINTK_HEADER
-		"default ERP postaction finished with remaining chain:\n");
-	{
-		ccw_req_t *temp_erp = NULL;
-		for (temp_erp = cqr; temp_erp != NULL; temp_erp = temp_erp->refers) {
-			printk (KERN_WARNING PRINTK_HEADER
-				" erp %p refers to %p \n",
-				temp_erp, temp_erp->refers);
-		}
+                asm volatile ("STCK %0":"=m" (cqr->stopclk));
 	}
-#endif /* ERP_DEBUG */
 
 	return cqr;
-}				/* end default_erp_postaction */
+
+} /* end default_erp_postaction */
 
 /* SECTION: The helpers of the struct file_operations */
 
-/* 
- * function dasd_format 
+/*
+ * function dasd_format
  * performs formatting of _device_ according to _fdata_
  * Note: The discipline's format_function is assumed to deliver formatting
  * commands to format a single unit of the device. In terms of the ECKD
@@ -1791,196 +2179,118 @@
 dasd_format (dasd_device_t * device, format_data_t * fdata)
 {
 	int rc = 0;
-        int format_done = 0;
-	ccw_req_t *req = NULL;
-	format_data_t temp =
-	{
-		fdata->start_unit,
-		fdata->stop_unit,
-		fdata->blksize,
-		fdata->intensity
-	};
-        
-        spin_lock (&dasd_open_count_lock);
-	if (device->open_count != 1) {
-		DASD_MESSAGE (KERN_INFO, device,
-			      "device is already open %d times",
-			      device->open_count);
-                spin_unlock(&dasd_open_count_lock);
-		return -EINVAL;
-	}
-	if (!device->discipline->format_device) {
-                spin_unlock(&dasd_open_count_lock);
-		return -EINVAL;
-	}
-        device->open_count = -1;
-        spin_unlock (&dasd_open_count_lock);
-	/* downgrade state of the device */
-	dasd_set_device_level (device->devinfo.irq,
-			       DASD_DEVICE_LEVEL_RECOGNIZED,
-			       device->discipline,
-			       0);
-	DASD_MESSAGE (KERN_INFO, device, 
-                      "Starting format from %d to %d (%d B blocks flags %d",
-                      fdata->start_unit,
+	int openct = atomic_read (&device->open_count);
+
+	if (openct > 1) {
+		DASD_MESSAGE (KERN_WARNING, device, "%s",
+			      "dasd_format: device is open! expect errors.");
+	}
+	DASD_MESSAGE (KERN_INFO, device,
+		      "formatting units %d to %d (%d B blocks) flags %d",
+		      fdata->start_unit, 
                       fdata->stop_unit,
-                      fdata->blksize,
+		      fdata->blksize, 
                       fdata->intensity);
-	/* Invalidate first track */
-	if (fdata->start_unit == DASD_FORMAT_DEFAULT_START_UNIT &&
-	    fdata->stop_unit  == DASD_FORMAT_DEFAULT_STOP_UNIT  &&
-	    fdata->intensity  == DASD_FORMAT_DEFAULT_INTENSITY    ) {
-		format_data_t temp2 =
-		{0, 0, fdata->blksize, 0x04};
-		DASD_MESSAGE (KERN_INFO, device, 
-                              "%s", 
-                              "Invalidating first track...");
-		req = device->discipline->format_device (device, &temp2);
-		if (req) {
-			rc = sleep_on_req (req);
-			dasd_free_request (req);	/* request is no longer used */
-		} else {
-			rc = -EINVAL;
+	while ((!rc) && (fdata->start_unit <= fdata->stop_unit)) {
+                ccw_req_t *req;
+                dasd_format_fn_t ffn = device->discipline->format_device;
+		ffn = device->discipline->format_device;
+		if (ffn == NULL)
+			break;
+		req = ffn (device, fdata);
+		if (req == NULL) {
+			rc = -ENOMEM;
+			break;
 		}
-		if (rc) {
-                        DASD_MESSAGE (KERN_WARNING, device, 
-                                      "%s",
-                                      "Can't invalidate Track 0\n");
-		} else {
-                        DASD_MESSAGE (KERN_INFO, device, 
-                                      "%s", 
-                                      "...Invalidation complete");
-                }
-		temp.start_unit++;
-	}
-	/* format remainnig tracks of device */
-	while (!rc                                                                 &&
-	       ((req = device->discipline->format_device (device, &temp)) != NULL)   ) {
-                                format_done=1;
-		if ((rc = sleep_on_req (req)) != 0) {
-
-
+		if ((rc = dasd_sleep_on_req (req)) != 0) {
 			DASD_MESSAGE (KERN_WARNING, device,
-				      " Formatting failed with rc = %d\n",
-				      rc);
+				      " Formatting of unit %d failed with rc = %d\n",
+				      fdata->start_unit, rc);
 			break;
-		}
-                
-		dasd_free_request (req);	/* request is no longer used */
-		temp.start_unit++;
+		} 
+		dasd_free_request (req, device);	/* request is no longer used */
+	        if ( signal_pending(current) ) {
+			rc = -ERESTARTSYS;
+			break;		
+                }
+		fdata->start_unit++;
 	}
-
-	if (!rc         &&
-	    req == NULL   ) {
-		if (fdata->start_unit == DASD_FORMAT_DEFAULT_START_UNIT &&
-		    fdata->stop_unit  == DASD_FORMAT_DEFAULT_STOP_UNIT  &&
-	    	    fdata->intensity  == DASD_FORMAT_DEFAULT_INTENSITY    ) {
-			format_data_t temp2 =
-			{0, 0, fdata->blksize, fdata->intensity};
-			DASD_MESSAGE (KERN_INFO, device, 
-                                      "%s", 
-                                      "Revalidating first track...");
-			req = device->discipline->format_device (device, &temp2);
-			if (req) {
-				rc = sleep_on_req (req);
-				dasd_free_request (req);	/* request is no longer used */
-			} else {
-				rc = -EINVAL;
-			}
-			if (rc) {
-				DASD_MESSAGE (KERN_WARNING, device,
-                                              "%s",
-                                              "Can't revalidate Track 0\n");
-			} else {
-                                DASD_MESSAGE (KERN_INFO, device, 
-                                              "%s", 
-                                              "...Revalidation complete");
-                        }
-		}
-	}			/* end if no more requests */
-
-        /* check if at least one format cp was build in discipline */
-        if (!format_done) {
-                rc = -EINVAL;
-        }
-
-	if (rc)
-		DASD_MESSAGE (KERN_WARNING, device,
-			      "%s", " Formatting finished unsuccessfully");
-	else
-		DASD_MESSAGE (KERN_INFO, device,
-			      "%s", " Formatting finished successfully");
-
-        /* 
-         * re-analyse device
-         */
-        dasd_set_device_level (device->devinfo.irq,
-                               DASD_DEVICE_LEVEL_ONLINE,
-                               device->discipline,
-                               0);
-        udelay (1500000);
-                
-        dasd_set_device_level (device->devinfo.irq,
-                               DASD_DEVICE_LEVEL_ONLINE,
-                               device->discipline,
-                               0);
-
-        spin_lock (&dasd_open_count_lock);
-        device->open_count=1;
-        spin_unlock (&dasd_open_count_lock);
 	return rc;
 }				/* end dasd_format */
 
-static struct list_head dasd_ioctls = LIST_HEAD_INIT(dasd_ioctls);
+static struct list_head dasd_ioctls = LIST_HEAD_INIT (dasd_ioctls);
 
 static dasd_ioctl_list_t *
-dasd_find_ioctl( int no )
+dasd_find_ioctl (int no)
 {
 	struct list_head *curr;
-	list_for_each(curr,&dasd_ioctls){
-		if (list_entry(curr,dasd_ioctl_list_t,list)->no == no ){
-			return list_entry(curr,dasd_ioctl_list_t,list);
+	list_for_each (curr, &dasd_ioctls) {
+		if (list_entry (curr, dasd_ioctl_list_t, list)->no == no) {
+			return list_entry (curr, dasd_ioctl_list_t, list);
 		}
 	}
 	return NULL;
 }
 
 int
-dasd_ioctl_no_register ( int no, dasd_ioctl_fn_t handler )
+dasd_ioctl_no_register (struct module *owner, int no, dasd_ioctl_fn_t handler)
 {
 	dasd_ioctl_list_t *new;
-	if (dasd_find_ioctl(no))
+	if (dasd_find_ioctl (no))
 		return -EBUSY;
-	new = kmalloc(sizeof(dasd_ioctl_list_t),GFP_KERNEL);
- 	if ( new ==  NULL )
+	new = kmalloc (sizeof (dasd_ioctl_list_t), GFP_KERNEL);
+	if (new == NULL)
 		return -ENOMEM;
-	new -> no = no;
-	new -> handler = handler;
-	list_add(&new->list,&dasd_ioctls);
-#ifdef MODULE
-        MOD_INC_USE_COUNT;
-#endif
+	new->owner = owner;
+	new->no = no;
+	new->handler = handler;
+	list_add (&new->list, &dasd_ioctls);
+	MOD_INC_USE_COUNT;
 	return 0;
 }
 
 int
-dasd_ioctl_no_unregister ( int no, dasd_ioctl_fn_t handler )
-{	
-	dasd_ioctl_list_t *old = dasd_find_ioctl(no);
-	if ( old == NULL )
+dasd_ioctl_no_unregister (struct module *owner, int no, dasd_ioctl_fn_t handler)
+{
+	dasd_ioctl_list_t *old = dasd_find_ioctl (no);
+	if (old == NULL)
 		return -ENOENT;
-	if ( old->no != no ||
-	     old->handler != handler )
+	if (old->no != no || old->handler != handler || owner != old->owner )
 		return -EINVAL;
-	list_del(&old->list);
-	kfree(old);
-#ifdef MODULE
-        MOD_DEC_USE_COUNT;
-#endif
+	list_del (&old->list);
+	kfree (old);
+	MOD_DEC_USE_COUNT;
 	return 0;
 }
 
 static int
+dasd_revalidate (dasd_device_t * device)
+{
+        int rc = 0;
+	int i;
+	kdev_t kdev = device->kdev;
+	int openct = atomic_read (&device->open_count);
+	int start = MINOR (kdev);
+	if (openct != 1) {
+		DASD_MESSAGE (KERN_WARNING, device, "%s",
+			      "BLKRRPART: device is open! expect errors.");
+	}
+	for (i = (1 << DASD_PARTN_BITS) - 1; i >= 0; i--) {
+                int major = device->major_info->gendisk.major;
+		int minor = start + i;
+		kdev_t devi = MKDEV (major, minor);
+		struct super_block *sb = get_super (devi);
+		sync_dev (devi);
+		if (sb)
+			invalidate_inodes (sb);
+		invalidate_buffers (devi);
+	}
+        dasd_destroy_partitions(device);
+        dasd_setup_partitions(device);
+        return rc;
+
+}
+static int
 do_dasd_ioctl (struct inode *inp, /* unsigned */ int no, unsigned long data)
 {
 	int rc = 0;
@@ -1990,7 +2300,8 @@
 	if (!device) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"No device registered as device (%d:%d)\n",
-			MAJOR (inp->i_rdev), MINOR (inp->i_rdev));
+			MAJOR (inp->i_rdev), 
+                        MINOR (inp->i_rdev));
 		return -EINVAL;
 	}
 	if ((_IOC_DIR (no) != _IOC_NONE) && (data == 0)) {
@@ -2001,39 +2312,51 @@
 #if 0
 	printk (KERN_DEBUG PRINTK_HEADER
 		"ioctl 0x%08x %s'0x%x'%d(%d) on /dev/%s (%d:%d,"
-		" devno 0x%04X on irq %d) with data %8lx\n",
+		" devno 0x%04x on irq %d) with data %8lx\n",
 		no,
 		_IOC_DIR (no) == _IOC_NONE ? "0" :
 		_IOC_DIR (no) == _IOC_READ ? "r" :
 		_IOC_DIR (no) == _IOC_WRITE ? "w" :
 		_IOC_DIR (no) == (_IOC_READ | _IOC_WRITE) ? "rw" : "u",
-		_IOC_TYPE (no), _IOC_NR (no), _IOC_SIZE (no),
-		device->name, MAJOR (inp->i_rdev), MINOR (inp->i_rdev),
-		device->devinfo.devno, device->devinfo.irq,
-		data);
+		_IOC_TYPE (no),
+                _IOC_NR (no),
+                _IOC_SIZE (no),
+		device->name, 
+                MAJOR (inp->i_rdev), 
+                MINOR (inp->i_rdev),
+		device->devinfo.devno, 
+                device->devinfo.irq, 
+                data);
 #endif
 	switch (no) {
+        case DASDAPIVER: {
+                       int ver = DASD_API_VERSION;
+                       rc = copy_to_user ((int *) data, &ver, sizeof (int));
+                       if (rc)
+                               rc = -EFAULT;
+                       break;
+        }
 	case BLKGETSIZE:{	/* Return device size */
-			long blocks = blk_size[MAJOR (inp->i_rdev)][MINOR (inp->i_rdev)] << 1;
-			rc = copy_to_user ((long *) data, &blocks, sizeof (long));
+			long blocks = major_info->gendisk.sizes 
+                                      [MINOR (inp->i_rdev)] << 1;
+			rc =
+			    copy_to_user ((long *) data, &blocks,
+					  sizeof (long));
 			if (rc)
 				rc = -EFAULT;
 			break;
 		}
 	case BLKRRPART:{
-                        if (!capable(CAP_SYS_ADMIN)) {
-                            rc = -EACCES;
-                            break;
-                        }
-			fsync_dev(inp->i_rdev);
-			dasd_partn_detect (device);
-			invalidate_buffers(inp->i_rdev);
-			rc = 0;
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+			rc = dasd_revalidate (device);
 			break;
 		}
 	case HDIO_GETGEO:{
-			struct hd_geometry geo = {0,};
-			rc = dasd_fillgeo(inp->i_rdev, &geo);
+			struct hd_geometry geo = { 0, };
+			rc = dasd_fillgeo (inp->i_rdev, &geo);
 			if (rc)
 				break;
 
@@ -2043,148 +2366,216 @@
 				rc = -EFAULT;
 			break;
 		}
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-        case BLKSSZGET:
-        case BLKROSET:
-        case BLKROGET:
-        case BLKRASET:
-        case BLKRAGET:
-        case BLKFLSBUF:
-        case BLKPG: 
-        case BLKELVGET:
-        case BLKELVSET:
-                return blk_ioctl(inp->i_rdev, no, data);
-                break;
-#else
-        case BLKRASET:
-                if(!capable(CAP_SYS_ADMIN))
-                        return -EACCES;
-                if(!dev || arg > 0xff)
-                        return -EINVAL;
-                read_ahead[MAJOR(dev)] = arg;
-                rc = 0;
-                break;
-        case BLKRAGET:
-                if (!arg)
-                        return -EINVAL;
-                rc = put_user(read_ahead[MAJOR(dev)], (long *) arg);
-                break;
-        case BLKSSZGET: {
-            /* Block size of media */
-            rc = copy_to_user((int *)data,
-                              &blksize_size[MAJOR(device->kdev)]
-                              [MINOR(device->kdev)],
-                              sizeof(int)) ? -EFAULT : 0;
-        }
-        RO_IOCTLS (inp->i_rdev, data);
-	case BLKFLSBUF:{
-                if (!capable(CAP_SYS_ADMIN)) 
-                        return -EACCES;
-                fsync_dev(inp->i_rdev);
-                invalidate_buffers(inp->i_rdev);
-                rc = 0;
-                break;
-        }
-#endif				/* LINUX_IS_24 */
-	case BIODASDRSID:{
-			rc = copy_to_user ((void *) data,
-					   &(device->devinfo.sid_data),
-					   sizeof (senseid_t)) ? -EFAULT : 0;
-			break;
-		}
-	case BIODASDRWTB:{
-			int offset = 0;
-			int xlt;
-			rc = copy_from_user (&xlt, (void *) data,
-					     sizeof (int)) ? -EFAULT : 0;
-			if (rc)
+	case BIODASDDISABLE:{
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
 				break;
-			offset = major_info->gendisk.part[MINOR (inp->i_rdev)].start_sect >>
-			    device->sizes.s2b_shift;
-			xlt += offset;
-			rc = copy_to_user ((void *) data, &xlt,
-					   sizeof (int)) ? -EFAULT : 0;
-			break;
-		}
-	case BIODASDFORMAT:{
-			/* fdata == NULL is a valid arg to dasd_format ! */
-			int partn;
-			format_data_t fdata =
-			{
-				DASD_FORMAT_DEFAULT_START_UNIT,
-				DASD_FORMAT_DEFAULT_STOP_UNIT,
-				DASD_FORMAT_DEFAULT_BLOCKSIZE,
-				DASD_FORMAT_DEFAULT_INTENSITY};
-
-                        if (!capable(CAP_SYS_ADMIN)) {
-                            rc = -EACCES;
-                            break;
-                        }
-			if (data) {
-				rc = copy_from_user (&fdata, (void *) data,
-						     sizeof (format_data_t));
-				if (rc) {
-					rc = -EFAULT;
-					break;
-				}
 			}
-			partn = MINOR (inp->i_rdev) & ((1 << major_info->gendisk.minor_shift) - 1);
-			if (partn != 0) {
-				printk (KERN_WARNING PRINTK_HEADER
-					" devno 0x%04X on subchannel %d = /dev/%s (%d:%d)"
-				     " Cannot low-level format a partition\n",
-					device->devinfo.devno, device->devinfo.irq, device->name,
-				    MAJOR (inp->i_rdev), MINOR (inp->i_rdev));
-				return -EINVAL;
+                        if ( device->level > DASD_STATE_ACCEPT) {
+                                dasd_deactivate_queue(device);
+                                if ( device->request_queue)
+                                        dasd_flush_request_queues(device,0);
+                                dasd_flush_chanq(device,0);
+                                dasd_disable_blkdev(device);
+                                dasd_set_device_level (device->devinfo.devno, 
+                                                       device->discipline, 
+                                                       DASD_STATE_ACCEPT);
+                        }
+                        break;
+        }
+	case BIODASDENABLE:{
+                        dasd_range_t range = { 
+                                from: device->devinfo.devno,
+                                to: device->devinfo.devno 
+                        };
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
 			}
-			rc = dasd_format (device, &fdata);
-			break;
-		}
-	case BIODASDRSRV:{
-            ccw_req_t *req;
-            if (!capable(CAP_SYS_ADMIN)) {
-                rc = -EACCES;
-                break;
-            }
-            req = device->discipline->reserve (device);
-            rc = sleep_on_req (req);
-            dasd_free_request (req);
-            break;
-        }
-	case BIODASDRLSE:{
-            ccw_req_t *req;
-            if (!capable(CAP_SYS_ADMIN)) {
-                rc = -EACCES;
-                break;
-            }
-            req = device->discipline->release (device);
-            rc = sleep_on_req (req);
-            dasd_free_request (req);
-            break;
+                        dasd_enable_ranges (&range, device->discipline, 0);
+                        break;
         }
-	case BIODASDSLCK:{
-			printk (KERN_WARNING PRINTK_HEADER
-				"Unsupported ioctl BIODASDSLCK\n");
-			break;
-		}
+	case BIODASDFMT:{
+			/* fdata == NULL is no longer a valid arg to dasd_format ! */
+			int partn = MINOR (inp->i_rdev) &
+			    ((1 << major_info->gendisk.minor_shift) - 1);
+			format_data_t fdata;
+
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+                        if (dasd_features_from_devno(device->devinfo.devno)&DASD_FEATURE_READONLY) {
+                                rc = -EROFS;
+                                break;
+                        }
+			if (!data) {
+				rc = -EINVAL;
+				break;
+			}
+			rc = copy_from_user (&fdata, (void *) data,
+					     sizeof (format_data_t));
+			if (rc) {
+				rc = -EFAULT;
+				break;
+			}
+			if (partn != 0) {
+				DASD_MESSAGE (KERN_WARNING, device, "%s",
+					      "Cannot low-level format a partition");
+				return -EINVAL;
+			}
+			rc = dasd_format (device, &fdata);
+			break;
+		}
+	case BIODASDPRRST:{     /* reset device profile information */
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+			memset (&device->profile, 0,
+				sizeof (dasd_profile_info_t));
+			break;
+		}
+	case BIODASDPRRD:{      /* retrun device profile information */
+			rc = copy_to_user((long *)data,
+					  (long *)&device->profile,
+					  sizeof(dasd_profile_info_t));
+			if (rc)
+				rc = -EFAULT;
+			break;
+		}
+	case BIODASDRSRV:{      /* reserve */
+			ccw_req_t *req;
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+			req = device->discipline->reserve (device);
+			rc = dasd_sleep_on_req (req);
+			dasd_free_request (req, device);
+			break;
+		}
+	case BIODASDRLSE:{      /* release */
+			ccw_req_t *req;
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+			req = device->discipline->release (device);
+			rc = dasd_sleep_on_req (req);
+			dasd_free_request (req, device);
+			break;
+		}
+	case BIODASDSLCK:{      /* steal lock - unconditional reserve */
+			ccw_req_t *req;
+			if (!capable (CAP_SYS_ADMIN)) {
+				rc = -EACCES;
+				break;
+			}
+			req = device->discipline->steal_lock (device);
+			rc = dasd_sleep_on_req (req);
+			dasd_free_request (req, device);
+			break;
+		}
+	case BIODASDINFO:{
+			dasd_information_t dasd_info;
+			unsigned long flags;
+			rc = device->discipline->fill_info (device, &dasd_info);
+                        dasd_info.label_block = device->sizes.pt_block;
+			dasd_info.devno = device->devinfo.devno;
+			dasd_info.schid = device->devinfo.irq;
+			dasd_info.cu_type = device->devinfo.sid_data.cu_type;
+			dasd_info.cu_model = device->devinfo.sid_data.cu_model;
+			dasd_info.dev_type = device->devinfo.sid_data.dev_type;
+			dasd_info.dev_model = device->devinfo.sid_data.dev_model;
+			dasd_info.open_count =
+			    atomic_read (&device->open_count);
+			dasd_info.status = device->level;
+			if (device->discipline) {
+				memcpy (dasd_info.type,
+					device->discipline->name, 4);
+			} else {
+				memcpy (dasd_info.type, "none", 4);
+			}
+			dasd_info.req_queue_len = 0;
+			dasd_info.chanq_len = 0;
+			if (device->request_queue->request_fn) {
+				struct list_head *l;
+				ccw_req_t *cqr = device->queue.head;
+				spin_lock_irqsave (&io_request_lock, flags);
+				list_for_each (l,
+					       &device->request_queue->
+					       queue_head) {
+					dasd_info.req_queue_len++;
+				}
+				spin_unlock_irqrestore (&io_request_lock,
+							flags);
+				s390irq_spin_lock_irqsave (device->devinfo.irq,
+							   flags);
+				while (cqr) {
+					cqr = cqr->next;
+					dasd_info.chanq_len++;
+				}
+				s390irq_spin_unlock_irqrestore (device->devinfo.
+								irq, flags);
+			}
+			rc =
+			    copy_to_user ((long *) data, (long *) &dasd_info,
+					  sizeof (dasd_information_t));
+			if (rc)
+				rc = -EFAULT;
+			break;
+		}
+#if 0 /* needed for XFS */
+	case BLKBSZSET:{
+		int bsz;
+		rc = copy_from_user ((long *)&bsz,(long *)data,sizeof(int));
+		if ( rc ) {
+			rc = -EFAULT;
+		} else {
+			if ( bsz >= device->sizes.bp_block )
+				rc = blk_ioctl (inp->i_rdev, no, data);
+			else
+				rc = -EINVAL; 
+		}
+		break;
+		}
+#endif /* 0 */
+	case BLKSSZGET:
+	case BLKROSET:
+	case BLKROGET:
+	case BLKRASET:
+	case BLKRAGET:
+	case BLKFLSBUF:
+	case BLKPG:
+	case BLKELVGET:
+	case BLKELVSET:
+		return blk_ioctl (inp->i_rdev, no, data);
+		break;
 	default:{
 
-			dasd_ioctl_list_t *old = dasd_find_ioctl(no);
-			if ( old ) {
-				rc = old->handler(inp,no,data);
+			dasd_ioctl_list_t *old = dasd_find_ioctl (no);
+			if (old) {
+				if ( old->owner )
+					__MOD_INC_USE_COUNT(old->owner);
+				rc = old->handler (inp, no, data);
+				if ( old->owner )
+					__MOD_DEC_USE_COUNT(old->owner);
 			} else {
 				DASD_MESSAGE (KERN_INFO, device,
-					    "ioctl 0x%08x=%s'0x%x'%d(%d) data %8lx\n",
+					      "ioctl 0x%08x=%s'0x%x'%d(%d) data %8lx\n",
 					      no,
 					      _IOC_DIR (no) == _IOC_NONE ? "0" :
 					      _IOC_DIR (no) == _IOC_READ ? "r" :
-					      _IOC_DIR (no) == _IOC_WRITE ? "w" :
-					   _IOC_DIR (no) == (_IOC_READ | _IOC_WRITE) ?
-					      "rw" : "u",
-					 _IOC_TYPE (no), _IOC_NR (no), _IOC_SIZE (no),
+					      _IOC_DIR (no) == _IOC_WRITE ? "w" : 
+                                              _IOC_DIR (no) == 
+                                              (_IOC_READ | _IOC_WRITE) ? "rw" : "u",
+                                              _IOC_TYPE (no),
+					      _IOC_NR (no), 
+                                              _IOC_SIZE (no),
 					      data);
-				rc = -EINVAL;
-			}	
+				rc = -ENOTTY;
+			}
 			break;
 		}
 	}
@@ -2209,66 +2600,96 @@
 dasd_open (struct inode *inp, struct file *filp)
 {
 	int rc = 0;
+        unsigned long flags;
 	dasd_device_t *device;
 
+        MOD_INC_USE_COUNT;
 	if ((!inp) || !(inp->i_rdev)) {
-		return -EINVAL;
+		rc = -EINVAL;
+                goto fail;
 	}
 	if (dasd_probeonly) {
-		printk ("\n" KERN_INFO PRINTK_HEADER "No access to device (%d:%d) due to probeonly mode\n", MAJOR (inp->i_rdev), MINOR (inp->i_rdev));
-		return -EPERM;
+		printk ("\n" KERN_INFO PRINTK_HEADER
+			"No access to device (%d:%d) due to probeonly mode\n",
+			MAJOR (inp->i_rdev), 
+                        MINOR (inp->i_rdev));
+		rc = -EPERM;
+                goto fail;
 	}
+        spin_lock_irqsave(&discipline_lock,flags);
 	device = dasd_device_from_kdev (inp->i_rdev);
-	if (device == NULL) {
+	if (!device) {
 		printk (KERN_WARNING PRINTK_HEADER
-			"No device registered as (%d:%d)\n", MAJOR (inp->i_rdev), MINOR (inp->i_rdev));
-		return -ENODEV;
-	}
-	if (device->level < DASD_DEVICE_LEVEL_RECOGNIZED ||
-	    device->discipline == NULL) {
-		DASD_MESSAGE (KERN_WARNING, device,
-			      " %s", " Cannot open unrecognized device\n");
-		return -EINVAL;
-	}
-        spin_lock(&dasd_open_count_lock);
-        if (device->open_count == -1) {
-            spin_unlock (&dasd_open_count_lock);
-            return -EBUSY;
+			"No device registered as (%d:%d)\n",
+			MAJOR (inp->i_rdev), 
+                        MINOR (inp->i_rdev));
+		rc = -ENODEV;
+                goto unlock;
+	}
+	if (device->level <= DASD_STATE_ACCEPT ) {
+		DASD_MESSAGE (KERN_WARNING, device, " %s", 
+                              " Cannot open unrecognized device\n");
+		rc = -ENODEV;
+                goto unlock;
+	}
+	if (atomic_inc_return (&device->open_count) == 1 ) {
+                if ( device->discipline->owner )
+                        __MOD_INC_USE_COUNT(device->discipline->owner);
+        } else {
+                MOD_DEC_USE_COUNT;
         }
-#ifdef MODULE
-	MOD_INC_USE_COUNT;
-#endif				/* MODULE */
-	device->open_count++;
-        spin_unlock (&dasd_open_count_lock);
+ unlock:
+        spin_unlock_irqrestore(&discipline_lock,flags);
+ fail:
+        if (rc) MOD_DEC_USE_COUNT;
 	return rc;
 }
 
+/*
+ * DASD_RELEASE
+ *
+ * DESCRIPTION
+ */
 static int
 dasd_release (struct inode *inp, struct file *filp)
 {
 	int rc = 0;
+        int count;
 	dasd_device_t *device;
 
 	if ((!inp) || !(inp->i_rdev)) {
-		return -EINVAL;
+		rc = -EINVAL;
+                goto out;
 	}
 	device = dasd_device_from_kdev (inp->i_rdev);
-	if (device == NULL) {
+	if (!device) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"No device registered as %d:%d\n",
-			MAJOR (inp->i_rdev), MINOR (inp->i_rdev));
-		return -EINVAL;
-	}
-        spin_lock(&dasd_open_count_lock);
-	if (device->open_count--) {
-#ifdef MODULE
-		MOD_DEC_USE_COUNT;
-#endif				/* MODULE */
-	} 
-	fsync_dev(inp->i_rdev); /* sync the device */
-	if (device->open_count == 0) /* finally invalidate buffers */
-		invalidate_buffers(inp->i_rdev);
-        spin_unlock(&dasd_open_count_lock);
+			MAJOR (inp->i_rdev), 
+                        MINOR (inp->i_rdev));
+		rc = -EINVAL;
+                goto out;
+	}
+
+	if (device->level < DASD_STATE_ACCEPT ) {
+		DASD_MESSAGE (KERN_WARNING, device, " %s",
+                              " Cannot release unrecognized device\n");
+		rc = -ENODEV;
+                goto out;
+	}
+	fsync_dev (inp->i_rdev);	/* sync the device */
+        count = atomic_dec_return (&device->open_count);
+        if ( count == 0) {
+                invalidate_buffers (inp->i_rdev);
+                if ( device->discipline->owner )
+                        __MOD_DEC_USE_COUNT(device->discipline->owner);
+                MOD_DEC_USE_COUNT;
+	} else if ( count == -1 ) { /* paranoia only */
+                atomic_set (&device->open_count,0);
+                printk (KERN_WARNING PRINTK_HEADER
+                        "release called with open count==0\n");
+        }
+ out:
 	return rc;
 }
 
@@ -2278,11 +2699,6 @@
 	open:dasd_open,
 	release:dasd_release,
 	ioctl:dasd_ioctl,
-#if ! (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	read:block_read,
-	write:block_write,
-	fsync:block_fsync,
-#endif				/* LINUX_IS_24 */
 };
 
 /* SECTION: Management of device list */
@@ -2290,20 +2706,17 @@
 dasd_fillgeo(int kdev,struct hd_geometry *geo)
 {
 	dasd_device_t *device = dasd_device_from_kdev (kdev);
-	if (!device->discipline->fill_geometry)
-		return -EINVAL;
 
-	device->discipline->fill_geometry (device, geo);
-	geo->start = device->major_info->
-			gendisk.part[MINOR(kdev)].start_sect;
+	if (!device)
+                return -EINVAL;
 
-	/* This is a hack.  dasdfmt and ibm.c expect geo.start 
-	   to contain the block number of the label block when
-	   it calls HDIO_GETGEO on the first partition. */
-	if (geo->start == 0)
-                geo->start = device->sizes.pt_block;
+        if (!device->discipline->fill_geometry)
+		return -EINVAL;
 
-	return 0;
+	device->discipline->fill_geometry (device, geo);
+	geo->start = device->major_info->gendisk.part[MINOR(kdev)].start_sect 
+		     >> device->sizes.s2b_shift;;
+        return 0;
 } 
 
 
@@ -2315,11 +2728,11 @@
 	char first, second, third;
 
 	if (hd) {
-		major_info_t *major_info=NULL;
+		major_info_t *major_info = NULL;
 		struct list_head *l;
 
-		list_for_each(l,&dasd_major_info[0].list) {
-			major_info = list_entry(l,major_info_t,list); 
+		list_for_each (l, &dasd_major_info[0].list) {
+			major_info = list_entry (l, major_info_t, list);
 			if (&major_info->gendisk == hd) {
 				break;
 			}
@@ -2330,14 +2743,14 @@
 		}
 	}
 	third = index % 26;
-	second = ((index-26) / 26) % 26;
-	first = (((index-702) / 26) / 26) % 26;
+	second = ((index - 26) / 26) % 26;
+	first = (((index - 702) / 26) / 26) % 26;
 
 	len = sprintf (str, "dasd");
-	if (index>701) {
+	if (index > 701) {
 		len += sprintf (str + len, "%c", first + 'a');
 	}
-	if (index>25) {
+	if (index > 25) {
 		len += sprintf (str + len, "%c", second + 'a');
 	}
 	len += sprintf (str + len, "%c", third + 'a');
@@ -2352,20 +2765,226 @@
 	return 0;
 }
 
-#ifdef CONFIG_DASD_DYNAMIC
 static void
-dasd_plug_device (dasd_device_t *device)
+dasd_plug_device (dasd_device_t * device)
 {
-        device->request_queue.plugged = 1; /* inhibit further calls of request_fn */
+	atomic_set(&device->plugged,1);	
 }
 
 static void
-dasd_unplug_device (dasd_device_t *device)
+dasd_unplug_device (dasd_device_t * device)
 {
-        generic_unplug_device(&device->request_queue);
+	atomic_set(&device->plugged,0);	
+        dasd_schedule_bh(device);
 }
 
 static void
+dasd_flush_chanq ( dasd_device_t * device, int destroy ) 
+{
+        ccw_req_t *cqr;
+        unsigned long flags;
+        if ( destroy ) {
+                s390irq_spin_lock_irqsave (device->devinfo.irq, flags);
+                cqr = device->queue.head;
+                while ( cqr != NULL ) {
+                        if ( cqr->status == CQR_STATUS_IN_IO )
+                                device->discipline->term_IO (cqr);
+                        if ( cqr->status != CQR_STATUS_DONE ||
+                             cqr->status != CQR_STATUS_FAILED ) {
+
+                                cqr->status = CQR_STATUS_FAILED;
+                                asm volatile ("STCK %0":"=m" (cqr->stopclk));
+
+                        }
+                        dasd_schedule_bh(device);
+                        cqr = cqr->next;
+                }
+                s390irq_spin_unlock_irqrestore (device->devinfo.irq, flags);
+        }
+        wait_event( device->wait_q, device->queue.head == NULL );
+}
+
+static void
+dasd_flush_request_queues ( dasd_device_t * device, int destroy )
+{
+        int i;
+        int major = MAJOR(device->kdev);
+        int minor = MINOR(device->kdev);
+        for ( i = 0; i < (1 << DASD_PARTN_BITS); i ++) {
+                if ( destroy )
+                        destroy_buffers(MKDEV(major,minor+i)); 
+                else
+                        invalidate_buffers(MKDEV(major,minor+i)); 
+        } 
+}
+
+static int
+dasd_disable_volume ( dasd_device_t * device, int force ) 
+{
+        int rc = 0;
+        int target  = DASD_STATE_KNOWN;
+        int count = atomic_read (&device->open_count);
+        
+	if ( count ) {
+		DASD_MESSAGE (KERN_EMERG, device, "%s",
+			      "device has vanished although it was open!");
+        }
+        if ( force ) {
+                dasd_deactivate_queue(device);
+                dasd_flush_chanq(device,force);
+                dasd_flush_request_queues(device,force);
+                dasd_disable_blkdev(device);
+                target = DASD_STATE_DEL;
+        }
+
+        /* unregister partitions ('ungrok_partitions') */
+        devfs_register_partitions(&device->major_info->gendisk,
+                                  MINOR(device->kdev),1);
+        
+        DASD_MESSAGE (KERN_WARNING, device, 
+                      "disabling device, target state: %d",target);
+
+        dasd_set_device_level (device->devinfo.devno, 
+                               device->discipline, 
+                               target);
+        return rc;
+}
+
+static void
+dasd_disable_ranges (dasd_range_t *range, 
+                     dasd_discipline_t *d,
+                     int all, int force ) 
+{
+        dasd_range_t *rrange;
+        int j;
+
+        if (range == &dasd_range_head) {
+                rrange = list_entry (range->list.next, 
+                                     dasd_range_t, list);
+        } else {
+                rrange = range;
+        }
+        do {
+                for (j = rrange->from; j <= rrange->to; j++) {
+                        dasd_device_t **dptr;
+                        dasd_device_t *device;
+                        dptr = dasd_device_from_devno(j);
+                        if ( dptr == NULL ) {
+                            continue;
+                        }
+                        device = *dptr;
+                        if (device == NULL ||
+                            (d != NULL &&
+                             device -> discipline != d))
+                                continue;
+                        
+                        dasd_disable_volume(device, force);
+                }
+                rrange = list_entry (rrange->list.next, dasd_range_t, list);
+        } while ( all && rrange && rrange != range );
+}
+
+static void 
+dasd_enable_single_device ( unsigned long arg ) {
+        dasd_device_t * device =(dasd_device_t *) arg;
+        int devno = device->devinfo.devno;
+        dasd_range_t range = { from: devno, to:devno };
+        dasd_enable_ranges (&range,NULL,0);
+}
+
+static void
+dasd_enable_ranges (dasd_range_t *range, dasd_discipline_t *d, int all ) 
+{
+        int retries = 0;
+	int j;
+        kdev_t tempdev;
+	dasd_range_t *rrange;
+
+	if (range == NULL)
+		return;
+        
+        do {
+                if (range == &dasd_range_head) {
+                        rrange = list_entry (range->list.next, 
+                                             dasd_range_t, list);
+                } else {
+                        rrange = range;
+                }
+                do {
+                        for (j = rrange->from; j <= rrange->to; j++) {
+                                if ( dasd_devindex_from_devno(j) < 0 )
+                                        continue;
+                                dasd_set_device_level (j, d, DASD_STATE_ONLINE);
+                        }
+                        rrange = list_entry (rrange->list.next, dasd_range_t, list);
+                } while ( all && rrange && rrange != range );
+
+                if (atomic_read (&dasd_init_pending) == 0) /* we are done, exit loop */
+                        break;
+
+                if ( retries == 0 ) {
+                        printk (KERN_INFO PRINTK_HEADER
+                                "waiting for responses...\n");
+                } else if ( retries < 5 ) {
+                        printk (KERN_INFO PRINTK_HEADER
+                                "waiting a little bit longer...\n");
+                } else {
+                        printk (KERN_INFO PRINTK_HEADER
+                                "giving up, enable late devices manually!\n");
+                        break;
+                }
+                interruptible_sleep_on_timeout (&dasd_init_waitq, (1 * HZ));
+                retries ++;
+        } while (1);
+        /* now setup block devices */
+
+        /* Now do block device and partition setup */
+        if (range == &dasd_range_head) {
+                rrange = list_entry (range->list.next, 
+                                     dasd_range_t, list);
+        } else {
+                rrange = range;
+        }
+        do {
+                for (j = rrange->from; j <= rrange->to; j++) {
+                        dasd_device_t **dptr;
+                        dasd_device_t *device;
+                        if ( dasd_devindex_from_devno(j) < 0 )
+                                continue;
+                        dptr = dasd_device_from_devno(j);
+                        device = *dptr;
+                        if (device == NULL )
+                                continue;
+                        if ( ((d == NULL && device->discipline != NULL) ||
+                              (device->discipline == d )) &&
+                             device->level >= DASD_STATE_READY &&
+                             device->request_queue == NULL ) {
+                                if (dasd_features_from_devno(j)&DASD_FEATURE_READONLY) {
+                                        for (tempdev=device->kdev;
+                                             tempdev<(device->kdev +(1 << DASD_PARTN_BITS));
+                                             tempdev++)
+                                                set_device_ro (tempdev, 1);
+
+                                        printk (KERN_WARNING PRINTK_HEADER 
+                                                "setting read-only mode for device /dev/%s\n",
+                                                device->name);
+                                }
+                                dasd_setup_blkdev(device);
+                                dasd_setup_partitions(device);
+                        }
+                }
+                rrange = list_entry (rrange->list.next, dasd_range_t, list);
+        } while ( all && rrange && rrange != range );
+}
+
+#ifdef CONFIG_DASD_DYNAMIC
+/*
+ * DASD_NOT_OPER_HANDLER
+ *
+ * DESCRIPTION
+ *   handles leaving devices
+ */
+static void
 dasd_not_oper_handler (int irq, int status)
 {
 	dasd_device_t *device = NULL;
@@ -2373,13 +2992,12 @@
 	struct list_head *l;
 	int i, devno = -ENODEV;
 
-        /* find out devno of leaving device: CIO has already deleted this information ! */
-	list_for_each(l,&dasd_major_info[0].list) {
-		major_info=list_entry(l, major_info_t,list);	
+	/* find out devno of leaving device: CIO has already deleted this information ! */
+	list_for_each (l, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
 		for (i = 0; i < DASD_PER_MAJOR; i++) {
 			device = major_info->dasd_device[i];
-			if (device &&
-			    device->devinfo.irq == irq) {
+			if (device && device->devinfo.irq == irq) {
 				devno = device->devinfo.devno;
 				break;
 			}
@@ -2387,365 +3005,622 @@
 		if (devno != -ENODEV)
 			break;
 	}
+
+	DASD_DRIVER_DEBUG_EVENT (5, dasd_not_oper_handler, 
+                                 "called for devno %04x", 
+                                 devno);
+
 	if (devno < 0) {
 		printk (KERN_WARNING PRINTK_HEADER
-			"not_oper_handler called on irq %d no devno!\n", irq);
+			"not_oper_handler called on irq 0x%04x no devno!\n", 
+                        irq);
 		return;
 	}
-
-	if (device->open_count != 0) {
-                DASD_MESSAGE(KERN_ALERT,device,"%s",
-                             "open device has gone. please repair!");
-                dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ANALYSED, 
-                                       NULL, 0);
-	} else {
-                DASD_MESSAGE(KERN_INFO,device,"%s","device has gone");
-                dasd_set_device_level (irq, DASD_DEVICE_LEVEL_UNKNOWN, 
-                                       NULL, 0);
-        }
+        dasd_disable_volume(device, 1);
 }
 
-static int
-dasd_enable_single_volume (int irq)
+/*
+ * DASD_OPER_HANDLER
+ *
+ * DESCRIPTION
+ *   called by the machine check handler to make an device operational
+ */
+int
+dasd_oper_handler (int irq, devreg_t * devreg)
 {
+	int devno;
 	int rc = 0;
-	dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ONLINE,
-			       NULL, 0);
-	printk (KERN_INFO PRINTK_HEADER "waiting for response...\n");
-	{
-		static wait_queue_head_t wait_queue;
-		init_waitqueue_head (&wait_queue);
-		interruptible_sleep_on_timeout (&wait_queue, (5 * HZ) >> 1);
+	major_info_t *major_info = NULL;
+        dasd_range_t *rptr,range;
+        dasd_device_t *device = NULL;
+	struct list_head *l;
+        int i;
+
+	devno = get_devno_by_irq (irq);
+	if (devno == -ENODEV) {
+		rc = -ENODEV;
+                goto out;
 	}
-	dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ONLINE, NULL, 0);
+
+	DASD_DRIVER_DEBUG_EVENT (5, dasd_oper_handler, 
+                                 "called for devno %04x", 
+                                 devno);
+
+	/* find out devno of device */
+	list_for_each (l, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
+		for (i = 0; i < DASD_PER_MAJOR; i++) {
+			device = major_info->dasd_device[i];
+			if (device && device->devinfo.irq == irq) {
+				devno = device->devinfo.devno;
+				break;
+			}
+		}
+		if (devno != -ENODEV)
+			break;
+	}
+	if (devno < 0) {
+                BUG();
+	}
+        if ( device &&
+             device->level == DASD_STATE_READY ) {
+            dasd_set_device_level (device->devinfo.devno, 
+                                   device->discipline, DASD_STATE_ONLINE);
+
+        } else {
+            if (dasd_autodetect) {
+		rptr = dasd_add_range (devno, devno, DASD_DEFAULT_FEATURES);
+                if ( rptr == NULL ) {
+                    rc = -ENOMEM;
+                    goto out;
+                }
+            } else {
+                range.from = devno;
+                range.to = devno;
+                rptr = &range;
+            }
+            dasd_enable_ranges (rptr, NULL, 0);
+        }
+ out:
 	return rc;
 }
+#endif				/* CONFIG_DASD_DYNAMIC */
 
-int
-dasd_oper_handler (int irq, devreg_t * devreg)
+static inline dasd_device_t **
+dasd_find_device_addr ( int devno ) 
 {
-	int devno;
-	int rc;
-	devno = get_devno_by_irq (irq);
-        printk (KERN_WARNING PRINTK_HEADER "Oper handler called\n");
-	if (devno == -ENODEV) {
-          printk (KERN_WARNING PRINTK_HEADER "NODEV\n");
-		return -ENODEV;
+        dasd_device_t **device_addr;
+
+	DASD_DRIVER_DEBUG_EVENT (1, dasd_find_device_addr, 
+                                 "devno %04x", 
+                                 devno);
+	if ( dasd_devindex_from_devno (devno) < 0 ) {
+                DASD_DRIVER_DEBUG_EXCEPTION (1, dasd_find_device_addr, 
+                                             "no dasd: devno %04x",
+                                             devno);
+		return NULL;
+	}
+        /* allocate major numbers on demand  for new devices */
+	while ((device_addr = dasd_device_from_devno (devno)) == NULL) {
+                int rc;
+
+		if ((rc = dasd_register_major (NULL)) <= 0) {
+
+                        DASD_DRIVER_DEBUG_EXCEPTION (1, dasd_find_device_addr, 
+                                                     "%s",
+                                                     "out of major numbers!");
+                        break;
+		}
+	}
+        return device_addr;
+}
+
+static inline int
+dasd_state_del_to_new (dasd_device_t **addr ) 
+{
+        dasd_device_t* device;
+        int rc = 0;
+	if (*addr == NULL) { /* allocate device descriptor on demand for new device */
+                device = kmalloc (sizeof (dasd_device_t), GFP_ATOMIC);
+		if (device == NULL ) {
+			rc = -ENOMEM;
+                        goto out;
+		}
+		memset (device, 0, sizeof (dasd_device_t));
+                *addr = device;
+                device->lowmem_ccws = (void*)get_free_page (GFP_ATOMIC|GFP_DMA);
+                if (device->lowmem_ccws == NULL) {
+                        rc = -ENOMEM;
+                        goto noccw;
+	}
+#ifdef CONFIG_ARCH_S390X
+                device->lowmem_idals =
+                    device->lowmem_idal_ptr = (void*) get_free_page (GFP_ATOMIC|GFP_DMA);
+                if (device->lowmem_idals == NULL) {
+                        rc = -ENOMEM;
+                        goto noidal;
+                }                
+#endif
+}
+        goto out;
+#ifdef CONFIG_ARCH_S390X
+ noidal:
+        free_page ((long) device->lowmem_ccws);
+#endif
+ noccw:
+        kfree(device);
+ out:
+        return rc;
+}
+
+static inline int
+dasd_state_new_to_del (dasd_device_t **addr )
+{
+        dasd_device_t *device = *addr;
+        if (device && device->private) {
+                kfree(device->private);
+                device->private = NULL;
         }
-	if (dasd_autodetect) {
-		dasd_add_range (devno, 0);
+#ifdef CONFIG_ARCH_S390X
+        free_page ((long)(device->lowmem_idals));
+#endif
+        free_page((long)(device->lowmem_ccws));
+        kfree(device);
+        *addr = NULL; 
+        return 0;
+}
+
+static inline int
+dasd_state_new_to_known (dasd_device_t **dptr, int devno, dasd_discipline_t *disc) 
+{
+        int rc = 0;
+	umode_t devfs_perm  = S_IFBLK | S_IRUSR | S_IWUSR;
+        struct list_head *l;
+        major_info_t *major_info = NULL;
+        int i;
+        dasd_device_t *device = *dptr;
+        devfs_handle_t dir;
+        char buffer[5];
+        
+
+	list_for_each (l, &dasd_major_info[0].list) {
+                major_info = list_entry (l, major_info_t, list);
+		for (i = 0; i < DASD_PER_MAJOR; i++) {
+			if (major_info->dasd_device[i] == device) {
+				device->kdev = MKDEV (major_info->gendisk.major,
+                                                      i << DASD_PARTN_BITS);
+				break;
+			}
+		}
+		if (i < DASD_PER_MAJOR) /* we found one */
+			break;
 	}
-	rc = dasd_enable_single_volume (irq);
-	return rc;
+        if ( major_info == NULL || major_info == &dasd_major_info[0] ) 
+                BUG();
+
+        device->major_info = major_info;
+        dasd_device_name (device->name,
+                          (((long)dptr -
+                            (long)device->major_info->dasd_device) /
+                           sizeof (dasd_device_t *)),
+                          0, &device->major_info->gendisk);
+        init_waitqueue_head (&device->wait_q);
+        
+        rc = get_dev_info_by_devno (devno, &device->devinfo);
+        if ( rc ) {
+                goto out;
+        }
+
+	DASD_DRIVER_DEBUG_EVENT (5, dasd_state_new_to_known, 
+                                 "got devinfo CU-type %04x and dev-type %04x", 
+                                 device->devinfo.sid_data.cu_type,
+                                 device->devinfo.sid_data.dev_type);
+
+
+        if ( devno != device->devinfo.devno )
+                BUG();
+        device->discipline = dasd_find_disc (device, disc);
+        if ( device->discipline == NULL ) {
+                rc = -ENODEV;
+                goto out;
+        }
+        sprintf (buffer, "%04x", 
+                 device->devinfo.devno);
+        dir = devfs_mk_dir (dasd_devfs_handle, buffer, device);
+        device->major_info->gendisk.de_arr[MINOR(device->kdev)
+                                          >> DASD_PARTN_BITS] = dir;
+	if (dasd_features_from_devno(device->devinfo.devno)&DASD_FEATURE_READONLY) {
+	        devfs_perm &= ~(S_IWUSR);
+	}
+        device->devfs_entry = devfs_register (dir,"device",DEVFS_FL_DEFAULT,
+                                              MAJOR(device->kdev),
+                                              MINOR(device->kdev),
+                                              devfs_perm,
+                                              &dasd_device_operations,NULL);
+        device->level = DASD_STATE_KNOWN;
+ out:
+        return rc;
+}
+
+static inline int
+dasd_state_known_to_new (dasd_device_t *device ) 
+{
+        int rc = 0;
+        /* don't reset to zeros because of persistent data durich detach/attach! */
+        devfs_unregister(device->devfs_entry);
+        devfs_unregister(device->major_info->gendisk.de_arr[MINOR(device->kdev) >> DASD_PARTN_BITS]);
+
+        return rc;
+}
+
+static inline int
+dasd_state_known_to_accept (dasd_device_t *device) 
+{
+        int rc = 0;
+        device->debug_area = debug_register (device->name, 0, 2, 
+                                             3 * sizeof (long));
+        debug_register_view (device->debug_area, &debug_sprintf_view);
+        debug_register_view (device->debug_area, &debug_hex_ascii_view);
+        DASD_DEVICE_DEBUG_EVENT (0, device,"%p debug area created",
+                                 device);
+        
+        if (device->discipline->int_handler) {
+                rc = s390_request_irq_special (device->devinfo.irq,
+                                               device->discipline->int_handler,
+                                               dasd_not_oper_handler,
+                                               0, DASD_NAME,
+                                               &device->dev_status);
+                if ( rc ) {
+                        printk("No request IRQ\n");
+                        goto out;
+                }
+        }
+        device->level = DASD_STATE_ACCEPT;
+ out:
+        return rc;
+}
+
+static inline int
+dasd_state_accept_to_known (dasd_device_t *device ) 
+{
+        if ( device->discipline == NULL )
+                goto out;
+        if (device->discipline->int_handler) {
+                free_irq (device->devinfo.irq, &device->dev_status);
+        }
+        DASD_DEVICE_DEBUG_EVENT (0, device,"%p debug area deleted",
+                                 device);
+        if ( device->debug_area != NULL )
+                debug_unregister (device->debug_area);
+        device->discipline = NULL;
+        device->level = DASD_STATE_KNOWN;
+ out:
+        return 0;
+}
+
+static inline int
+dasd_state_accept_to_init (dasd_device_t *device) 
+{
+        int rc = 0;
+        unsigned long flags;
+
+        if ( device->discipline->init_analysis ) {
+                device->init_cqr=device->discipline->init_analysis (device);
+                if ( device->init_cqr != NULL ) {
+                        if ( device->discipline->start_IO == NULL )
+                                BUG();
+                        atomic_inc (&dasd_init_pending);
+                        s390irq_spin_lock_irqsave (device->devinfo.irq, 
+                                                   flags);
+                        rc = device->discipline->start_IO (device->init_cqr);
+                        s390irq_spin_unlock_irqrestore(device->devinfo.irq, 
+                                                       flags);
+                        if ( rc )
+                                goto out;
+                        device->level = DASD_STATE_INIT;
+                } else {
+                        rc = -ENOMEM;
+                }
+        } else {
+                rc = dasd_state_init_to_ready ( device ); 
+        }
+ out:
+        return rc;
+}
+
+static inline int
+dasd_state_init_to_ready (dasd_device_t *device ) 
+{
+        int rc = 0;    
+        if (device->discipline->do_analysis != NULL)
+                if ( device->discipline->do_analysis (device) == 0 ) 
+                        switch (device->sizes.bp_block) {
+                        case 512:
+                        case 1024:
+                        case 2048:
+                        case 4096:
+                                break;
+                        default:
+                                rc = -EMEDIUMTYPE;
+                        }
+        if ( device->init_cqr ) {
+                /* This pointer is no longer needed, BUT dont't free the       */ 
+                /* memory, because this is done in bh for finished request!!!! */
+                atomic_dec(&dasd_init_pending);
+                device->init_cqr = NULL; 
+        }
+        device->level = DASD_STATE_READY;
+        return rc;
+}
+
+static inline int
+dasd_state_ready_to_accept (dasd_device_t *device ) 
+{
+        int rc = 0;
+        unsigned long flags;
+
+        s390irq_spin_lock_irqsave (device->devinfo.irq, flags);
+        if ( device->init_cqr != NULL &&  atomic_read(&dasd_init_pending) != 0 ) {
+                if ( device->discipline->term_IO == NULL )
+                        BUG();
+                device->discipline->term_IO (device->init_cqr);
+                atomic_dec (&dasd_init_pending);
+                dasd_free_request (device->init_cqr, device);
+                device->init_cqr = NULL;
+        }
+        s390irq_spin_unlock_irqrestore(device->devinfo.irq, flags);
+        memset(&device->sizes,0,sizeof(dasd_sizes_t));
+        device->level = DASD_STATE_ACCEPT;
+        return rc;
+}
+
+static inline int
+dasd_state_ready_to_online (dasd_device_t *device ) 
+{
+        int rc = 0;
+        dasd_unplug_device (device);
+        device->level = DASD_STATE_ONLINE;
+        return rc;
+}
+
+static inline int
+dasd_state_online_to_ready (dasd_device_t *device ) 
+{
+        int rc = 0;
+        dasd_plug_device (device);
+        device->level = DASD_STATE_READY;
+        return rc;
+}
+
+static inline int
+dasd_setup_blkdev (dasd_device_t *device ) 
+{
+        int rc = 0;
+        int i;
+        int major = MAJOR(device->kdev);
+        int minor = MINOR(device->kdev);
+
+        for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
+                if (i == 0)
+                        device->major_info->gendisk.sizes[minor] =
+                                (device->sizes.blocks << device->
+                                 sizes.s2b_shift) >> 1;
+                else
+                        device->major_info->gendisk.sizes[minor + i] = 0;
+                hardsect_size[major][minor + i] = device->sizes.bp_block;
+                blksize_size[major][minor + i] = device->sizes.bp_block;
+                max_sectors[major][minor + i] =
+                        device->discipline->max_blocks << 
+                        device->sizes.s2b_shift;
+		device->major_info->gendisk.part[minor+i].start_sect = 0;
+		device->major_info->gendisk.part[minor+i].nr_sects = 0;
+        }
+        device->request_queue = kmalloc(sizeof(request_queue_t),GFP_KERNEL);
+        device->request_queue->queuedata = device;
+        blk_init_queue (device->request_queue, do_dasd_request);
+        blk_queue_headactive (device->request_queue, 0);
+        elevator_init (&(device->request_queue->elevator),ELEVATOR_NOOP);
+        return rc;
+}
+
+static void
+dasd_deactivate_queue (dasd_device_t *device)
+{
+        int i;
+        int minor = MINOR(device->kdev);
+
+        for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
+                device->major_info->gendisk.sizes[minor + i] = 0;
+        }
+}
+
+static inline int
+dasd_disable_blkdev (dasd_device_t *device ) 
+{
+        int i;
+        int major = MAJOR(device->kdev);
+        int minor = MINOR(device->kdev);
+
+        for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
+                destroy_buffers(MKDEV(major,minor+i));
+                device->major_info->gendisk.sizes[minor + i] = 0;
+                hardsect_size[major][minor + i] = 0;
+                blksize_size[major][minor + i] = 0;
+                max_sectors[major][minor + i] = 0;
+        }
+        if (device->request_queue) {
+            blk_cleanup_queue (device->request_queue);
+            kfree(device->request_queue);
+            device->request_queue = NULL;
+        }
+        return 0;
+}
+
+
+/*
+ * function dasd_setup_partitions
+ * calls the function in genhd, which is appropriate to setup a partitioned disk
+ */
+static inline void
+dasd_setup_partitions ( dasd_device_t * device ) 
+{
+	register_disk (&device->major_info->gendisk,
+                       device->kdev,
+		       1 << DASD_PARTN_BITS,
+		       &dasd_device_operations,
+		       (device->sizes.blocks << device->sizes.s2b_shift));
+}
+
+static inline void
+dasd_destroy_partitions ( dasd_device_t * device ) 
+{
+        int i;
+        int minor = MINOR(device->kdev);
+        
+        for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
+                device->major_info->gendisk.part[minor+i].start_sect = 0;
+                device->major_info->gendisk.part[minor+i].nr_sects   = 0;
+        }
+        devfs_register_partitions(&device->major_info->gendisk,
+                                  MINOR(device->kdev),1);
+}
+
+static inline void
+dasd_resetup_partitions ( dasd_device_t * device ) 
+{
+    BUG();
+    dasd_destroy_partitions ( device ) ;
+    dasd_setup_partitions ( device ) ;
 }
-#endif	/* CONFIG_DASD_DYNAMIC */
 
-/* 
- * function dasd_set_device_level 
- */
-static int
-dasd_set_device_level (unsigned int irq, int desired_level,
-		       dasd_discipline_t * discipline, int flags)
-{
-	int rc = 0;
-	int devno;
-	dasd_device_t **device_addr, *device;
-	int current_level;
-	major_info_t *major_info = NULL;
-	struct list_head *l;
-	int i, minor, major;
-	ccw_req_t *cqr = NULL;
-	struct gendisk *dd;
+/*
+ * function dasd_set_device_level
+ */
+static int
+dasd_set_device_level (unsigned int devno, 
+                       dasd_discipline_t * discipline,
+                       int to_state)
+{
+	int rc = 0;
+        dasd_device_t **device_addr;
+        dasd_device_t *device;
+        int from_state;
+
+        device_addr = dasd_find_device_addr ( devno );
+        if ( device_addr == NULL ) {
+                rc = -ENODEV;
+                goto out;
+        }
+        device = *device_addr;
+
+        if ( device == NULL ) {
+                from_state = DASD_STATE_DEL;
+                if ( to_state == DASD_STATE_DEL )
+                        goto out;
+        } else {
+                from_state = device->level;
+        }
+
+        DASD_DRIVER_DEBUG_EVENT (3, dasd_set_device_level,
+                                 "devno %04x; from %i to %i",
+                                 devno,
+                                 from_state,
+                                 to_state);
+
+        if ( from_state == to_state )
+                goto out;
+
+        if ( to_state < from_state )
+                goto shutdown;
+
+        /* First check for bringup */
+        if ( from_state <= DASD_STATE_DEL &&
+             to_state >= DASD_STATE_NEW ) { 
+                rc = dasd_state_del_to_new(device_addr);
+                if ( rc ) {
+                        goto bringup_fail;
+                }
+                device = *device_addr;
+        }
+        if ( from_state <= DASD_STATE_NEW &&
+             to_state >= DASD_STATE_KNOWN ) { 
+                rc = dasd_state_new_to_known( device_addr, devno, discipline );
+                if ( rc ) {
+                        goto bringup_fail;
+                }
+        }
+        if ( from_state <= DASD_STATE_KNOWN &&
+             to_state >= DASD_STATE_ACCEPT ) { 
+                rc = dasd_state_known_to_accept(device);
+                if ( rc ) {
+                        goto bringup_fail;
+                }
+        }
+        if ( dasd_probeonly ) {
+            goto out;
+        }
+        if ( from_state <= DASD_STATE_ACCEPT &&
+             to_state >= DASD_STATE_INIT ) { 
+                rc = dasd_state_accept_to_init(device);
+                if ( rc ) {
+                        goto bringup_fail;
+                }
+        }
+        if ( from_state <= DASD_STATE_INIT &&
+             to_state >= DASD_STATE_READY ) { 
+                rc = -EAGAIN;
+                goto out;
+        }
+        if ( from_state <= DASD_STATE_READY &&
+             to_state >= DASD_STATE_ONLINE ) { 
+                rc = dasd_state_ready_to_online(device);
+                if ( rc ) {
+                        goto bringup_fail;
+                }
+        }
+        goto out;
+ bringup_fail:   /* revert changes */
+#if 0
+        printk (KERN_DEBUG PRINTK_HEADER
+                "failed to set device from state %d to %d at "
+                "level %d rc %d. Reverting...\n",
+                from_state,
+                to_state,
+                device->level,
+                rc);
+#endif
+        to_state = from_state;
+        from_state = device->level;
+        
+        /* now do a shutdown */
+ shutdown: 
+        if ( from_state >= DASD_STATE_ONLINE &&
+             to_state <= DASD_STATE_READY ) 
+                if (dasd_state_online_to_ready(device))
+                        BUG();
+
+        if ( from_state >= DASD_STATE_READY &&
+             to_state <= DASD_STATE_ACCEPT ) 
+                if ( dasd_state_ready_to_accept(device))
+                        BUG();
+
+        if ( from_state >= DASD_STATE_ACCEPT &&
+             to_state <= DASD_STATE_KNOWN ) 
+                if ( dasd_state_accept_to_known(device))
+                        BUG();
+
+        if ( from_state >= DASD_STATE_KNOWN &&
+             to_state <= DASD_STATE_NEW ) 
+                if ( dasd_state_known_to_new(device))
+                        BUG();
 
-	devno = get_devno_by_irq (irq);
-	if (devno < 0) { /* e.g. when device has been detached before */
-		/* search in device list */
-		list_for_each(l,&dasd_major_info[0].list) {
-			major_info = list_entry(l,major_info_t,list);	
-			for (i = 0; i < DASD_PER_MAJOR; i++) {
-				device = major_info->dasd_device[i];
-				if (device && device->devinfo.irq == irq) {
-					devno = device->devinfo.devno;
-					break;
-				}
-			}
-			if (devno == -ENODEV)
-				return -ENODEV;
-		}
-	}
-	if (dasd_devindex_from_devno (devno) < 0) {
-		return -ENODEV;
-	}
-	while ((device_addr = dasd_device_from_devno (devno)) == NULL) {
-		if ((rc = dasd_register_major (NULL)) > 0) {
-			printk (KERN_INFO PRINTK_HEADER
-				"Registered to major number: %u\n", rc);
-		} else {
-			printk (KERN_WARNING PRINTK_HEADER
-				"Couldn't register to another major no\n");
-			return -ERANGE;
-		}
-	}
-	device = *device_addr;
-	if (!device) {		/* allocate device descriptor */
-		device = kmalloc (sizeof (dasd_device_t), GFP_ATOMIC);
-		if (!device) {
-			printk (KERN_WARNING PRINTK_HEADER " No memory for device descriptor\n");
-			goto nomem;
-		}
-		memset (device, 0, sizeof (dasd_device_t));
-		*device_addr = device;
-	}
-	list_for_each(l,&dasd_major_info[0].list) {
-		int i;
-		major_info = list_entry(l,major_info_t,list);	
-		for (i = 0; i < DASD_PER_MAJOR; i++) {
-			if (major_info->dasd_device[i] == device) {
-				device->kdev = MKDEV (major_info->gendisk.major, i << DASD_PARTN_BITS);
-				break;
-			}
-		}
-		if (i < DASD_PER_MAJOR)
-			break;
-	}
-	if (major_info == &dasd_major_info[0]) {
-		return -ENODEV;
-	}
-	minor = MINOR (device->kdev);
-	major = MAJOR (device->kdev);
-	current_level = device->level;
-	if (desired_level > current_level) {
-		switch (current_level) {
-		case DASD_DEVICE_LEVEL_UNKNOWN:	/* Find a discipline */
-                        device->major_info = major_info;
-                        dasd_device_name (device->name,
-                                          ((long) device_addr -
-                                           (long) device->major_info->dasd_device) /
-                                          sizeof (dasd_device_t *),
-                                          0, &major_info->gendisk);
-			rc = get_dev_info_by_irq (irq, &device->devinfo);
-			if (rc < 0) {
-				break;
-			}
-			discipline = dasd_find_discipline (device);
-			if (discipline && !rc) {
-                                DASD_MESSAGE (KERN_INFO, device,
-                                              "%s", " ");
-			} else {
-                                break;
-			}
-			device->discipline = discipline;
-                        device->debug_area = debug_register(device->name,0,2,3*sizeof(long));
-                        debug_register_view(device->debug_area,&debug_sprintf_view);
-                        debug_register_view(device->debug_area,&debug_hex_ascii_view);
-			if (device->discipline->int_handler) {
-#ifdef CONFIG_DASD_DYNAMIC
-				s390_request_irq_special (irq,
-                                                          device->discipline->int_handler,
-                                                          dasd_not_oper_handler,
-							  0,
-							  DASD_NAME,
-							  &device->dev_status);
-#else				/* !defined(CONFIG_DASD_DYNAMIC) */
-				request_irq (irq,
-					     device->discipline->int_handler,
-					     0,
-					     DASD_NAME,
-					     &device->dev_status);
-#endif				/* CONFIG_DASD_DYNAMIC */
-			}
-			device->proc_dir = (struct proc_dir_entry *)
-			    kmalloc (sizeof (struct proc_dir_entry), GFP_KERNEL);
-			if (device->proc_dir) {
-				memset (device->proc_dir, 0, sizeof (struct proc_dir_entry));
-				device->proc_info = (struct proc_dir_entry *)
-				    kmalloc (sizeof (struct proc_dir_entry), GFP_KERNEL);
-				if (device->proc_info) {
-					memset (device->proc_info, 0,
-					      sizeof (struct proc_dir_entry));
-				}
-				device->proc_stats = (struct proc_dir_entry *)
-				    kmalloc (sizeof (struct proc_dir_entry), GFP_KERNEL);
-				if (device->proc_stats) {
-					memset (device->proc_stats, 0,
-					      sizeof (struct proc_dir_entry));
-				}
-			}
-			init_waitqueue_head (&device->wait_q);
-			check_then_set (&device->level,
-				       DASD_DEVICE_LEVEL_UNKNOWN,
-				       DASD_DEVICE_LEVEL_RECOGNIZED);
-			if (desired_level == DASD_DEVICE_LEVEL_RECOGNIZED)
-				break;
-		case DASD_DEVICE_LEVEL_RECOGNIZED:	/* Fallthrough ?? */
-			if (device->discipline->init_analysis) {
-				cqr = device->discipline->init_analysis (device);
-				if (cqr != NULL) {
-					dasd_chanq_enq (&device->queue, cqr);
-					if (device->discipline->start_IO) {
-						long flags;
-						s390irq_spin_lock_irqsave (irq, flags);
-						device->discipline->start_IO (cqr);
-						check_then_set (&device->level,
-                                                                DASD_DEVICE_LEVEL_RECOGNIZED,
-                                                                DASD_DEVICE_LEVEL_ANALYSIS_PENDING);
-						s390irq_spin_unlock_irqrestore (irq, flags);
-					}
-				}
-			} else {
-				check_then_set (&device->level, DASD_DEVICE_LEVEL_RECOGNIZED,
-                                                DASD_DEVICE_LEVEL_ANALYSIS_PREPARED);
-			}
-			if (desired_level >= DASD_DEVICE_LEVEL_ANALYSIS_PENDING)
-				break;
-		case DASD_DEVICE_LEVEL_ANALYSIS_PENDING:	/* Fallthrough ?? */
-			return -EAGAIN;
-		case DASD_DEVICE_LEVEL_ANALYSIS_PREPARED:	/* Re-entering here ! */
-			if (device->discipline->do_analysis)
-                                if (device->discipline->do_analysis (device))
-                                        return -ENODEV;
-			switch (device->sizes.bp_block) {
-			case 512:
-			case 1024:
-			case 2048:
-			case 4096:
-				break;
-			default:
-				{
-					printk (KERN_INFO PRINTK_HEADER
-						"/dev/%s (devno 0x%04X): Detected invalid blocksize of %d bytes"
-						" Did you format the drive?\n",
-						device->name, devno, device->sizes.bp_block);
-					return -EMEDIUMTYPE;
-				}
-			}
-			blk_init_queue (&device->request_queue, do_dasd_request);
-			blk_queue_headactive (&device->request_queue, 0);
-			elevator_init(&device->request_queue.elevator, ELEVATOR_NOOP);
-			for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
-                                if (i == 0)
-                                        blk_size[major][minor] = (device->sizes.blocks << device->sizes.s2b_shift) >> 1;
-				else
-					blk_size[major][minor + i] = 0;
-				hardsect_size[major][minor + i] = device->sizes.bp_block;
-				blksize_size[major][minor + i] = device->sizes.bp_block;
-				if (blksize_size[major][minor + i] < 1024)
-					blksize_size[major][minor + i] = 1024;
-
-				max_sectors[major][minor + i] =
-                                        device->discipline->max_blocks << device->sizes.s2b_shift;
-			}
-			check_then_set (&device->level,
-				       DASD_DEVICE_LEVEL_ANALYSIS_PREPARED,
-				       DASD_DEVICE_LEVEL_ANALYSED);
-			dd = &major_info->gendisk;
-			dd->sizes[minor] = (device->sizes.blocks <<
-					    device->sizes.s2b_shift) >> 1;
-                        dd->part[minor].start_sect = 0;
-			{
-				char buffer[5];
-				sprintf(buffer,"%04X",device->devinfo.devno);
-				dd->de_arr[minor>>DASD_PARTN_BITS] = devfs_mk_dir(dasd_devfs_handle,buffer,NULL);
-			}
-#if !(LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-#ifndef MODULE
-			if (flags & 0x80)
-#endif
-#endif				/* KERNEL_VERSION */
-				dasd_partn_detect (device);
-			if (desired_level == DASD_DEVICE_LEVEL_ANALYSED)
-				break;
-		case DASD_DEVICE_LEVEL_ANALYSED:	/* Fallthrough ?? */
-                        dasd_unplug_device(device);
-			check_then_set (&device->level,
-                                        DASD_DEVICE_LEVEL_ANALYSED,
-                                        DASD_DEVICE_LEVEL_ONLINE);
-                        
-			if (desired_level == DASD_DEVICE_LEVEL_ONLINE)
-                                break;
-		case DASD_DEVICE_LEVEL_ONLINE:	
-                        break;
-		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"Internal error in " __FILE__ " on line %d."
-				" validate_dasd called from %p with "
-				" desired_level = %d, current_level =%d"
-				" Pls send this message and your System.map to"
-				" linux390@de.ibm.com\n",
-				__LINE__, __builtin_return_address (0),
-				desired_level, current_level);
-			break;
-		}
-	} else if (desired_level < current_level) {	/* donwgrade device status */
-		switch (current_level) {
-		case DASD_DEVICE_LEVEL_ONLINE:	/* Fallthrough ?? */
-                        dasd_plug_device(device); 
-			check_then_set (&device->level,
-                                        DASD_DEVICE_LEVEL_ONLINE,
-                                        DASD_DEVICE_LEVEL_ANALYSED);
-			if (desired_level == DASD_DEVICE_LEVEL_ANALYSED)
-                                break;
-                case DASD_DEVICE_LEVEL_ANALYSED:	/* Fallthrough ?? */
-			for (i = 0; i < (1 << DASD_PARTN_BITS); i++) {
-                                __invalidate_buffers(MKDEV(major,minor),1);
-                                blk_size[major][minor] = 0;
-				hardsect_size[major][minor + i] = 0;
-				blksize_size[major][minor + i] = 0;
-				max_sectors[major][minor + i] = 0;
-			}
-			memset (&device->sizes, 0, sizeof (dasd_sizes_t));
-			blk_cleanup_queue (&device->request_queue);
-                        check_then_set (&device->level,
-                                        DASD_DEVICE_LEVEL_ANALYSED,
-                                        DASD_DEVICE_LEVEL_ANALYSIS_PREPARED);
-                        if (desired_level == DASD_DEVICE_LEVEL_ANALYSIS_PREPARED)
-                                break;
-		case DASD_DEVICE_LEVEL_ANALYSIS_PREPARED:
-			check_then_set (&device->level,
-				       DASD_DEVICE_LEVEL_ANALYSIS_PREPARED,
-				       DASD_DEVICE_LEVEL_ANALYSIS_PENDING);
-			if (desired_level == DASD_DEVICE_LEVEL_ANALYSIS_PENDING)
-				break;
-		case DASD_DEVICE_LEVEL_ANALYSIS_PENDING:	/* Fallthrough ?? */
-			check_then_set (&device->level,
-				       DASD_DEVICE_LEVEL_ANALYSIS_PENDING,
-				       DASD_DEVICE_LEVEL_RECOGNIZED);
-			if (desired_level == DASD_DEVICE_LEVEL_RECOGNIZED)
-				break;
-		case DASD_DEVICE_LEVEL_RECOGNIZED:	/* Fallthrough ?? */
-			if (device->discipline->int_handler) {
-				free_irq (irq, &device->dev_status);
-			}
-			device->discipline = NULL;
-                        debug_unregister(device->debug_area);
-			check_then_set (&device->level,
-				       DASD_DEVICE_LEVEL_RECOGNIZED,
-				       DASD_DEVICE_LEVEL_UNKNOWN);
-                        *device_addr = NULL;
-                        kfree(device);
-			if (desired_level == DASD_DEVICE_LEVEL_UNKNOWN)
-				break;
-		case DASD_DEVICE_LEVEL_UNKNOWN:
-			break;
-		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"Internal error in " __FILE__ " on line %d."
-				" validate_dasd called from %p with "
-				" desired_level = %d, current_level =%d"
-				" Pls send this message and your System.map to"
-				" linux390@de.ibm.com\n",
-				__LINE__, __builtin_return_address (0),
-				desired_level, current_level);
-			break;
-		}
-	}
-	if (rc) {
-		goto exit;
-	}
-      nomem:
-	rc = -ENOMEM;
-      exit:
-	return 0;
+        if ( from_state >= DASD_STATE_NEW &&
+             to_state <= DASD_STATE_DEL) 
+                if (dasd_state_new_to_del(device_addr))
+                        BUG();
+        goto out;
+ out:
+        return rc;
 }
 
 /* SECTION: Procfs stuff */
@@ -2754,29 +3629,16 @@
 	int len;
 } tempinfo_t;
 
-void dasd_fill_inode (struct inode* inode, int fill) {
-    if (fill)
-        MOD_INC_USE_COUNT;
-    else
-        MOD_DEC_USE_COUNT;
+void
+dasd_fill_inode (struct inode *inode, int fill)
+{
+	if (fill)
+		MOD_INC_USE_COUNT;
+	else
+		MOD_DEC_USE_COUNT;
 }
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 static struct proc_dir_entry *dasd_proc_root_entry = NULL;
-#else
-static struct proc_dir_entry dasd_proc_root_entry =
-{
-	low_ino:0,
-	namelen:4,
-	name:"dasd",
-	mode:S_IFDIR | S_IRUGO | S_IXUGO | S_IWUSR | S_IWGRP,
-	nlink:1,
-	uid:0,
-	gid:0,
-	size:0,
-        fill_inode:dasd_fill_inode
-};
-#endif				/* KERNEL_VERSION */
 static struct proc_dir_entry *dasd_devices_entry;
 static struct proc_dir_entry *dasd_statistics_entry;
 
@@ -2786,94 +3648,152 @@
 	int rc = 0;
 	int size = 1;
 	int len = 0;
-	major_info_t *temp = dasd_major_info;
+	major_info_t *temp = NULL;
 	struct list_head *l;
 	tempinfo_t *info;
 	int i;
+        unsigned long flags;
+        int index = 0;
 
+        MOD_INC_USE_COUNT;
+        spin_lock_irqsave(&discipline_lock,flags);
 	info = (tempinfo_t *) vmalloc (sizeof (tempinfo_t));
 	if (info == NULL) {
-		printk (KERN_WARNING "No memory available for data\n");
-		return -ENOMEM;
+                printk (KERN_WARNING "No memory available for data\n");
+                MOD_DEC_USE_COUNT;
+                return -ENOMEM;
 	} else {
 		file->private_data = (void *) info;
 	}
-	list_for_each(l,&dasd_major_info[0].list) {
-		temp = list_entry(l,major_info_t,list);	
-		for (i = 0; i < 1 << (MINORBITS - DASD_PARTN_BITS); i++) {
-			dasd_device_t *device = temp->dasd_device[i];
-			if (device) {
-				size += 128;
-			}
-		}
+	list_for_each (l, &dasd_major_info[0].list) {
+                size += 128 * 1 << (MINORBITS - DASD_PARTN_BITS);
 	}
-	temp = dasd_major_info;
-	info->data = (char *) vmalloc (size);	/* FIXME! determine space needed in a better way */
+	info->data = (char *) vmalloc (size);	
+	DASD_DRIVER_DEBUG_EVENT (1, dasd_devices_open, "area: %p, size 0x%x",
+				 info->data, 
+                                 size);
 	if (size && info->data == NULL) {
 		printk (KERN_WARNING "No memory available for data\n");
 		vfree (info);
+                MOD_DEC_USE_COUNT;
 		return -ENOMEM;
 	}
-	list_for_each(l,&dasd_major_info[0].list) {
-		temp = list_entry(l,major_info_t,list);	
+	list_for_each (l, &dasd_major_info[0].list) {
+		temp = list_entry (l, major_info_t, list);
 		for (i = 0; i < 1 << (MINORBITS - DASD_PARTN_BITS); i++) {
-			dasd_device_t *device = temp->dasd_device[i];
+			dasd_device_t *device;
+                        int devno = dasd_devno_from_devindex(index+i);
+                        int features;
+
+                        if ( devno == -ENODEV )
+                                continue;
+
+                        features = dasd_features_from_devno(devno);
+                        if (features < DASD_DEFAULT_FEATURES)
+                                features = DASD_DEFAULT_FEATURES;
+
+                        device = temp->dasd_device[i];
 			if (device) {
+
 				len += sprintf (info->data + len,
-						"%04X(%s) at (%d:%d) is %7s:",
+						"%04x(%s) at (%3d:%3d) is %-7s%4s: ",
 						device->devinfo.devno,
-						device->discipline ? device->discipline->name : "none",
-				    temp->gendisk.major, i << DASD_PARTN_BITS,
-						device->name);
+						device->discipline ?
+						device->
+						discipline->name : "none",
+						temp->gendisk.major,
+						i << DASD_PARTN_BITS,
+						device->name,
+                                                (features & DASD_FEATURE_READONLY) ? 
+                                                "(ro)" : " ");
+                                
 				switch (device->level) {
-				case DASD_DEVICE_LEVEL_UNKNOWN:
-					len += sprintf (info->data + len, "unknown\n");
-					break;
-				case DASD_DEVICE_LEVEL_RECOGNIZED:
-					len += sprintf (info->data + len, "passive");
-					len += sprintf (info->data + len, " at blocksize: %d, %ld blocks, %ld MB\n",
-							device->sizes.bp_block,
-							device->sizes.blocks,
-							((device->sizes.bp_block >> 9) * device->sizes.blocks) >> 11);
-					break;
-				case DASD_DEVICE_LEVEL_ANALYSIS_PENDING:
-					len += sprintf (info->data + len, "busy   \n");
+				case DASD_STATE_NEW:
+                                        len +=
+					    sprintf (info->data + len,
+						     "new");
+                                        break;
+				case DASD_STATE_KNOWN:
+					len +=
+					    sprintf (info->data + len,
+						     "detected");
 					break;
-				case DASD_DEVICE_LEVEL_ANALYSIS_PREPARED:
-					len += sprintf (info->data + len, "n/f    \n");
+				case DASD_STATE_ACCEPT:
+                                        len += sprintf (info->data + len,"accepted");
 					break;
-				case DASD_DEVICE_LEVEL_ANALYSED:
-					len += sprintf (info->data + len, "active ");
-					len += sprintf (info->data + len, " at blocksize: %d, %ld blocks, %ld MB\n",
-							device->sizes.bp_block,
-							device->sizes.blocks,
-							((device->sizes.bp_block >> 9) * device->sizes.blocks) >> 11);
+				case DASD_STATE_INIT:
+					len +=
+					    sprintf (info->data + len,
+						     "busy   ");
 					break;
-				case DASD_DEVICE_LEVEL_ONLINE:
-					len += sprintf (info->data + len, "active ");
-					len += sprintf (info->data + len, " at blocksize: %d, %ld blocks, %ld MB\n",
-							device->sizes.bp_block,
-							device->sizes.blocks,
-							((device->sizes.bp_block >> 9) * device->sizes.blocks) >> 11);
+				case DASD_STATE_READY:
+				case DASD_STATE_ONLINE:
+                                    if ( atomic_read(&device->plugged) )
+                                        len +=
+                                            sprintf (info->data + len,
+                                                     "fenced ");
+                                    else
+                                        len +=
+                                            sprintf (info->data + len,
+                                                     "active ");
+                                    if ( device->sizes.bp_block == 512 ||
+                                         device->sizes.bp_block == 1024 ||
+                                         device->sizes.bp_block == 2048 ||
+                                         device->sizes.bp_block == 4096 )
+					len +=
+					    sprintf (info->data + len,
+						     "at blocksize: %d, %ld blocks, %ld MB",
+						     device->sizes.bp_block,
+						     device->sizes.blocks,
+						     ((device->
+						       sizes.bp_block >> 9) *
+						      device->sizes.
+						      blocks) >> 11);
+                                    else
+                                        len +=
+                                            sprintf (info->data + len,
+                                                     "n/f    ");
 					break;
 				default:
-					len += sprintf (info->data + len, "no stat\n");
+					len +=
+					    sprintf (info->data + len,
+						     "no stat");
 					break;
 				}
-			}
+			} else {
+                                char buffer[7];
+                                dasd_device_name (buffer, i, 0, &temp->gendisk);
+                                if ( devno < 0  ) {
+                                        len += sprintf (info->data + len,
+                                                        "none");
+                                } else {
+                                        len += sprintf (info->data + len,
+                                                        "%04x",devno);
+                                }
+                                len += sprintf (info->data + len,
+                                                "(none) at (%3d:%3d) is %-7s%4s: unknown",
+						temp->gendisk.major,
+						i << DASD_PARTN_BITS,
+						buffer,
+                                                (features & DASD_FEATURE_READONLY) ? 
+                                                "(ro)" : " ");
+                        }
+                        if ( dasd_probeonly )
+                            len += sprintf(info->data + len,"(probeonly)");
+                        len += sprintf(info->data + len,"\n");
 		}
+                index += 1 << (MINORBITS - DASD_PARTN_BITS);
 	}
 	info->len = len;
-#ifdef MODULE
-        MOD_INC_USE_COUNT;
-#endif
+        spin_unlock_irqrestore(&discipline_lock,flags);
 	return rc;
 }
 
 #define MIN(a,b) ((a)<(b)?(a):(b))
 
 static ssize_t
-dasd_devices_read (struct file *file, char *user_buf, size_t user_len, loff_t * offset)
+dasd_generic_read (struct file *file, char *user_buf, size_t user_len,
+		   loff_t * offset)
 {
 	loff_t len;
 	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
@@ -2890,85 +3810,85 @@
 }
 
 static ssize_t
-dasd_devices_write (struct file *file, const char *user_buf, size_t user_len, loff_t * offset)
+dasd_devices_write (struct file *file, const char *user_buf,
+		    size_t user_len, loff_t * offset)
 {
 	char *buffer = vmalloc (user_len+1);
 	int off = 0;
 	char *temp;
-        int irq;
-        int j,target;
-        dasd_range_t *rptr, range;
+	dasd_range_t range;
+        int features;
 
 	if (buffer == NULL)
 		return -ENOMEM;
 	if (copy_from_user (buffer, user_buf, user_len)) {
-		vfree(buffer);
+		vfree (buffer);
 		return -EFAULT;
 	}
-	buffer[user_len] = 0;
-	printk (KERN_INFO PRINTK_HEADER "Now executing %s\n", buffer);
-        if (strncmp ( buffer, "set ",4) &&
-            strncmp ( buffer, "add ",4)){
-                printk (KERN_WARNING PRINTK_HEADER 
-                        "/proc/dasd/devices: only 'set' and 'add' are supported verbs");
-                return -EINVAL;
+
+        /* replace LF with '\0' */
+        if (buffer[user_len -1] == '\n') {
+                buffer[user_len -1] = '\0';
+        } else {
+                buffer[user_len] = '\0';
         }
-        off += 4;
-        while (!isalnum(buffer[off])) off++;
+
+	printk (KERN_INFO PRINTK_HEADER "/proc/dasd/devices: '%s'\n", buffer);
+	if (strncmp (buffer, "set ", 4) && strncmp (buffer, "add ", 4)) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"/proc/dasd/devices: only 'set' and 'add' are supported verbs\n");
+		return -EINVAL;
+	}
+	off += 4;
+	while (buffer[off] && !isalnum (buffer[off]))
+		off++;
 	if (!strncmp (buffer + off, "device", strlen ("device"))) {
-		off += strlen("device");
-		while (!isalnum(buffer[off])) off++;
-        }
+		off += strlen ("device");
+		while (buffer[off] && !isalnum (buffer[off]))
+			off++;
+	}
 	if (!strncmp (buffer + off, "range=", strlen ("range="))) {
-		off += strlen("range=");
-		while (!isalnum(buffer[off])) off++;
-        }
-        temp = buffer+off;
-        range.from = dasd_strtoul (temp, &temp);
-        range.to = range.from;
-        if (*temp == '-') {
-                temp++;
-                range.to = dasd_strtoul (temp, &temp);
-        }
-        off = (long)temp - (long)buffer;
-        if ( !strncmp ( buffer, "add",strlen("add"))) {
-                rptr = dasd_add_range (range.from, range.to);
-        } else {
-                rptr = &range;
-        }
-        while (!isalnum(buffer[off])) off++;
-        printk (KERN_INFO PRINTK_HEADER 
-                "varying device range %04X-%04X\n", rptr->from, rptr->to);
-        if ( !strncmp ( buffer, "add",strlen("add")) ||
-             !strncmp ( buffer+off, "on",strlen("on")) ) {
-                target = DASD_DEVICE_LEVEL_ONLINE;
-                for (j = rptr->from; j <= rptr->to; j++) {
-			irq = get_irq_by_devno (j);
-			if (irq >= 0) {
-				dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ONLINE, NULL, 0);
-			}
-		}
-		printk (KERN_INFO PRINTK_HEADER "waiting for responses...\n");
-		{
-			static wait_queue_head_t wait_queue;
-			init_waitqueue_head (&wait_queue);
-			interruptible_sleep_on_timeout (&wait_queue, (5 * HZ) );
-		}
-        } else if ( !strncmp ( buffer+off, "off",strlen("off"))) {
-                target = DASD_DEVICE_LEVEL_UNKNOWN;
-        } else {
-                printk (KERN_WARNING PRINTK_HEADER 
-                        "/proc/dasd/devices: parse error in '%s'", buffer);
-                vfree (buffer);
-                return -EINVAL;
+		off += strlen ("range=");
+		while (buffer[off] && !isalnum (buffer[off]))
+			off++;
+	}
+	
+	temp = buffer + off;
+	range.from = dasd_strtoul (temp, &temp, &features);
+	range.to = range.from;
+
+	if (*temp == '-') {
+		temp++;
+		range.to = dasd_strtoul (temp, &temp, &features);
+	}
+
+        if (range.from == -EINVAL ||
+            range.to   == -EINVAL   ) {
                 
-        }
-        for (j = rptr->from; j <= rptr->to; j++) {
-                irq = get_irq_by_devno (j);
-                if (irq >= 0) {
-                        dasd_set_device_level (irq, target, NULL, 0);
+                printk (KERN_WARNING PRINTK_HEADER
+                        "/proc/dasd/devices: range parse error in '%s'\n", 
+                        buffer);
+        } else {
+                off = (long) temp - (long) buffer;
+                if (!strncmp (buffer, "add", strlen ("add"))) {
+                        dasd_add_range (range.from, range.to, features);
+                        dasd_enable_ranges (&range, NULL, 0);
+                } else { 
+                        while (buffer[off] && !isalnum (buffer[off]))
+                                off++;
+                        if (!strncmp (buffer + off, "on", strlen ("on"))) {
+                                dasd_enable_ranges (&range, NULL, 0);
+                        } else if (!strncmp (buffer + off, "off", strlen ("off"))) {
+                                dasd_disable_ranges (&range, NULL, 0, 1);
+                        } else {
+                                printk (KERN_WARNING PRINTK_HEADER
+                                        "/proc/dasd/devices: parse error in '%s'\n",
+                                        buffer);
+                        }
                 }
         }
+
+	vfree (buffer);
 	return user_len;
 }
 
@@ -2982,25 +3902,18 @@
 			vfree (p_info->data);
 		vfree (p_info);
 	}
-#ifdef MODULE
-        MOD_DEC_USE_COUNT;
-#endif
+	MOD_DEC_USE_COUNT;
 	return rc;
 }
 
-static struct file_operations dasd_devices_file_ops =
-{
-	read:dasd_devices_read,	/* read */
+static struct file_operations dasd_devices_file_ops = {
+	read:dasd_generic_read,	/* read */
 	write:dasd_devices_write,	/* write */
 	open:dasd_devices_open,	/* open */
 	release:dasd_devices_close,	/* close */
 };
 
-static struct inode_operations dasd_devices_inode_ops =
-{
-#if !(LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	default_file_ops:&dasd_devices_file_ops		/* file ops */
-#endif				/* LINUX_IS_24 */
+static struct inode_operations dasd_devices_inode_ops = {
 };
 
 static int
@@ -3011,9 +3924,11 @@
 	tempinfo_t *info;
 	int shift, i, help = 0;
 
+        MOD_INC_USE_COUNT;
 	info = (tempinfo_t *) vmalloc (sizeof (tempinfo_t));
 	if (info == NULL) {
 		printk (KERN_WARNING "No memory available for data\n");
+                MOD_DEC_USE_COUNT;
 		return -ENOMEM;
 	} else {
 		file->private_data = (void *) info;
@@ -3023,99 +3938,166 @@
 		printk (KERN_WARNING "No memory available for data\n");
 		vfree (info);
 		file->private_data = NULL;
+                MOD_DEC_USE_COUNT;
 		return -ENOMEM;
 	}
+        
+        /* prevent couter 'ouverflow' on output */
 	for (shift = 0, help = dasd_global_profile.dasd_io_reqs;
-	     help > 8192;
-	     help = help >> 1, shift++) ;
-	len = sprintf (info->data, "%ld dasd I/O requests\n", dasd_global_profile.dasd_io_reqs);
-	len += sprintf (info->data + len, "__<4 ___8 __16 __32 __64 _128 _256 _512 __1k __2k __4k __8k _16k _32k _64k 128k\n");
-	len += sprintf (info->data + len, "_256 _512 __1M __2M __4M __8M _16M _32M _64M 128M 256M 512M __1G __2G __4G _>4G\n");
+	     help > 9999999; help = help >> 1, shift++) ;
+
+	len = sprintf (info->data, "%d dasd I/O requests\n",
+                       dasd_global_profile.dasd_io_reqs);
+	len += sprintf (info->data + len, "with %d sectors(512B each)\n",
+                        dasd_global_profile.dasd_io_sects);
+
+	len += sprintf (info->data + len,
+                        "   __<4    ___8    __16    __32    __64 "
+                        "   _128    _256    _512    __1k    __2k "
+                        "   __4k    __8k    _16k    _32k    _64k "
+                        "   128k\n");
+
+	len += sprintf (info->data + len,
+                        "   _256    _512    __1M    __2M    __4M "
+                        "   __8M    _16M    _32M    _64M    128M "
+                        "   256M    512M    __1G    __2G    __4G "
+                        "   _>4G\n");
+
 	len += sprintf (info->data + len, "Histogram of sizes (512B secs)\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_secs[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_secs[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
-	len += sprintf (info->data + len, "Histogram of I/O times\n");
+
+	len += sprintf (info->data + len, "Histogram of I/O times (microseconds)\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_times[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_times[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_times[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_times[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
+
 	len += sprintf (info->data + len, "Histogram of I/O times per sector\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_timps[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_timps[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_timps[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_timps[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
+
 	len += sprintf (info->data + len, "Histogram of I/O time till ssch\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time1[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time1[i] >> shift);
+	}
+	len += sprintf (info->data + len, "\n");
+	for (; i < 32; i++) {
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time1[i] >> shift);
+	}
+	len += sprintf (info->data + len, "\n");
+
+	len += sprintf (info->data + len,
+                        "Histogram of I/O time between ssch and irq\n");
+	for (i = 0; i < 16; i++) {
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time2[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time1[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time2[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
-	len += sprintf (info->data + len, "Histogram of I/O time between ssch and irq\n");
+
+	len += sprintf (info->data + len,
+                        "Histogram of I/O time between ssch and irq per sector\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time2[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time2ps[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time2[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time2ps[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
-	len += sprintf (info->data + len, "Histogram of I/O time between ssch and irq per sector\n");
+
+	len += sprintf (info->data + len,
+                        "Histogram of I/O time between irq and end\n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time2ps[i] >> shift);
+		len +=
+		    sprintf (info->data + len, "%7d ",
+			     dasd_global_profile.dasd_io_time3[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time2ps[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_time3[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
-	len += sprintf (info->data + len, "Histogram of I/O time between irq and end\n");
+
+	len += sprintf (info->data + len,
+                        "# of req in chanq at enqueuing (1..32) \n");
 	for (i = 0; i < 16; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time3[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_nr_req[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
 	for (; i < 32; i++) {
-		len += sprintf (info->data + len, "%4ld ", dasd_global_profile.dasd_io_time3[i] >> shift);
+		len += sprintf (info->data + len, "%7d ",
+                                dasd_global_profile.dasd_io_nr_req[i] >> shift);
 	}
 	len += sprintf (info->data + len, "\n");
+
 	info->len = len;
-#ifdef MODULE
-        MOD_INC_USE_COUNT;
-#endif
 	return rc;
 }
 
-static struct file_operations dasd_statistics_file_ops =
+static ssize_t
+dasd_statistics_write (struct file *file, const char *user_buf,
+		       size_t user_len, loff_t * offset)
 {
-	read:dasd_devices_read,	/* read */
+	char *buffer = vmalloc (user_len);
+
+	if (buffer == NULL)
+		return -ENOMEM;
+	if (copy_from_user (buffer, user_buf, user_len)) {
+		vfree (buffer);
+		return -EFAULT;
+	}
+	buffer[user_len] = 0;
+	printk (KERN_INFO PRINTK_HEADER "/proc/dasd/statictics: '%s'\n",
+		buffer);
+	if (strncmp (buffer, "reset", 4)) {
+		memset (&dasd_global_profile, 0, sizeof (dasd_profile_info_t));
+	}
+	return user_len;
+}
+
+static struct file_operations dasd_statistics_file_ops = {
+	read:dasd_generic_read,	/* read */
 	open:dasd_statistics_open,	/* open */
+	write:dasd_statistics_write,	/* write */
 	release:dasd_devices_close,	/* close */
 };
 
-static struct inode_operations dasd_statistics_inode_ops =
-{
-#if !(LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	default_file_ops:&dasd_statistics_file_ops	/* file ops */
-#endif				/* LINUX_IS_24 */
+static struct inode_operations dasd_statistics_inode_ops = {
 };
 
 int
 dasd_proc_init (void)
 {
 	int rc = 0;
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 	dasd_proc_root_entry = proc_mkdir ("dasd", &proc_root);
 	dasd_devices_entry = create_proc_entry ("devices",
 						S_IFREG | S_IRUGO | S_IWUSR,
@@ -3127,204 +4109,184 @@
 						   dasd_proc_root_entry);
 	dasd_statistics_entry->proc_fops = &dasd_statistics_file_ops;
 	dasd_statistics_entry->proc_iops = &dasd_statistics_inode_ops;
-#else
-	proc_register (&proc_root, &dasd_proc_root_entry);
-	dasd_devices_entry = (struct proc_dir_entry *) kmalloc (sizeof (struct proc_dir_entry), GFP_ATOMIC);
-	if (dasd_devices_entry) {
-		memset (dasd_devices_entry, 0, sizeof (struct proc_dir_entry));
-		dasd_devices_entry->name = "devices";
-		dasd_devices_entry->namelen = strlen ("devices");
-		dasd_devices_entry->low_ino = 0;
-		dasd_devices_entry->mode = (S_IFREG | S_IRUGO | S_IWUSR);
-		dasd_devices_entry->nlink = 1;
-		dasd_devices_entry->uid = 0;
-		dasd_devices_entry->gid = 0;
-		dasd_devices_entry->size = 0;
-		dasd_devices_entry->get_info = NULL;
-		dasd_devices_entry->ops = &dasd_devices_inode_ops;
-		proc_register (&dasd_proc_root_entry, dasd_devices_entry);
-	}
-	dasd_statistics_entry = (struct proc_dir_entry *) kmalloc (sizeof (struct proc_dir_entry), GFP_ATOMIC);
-	if (dasd_statistics_entry) {
-		memset (dasd_statistics_entry, 0, sizeof (struct proc_dir_entry));
-		dasd_statistics_entry->name = "statistics";
-		dasd_statistics_entry->namelen = strlen ("statistics");
-		dasd_statistics_entry->low_ino = 0;
-		dasd_statistics_entry->mode = (S_IFREG | S_IRUGO | S_IWUSR);
-		dasd_statistics_entry->nlink = 1;
-		dasd_statistics_entry->uid = 0;
-		dasd_statistics_entry->gid = 0;
-		dasd_statistics_entry->size = 0;
-		dasd_statistics_entry->get_info = NULL;
-		dasd_statistics_entry->ops = &dasd_statistics_inode_ops;
-		proc_register (&dasd_proc_root_entry, dasd_statistics_entry);
-	}
-#endif				/* LINUX_IS_24 */
 	return rc;
 }
 
 void
 dasd_proc_cleanup (void)
 {
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 	remove_proc_entry ("devices", dasd_proc_root_entry);
 	remove_proc_entry ("statistics", dasd_proc_root_entry);
 	remove_proc_entry ("dasd", &proc_root);
-#else
-	proc_unregister (&dasd_proc_root_entry, dasd_statistics_entry->low_ino);
-	kfree (dasd_statistics_entry);
-	proc_unregister (&dasd_proc_root_entry, dasd_devices_entry->low_ino);
-	kfree (dasd_devices_entry);
-	proc_unregister (&proc_root, dasd_proc_root_entry.low_ino);
-#endif				/* LINUX_IS_24 */
 }
 
+int
+dasd_request_module ( void *name ) {
+	int rc = -ERESTARTSYS;
+    	strcpy(current->comm, name);
+   	daemonize();
+   	while ( current->fs->root == NULL ) { /* wait for root-FS */
+        	DECLARE_WAIT_QUEUE_HEAD(wait);
+        	sleep_on_timeout(&wait,HZ); /* wait in steps of one second */
+	} 
+	while ( (rc=request_module(name)) != 0 ) {
+        	DECLARE_WAIT_QUEUE_HEAD(wait);
+		printk ( KERN_INFO "request_module returned %d for %s\n",
+                         rc,
+                         (char*)name);
+        	sleep_on_timeout(&wait,5* HZ); /* wait in steps of 5 seconds */
+    	}
+    	return rc;
+}
+
+
 /* SECTION: Initializing the driver */
 int __init
 dasd_init (void)
 {
 	int rc = 0;
 	int irq;
-	int j;
-	major_info_t *major_info=NULL;
+	major_info_t *major_info = NULL;
 	struct list_head *l;
-	dasd_range_t *range;
 
 	printk (KERN_INFO PRINTK_HEADER "initializing...\n");
-        dasd_debug_area = debug_register(DASD_NAME,0,2,3*sizeof(long));
-        debug_register_view(dasd_debug_area,&debug_sprintf_view);
-        debug_register_view(dasd_debug_area,&debug_hex_ascii_view);
-        
-        if ( dasd_debug_area == NULL ) {
-                goto failed;
-        }
-        DASD_DRIVER_DEBUG_EVENT(0,dasd_init,"%s","ENTRY");
-	dasd_devfs_handle = devfs_mk_dir(NULL,DASD_NAME,NULL);
-        if ( dasd_devfs_handle < 0 ) {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,"%s","no devfs");
-                goto failed;
-        }
-	list_for_each(l,&dasd_major_info[0].list) {
-		major_info=list_entry(l,major_info_t,list);
-                if ((rc = dasd_register_major (major_info)) > 0) {
-                        DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                                "major %d: success",major_info->gendisk.major);
-                        printk (KERN_INFO PRINTK_HEADER
-                                "Registered successfully to major no %u\n", major_info->gendisk.major);
+	dasd_debug_area = debug_register (DASD_NAME, 0, 2, 5 * sizeof (long));
+	debug_register_view (dasd_debug_area, &debug_sprintf_view);
+	debug_register_view (dasd_debug_area, &debug_hex_ascii_view);
+
+	init_waitqueue_head (&dasd_init_waitq);
+
+	if (dasd_debug_area == NULL) {
+		goto failed;
+	}
+	DASD_DRIVER_DEBUG_EVENT (0, dasd_init, "%s", 
+                                 "ENTRY");
+	dasd_devfs_handle = devfs_mk_dir (NULL, DASD_NAME, NULL);
+	if (dasd_devfs_handle < 0) {
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init, "%s", 
+                                         "no devfs");
+		goto failed;
+	}
+	list_for_each (l, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
+		if ((rc = dasd_register_major (major_info)) > 0) {
+			DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+						 "major %d: success",
+						 major_info->gendisk.major);
+			printk (KERN_INFO PRINTK_HEADER
+				"Registered successfully to major no %u\n",
+				major_info->gendisk.major);
 		} else {
-                        DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                                "major %d: failed",major_info->gendisk.major);
+			DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+						 "major %d: failed",
+						 major_info->gendisk.major);
 			printk (KERN_WARNING PRINTK_HEADER
-				"Couldn't register successfully to major no %d\n", major_info->gendisk.major);
+				"Couldn't register successfully to major no %d\n",
+				major_info->gendisk.major);
 			/* revert registration of major infos */
-                        goto failed;
+			goto failed;
 		}
 	}
 #ifndef MODULE
 	dasd_split_parm_string (dasd_parm_string);
 #endif				/* ! MODULE */
-	dasd_parse (dasd);
-	dasd_init_emergency_req ();
+	rc = dasd_parse (dasd);
+	if (rc) {
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init, "%s",
+                                         "invalid range found");
+		goto failed;
+	}
 
 	rc = dasd_proc_init ();
 	if (rc) {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                        "%s","no proc-FS");
-                goto failed;
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init, "%s", "no proc-FS");
+		goto failed;
 	}
 	genhd_dasd_name = dasd_device_name;
-	genhd_dasd_fillgeo = dasd_fillgeo;
 
+	if (dasd_autodetect) {	/* update device range to all devices */
+		for (irq = get_irq_first (); irq != -ENODEV;
+		     irq = get_irq_next (irq)) {
+			int devno = get_devno_by_irq (irq);
+			int index = dasd_devindex_from_devno (devno);
+			if (index == -ENODEV) {	/* not included in ranges */
+				DASD_DRIVER_DEBUG_EVENT (2, dasd_init,
+							 "add %04x to range",
+							 devno);
+				dasd_add_range (devno, devno, DASD_DEFAULT_FEATURES);
+			}
+		}
+	}
+
+	if (MACHINE_IS_VM) {
+#ifdef CONFIG_DASD_DIAG
+		rc = dasd_diag_init ();
+		if (rc == 0) {
+			DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+						 "DIAG discipline %s",
+						 "success");
+			printk (KERN_INFO PRINTK_HEADER
+				"Registered DIAG discipline successfully\n");
+		} else {
+			DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+						 "DIAG discipline %s",
+						 "failed");
+			goto failed;
+		}
+#endif /* CONFIG_DASD_DIAG */
+#if defined(CONFIG_DASD_DIAG_MODULE) && defined(CONFIG_DASD_AUTO_DIAG)
+                kernel_thread(dasd_request_module,"dasd_diag_mod",SIGCHLD);
+#endif /* CONFIG_DASD_AUTO_DIAG */
+	}
 #ifdef CONFIG_DASD_ECKD
 	rc = dasd_eckd_init ();
 	if (rc == 0) {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                        "ECKD discipline %s","success");
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+					 "ECKD discipline %s", "success");
 		printk (KERN_INFO PRINTK_HEADER
 			"Registered ECKD discipline successfully\n");
 	} else {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                        "ECKD discipline %s","failed");
-                goto failed;
-	}
-#endif				/* CONFIG_DASD_ECKD */
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+					 "ECKD discipline %s", "failed");
+		goto failed;
+	}
+#endif /* CONFIG_DASD_ECKD */
+#if defined(CONFIG_DASD_ECKD_MODULE) && defined(CONFIG_DASD_AUTO_ECKD)
+        kernel_thread(dasd_request_module,"dasd_eckd_mod",SIGCHLD);
+#endif /* CONFIG_DASD_AUTO_ECKD */
 #ifdef CONFIG_DASD_FBA
 	rc = dasd_fba_init ();
 	if (rc == 0) {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                        "FBA discipline %s","success");
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+					 "FBA discipline %s", "success");
 
 		printk (KERN_INFO PRINTK_HEADER
 			"Registered FBA discipline successfully\n");
 	} else {
-                DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                        "FBA discipline %s","failed");
-                goto failed;
-	}
-#endif				/* CONFIG_DASD_FBA */
-#ifdef CONFIG_DASD_DIAG
-	if (MACHINE_IS_VM) {
-		rc = dasd_diag_init ();
-		if (rc == 0) {
-                        DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                                "DIAG discipline %s","success");
-			printk (KERN_INFO PRINTK_HEADER
-				"Registered DIAG discipline successfully\n");
-		} else {
-                        DASD_DRIVER_DEBUG_EVENT(1,dasd_init,
-                                                "DIAG discipline %s","failed");
-                        goto failed;
-		}
-	}
-#endif				/* CONFIG_DASD_DIAG */
-	rc = 0;
-	if (dasd_autodetect) { /* update device range to all devices */
-		for (irq = get_irq_first (); irq != -ENODEV; 
-                     irq = get_irq_next (irq)) {
-			int devno = get_devno_by_irq (irq);
-			int index = dasd_devindex_from_devno (devno);
-			if (index == -ENODEV) {		/* not included in ranges */
-                                DASD_DRIVER_DEBUG_EVENT(2,dasd_init,
-                                                        "add %04X to range",
-                                                        devno);
-				dasd_add_range (devno, 0);
-                        }
+		DASD_DRIVER_DEBUG_EVENT (1, dasd_init,
+					 "FBA discipline %s", "failed");
+		goto failed;
+	}
+#endif /* CONFIG_DASD_FBA */
+#if defined(CONFIG_DASD_FBA_MODULE) && defined(CONFIG_DASD_AUTO_FBA)
+        kernel_thread(dasd_request_module,"dasd_fba_mod",SIGCHLD);
+#endif /* CONFIG_DASD_AUTO_FBA */
+        {
+                char **disc=dasd_disciplines;
+                while (*disc) {
+                        kernel_thread(dasd_request_module,*disc,SIGCHLD);
+                        disc++;
                 }
         }
-	for (range = dasd_range_head; range; range = range->next) {
-		for (j = range->from; j <= range->to; j++) {
-			irq = get_irq_by_devno (j);
-                        if (irq >= 0)
-                                DASD_DRIVER_DEBUG_EVENT(2,dasd_init,
-                                                        "1st step in initialization irq 0x%x",irq);
-                        dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ONLINE,
-                                               NULL, 0);
-		}
-	}
-	printk (KERN_INFO PRINTK_HEADER "waiting for responses...\n");
-	{
-		static wait_queue_head_t wait_queue;
-		init_waitqueue_head (&wait_queue);
-		interruptible_sleep_on_timeout (&wait_queue,
-						(5 * HZ) );
-	}
-	for (range = dasd_range_head; range; range = range->next) {
-		for (j = range->from; j <= range->to; j++) {
-			irq = get_irq_by_devno (j);
-			if (irq >= 0) {
-                                DASD_DRIVER_DEBUG_EVENT(2,dasd_init,
-                                                        "2nd step in initialization irq 0x%x",irq);
-				dasd_set_device_level (irq, DASD_DEVICE_LEVEL_ONLINE,
-						       NULL, 0);
-			}
-		}
-	}
-        goto out;
- failed:
-	printk (KERN_INFO PRINTK_HEADER "initialization not performed due to errors\n");
-        cleanup_dasd();
- out:
-        DASD_DRIVER_DEBUG_EVENT(0,dasd_init,"%s","LEAVE");
+
+	rc = 0;
+	goto out;
+      failed:
+	printk (KERN_INFO PRINTK_HEADER
+		"initialization not performed due to errors\n");
+	cleanup_dasd ();
+      out:
+	DASD_DRIVER_DEBUG_EVENT (0, dasd_init, "%s", "LEAVE");
 	printk (KERN_INFO PRINTK_HEADER "initialization finished\n");
 	return rc;
 }
@@ -3332,95 +4294,78 @@
 static void
 cleanup_dasd (void)
 {
-	int i,j,rc;
-	int irq;
-	major_info_t *major_info=NULL;
-	struct list_head *l;
-	dasd_range_t *range, *next;
+	int i,rc=0;
+	major_info_t *major_info = NULL;
+	struct list_head *l,*n;
+	dasd_range_t *range;
 
 	printk (KERN_INFO PRINTK_HEADER "shutting down\n");
         DASD_DRIVER_DEBUG_EVENT(0,"cleanup_dasd","%s","ENTRY");
-	for (range = dasd_range_head; range; range = range->next) {
-		for (j = range->from; j <= range->to; j++) {
-			irq = get_irq_by_devno (j);
-			if (irq >= 0) {
-                                DASD_DRIVER_DEBUG_EVENT(2,"cleanup_dasd",
-                                                        "shutdown irq 0x%x",irq);
-				dasd_set_device_level (irq, DASD_DEVICE_LEVEL_UNKNOWN,
-						       NULL, 0);
-			}
-		}
-	}
+	dasd_disable_ranges (&dasd_range_head, NULL, 1, 1);
+        if (MACHINE_IS_VM) {
 #ifdef CONFIG_DASD_DIAG
-	if (MACHINE_IS_VM) {
-		dasd_diag_cleanup ();
-                DASD_DRIVER_DEBUG_EVENT(1,"cleanup_dasd",
-                                        "DIAG discipline %s","success");
+                dasd_diag_cleanup ();
+                DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
+                                         "DIAG discipline %s", "success");
                 printk (KERN_INFO PRINTK_HEADER
-                        "De-Registered DIAG discipline successfully\n");
+			"De-Registered DIAG discipline successfully\n");
+#endif /* CONFIG_DASD_ECKD_BUILTIN */
 	}
-#endif				/* CONFIG_DASD_DIAG */
 #ifdef CONFIG_DASD_FBA
 	dasd_fba_cleanup ();
-        DASD_DRIVER_DEBUG_EVENT(1,"cleanup_dasd",
-                                "FBA discipline %s","success");
-        printk (KERN_INFO PRINTK_HEADER
-                "De-Registered FBA discipline successfully\n");
-#endif				/* CONFIG_DASD_FBA */
+	DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
+				 "FBA discipline %s", "success");
+	printk (KERN_INFO PRINTK_HEADER
+		"De-Registered FBA discipline successfully\n");
+#endif /* CONFIG_DASD_ECKD_BUILTIN */
 #ifdef CONFIG_DASD_ECKD
 	dasd_eckd_cleanup ();
-        DASD_DRIVER_DEBUG_EVENT(1,"cleanup_dasd",
-                                "ECKD discipline %s","success");
-        printk (KERN_INFO PRINTK_HEADER
-                "De-Registered ECKD discipline successfully\n");
-#endif				/* CONFIG_DASD_ECKD */
+	DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
+				 "ECKD discipline %s", "success");
+	printk (KERN_INFO PRINTK_HEADER
+		"De-Registered ECKD discipline successfully\n");
+#endif /* CONFIG_DASD_ECKD_BUILTIN */
         
 	dasd_proc_cleanup ();
-	dasd_cleanup_emergency_req ();
-
-	list_for_each(l,&dasd_major_info[0].list) {
-		major_info=list_entry(l,major_info_t,list);	
+        
+	list_for_each_safe (l, n, &dasd_major_info[0].list) {
+		major_info = list_entry (l, major_info_t, list);
 		for (i = 0; i < DASD_PER_MAJOR; i++) {
 			kfree (major_info->dasd_device[i]);
 		}
-		if ((major_info -> flags & DASD_MAJOR_INFO_REGISTERED) &&
+		if ((major_info->flags & DASD_MAJOR_INFO_REGISTERED) &&
 		    (rc = dasd_unregister_major (major_info)) == 0) {
-                        DASD_DRIVER_DEBUG_EVENT(1,"cleanup_dasd",
-                                                "major %d: success",major_info->gendisk.major);
+			DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
+						 "major %d: success",
+						 major_info->gendisk.major);
 			printk (KERN_INFO PRINTK_HEADER
-				"Unregistered successfully from major no %u\n", major_info->gendisk.major);
+				"Unregistered successfully from major no %u\n",
+				major_info->gendisk.major);
 		} else {
-                        DASD_DRIVER_DEBUG_EVENT(1,"cleanup_dasd",
-                                                "major %d: failed",major_info->gendisk.major);
+			DASD_DRIVER_DEBUG_EVENT (1, "cleanup_dasd",
+						 "major %d: failed",
+						 major_info->gendisk.major);
 			printk (KERN_WARNING PRINTK_HEADER
-				"Couldn't unregister successfully from major no %d rc = %d\n", major_info->gendisk.major, rc);
-		}
-	}
-
+				"Couldn't unregister successfully from major no %d rc = %d\n",
+				major_info->gendisk.major, rc);
+  		}
+  	}
+	list_for_each_safe (l, n, &dasd_range_head.list) {
+		range = list_entry (l, dasd_range_t, list);
+                dasd_remove_range(range);
+        }
 
-	range = dasd_range_head;
-	while (range) {
-		next = range->next;
-                dasd_remove_range (range);
-		if (next == NULL)
-			break;
-		else
-			range = next;
-	}
-	dasd_range_head = NULL;
-        
 #ifndef MODULE
-        for( j = 0; j < 256; j++ )
-                if ( dasd[j] ) {
-                        kfree(dasd[j]);
-                        dasd[j] = NULL;
+        for( i = 0; i < 256; i++ )
+                if ( dasd[i] ) {
+                        kfree(dasd[i]);
+                        dasd[i] = NULL;
                 }
 #endif /* MODULE */
         if (dasd_devfs_handle) 
                 devfs_unregister(dasd_devfs_handle);
         if (dasd_debug_area != NULL )
                 debug_unregister(dasd_debug_area);
-
 	printk (KERN_INFO PRINTK_HEADER "shutdown completed\n");
         DASD_DRIVER_DEBUG_EVENT(0,"cleanup_dasd","%s","LEAVE");
 }
@@ -3430,7 +4375,7 @@
 init_module (void)
 {
 	int rc = 0;
-	return dasd_init ();
+	rc = dasd_init ();
 	return rc;
 }
 
@@ -3449,7 +4394,7 @@
  * of the file.
  * ---------------------------------------------------------------------------
  * Local variables:
- * c-indent-level: 4 
+ * c-indent-level: 4
  * c-brace-imaginary-offset: 0
  * c-brace-offset: -4
  * c-argdecl-indent: 4
diff -urN linux/drivers/s390/block/dasd_3370_erp.c linux-2.4.7/drivers/s390/block/dasd_3370_erp.c
--- linux/drivers/s390/block/dasd_3370_erp.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/block/dasd_3370_erp.c	Mon Dec 17 13:41:19 2001
@@ -6,8 +6,9 @@
  */
 
 #include <asm/ccwcache.h>
-#include <asm/dasd.h>
 
+#include "dasd_int.h"
+#include "dasd_3370_erp.h"
 #ifdef PRINTK_HEADER
 #undef PRINTK_HEADER
 #define PRINTK_HEADER "dasd_erp(3370)"
@@ -29,7 +30,7 @@
  *   dasd_era_fatal     for all fatal (unrecoverable errors)
  *   dasd_era_recover   for all others.
  */
-dasd_era_t
+dasd_era_t 
 dasd_3370_erp_examine (ccw_req_t * cqr, devstat_t * stat)
 {
 	char *sense = stat->ii.sense.data;
@@ -37,7 +38,7 @@
 	/* check for successful execution first */
 	if (stat->cstat == 0x00 &&
 	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
-		return dasd_era_none;
+		    return dasd_era_none;
 	if (sense[0] & 0x80) {	/* CMD reject */
 		return dasd_era_fatal;
 	}
diff -urN linux/drivers/s390/block/dasd_3370_erp.h linux-2.4.7/drivers/s390/block/dasd_3370_erp.h
--- linux/drivers/s390/block/dasd_3370_erp.h	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/drivers/s390/block/dasd_3370_erp.h	Mon Dec 17 13:41:19 2001
@@ -0,0 +1,15 @@
+/* 
+ * File...........: linux/drivers/s390/block/dasd_3370_erp.h
+ * Author(s)......: Horst Hummel <Horst Hummel@de.ibm.com>
+ * Bugreports.to..: <Linux390@de.ibm.com>
+ * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000
+ *
+ * History of changes (starts July 2000)
+ */
+
+#ifndef DASD_3370_ERP_H
+#define DASD_3370_ERP_H
+
+dasd_era_t dasd_3370_erp_examine (ccw_req_t *, devstat_t *);
+
+#endif				/* DASD_3990_ERP_H */
diff -urN linux/drivers/s390/block/dasd_3990_erp.c linux-2.4.7/drivers/s390/block/dasd_3990_erp.c
--- linux/drivers/s390/block/dasd_3990_erp.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_3990_erp.c	Mon Dec 17 13:41:49 2001
@@ -4,13 +4,17 @@
  *                  Holger Smolinski <Holger.Smolinski@de.ibm.com>
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000, 2001
+ *
+ * History of changes:
+ * 05/14/01 fixed PL030160GTO (BUG() in erp_action_5)
  */
 
 #include <asm/ccwcache.h>
 #include <asm/idals.h>
-#include <asm/dasd.h>
 #include <asm/s390io.h>
 #include <linux/timer.h>
+
+#include "dasd_int.h"
 #include "dasd_eckd.h"
 #include "dasd_3990_erp.h"
 
@@ -24,7 +28,6 @@
  * SECTION DEBUG ROUTINES
  ***************************************************************************** 
  */
-#ifdef ERP_DEBUG
 void
 log_erp_chain (ccw_req_t *cqr,
                int       caller,
@@ -34,104 +37,100 @@
         ccw_req_t     *loop_cqr = cqr;
 	dasd_device_t *device   = cqr->device;
 
-        char    *page = (char *)get_free_page(GFP_ATOMIC);
-        int     len = 0;
         int     i;
         char    *nl, 
                 *end_cqr,
                 *begin, 
                 *end;
+        
+        /* dump sense data */
+        if (device->discipline            && 
+            device->discipline->dump_sense  ) {
 
-        if ( page == NULL ) {
-                printk (KERN_WARNING PRINTK_HEADER
-                        "No memory to dump ERP chain\n");
-                return;
-        }        
-                        
+                device->discipline->dump_sense (device, 
+                                                cqr);
+        }
+
+        /* log the channel program */
         while (loop_cqr != NULL) {
                 
-                memset (page, 0, 4096);
-                len = 0;
-
-                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                 "device %04X on irq %d: (%s) ERP chain report for req: %p\n",
-                                 device->devinfo.devno,
-                                 device->devinfo.irq,
-                                 caller == 0 ? "EXAMINE" : "ACTION",
-                                 loop_cqr);
+                DASD_MESSAGE (KERN_ERR, device, 
+                              "(%s) ERP chain report for req: %p\n",
+                              caller == 0 ? "EXAMINE" : "ACTION",
+                              loop_cqr);
                 
                 nl      = (char *) loop_cqr;
                 end_cqr = nl + sizeof (ccw_req_t); 
-
+                
                 while (nl < end_cqr) {
-
-                        len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                         "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
-                                         "%02x%02x%02x%02x %02x%02x%02x%02x\n",
-                                         nl,
-                                         nl[0], nl[1], nl[2], nl[3],
-                                         nl[4], nl[5], nl[6], nl[7],
-                                         nl[8], nl[9], nl[10], nl[11],
-                                         nl[12], nl[13], nl[14], nl[15]);
+                        
+                        DASD_MESSAGE (KERN_ERR, device, 
+                                      "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
+                                      "%02x%02x%02x%02x %02x%02x%02x%02x\n",
+                                      nl,
+                                      nl[0], nl[1], nl[2], nl[3],
+                                      nl[4], nl[5], nl[6], nl[7],
+                                      nl[8], nl[9], nl[10], nl[11],
+                                      nl[12], nl[13], nl[14], nl[15]);
                         nl +=16;
                 }        
                 
                 nl  = (char *) loop_cqr->cpaddr;
+                
+                if (loop_cqr->cplength > 40) { /* log only parts of the CP */
 
-                if (loop_cqr->cplength > 40 ) { /* log only parts of the CP */
-
-                        len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                         "Start of channel program:\n");
-
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "Start of channel program:\n");
+                        
                         for (i = 0; i < 20; i += 2) { 
-
-                                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                 "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
-                                                 "%02x%02x%02x%02x %02x%02x%02x%02x\n",
-                                                 nl,
-                                                 nl[0], nl[1], nl[2], nl[3],
-                                                 nl[4], nl[5], nl[6], nl[7],
-                                                 nl[8], nl[9], nl[10], nl[11],
-                                                 nl[12], nl[13], nl[14], nl[15]);
+                                
+                                DASD_MESSAGE (KERN_ERR, device, 
+                                              "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
+                                              "%02x%02x%02x%02x %02x%02x%02x%02x\n",
+                                              nl,
+                                              nl[0], nl[1], nl[2], nl[3],
+                                              nl[4], nl[5], nl[6], nl[7],
+                                              nl[8], nl[9], nl[10], nl[11],
+                                              nl[12], nl[13], nl[14], nl[15]);
                                 
                                 nl += 16;
                         }
                         
-                        len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                         "End of channel program:\n");
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "End of channel program:\n");
                         
                         nl  = (char *) loop_cqr->cpaddr;
                         nl  += ((loop_cqr->cplength - 10) * 8);
                         
                         for (i = 0; i < 20; i += 2) { 
                                 
-                                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                 "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
-                                                 "%02x%02x%02x%02x %02x%02x%02x%02x\n",
-                                                 nl,
-                                                 nl[0], nl[1], nl[2], nl[3],
-                                                 nl[4], nl[5], nl[6], nl[7],
-                                                 nl[8], nl[9], nl[10], nl[11],
-                                                 nl[12], nl[13], nl[14], nl[15]);
+                                DASD_MESSAGE (KERN_ERR, device, 
+                                              "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
+                                              "%02x%02x%02x%02x %02x%02x%02x%02x\n",
+                                              nl,
+                                              nl[0], nl[1], nl[2], nl[3],
+                                              nl[4], nl[5], nl[6], nl[7],
+                                              nl[8], nl[9], nl[10], nl[11],
+                                              nl[12], nl[13], nl[14], nl[15]);
                                 
                                 nl += 16;
                         }
                         
                 } else { /* log the whole CP */
                         
-                        len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                         "Channel program (complete):\n");
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "Channel program (complete):\n");
                         
                         for (i = 0; i < (loop_cqr->cplength + 4); i += 2) { 
                                 
-                                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                 "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
-                                                 "%02x%02x%02x%02x %02x%02x%02x%02x\n",
-                                                 nl,
-                                                 nl[0], nl[1], nl[2], nl[3],
-                                                 nl[4], nl[5], nl[6], nl[7],
-                                                 nl[8], nl[9], nl[10], nl[11],
-                                                 nl[12], nl[13], nl[14], nl[15]);
+                                DASD_MESSAGE (KERN_ERR, device, 
+                                              "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
+                                              "%02x%02x%02x%02x %02x%02x%02x%02x\n",
+                                              nl,
+                                              nl[0], nl[1], nl[2], nl[3],
+                                              nl[4], nl[5], nl[6], nl[7],
+                                              nl[8], nl[9], nl[10], nl[11],
+                                              nl[12], nl[13], nl[14], nl[15]);
                                 
                                 nl += 16;
                         }
@@ -140,51 +139,47 @@
                 /* log bytes arround failed CCW if not already done */ 
                 begin = (char *) loop_cqr->cpaddr;
                 end   = begin + ((loop_cqr->cplength+4) * 8);
-                nl = (void *)cpa;
+                nl = (void *)(long)cpa;
 
                 if (loop_cqr == cqr) {  /* log only once */
  
-                        if ((loop_cqr->cplength > 40) ||     /* not whole CP was logged or */
-                            ((nl < begin ) &&                /* CCW is outside logged CP   */
-                             (nl > end   )          )   ) {
+                        /* if not whole CP logged OR CCW outside logged CP */
+                        if ((loop_cqr->cplength > 40) ||   
+                            ((nl < begin        ) &&
+                             (nl > end          )   )   ) {
                         
-                                nl -= 10*8;     /* start some bytes before */          
+                                nl -= 10*8;     /* start some bytes before */
                                 
-                                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                 "Failed CCW (%p) (area):\n",
-                                                 (void *)cpa);
+                                DASD_MESSAGE (KERN_ERR, device, 
+                                                "Failed CCW (%p) (area):\n",
+                                                (void *)(long)cpa);
                                 
                                 for (i = 0; i < 20; i += 2) { 
                                         
-                                        len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                         "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
-                                                         "%02x%02x%02x%02x %02x%02x%02x%02x\n",
-                                                         nl,
-                                                         nl[0], nl[1], nl[2], nl[3],
-                                                         nl[4], nl[5], nl[6], nl[7],
-                                                         nl[8], nl[9], nl[10], nl[11],
-                                                         nl[12], nl[13], nl[14], nl[15]);
+                                        DASD_MESSAGE (KERN_ERR, device, 
+                                                      "%p: %02x%02x%02x%02x %02x%02x%02x%02x "
+                                                      "%02x%02x%02x%02x %02x%02x%02x%02x\n",
+                                                      nl,
+                                                      nl[0], nl[1], nl[2], nl[3],
+                                                      nl[4], nl[5], nl[6], nl[7],
+                                                      nl[8], nl[9], nl[10], nl[11],
+                                                      nl[12], nl[13], nl[14], nl[15]);
                                         
                                         nl += 16;
                                 }
                                 
                         } else {
                                 
-                                len += sprintf ( page + len, KERN_WARNING PRINTK_HEADER 
-                                                 "Failed CCW (%p) already logged\n",
-                                                 (void *)cpa);
+                                DASD_MESSAGE (KERN_ERR, device, 
+                                              "Failed CCW (%p) already logged\n",
+                                              (void *)(long)cpa);
                         }
                 }
-
-                printk ("%s", page);
+                
                 loop_cqr = loop_cqr->refers;
         }
         
-        free_page ((unsigned long) page);
-
 } /* end log_erp_chain */
-#endif /* ERP_DEBUG */
-
 
 /*
  ***************************************************************************** 
@@ -211,32 +206,46 @@
  *   dasd_era_recover   for all others.
  */
 dasd_era_t
-dasd_3990_erp_examine_24 (char *sense)
+dasd_3990_erp_examine_24 (ccw_req_t *cqr,
+                          char      *sense)
 {
 
-	/* check for 'Command Recejct' which is always a fatal error  */
-	if (sense[0] & SNS0_CMD_REJECT) {
-		if (sense[2] & SNS2_ENV_DATA_PRESENT) {
-			return dasd_era_recover;
-		} else {
-			return dasd_era_fatal;
-		}
+        dasd_device_t *device = cqr->device;
+        
+	/* check for 'Command Reject' */
+	if ((  sense[0] & SNS0_CMD_REJECT       ) &&
+	    (!(sense[2] & SNS2_ENV_DATA_PRESENT))   ) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "EXAMINE 24: Command Reject detected - "
+                              "fatal error");
+
+                return dasd_era_fatal;
 	}
-	/* check for 'Invalid Track Format'                           */
-	if (sense[1] & SNS1_INV_TRACK_FORMAT) {
-		if (sense[2] & SNS2_ENV_DATA_PRESENT) {
-			return dasd_era_recover;
-		} else {
-			return dasd_era_fatal;
-		}
+
+	/* check for 'Invalid Track Format' */
+	if ((  sense[1] & SNS1_INV_TRACK_FORMAT ) &&
+            (!(sense[2] & SNS2_ENV_DATA_PRESENT))   ) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "EXAMINE 24: Invalid Track Format detected "
+                              "- fatal error");
+
+                return dasd_era_fatal;
 	}
-	/* check for 'No Record Found'                                */
+
+	/* check for 'No Record Found' */
 	if (sense[1] & SNS1_NO_REC_FOUND) {
-            return dasd_era_fatal;
+                
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "EXAMINE 24: No Record Found detected "
+                              "- fatal error");
+
+                return dasd_era_fatal;
 	}
-	/* return recoverable for all others                          */
-	return dasd_era_recover;
 
+	/* return recoverable for all others */
+  	return dasd_era_recover;
 } /* END dasd_3990_erp_examine_24 */
 
 /*
@@ -253,19 +262,27 @@
  *   dasd_era_recover   for recoverable others.
  */
 dasd_era_t
-dasd_3990_erp_examine_32 (char *sense)
+dasd_3990_erp_examine_32 (ccw_req_t *cqr,
+                          char      *sense)
 {
 
+        dasd_device_t *device = cqr->device;
+
 	switch (sense[25]) {
 	case 0x00:
 		return dasd_era_none;
+
 	case 0x01:
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "EXAMINE 32: fatal error");
 		return dasd_era_fatal;
+
 	default:
+
 		return dasd_era_recover;
 	}
 
-}				/* end dasd_3990_erp_examine_32 */
+} /* end dasd_3990_erp_examine_32 */
 
 /*
  * DASD_3990_ERP_EXAMINE 
@@ -292,31 +309,30 @@
         dasd_era_t era    = dasd_era_recover;
 
 	/* check for successful execution first */
-	if (stat->cstat == 0x00 &&
-	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
+	if (stat->cstat == 0x00                                 &&
+	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END)  )
 		return dasd_era_none;
 
 	/* distinguish between 24 and 32 byte sense data */
 	if (sense[27] & DASD_SENSE_BIT_0) {
 
-		/* examine the 24 byte sense data */
-		era = dasd_3990_erp_examine_24 (sense);
+		era = dasd_3990_erp_examine_24 (cqr,
+                                                sense);
 
 	} else {
 
-		/* examine the 32 byte sense data */
-		era = dasd_3990_erp_examine_32 (sense);
+		era = dasd_3990_erp_examine_32 (cqr,
+                                                sense);
 
-	} /* end distinguish between 24 and 32 byte sense data */
+	} 
 
-#ifdef ERP_DEBUG
+        /* log the erp chain if fatal error occurred */
         if (era == dasd_era_fatal) {
 
                 log_erp_chain (cqr, 
                                0, 
                                stat->cpa);
         }
-#endif /* ERP_DEBUG */
         
         return era;
 
@@ -334,6 +350,37 @@
  */
 
 /*
+ * DASD_3990_ERP_CLEANUP 
+ *
+ * DESCRIPTION
+ *   Removes the already build but not neccessary ERP request and sets
+ *   the status of the original cqr / erp to the given (final) status
+ *
+ *  PARAMETER
+ *   erp                request to be blocked
+ *   final_status       either CQR_STATUS_DONE or CQR_STATUS_FAILED 
+ *
+ * RETURN VALUES
+ *   cqr                original cqr               
+ */
+ccw_req_t *
+dasd_3990_erp_cleanup (ccw_req_t *erp,
+                       char      final_status)
+{
+
+        ccw_req_t *cqr = erp->refers;
+        
+        dasd_free_request (erp, erp->device);
+
+        check_then_set (&cqr->status,
+                        CQR_STATUS_ERROR,
+                        final_status);
+
+        return cqr;
+
+} /* end dasd_3990_erp_cleanup */ 
+
+/*
  * DASD_3990_ERP_BLOCK_QUEUE 
  *
  * DESCRIPTION
@@ -365,8 +412,9 @@
 
         /* restart queue after some time */
         device->timer.function = dasd_3990_erp_restart_queue; 
-        device->timer.data = (unsigned long) erp;
-        device->timer.expires = jiffies + (expires * HZ);
+        device->timer.data     = (unsigned long) erp;
+        device->timer.expires  = jiffies + (expires * HZ);
+
         add_timer(&device->timer); 
 
 } /* end dasd_3990_erp_block_queue */ 
@@ -390,6 +438,7 @@
 void
 dasd_3990_erp_restart_queue (unsigned long erp)
 {
+
         ccw_req_t     *cqr    = (void *) erp;
 	dasd_device_t *device = cqr->device;
 	unsigned long flags;
@@ -399,10 +448,9 @@
                                    flags);
 
         /* 'restart' the device queue */
-        if (cqr->status == CQR_STATUS_PENDING){
+        if (cqr->status == CQR_STATUS_PENDING) {
                 
-                DASD_MESSAGE (KERN_INFO, device,
-                              "%s",
+                DASD_MESSAGE (KERN_INFO, device, "%s",
                               "request queue restarted by MIH");
 
                 check_then_set (&cqr->status,
@@ -414,11 +462,10 @@
         s390irq_spin_unlock_irqrestore (device->devinfo.irq, 
                                         flags);
 
-        dasd_schedule_bh(device);
+        dasd_schedule_bh (device);
 
 } /* end dasd_3990_erp_restart_queue */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_INT_REQ 
  *
@@ -434,27 +481,31 @@
 ccw_req_t *
 dasd_3990_erp_int_req (ccw_req_t *erp)
 {
+
 	dasd_device_t *device = erp->device;
 
         /* first time set initial retry counter and erp_function */
+        /* and retry once without blocking queue                 */
+        /* (this enables easier enqueing of the cqr)             */
         if (erp->function != dasd_3990_erp_int_req) {
+
                 erp->retries  = 256;
                 erp->function = dasd_3990_erp_int_req;
-        }
 
-        /* issue a message and wait for 'device ready' interrupt */
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "is offline or not installed - "
-                      "INTERVENTION REQUIRED!!\n");
+        } else {
 
-        dasd_3990_erp_block_queue (erp,
-                                   60);
+                /* issue a message and wait for 'device ready' interrupt */
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "is offline or not installed - "
+                              "INTERVENTION REQUIRED!!");
+                
+                dasd_3990_erp_block_queue (erp,
+                                           60);
+        }
 
 	return erp;
 
 } /* end dasd_3990_erp_int_req */
-#endif /* ERP_FULL_ERP */
 
 /*
  * DASD_3990_ERP_ALTERNATE_PATH 
@@ -478,22 +529,17 @@
 	dasd_device_t *device = erp->device;
         int irq = device->devinfo.irq;
 
-	/* dissable current channel path - this causes the use of an other 
-	   channel path if there is one.. */
-
-	DASD_MESSAGE (KERN_WARNING, device,
-                      "disable lpu %x",
-                      erp->dstat->lpum);
-
         /* try alternate valid path */
         erp->lpm     &= ~(erp->dstat->lpum);
         erp->options |= DOIO_VALID_LPM;		/* use LPM for DO_IO */
 
 	if ((erp->lpm & ioinfo[irq]->opm) != 0x00) {
 
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "try alternate lpm %x",
-                              erp->lpm);
+		DASD_MESSAGE (KERN_DEBUG, device,
+                              "try alternate lpm=%x (lpum=%x / opm=%x)",
+                              erp->lpm,
+                              erp->dstat->lpum,
+                              ioinfo[irq]->opm);
 
 		/* reset status to queued to handle the request again... */
 		check_then_set (&erp->status,
@@ -504,10 +550,11 @@
                 
 	} else {
          
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",      
-                              "No alternate channel path left -> "
-                              "permanent error");
+                DASD_MESSAGE (KERN_ERR, device,
+                              "No alternate channel path left (lpum=%x / "
+                              "opm=%x) -> permanent error",
+                              erp->dstat->lpum,
+                              ioinfo[irq]->opm);
                 
                 /* post request with permanent error */
                 check_then_set (&erp->status,
@@ -518,7 +565,6 @@
         
 } /* end dasd_3990_erp_alternate_path */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_DCTL
  *
@@ -527,7 +573,7 @@
  *   Inhibit Write subcommand (0x20) and the given modifier.
  *
  *  PARAMETER
- *   erp                pointer to the current ERP
+ *   erp                pointer to the current (failed) ERP
  *   modifier           subcommand modifier
  *   
  * RETURN VALUES
@@ -538,14 +584,25 @@
 dasd_3990_erp_DCTL (ccw_req_t *erp,
                     char      modifier)
 {
-	DCTL_data_t *DCTL_data;
-        ccw1_t      *ccw;
-        ccw_req_t   *dctl_cqr = dasd_alloc_request ((char *) &erp->magic,
-                                                    1,
-                                                    sizeof(DCTL_data_t));
+
+	dasd_device_t *device = erp->device;
+	DCTL_data_t   *DCTL_data;
+        ccw1_t        *ccw;
+        ccw_req_t     *dctl_cqr = dasd_alloc_request ((char *) &erp->magic,
+                                                      1,
+                                                      sizeof(DCTL_data_t),
+                                                      erp->device);
         
-	if (dctl_cqr == NULL) {
-		BUG();
+	if (!dctl_cqr) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate DCTL-CQR");
+                
+                check_then_set (&erp->status,
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_FAILED);
+
+		return erp;
         }
 
 	DCTL_data = dctl_cqr->data;
@@ -557,15 +614,24 @@
 	memset (ccw, 0, sizeof (ccw1_t));
         ccw->cmd_code = CCW_CMD_DCTL;
         ccw->count    = 4;
-        set_normalized_cda(ccw, __pa (DCTL_data));
+        if (dasd_set_normalized_cda(ccw, 
+                                    __pa (DCTL_data), dctl_cqr, erp->device)) {
+                dasd_free_request (dctl_cqr, erp->device);
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate DCTL-CQR");
 
+                check_then_set (&erp->status,
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_FAILED);
+		return erp;
+        }
         dctl_cqr->function = dasd_3990_erp_DCTL;
-        dctl_cqr->refers = erp;
-        dctl_cqr->device = erp->device;
-        dctl_cqr->magic = erp->magic;
-        dctl_cqr->lpm = LPM_ANYPATH;
-        dctl_cqr->expires = 5 * TOD_MIN;
-        dctl_cqr->retries = 2;
+        dctl_cqr->refers   = erp;
+        dctl_cqr->device   = erp->device;
+        dctl_cqr->magic    = erp->magic;
+        dctl_cqr->lpm      = LPM_ANYPATH;
+        dctl_cqr->expires  = 5 * TOD_MIN;
+        dctl_cqr->retries  = 2;
 	asm volatile ("STCK %0":"=m" (dctl_cqr->buildclk));
 
         dctl_cqr->status = CQR_STATUS_FILLED;
@@ -573,7 +639,6 @@
 	return dctl_cqr;
 
 } /* end dasd_3990_erp_DCTL */
-#endif /* ERP_FULL_ERP */  
 
 /*
  * DASD_3990_ERP_ACTION_1 
@@ -595,6 +660,7 @@
 ccw_req_t *
 dasd_3990_erp_action_1 (ccw_req_t *erp)
 {
+
         erp->function = dasd_3990_erp_action_1;
 
         dasd_3990_erp_alternate_path (erp);
@@ -624,21 +690,22 @@
 dasd_3990_erp_action_4 (ccw_req_t *erp,
 			char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
         /* first time set initial retry counter and erp_function    */
         /* and retry once without waiting for state change pending  */
         /* interrupt (this enables easier enqueing of the cqr)      */
         if (erp->function != dasd_3990_erp_action_4) {
-                erp->retries  = 255; 
+
+                erp->retries  = 256; 
                 erp->function = dasd_3990_erp_action_4;
 
         } else {
 
                 if (sense[25] & 0x1D) {	/* state change pending */
                         
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
+                        DASD_MESSAGE (KERN_INFO, device, "%s",
                                       "waiting for state change pending "
                                       "int");
                         
@@ -646,11 +713,8 @@
                                                    30);
                         
                 } else {
+
                         /* no state change pending - retry */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "no state change pending - retry");
-                        
                         check_then_set (&erp->status,
                                         CQR_STATUS_ERROR,
                                         CQR_STATUS_QUEUED);
@@ -667,12 +731,12 @@
  ***************************************************************************** 
  */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_ACTION_5 
  *
  * DESCRIPTION
  *   Setup ERP to do the ERP action 5 (see Reference manual).
+ *   NOTE: Further handling is done in xxx_further_erp after the retries.
  *
  *  PARAMETER
  *   erp                pointer to the current ERP
@@ -684,16 +748,11 @@
 ccw_req_t *
 dasd_3990_erp_action_5 (ccw_req_t *erp)
 {
+
         /* first of all retry */
         erp->retries = 10;
         erp->function = dasd_3990_erp_action_5;
 
-        check_then_set (&erp->status,
-                        CQR_STATUS_ERROR,
-                        CQR_STATUS_QUEUED);
-
-        /* further handling is done in xxx_further_erp after the retries */
-
         return erp;
 
 } /* end dasd_3990_erp_action_5 */
@@ -702,7 +761,7 @@
  * DASD_3990_HANDLE_ENV_DATA
  *
  * DESCRIPTION
- *   Handles 24 byte 'Enviromental data present'.
+ *   Handles 24 byte 'Environmental data present'.
  *   Does a analysis of the sense data (message Format)
  *   and prints the error messages.
  *
@@ -713,15 +772,17 @@
  *   void
  */
 void
-dasd_3990_handle_env_data (char *sense)
+dasd_3990_handle_env_data (ccw_req_t *erp,
+                           char      *sense)
 {
-	/* check bytes 7-23 for further information */
 
-	char msg_format = (sense[7] & 0xF0);
-	char msg_no = (sense[7] & 0x0F);
+        dasd_device_t *device = erp->device;
+	char msg_format       = (sense[7] & 0xF0);
+	char msg_no           = (sense[7] & 0x0F);
+        
 
 	switch (msg_format) {
-	case 0x00:		/* Format 0 - Program or System Checks */
+	case 0x00:	/* Format 0 - Program or System Checks */
 
 		if (sense[1] & 0x10) {	/* check message to operator bit */
 
@@ -729,579 +790,595 @@
 			case 0x00:	/* No Message */
 				break;
 			case 0x01:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Invalid Command\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Invalid Command");
 				break;
 			case 0x02:
-				printk (KERN_WARNING PRINTK_HEADER
-				     "FORMAT 0 - Invalid Command Sequence\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Invalid Command "
+                                              "Sequence");
 				break;
 			case 0x03:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - CCW Count less than "
-					"required\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - CCW Count less than "
+                                              "required");
 				break;
 			case 0x04:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Invalid Parameter\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Invalid Parameter");
 				break;
 			case 0x05:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Diagnostic of Sepecial "
-					"Command Violates File Mask\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Diagnostic of Sepecial"
+                                              " Command Violates File Mask");
 				break;
 			case 0x07:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Channel Returned with "
-					"Incorrect retry CCW\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Channel Returned with "
+                                              "Incorrect retry CCW");
 				break;
 			case 0x08:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Reset Notification\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Reset Notification");
 				break;
 			case 0x09:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Storage Path Restart\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Storage Path Restart");
 				break;
 			case 0x0A:
-				printk (KERN_WARNING PRINTK_HEADER
-				    "FORMAT 0 - Channel requested ... %02x\n",
-					sense[8]);
+                                DASD_MESSAGE (KERN_WARNING, device,
+                                              "FORMAT 0 - Channel requested "
+                                              "... %02x",
+                                              sense[8]);
 				break;
 			case 0x0B:
-				printk (KERN_WARNING PRINTK_HEADER
-				     "FORMAT 0 - Invalid Defective/Alternate "
-					"Track Pointer\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Invalid Defective/"
+                                              "Alternate Track Pointer");
 				break;
 			case 0x0C:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - DPS Installation Check\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - DPS Installation "
+                                              "Check");
 				break;
 			case 0x0E:
-				printk (KERN_WARNING PRINTK_HEADER
-				    "FORMAT 0 - Command Invalid on Secondary "
-					"Address\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Command Invalid on "
+                                              "Secondary Address");
 				break;
 			case 0x0F:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Status Not As Required: "
-					"reason %02x\n",
-					sense[8]);
+                                DASD_MESSAGE (KERN_WARNING, device,
+                                              "FORMAT 0 - Status Not As "
+                                              "Required: reason %02x",
+                                              sense[8]);
 				break;
 			default:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Reseved\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Reseved");
 			}
 		} else {
 			switch (msg_no) {
 			case 0x00:	/* No Message */
 				break;
 			case 0x01:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Device Error Source\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Device Error Source");
 				break;
 			case 0x02:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Reserved\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Reserved");
 				break;
 			case 0x03:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Device Fenced - device = "
-					"%02x\n",
-					sense[4]);
+                                DASD_MESSAGE (KERN_WARNING, device,
+                                              "FORMAT 0 - Device Fenced - "
+                                              "device = %02x",
+                                              sense[4]);
 				break;
 			case 0x04:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Data Pinned for Device\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Data Pinned for "
+                                              "Device");
 				break;
 			default:
-				printk (KERN_WARNING PRINTK_HEADER
-					"FORMAT 0 - Reserved\n");
+                                DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                              "FORMAT 0 - Reserved");
 			}
                 }
                 break;
 		
-	case 0x10:		/* Format 1 - Device Equipment Checks */
+	case 0x10:	/* Format 1 - Device Equipment Checks */
 		switch (msg_no) {
 		case 0x00:	/* No Message */
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Device Status 1 not as "
-				"expected\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Device Status 1 not as "
+                                      "expected");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Index missing\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Index missing");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Interruption cannot be reset\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Interruption cannot be reset");
 			break;
 		case 0x05:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Device did not respond to "
-				"selection\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Device did not respond to "
+                                      "selection");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Device check-2 error or Set "
-				"Sector is not complete\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Device check-2 error or Set "
+                                      "Sector is not complete");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Head address does not compare\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Head address does not "
+                                      "compare");
 			break;
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Device status 1 not valid\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Device status 1 not valid");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Device not ready\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Device not ready");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Track physical address did "
-				"not compare\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Track physical address did "
+                                      "not compare");
 			break;
 		case 0x0B:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Missing device address bit\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Missing device address bit");
 			break;
 		case 0x0C:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Drive motor switch is off\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Drive motor switch is off");
 			break;
 		case 0x0D:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Seek incomplete\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Seek incomplete");
 			break;
 		case 0x0E:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Cylinder address did not "
-				"compare\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Cylinder address did not "
+                                      "compare");
 			break;
 		case 0x0F:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Offset active cannot be reset\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Offset active cannot be "
+                                      "reset");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 1 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 1 - Reserved");
 		}
                 break;		
                         
-	case 0x20:		/* Format 2 - 3990 Equipment Checks */
+	case 0x20:	/* Format 2 - 3990 Equipment Checks */
 		switch (msg_no) {
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 2 - 3990 check-2 error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 2 - 3990 check-2 error");
 			break;
 		case 0x0E:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 2 - Support facility errors\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 2 - Support facility errors");
 			break;
 		case 0x0F:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 2 - Microcode detected error %02x\n",
-				sense[8]);
+                        DASD_MESSAGE (KERN_WARNING, device,
+                                      "FORMAT 2 - Microcode detected error %02x",
+                                      sense[8]);
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 2 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 2 - Reserved");
 		}
                 break;		
 
-	case 0x30:		/* Format 3 - 3990 Control Checks */
+	case 0x30:	/* Format 3 - 3990 Control Checks */
 		switch (msg_no) {
 		case 0x0F:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 3 - Allegiance terminated\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 3 - Allegiance terminated");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 3 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 3 - Reserved");
 		}
                 break;		
 
-	case 0x40:		/* Format 4 - Data Checks */
+	case 0x40:	/* Format 4 - Data Checks */
 		switch (msg_no) {
 		case 0x00:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Home address area error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Home address area error");
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Count area error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Count area error");
 			break;
 		case 0x02:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Key area error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Key area error");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Data area error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Data area error");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-			    "FORMAT 4 - No sync byte in home address area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in home address "
+                                      "area");
 			break;
 		case 0x05:
-			printk (KERN_WARNING PRINTK_HEADER
-			    "FORMAT 4 - No syn byte in count address area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in count address "
+                                      "area");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - No sync byte in key area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in key area");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - No syn byte in data area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in data area");
 			break;
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Home address area error; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Home address area error; "
+                                      "offset active");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT 4 - Count area error; offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Count area error; offset "
+                                      "active");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Key area error; offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Key area error; offset "
+                                      "active");
 			break;
 		case 0x0B:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Data area error; offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Data area error; "
+                                      "offset active");
 			break;
 		case 0x0C:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT 4 - No sync byte in home address area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in home "
+                                      "address area; offset active");
 			break;
 		case 0x0D:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT 4 - No syn byte in count address area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No syn byte in count "
+                                      "address area; offset active");
 			break;
 		case 0x0E:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - No sync byte in key area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No sync byte in key area; "
+                                      "offset active");
 			break;
 		case 0x0F:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - No syn byte in data area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - No syn byte in data area; "
+                                      "offset active");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 4 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 4 - Reserved");
 		}
                 break;		
 
-	case 0x50:		/* Format 5 - Data Check with displacement information */
+	case 0x50:	/* Format 5 - Data Check with displacement information */
 		switch (msg_no) {
 		case 0x00:
-			printk (KERN_WARNING PRINTK_HEADER
-			  "FORMAT 5 - Data Check in the home address area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the "
+                                      "home address area");
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the count area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the count area");
 			break;
 		case 0x02:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the key area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the key area");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the data area\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the data area");
 			break;
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-			    "FORMAT 5 - Data Check in the home address area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the "
+                                      "home address area; offset active");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the count area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the count area; "
+                                      "offset active");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the key area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the key area; "
+                                      "offset active");
 			break;
 		case 0x0B:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Data Check in the data area; "
-				"offset active\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Data Check in the data area; "
+                                      "offset active");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 5 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 5 - Reserved");
 		}
                 break;		
 
-	case 0x60:		/* Format 6 - Usage Statistics/Overrun Errors */
+	case 0x60:	/* Format 6 - Usage Statistics/Overrun Errors */
 		switch (msg_no) {
 		case 0x00:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel A\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel A");
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel B\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel B");
 			break;
 		case 0x02:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel C\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel C");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel D\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel D");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel E\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel E");
 			break;
 		case 0x05:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel F\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel F");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel G\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel G");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Overrun on channel H\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Overrun on channel H");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 6 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 6 - Reserved");
 		}
                 break;		
 
-	case 0x70:		/* Format 7 - Device Connection Control Checks */
+	case 0x70:	/* Format 7 - Device Connection Control Checks */
 		switch (msg_no) {
 		case 0x00:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - RCC initiated by a connection "
-				"check alert\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - RCC initiated by a connection "
+                                      "check alert");
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - RCC 1 sequence not successful\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - RCC 1 sequence not "
+                                      "successful");
 			break;
 		case 0x02:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - RCC 1 and RCC 2 sequences not "
-				"successful\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - RCC 1 and RCC 2 sequences not "
+                                      "successful");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Invalid tag-in during selection "
-				"sequence\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Invalid tag-in during "
+                                      "selection sequence");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - extra RCC required\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - extra RCC required");
 			break;
 		case 0x05:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Invalid DCC selection response "
-				"or timeout\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Invalid DCC selection "
+                                      "response or timeout");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Missing end operation; device "
-				"transfer complete\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Missing end operation; device "
+                                      "transfer complete");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Missing end operation; device "
-				"transfer incomplete\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Missing end operation; device "
+                                      "transfer incomplete");
 			break;
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Invalid tag-in for an immediate "
-				"command sequence\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Invalid tag-in for an "
+                                      "immediate command sequence");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Invalid tag-in for an extended "
-				"command sequence\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Invalid tag-in for an "
+                                      "extended command sequence");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - 3990 microcode time out when "
-				"stopping selection\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - 3990 microcode time out when "
+                                      "stopping selection");
 			break;
 		case 0x0B:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - No response to selection after "
-				"a poll interruption\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - No response to selection "
+                                      "after a poll interruption");
 			break;
 		case 0x0C:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Permanent path error (DASD "
-				"controller not available)\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Permanent path error (DASD "
+                                      "controller not available)");
 			break;
 		case 0x0D:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - DASD controller not available on "
-				"disconnected command chain\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - DASD controller not available"
+                                      " on disconnected command chain");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 7 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 7 - Reserved");
 		}
                 break;		
 
-	case 0x80:		/* Format 8 - Additional Device Equipment Checks */
+	case 0x80:	/* Format 8 - Additional Device Equipment Checks */
 		switch (msg_no) {
 		case 0x00:	/* No Message */
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - Error correction code hardware "
-				"fault\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - Error correction code "
+                                      "hardware fault");
 			break;
 		case 0x03:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - Unexpected end operation response "
-				"code\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - Unexpected end operation "
+                                      "response code");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - End operation with transfer count "
-				"not zero\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - End operation with transfer "
+                                      "count not zero");
 			break;
 		case 0x05:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - End operation with transfer "
-				"count zero\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - End operation with transfer "
+                                      "count zero");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT 8 - DPS checks after a system reset or "
-				"selective reset\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - DPS checks after a system "
+                                      "reset or selective reset");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - DPS cannot be filled\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - DPS cannot be filled");
 			break;
 		case 0x08:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - Short busy time-out during device "
-				"selection\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - Short busy time-out during "
+                                      "device selection");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - DASD controller failed to set or "
-				"reset the long busy latch\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - DASD controller failed to "
+                                      "set or reset the long busy latch");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT 8 - No interruption from device during "
-				"a command chain\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - No interruption from device "
+                                      "during a command chain");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 8 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 8 - Reserved");
 		}
                 break;		
 
-	case 0x90:		/* Format 9 - Device Read, Write, and Seek Checks */
+	case 0x90:	/* Format 9 - Device Read, Write, and Seek Checks */
 		switch (msg_no) {
 		case 0x00:
 			break;	/* No Message */
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 9 - Device check-2 error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 9 - Device check-2 error");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 9 - Head address did not compare\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 9 - Head address did not compare");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 9 - Track physical address did not "
-				"compare while oriented\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 9 - Track physical address did "
+                                      "not compare while oriented");
 			break;
 		case 0x0E:
-			printk (KERN_WARNING PRINTK_HEADER
-			     "FORMAT 9 - Cylinder address did not compare\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 9 - Cylinder address did not "
+                                      "compare");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT 9 - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT 9 - Reserved");
 		}
                 break;		
 
 	case 0xF0:		/* Format F - Cache Storage Checks */
 		switch (msg_no) {
 		case 0x00:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Operation Terminated\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Operation Terminated");
 			break;
 		case 0x01:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Subsystem Processing Error\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Subsystem Processing Error");
 			break;
 		case 0x02:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Cache or nonvolatile storage "
-				"equipment failure\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Cache or nonvolatile storage "
+                                      "equipment failure");
 			break;
 		case 0x04:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Caching terminated\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Caching terminated");
 			break;
 		case 0x06:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Cache fast write access not "
-				"authorized\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Cache fast write access not "
+                                      "authorized");
 			break;
 		case 0x07:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Track format incorrect\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Track format incorrect");
 			break;
 		case 0x09:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Caching reinitiated\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Caching reinitiated");
 			break;
 		case 0x0A:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Nonvolatile storage terminated\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Nonvolatile storage "
+                                      "terminated");
 			break;
 		case 0x0B:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Volume is suspended duplex\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Volume is suspended duplex");
 			break;
 		case 0x0C:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - Subsystem status connot be "
-				"determined\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Subsystem status connot be "
+                                      "determined");
 			break;
 		case 0x0D:
-			printk (KERN_WARNING PRINTK_HEADER
-			      "FORMAT F - Caching status reset to default\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - Caching status reset to "
+                                      "default");
 			break;
 		case 0x0E:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT F - DASD Fast Write inhibited\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT F - DASD Fast Write inhibited");
 			break;
 		default:
-			printk (KERN_WARNING PRINTK_HEADER
-				"FORMAT D - Reserved\n");
+                        DASD_MESSAGE (KERN_WARNING, device, "%s",
+                                      "FORMAT D - Reserved");
 		}
                 break;		
 
-	default:		/* unknown message format - should not happen */
+	default:	/* unknown message format - should not happen */
 
 	} /* end switch message format */
 
@@ -1324,38 +1401,29 @@
 dasd_3990_erp_com_rej (ccw_req_t *erp,
 		       char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
-        ccw_req_t     *cqr    = NULL;
 
         erp->function = dasd_3990_erp_com_rej;
 
 	/* env data present (ACTION 10 - retry should work) */
 	if (sense[2] & SNS2_ENV_DATA_PRESENT) {
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
-                              "Command Reject - environmental data present\n");
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                              "Command Reject - environmental data present");
 
-		dasd_3990_handle_env_data (sense);
+		dasd_3990_handle_env_data (erp,
+                                           sense);
 
 		erp->retries = 5;
 
 	} else {
 		/* fatal error -  set status to FAILED */
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
-                              "Command Reject - Fatal error\n");
-
-                cqr = erp->refers;
-
-                dasd_free_request (erp);
-
-                erp = cqr;
-
- 		check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_FAILED);
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Command Reject - Fatal error");
 
+                erp = dasd_3990_erp_cleanup (erp,
+                                             CQR_STATUS_FAILED);
 	}
 
 	return erp;
@@ -1376,27 +1444,31 @@
 ccw_req_t *
 dasd_3990_erp_bus_out (ccw_req_t *erp)
 {
+
 	dasd_device_t *device = erp->device;
 
         /* first time set initial retry counter and erp_function */
+        /* and retry once without blocking queue                 */
+        /* (this enables easier enqueing of the cqr)             */
         if (erp->function != dasd_3990_erp_bus_out) {
                 erp->retries  = 256;
                 erp->function = dasd_3990_erp_bus_out;
-        }
 
-        /* issue a message and wait for 'device ready' interrupt */
-
-	DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "bus out parity error or BOPC requested by channel\n");
+        } else {
 
-        dasd_3990_erp_block_queue (erp,
-                                   60);
+                /* issue a message and wait for 'device ready' interrupt */
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                              "bus out parity error or BOPC requested by "
+                              "channel");
+                
+                dasd_3990_erp_block_queue (erp,
+                                           60);
+                
+        }
 
 	return erp;
 
 } /* end dasd_3990_erp_bus_out */
-#endif /* ERP_FULL_ERP */
 
 /*
  * DASD_3990_ERP_EQUIP_CHECK
@@ -1413,60 +1485,51 @@
 dasd_3990_erp_equip_check (ccw_req_t *erp,
 			   char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_equip_check;
 
-#ifdef ERP_FULL_ERP
 	if (sense[1] & SNS1_WRITE_INHIBITED) {
 
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Write inhibited path encountered");
 
 		/* vary path offline */
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_ERR, device, "%s",
                               "Path should be varied off-line. "
-                              "This is not implemented yet \n - please report to "
-                              "linux390@de.ibm.com");
+                              "This is not implemented yet \n - please report "
+                              "to linux390@de.ibm.com");
 
 		erp = dasd_3990_erp_action_1 (erp);
 
-	} else 
-#endif /* ERP_FULL_ERP */
-                if (sense[2] & SNS2_ENV_DATA_PRESENT) {
-                        
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "Equipment Check - "
-                                      "environmental data present");
-#ifdef ERP_FULL_ERP
-                        dasd_3990_handle_env_data (sense);
-#endif /* ERP_FULL_ERP */
-                        
-                        erp = dasd_3990_erp_action_4 (erp,
-                                                      sense);
-
-#ifdef ERP_FULL_ERP
-                } else if (sense[1] & SNS1_PERM_ERR) {
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "Equipment Check - retry exhausted or "
-                                      "undesirable\n");
-                        
-                        erp = dasd_3990_erp_action_1 (erp);
-                        
-                } else {
-                        /* all other equipment checks - Action 5 */
-                        /* rest is done when retries == 0 */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "Equipment check or processing error\n");
-                        
-                        erp = dasd_3990_erp_action_5 (erp);
-#endif /* ERP_FULL_ERP */
-                }
+	} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {
+                
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                              "Equipment Check - "
+                              "environmental data present");
+                
+                dasd_3990_handle_env_data (erp,
+                                           sense);
+                
+                erp = dasd_3990_erp_action_4 (erp,
+                                              sense);
+                
+        } else if (sense[1] & SNS1_PERM_ERR) {
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                              "Equipment Check - retry exhausted or "
+                              "undesirable");
+                
+                erp = dasd_3990_erp_action_1 (erp);
+                
+        } else {
+                /* all other equipment checks - Action 5 */
+                /* rest is done when retries == 0 */
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                              "Equipment check or processing error");
+                
+                erp = dasd_3990_erp_action_5 (erp);
+        }
         
         return erp;
         
@@ -1487,18 +1550,17 @@
 dasd_3990_erp_data_check (ccw_req_t *erp,
 			  char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_data_check;
 
-#ifdef ERP_FULL_ERP
 	if (sense[2] & SNS2_CORRECTABLE) {	/* correctable data check */
 
 		/* issue message that the data has been corrected */
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_EMERG, device, "%s",
                               "Data recovered during retry with PCI "
-                              "fetch mode active\n");
+                              "fetch mode active");
 
                 /* not possible to handle this situation in Linux */    
                 panic("No way to inform appliction about the possibly "
@@ -1506,8 +1568,7 @@
 
 	} else if (sense[2] & SNS2_ENV_DATA_PRESENT) {
 
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Uncorrectable data check recovered secondary "
                               "addr of duplex pair");
 
@@ -1516,41 +1577,25 @@
 
 	} else if (sense[1] & SNS1_PERM_ERR) {
 
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Uncorrectable data check with internal "
-                              "retry exhausted\n");
+                              "retry exhausted");
 
 		erp = dasd_3990_erp_action_1 (erp);
 
 	} else {
 		/* all other data checks */
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Uncorrectable data check with retry count "
-                              "exhausted...\n");
+                              "exhausted...");
 
 		erp = dasd_3990_erp_action_5 (erp);
 	}
 
-#else
-	if (sense[2] & SNS2_ENV_DATA_PRESENT) {
-                
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
-                              "Uncorrectable data check recovered secondary "
-                              "addr of duplex pair");
-
-		erp = dasd_3990_erp_action_4 (erp,
-					      sense);
-	}
-#endif /* ERP_FULL_ERP */
-
 	return erp;
 
 } /* end dasd_3990_erp_data_check */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_OVERRUN
  *
@@ -1566,21 +1611,20 @@
 dasd_3990_erp_overrun (ccw_req_t *erp,
 		       char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_overrun;
 
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
+        DASD_MESSAGE (KERN_DEBUG, device, "%s",
                       "Overrun - service overrun or overrun"
-                      " error requested by channel\n");
+                      " error requested by channel");
 
         erp = dasd_3990_erp_action_5 (erp);
 
 	return erp;
 
 } /* end dasd_3990_erp_overrun */
-#endif /* ERP_FULL_ERP */
 
 /*
  * DASD_3990_ERP_INV_FORMAT
@@ -1597,44 +1641,36 @@
 dasd_3990_erp_inv_format (ccw_req_t *erp,
 			  char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_inv_format;
 
 	if (sense[2] & SNS2_ENV_DATA_PRESENT) {
 
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Track format error when destaging or "
                               "staging data");
 
-#ifdef ERP_FULL_ERP
-		dasd_3990_handle_env_data (sense);
+		dasd_3990_handle_env_data (erp,
+                                           sense);
 
 		erp = dasd_3990_erp_action_4 (erp,
 					      sense);
 
 	} else {
-		DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+		DASD_MESSAGE (KERN_ERR, device, "%s",
                               "Invalid Track Format - Fatal error should have "
-                              "been handled within the interrupt handler\n");
+                              "been handled within the interrupt handler");
 
-		check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_FAILED);
+                erp= dasd_3990_erp_cleanup (erp,
+                                            CQR_STATUS_FAILED);
         }
-#else
-		erp = dasd_3990_erp_action_4 (erp,
-					      sense);
-	}
-#endif /* ERP_FULL_ERP */
 
 	return erp;
 
 } /* end dasd_3990_erp_inv_format */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_EOC
  *
@@ -1642,30 +1678,25 @@
  *   Handles 24 byte 'End-of-Cylinder' error.
  *
  * PARAMETER
- *   erp                current erp_head
+ *   erp                already added default erp
  * RETURN VALUES
- *   erp                new erp_head - pointer to new ERP
+ *   erp                pointer to original (failed) cqr.
  */
 ccw_req_t *
-dasd_3990_erp_EOC (ccw_req_t *erp,
+dasd_3990_erp_EOC (ccw_req_t *default_erp,
 		   char      *sense)
 {
 
-	dasd_device_t *device = erp->device;
+	dasd_device_t *device = default_erp->device;
 
-	erp->function = dasd_3990_erp_EOC;
+        DASD_MESSAGE (KERN_ERR, device, "%s",
+                      "End-of-Cylinder - must never happen");
 
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "End-of-Cylinder - must never happen\n");
-
-        /* implement action 7 */
-        BUG();
-
-	return erp;
+        /* implement action 7 - BUG */
+        return dasd_3990_erp_cleanup (default_erp,
+                                      CQR_STATUS_FAILED);
 
 } /* end dasd_3990_erp_EOC */
-#endif /* ERP_FULL_ERP */  
 
 /*
  * DASD_3990_ERP_ENV_DATA
@@ -1682,25 +1713,32 @@
 dasd_3990_erp_env_data (ccw_req_t *erp,
 			char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_env_data;
 
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
+        DASD_MESSAGE (KERN_DEBUG, device, "%s",
                       "Environmental data present");
-#ifdef ERP_FULL_ERP
-        dasd_3990_handle_env_data (sense);
-#endif /* ERP_FULL_ERP */  
 
-	erp = dasd_3990_erp_action_4 (erp,
-				      sense);
+        dasd_3990_handle_env_data (erp,
+                                   sense);
+
+        /* don't retry on disabled interface */
+        if (sense[7] != 0x0F) {
+
+                erp = dasd_3990_erp_action_4 (erp,
+                                              sense);
+        } else {
+
+                erp = dasd_3990_erp_cleanup (erp,
+                                             CQR_STATUS_IN_IO);
+        }
 
 	return erp;
 
 } /* end dasd_3990_erp_env_data */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_NO_REC
  *
@@ -1708,28 +1746,24 @@
  *   Handles 24 byte 'No Record Found' error.
  *
  * PARAMETER
- *   erp                current erp_head
+ *   erp                already added default ERP
+ *              
  * RETURN VALUES
  *   erp                new erp_head - pointer to new ERP
  */
 ccw_req_t *
-dasd_3990_erp_no_rec (ccw_req_t *erp,
+dasd_3990_erp_no_rec (ccw_req_t *default_erp,
 		      char      *sense)
 {
-	dasd_device_t *device = erp->device;
 
-	erp->function = dasd_3990_erp_no_rec;
-        
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
+	dasd_device_t *device = default_erp->device;
+
+        DASD_MESSAGE (KERN_ERR, device, "%s",
                       "No Record Found - Fatal error should "
-                      "have been handled within the interrupt handler\n");
-        
-        check_then_set (&erp->status,
-                        CQR_STATUS_ERROR,
-                        CQR_STATUS_FAILED);
+                      "have been handled within the interrupt handler");
 
-	return erp;
+        return dasd_3990_erp_cleanup (default_erp,
+                                      CQR_STATUS_FAILED);
 
 } /* end dasd_3990_erp_no_rec */
 
@@ -1749,22 +1783,16 @@
 ccw_req_t *
 dasd_3990_erp_file_prot (ccw_req_t *erp)
 {
-	dasd_device_t *device = erp->device;
 
-	erp->function = dasd_3990_erp_file_prot;
+	dasd_device_t *device = erp->device;
 
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "File Protected\n");
+        DASD_MESSAGE (KERN_ERR, device, "%s",
+                      "File Protected");
 
-        check_then_set (&erp->status,
-                        CQR_STATUS_ERROR,
-                        CQR_STATUS_FAILED);
-
-	return erp;
+        return dasd_3990_erp_cleanup (erp,
+                                      CQR_STATUS_FAILED);
 
 } /* end dasd_3990_erp_file_prot */
-#endif /* ERP_FULL_ERP */  
 
 /*
  * DASD_3990_ERP_INSPECT_24 
@@ -1781,14 +1809,13 @@
  *   erp                pointer to the (addtitional) ERP
  */
 ccw_req_t *
-dasd_3990_erp_inspect_24 ( ccw_req_t *erp,
-                           char      *sense)
+dasd_3990_erp_inspect_24 (ccw_req_t *erp,
+                          char      *sense)
 {
+
 	ccw_req_t *erp_filled = NULL;
-	dasd_device_t *device = erp->device;
 
 	/* Check sense for ....    */
-#ifdef ERP_FULL_ERP
 	/* 'Command Reject'        */
 	if ((erp_filled == NULL) &&
 	    (sense[0] & SNS0_CMD_REJECT)) {
@@ -1805,7 +1832,6 @@
 	    (sense[0] & SNS0_BUS_OUT_CHECK)) {
 		erp_filled = dasd_3990_erp_bus_out (erp);
 	}
-#endif /* ERP_FULL_ERP */  
 	/* 'Equipment Check'       */
 	if ((erp_filled == NULL) &&
 	    (sense[0] & SNS0_EQUIPMENT_CHECK)) {
@@ -1818,35 +1844,30 @@
 		erp_filled = dasd_3990_erp_data_check (erp,
 						       sense);
 	}
-#ifdef ERP_FULL_ERP
 	/* 'Overrun'               */
 	if ((erp_filled == NULL) &&
 	    (sense[0] & SNS0_OVERRUN)) {
 		erp_filled = dasd_3990_erp_overrun (erp,
 						    sense);
 	}
-#endif /* ERP_FULL_ERP */  
 	/* 'Invalid Track Format'  */
 	if ((erp_filled == NULL) &&
 	    (sense[1] & SNS1_INV_TRACK_FORMAT)) {
 		erp_filled = dasd_3990_erp_inv_format (erp,
 						       sense);
 	}
-#ifdef ERP_FULL_ERP
 	/* 'End-of-Cylinder'       */
 	if ((erp_filled == NULL) &&
 	    (sense[1] & SNS1_EOC)) {
 		erp_filled = dasd_3990_erp_EOC (erp,
 						sense);
 	}
-#endif /* ERP_FULL_ERP */  
 	/* 'Environmental Data'    */
 	if ((erp_filled == NULL) &&
 	    (sense[2] & SNS2_ENV_DATA_PRESENT)) {
 		erp_filled = dasd_3990_erp_env_data (erp,
 						     sense);
 	}
-#ifdef ERP_FULL_ERP
 	/* 'No Record Found'       */
 	if ((erp_filled == NULL) &&
 	    (sense[1] & SNS1_NO_REC_FOUND)) {
@@ -1858,15 +1879,9 @@
 	    (sense[1] & SNS1_FILE_PROTECTED)) {
 		erp_filled = dasd_3990_erp_file_prot (erp);
 	}
-#endif /* ERP_FULL_ERP */  
-
-	/* other (unknown) error - do default ERP                     */
+	/* other (unknown) error - do default ERP */
 	if (erp_filled == NULL) {
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
-                              "default ERP taken");
-
 		erp_filled = erp;	
 	}
 
@@ -1880,7 +1895,6 @@
  ***************************************************************************** 
  */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERPACTION_10_32 
  *
@@ -1898,19 +1912,18 @@
 dasd_3990_erp_action_10_32 (ccw_req_t *erp,
                             char      *sense)
 {
+
 	dasd_device_t *device = erp->device;
 
         erp->retries  = 256;
         erp->function = dasd_3990_erp_action_10_32;
 
-	DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "Perform logging requested\n");
+	DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                      "Perform logging requested");
 
 	return erp;
 
 } /* end dasd_3990_erp_action_10_32 */
-#endif /* ERP_FULL_ERP */  
 
 /*
  * DASD_3990_ERP_ACTION_1B_32
@@ -1924,8 +1937,9 @@
  *   action because it contains no DE/LO data space.
  *
  * PARAMETER
- *   default_erp        already created default erp.
+ *   default_erp        already added default erp.
  *   sense              current sense data 
+ *
  * RETURN VALUES
  *   erp                new erp or 
  *                      default_erp in case of imprecise ending or error
@@ -1934,6 +1948,7 @@
 dasd_3990_erp_action_1B_32 (ccw_req_t *default_erp,
                             char      *sense)
 {
+
 	dasd_device_t  *device = default_erp->device;
         __u32          cpa     = 0;
         ccw_req_t      *cqr;
@@ -1942,14 +1957,14 @@
 	char           *LO_data;   /* LO_eckd_data_t */
         ccw1_t         *ccw;
 
-	DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "Write not finsihed because of unexpected condition");
+	DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                      "Write not finished because of unexpected condition");
         
         default_erp->function = dasd_3990_erp_action_1B_32;
 
         /* determine the original cqr */
         cqr = default_erp; 
+
         while (cqr->refers != NULL){
                 cqr = cqr->refers;
         }
@@ -1957,8 +1972,7 @@
         /* for imprecise ending just do default erp */
         if (sense[1] & 0x01) {
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Imprecise ending is set - just retry");
 
                 return default_erp;
@@ -1970,34 +1984,28 @@
         
         if (cpa == 0) {
                 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Unable to determine address of the CCW "
                               "to be restarted");
                 
-                check_then_set (&default_erp->status,
-                                CQR_STATUS_FILLED,
-                                CQR_STATUS_FAILED);
-                
-                return default_erp;
+                return dasd_3990_erp_cleanup (default_erp,
+                                              CQR_STATUS_FAILED);
         }
         
 	/* Build new ERP request including DE/LO */
 	erp = dasd_alloc_request ((char *) &cqr->magic,
                                   2 + 1,                    /* DE/LO + TIC */
                                   sizeof (DE_eckd_data_t) +
-                                  sizeof (LO_eckd_data_t));
+                                  sizeof (LO_eckd_data_t),
+                                  device);
 
-	if ( !erp ) {
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+	if (!erp) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
                               "Unable to allocate ERP");
                 
-                check_then_set (&default_erp->status,
-                                               CQR_STATUS_FILLED,
-                                               CQR_STATUS_FAILED);
-                
-                return default_erp;
+                return dasd_3990_erp_cleanup (default_erp,
+                                              CQR_STATUS_FAILED);
 	}
         
         /* use original DE */
@@ -2012,10 +2020,11 @@
         if ((sense[3]  == 0x01) &&
             (LO_data[1] & 0x01)   ){
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_ERR, device, "%s",
                               "BUG - this should not happen");
-                //BUG();    /* check for read count suffixing n.a. */
+
+                return dasd_3990_erp_cleanup (default_erp,
+                                              CQR_STATUS_FAILED);
         }
 
         if ((sense[7] & 0x3F) == 0x01) {
@@ -2043,22 +2052,38 @@
         ccw = erp->cpaddr;
 	memset (ccw, 0, sizeof (ccw1_t));
 	ccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;
-	ccw->flags = CCW_FLAG_CC;
-	ccw->count = 16;
-	set_normalized_cda (ccw, __pa (DE_data));
+	ccw->flags    = CCW_FLAG_CC;
+	ccw->count    = 16;
+	if (dasd_set_normalized_cda (ccw,
+                                     __pa (DE_data), erp, device)) {
+                dasd_free_request (erp, device);
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate ERP");
+
+                return dasd_3990_erp_cleanup (default_erp,
+                                              CQR_STATUS_FAILED);
+        }
 
         /* create LO ccw */    
         ccw++;
 	memset (ccw, 0, sizeof (ccw1_t));
 	ccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;
-	ccw->flags = CCW_FLAG_CC;
-	ccw->count = 16;
-	set_normalized_cda (ccw, __pa (LO_data));
+	ccw->flags    = CCW_FLAG_CC;
+	ccw->count    = 16;
+	if (dasd_set_normalized_cda (ccw, 
+                                     __pa (LO_data), erp, device)){
+                dasd_free_request (erp, device);
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate ERP");
+                
+                return dasd_3990_erp_cleanup (default_erp,
+                                              CQR_STATUS_FAILED);
+        }
         
         /* TIC to the failed ccw */
         ccw++;
 	ccw->cmd_code = CCW_CMD_TIC;
-	ccw->cda = cpa;
+	ccw->cda      = cpa;
 
         /* fill erp related fields */
         erp->function = dasd_3990_erp_action_1B_32;
@@ -2067,11 +2092,11 @@
 	erp->magic    = default_erp->magic;
 	erp->lpm      = 0xFF;
 	erp->expires  = 0;
-	erp->retries  = 255;
+	erp->retries  = 256;
 	erp->status   = CQR_STATUS_FILLED;
         
         /* remove the default erp */
-        dasd_free_request (default_erp);
+        dasd_free_request (default_erp, device);
         
 	return erp;
         
@@ -2096,6 +2121,7 @@
 dasd_3990_update_1B (ccw_req_t *previous_erp,
                      char      *sense)
 {
+
 	dasd_device_t  *device = previous_erp->device;
         __u32          cpa     = 0;
         ccw_req_t      *cqr;
@@ -2103,13 +2129,13 @@
 	char           *LO_data;   /* LO_eckd_data_t */
         ccw1_t         *ccw;
 
-	DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
-                      "Write not finsihed because of unexpected condition"
+	DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                      "Write not finished because of unexpected condition"
                       " - follow on");
         
         /* determine the original cqr */
-        cqr = previous_erp; 
+        cqr = previous_erp;
+
         while (cqr->refers != NULL){
                 cqr = cqr->refers;
         }
@@ -2117,13 +2143,12 @@
         /* for imprecise ending just do default erp */
         if (sense[1] & 0x01) {
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Imprecise ending is set - just retry");
 
                 check_then_set (&previous_erp->status,
-                                               CQR_STATUS_ERROR,
-                                               CQR_STATUS_QUEUED);
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_QUEUED);
 
                 return previous_erp;
         } 
@@ -2133,16 +2158,8 @@
         cpa = previous_erp->dstat->cpa;    
         
         if (cpa == 0) {
-                ccw = cqr->cpaddr;   /* addr of first data transfer */
-                ccw++;               /* command in domain           */
-                ccw++;
-                cpa = (__u32) ccw; 
-        }
-        
-        if (cpa == 0) {
                 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_DEBUG, device, "%s",
                               "Unable to determine address of the CCW "
                               "to be restarted");
                 
@@ -2161,10 +2178,14 @@
         if ((sense[3]  == 0x01) &&
             (LO_data[1] & 0x01)   ){
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
+                DASD_MESSAGE (KERN_ERR, device, "%s",
                               "BUG - this should not happen");
-                //BUG();    /* check for read count suffixing n.a. */
+
+                check_then_set (&previous_erp->status,
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_FAILED);
+                
+                return previous_erp;
         }
 
         if ((sense[7] & 0x3F) == 0x01) {
@@ -2202,12 +2223,14 @@
         
 } /* end dasd_3990_update_1B */
 
-#ifdef ERP_FULL_ERP
 /*
  * DASD_3990_ERP_COMPOUND_RETRY 
  *
  * DESCRIPTION
  *   Handles the compound ERP action retry code.
+ *   NOTE: At least one retry is done even if zero is specified
+ *         by the sense data. This makes enqueueing of the request
+ *         easier.
  *
  * PARAMETER
  *   sense              sense data of the actual error
@@ -2221,41 +2244,30 @@
 dasd_3990_erp_compound_retry (ccw_req_t *erp,
                               char      *sense)
 {
+
         switch (sense[25] & 0x03) { 
         case 0x00:	/* no not retry */
-                erp->retries = 0;
-                break;
+                erp->retries = 1; 
+                break;            
                 
         case 0x01:	/* retry 2 times */
                 erp->retries = 2;
-
-                check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_QUEUED);
                 break;
                 
         case 0x02:	/* retry 10 times */
                 erp->retries = 10;
-
-                check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_QUEUED);
                 break;
                 
-        case 0x03:	/* retry 255 times */
-                erp->retries = 255;
-
-                check_then_set (&erp->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_QUEUED);
+        case 0x03:	/* retry 256 times */
+                erp->retries = 256;
                 break;
                 
         default:
                 BUG();
         }
-
+        
         erp->function = dasd_3990_erp_compound_retry;
-
+        
 } /* end dasd_3990_erp_compound_retry */
 
 /*
@@ -2277,14 +2289,14 @@
 dasd_3990_erp_compound_path (ccw_req_t *erp,
                              char      *sense)
 {
-
+        
         if (sense[25] & DASD_SENSE_BIT_3) {
                 dasd_3990_erp_alternate_path (erp);
                 
                 if (erp->status == CQR_STATUS_FAILED) {
                         /* reset the lpm and the status to be able to 
                          * try further actions. */
-        
+                        
                         erp->lpm = LPM_ANYPATH;
                         
                         check_then_set (&erp->status,
@@ -2316,7 +2328,6 @@
 dasd_3990_erp_compound_code (ccw_req_t *erp,
                              char      *sense)
 {
-
         
         if (sense[25] & DASD_SENSE_BIT_2) {
 
@@ -2337,7 +2348,8 @@
                         break;
                         
                 default:
-                        BUG();
+                        /* should not happen - continue */
+
                 }
         }
 
@@ -2367,16 +2379,17 @@
 dasd_3990_erp_compound_config (ccw_req_t *erp,
                                char      *sense)
 {
+
         if ((sense[25] & DASD_SENSE_BIT_1) && 
             (sense[26] & DASD_SENSE_BIT_2)   ) {	
 
                 /* set to suspended duplex state then restart */
                 dasd_device_t *device  = erp->device;
 
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",      
-                              "Set device to suspended duplex state should be done!\n"
-                              "This is not implemented yet (for compound ERP)\n"
+                DASD_MESSAGE (KERN_ERR, device, "%s",      
+                              "Set device to suspended duplex state should be "
+                              "done!\n"
+                              "This is not implemented yet (for compound ERP)"
                               " - please report to linux390@de.ibm.com");
                 
         }
@@ -2389,12 +2402,12 @@
  * DASD_3990_ERP_COMPOUND 
  *
  * DESCRIPTION
- *   Does a detailed inspection of the 32 byte sense data
- *   and sets up a related error recovery action.  
+ *   Does the further compound program action if 
+ *   compound retry was not successful.
  *
  * PARAMETER
  *   sense              sense data of the actual error
- *   erp                pointer to the currently created ERP
+ *   erp                pointer to the current (failed) ERP
  *
  * RETURN VALUES
  *   erp                (additional) ERP pointer
@@ -2404,33 +2417,23 @@
 dasd_3990_erp_compound (ccw_req_t *erp,
                         char      *sense)
 {
-        if ((erp->function != dasd_3990_erp_compound_retry ) &&
-            (erp->function != dasd_3990_erp_compound_path  ) &&
-            (erp->function != dasd_3990_erp_compound_code  ) &&
-            (erp->function != dasd_3990_erp_compound_config)   ) {
 
-                /* called first time */
-                dasd_3990_erp_compound_retry (erp,
-                                              sense);
-        }
-        
-        /* do further action if no retry is specified / left */
         if ((erp->function == dasd_3990_erp_compound_retry) &&
-            (erp->status   == CQR_STATUS_ERROR            )   ){
+            (erp->status   == CQR_STATUS_ERROR            )   ) {
                 
                 dasd_3990_erp_compound_path (erp,
                                              sense);
         }
 
         if ((erp->function == dasd_3990_erp_compound_path) &&
-            (erp->status   == CQR_STATUS_ERROR           )   ){
+            (erp->status   == CQR_STATUS_ERROR           )    ){
 
                 erp = dasd_3990_erp_compound_code (erp,
                                                    sense);
         }
 
         if ((erp->function == dasd_3990_erp_compound_code) && 
-            (erp->status   == CQR_STATUS_ERROR           )   ){
+            (erp->status   == CQR_STATUS_ERROR           )   ) {
                 
                 dasd_3990_erp_compound_config (erp,
                                                sense);
@@ -2447,7 +2450,6 @@
         return erp;
         
 } /* end dasd_3990_erp_compound */
-#endif /* ERP_FULL_ERP */  
 
 /*
  * DASD_3990_ERP_INSPECT_32 
@@ -2468,6 +2470,7 @@
 dasd_3990_erp_inspect_32 ( ccw_req_t *erp,
                            char      *sense )
 {
+
 	dasd_device_t *device = erp->device;
 
 	erp->function = dasd_3990_erp_inspect_32;
@@ -2475,40 +2478,32 @@
 	if (sense[25] & DASD_SENSE_BIT_0) {
 
 		/* compound program action codes (byte25 bit 0 == '1') */
-#ifdef ERP_FULL_ERP
-                erp = dasd_3990_erp_compound (erp,
+                dasd_3990_erp_compound_retry (erp,
                                               sense);
-#else
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "%s",
-                              "default ERP taken");
-#endif /* ERP_FULL_ERP */  
 
 	} else {
 
 		/* single program action codes (byte25 bit 0 == '0') */
 		switch (sense[25]) {
-#ifdef ERP_FULL_ERP
+
 		case 0x00:	/* success */
-                        DASD_MESSAGE (KERN_WARNING, device,
+                        DASD_MESSAGE (KERN_DEBUG, device,
                                       "ERP called for successful request %p"
                                       " - NO ERP necessary",
                                       erp);
+                        
+                        erp = dasd_3990_erp_cleanup (erp,
+                                                     CQR_STATUS_DONE);
 
-                        check_then_set (&erp->status,
-                                        CQR_STATUS_ERROR,
-                                        CQR_STATUS_DONE);
                         break;
                         
 		case 0x01:	/* fatal error */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "Fatal error should "
-                                      "have been handled within the interrupt handler\n");
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "Fatal error should have been "
+                                      "handled within the interrupt handler");
 
-                        check_then_set (&erp->status,
-                                        CQR_STATUS_ERROR,
-                                        CQR_STATUS_FAILED);
+                        erp = dasd_3990_erp_cleanup (erp,
+                                                     CQR_STATUS_FAILED);
                         break;
 
 		case 0x02:	/* intervention required */
@@ -2517,15 +2512,15 @@
                         break;
 
 		case 0x0F:	/* length mismatch during update write command */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "update write command error - should not happen; "
-                                      "Please send this message together with the above "
-                                      "sense data to linux390@de.ibm.com\n");
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "update write command error - should not "
+                                      "happen;\n"
+                                      "Please send this message together with "
+                                      "the above sense data to linux390@de."
+                                      "ibm.com");
 
-                        check_then_set (&erp->status,
-                                        CQR_STATUS_ERROR,
-                                        CQR_STATUS_FAILED);
+                        erp = dasd_3990_erp_cleanup (erp,
+                                                     CQR_STATUS_FAILED);
                         break;
 
 		case 0x10:	/* logging required for other channel program */
@@ -2534,17 +2529,16 @@
                         break;
 
 		case 0x15:	/* next track outside defined extend */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "next track outside defined extend - should not happen; "
-                                      "Please send this message together with the above "
-                                      "sense data to linux390@de.ibm.com\n");
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "next track outside defined extend - "
+                                      "should not happen;\n"
+                                      "Please send this message together with "
+                                      "the above sense data to linux390@de."
+                                      "ibm.com");
 
-                        check_then_set (&erp->status,
-                                        CQR_STATUS_ERROR,
-                                        CQR_STATUS_FAILED);
+                        erp= dasd_3990_erp_cleanup (erp,
+                                                    CQR_STATUS_FAILED);
                         break;
-#endif /* ERP_FULL_ERP */  
 
 		case 0x1B:	/* unexpected condition during write */
 
@@ -2552,22 +2546,18 @@
                                                           sense);
                         break;
 
-#ifdef ERP_FULL_ERP
 		case 0x1C:	/* invalid data */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
+                        DASD_MESSAGE (KERN_EMERG, device, "%s",
                                       "Data recovered during retry with PCI "
-                                      "fetch mode active\n");
+                                      "fetch mode active");
                         
                         /* not possible to handle this situation in Linux */    
-                        panic("No way to inform appliction about the possibly "
-                              "incorret data");
+                        panic("Invalid data - No way to inform appliction about "
+                              "the possibly incorret data");
 			break;
-#endif /* ERP_FULL_ERP */  
 
 		case 0x1D:	/* state-change pending */
-                        DASD_MESSAGE (KERN_WARNING, device, 
-                                      "%s",
+                        DASD_MESSAGE (KERN_DEBUG, device, "%s",
                                       "A State change pending condition exists "
                                       "for the subsystem or device");
 
@@ -2575,10 +2565,8 @@
                                                       sense);
 			break;
 
-		default:	/* all others errors */
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "%s",
-                                      "default ERP taken");
+		default:	/* all others errors - default erp  */
+                        
 		}
 	}
 
@@ -2607,6 +2595,7 @@
 ccw_req_t *
 dasd_3990_erp_inspect (ccw_req_t *erp)
 {
+
 	ccw_req_t *erp_new = NULL;
 	/* sense data are located in the refers record of the */
 	/* already set up new ERP !                           */
@@ -2648,24 +2637,34 @@
 ccw_req_t *
 dasd_3990_erp_add_erp (ccw_req_t *cqr)
 {
+
+	dasd_device_t *device = cqr->device;
+
 	/* allocate additional request block */
-	ccw_req_t *erp = dasd_alloc_request ((char *) &cqr->magic, 1, 0);
-	if ( !erp ) {
-		printk( KERN_WARNING PRINTK_HEADER
-			"unable to allocate ERP request\n" );
-                return NULL;
+	ccw_req_t *erp = dasd_alloc_request ((char *) &cqr->magic, 1, 0, cqr->device);
+
+	if (!erp) {
+
+                DASD_MESSAGE (KERN_ERR, device, "%s",
+                              "Unable to allocate ERP request");
+                
+                check_then_set (&cqr->status,
+                                CQR_STATUS_ERROR,
+                                CQR_STATUS_FAILED);
+
+                return cqr;
 	}
 
 	/* initialize request with default TIC to current ERP/CQR */
 	erp->cpaddr->cmd_code = CCW_CMD_TIC;
-	erp->cpaddr->cda      = ((__u32) cqr->cpaddr);
+	erp->cpaddr->cda      = (long)(cqr->cpaddr);
 	erp->function = dasd_3990_erp_add_erp;
 	erp->refers   = cqr;
 	erp->device   = cqr->device;
 	erp->magic    = cqr->magic;
 	erp->lpm      = 0xFF;
 	erp->expires  = 0;
-	erp->retries  = 255;
+	erp->retries  = 256;
 
 	erp->status = CQR_STATUS_FILLED;
 
@@ -2697,7 +2696,8 @@
 	erp = dasd_3990_erp_add_erp (cqr);
 
 	/* inspect sense, determine specific ERP if possible */
-        if (erp != NULL) {
+        if (erp != cqr) {
+
                 erp = dasd_3990_erp_inspect (erp);
         }
 
@@ -2727,13 +2727,13 @@
 dasd_3990_erp_error_match (ccw_req_t *cqr1,
 			   ccw_req_t *cqr2)
 {
+
 	/* check failed CCW */
 	if (cqr1->dstat->cpa !=
 	    cqr2->dstat->cpa) {
 	//	return 0;	/* CCW doesn't match */
-                printk(KERN_WARNING PRINTK_HEADER 
-                       "_error_match: CCW doesn't match -> ignore\n");
 	}
+
 	/* check sense data; byte 0-2,25,27 */
 	if (!((strncmp (cqr1->dstat->ii.sense.data,
 			cqr2->dstat->ii.sense.data,
@@ -2745,9 +2745,10 @@
 
 		return 0;	/* sense doesn't match */
 	}
+
 	return 1;		/* match */
 
-}				/* end dasd_3990_erp_error_match */
+} /* end dasd_3990_erp_error_match */
 
 /*
  * DASD_3990_ERP_IN_ERP
@@ -2760,35 +2761,38 @@
  *   cqr                failed cqr (either original cqr or already an erp)
  *
  * RETURN VALUES
- *   erp                erp-pointer to the already defined error recovery procedure OR
+ *   erp                erp-pointer to the already defined error 
+ *                      recovery procedure OR
  *                      NULL if a 'new' error occurred.
  */
 ccw_req_t *
 dasd_3990_erp_in_erp (ccw_req_t *cqr)
 {
-	ccw_req_t *erp_head = cqr,	/* save erp chain head */
-	         *erp_match = NULL;	/* save erp chain head */
+
+	ccw_req_t *erp_head  = cqr,	/* save erp chain head */
+                  *erp_match = NULL;	/* save erp chain head */
 	int match = 0;		/* 'boolean' for matching error found */
 
 	if (cqr->refers == NULL) {	/* return if not in erp */
 		return NULL;
 	}
+
 	/* check the erp/cqr chain for current error */
 	do {
 		match = dasd_3990_erp_error_match (erp_head,
 						   cqr->refers);
-		erp_match = cqr;	/* save possible matching erp  */
-		cqr = cqr->refers;	/* check next erp/cqr in queue */
+		erp_match = cqr;	 /* save possible matching erp  */
+		cqr       = cqr->refers; /* check next erp/cqr in queue */
+
 	} while ((cqr->refers != NULL) &&
-		 (match == 0));
+		 (!match             )   );
 
-	if (match) {
-		return erp_match;	/* return address of matching erp */
-	} else {
-		return NULL;	/* return NULL to indicate that no match
-				   was found */
+	if (!match) {
+		return NULL; 	/* no match was found */
 	}
 
+        return erp_match;	/* return address of matching erp */
+
 } /* END dasd_3990_erp_in_erp */
 
 /*
@@ -2810,9 +2814,10 @@
 ccw_req_t *
 dasd_3990_erp_further_erp (ccw_req_t *erp)
 {
-        dasd_device_t     *device = erp->device;
+
+        dasd_device_t *device = erp->device;
+        char          *sense  = erp->dstat->ii.sense.data;
         
-#ifdef ERP_FULL_ERP
         /* check for 24 byte sense ERP */
 	if ((erp->function == dasd_3990_erp_bus_out ) ||
             (erp->function == dasd_3990_erp_action_1) ||
@@ -2823,8 +2828,6 @@
 	} else if (erp->function == dasd_3990_erp_action_5) {
                 
                 /* retries have not been successful */
-                char *sense = erp->dstat->ii.sense.data;
-                
                 /* prepare erp for retry on different channel path */
                 erp = dasd_3990_erp_action_1 (erp);
                 
@@ -2853,26 +2856,25 @@
                                 break;
                         }
                         default:
-                                DASD_MESSAGE (KERN_WARNING, device,
-                                              "invalid subcommand modifier 0x%x for "
-                                              "Diagnostic Control Command",
+                                DASD_MESSAGE (KERN_DEBUG, device,
+                                              "invalid subcommand modifier 0x%x "
+                                              "for Diagnostic Control Command",
                                               sense[25]);
                         }
                 } 
 
-//        /* check for 32 byte sense ERP */
-//	} else if ((erp->function == dasd_3990_erp_xxx){
-#else
-        /* check for 24 byte sense ERP */
-	if ((erp->function == dasd_3990_erp_action_1) ||
-            (erp->function == dasd_3990_erp_action_4)   ){
-                
-                erp = dasd_3990_erp_action_1 (erp);
-#endif /* ERP_FULL_ERP */  
+        /* check for 32 byte sense ERP */
+	} else if ((erp->function == dasd_3990_erp_compound_retry ) ||
+                   (erp->function == dasd_3990_erp_compound_path  ) ||
+                   (erp->function == dasd_3990_erp_compound_code  ) ||
+                   (erp->function == dasd_3990_erp_compound_config)   ) {
                 
+                erp = dasd_3990_erp_compound (erp,
+                                              sense);
+
 	} else {
                 /* no retry left and no additional special handling necessary */
-                DASD_MESSAGE (KERN_WARNING, device,
+                DASD_MESSAGE (KERN_ERR, device,
                               "no retries left for erp %p - "
                               "set status to FAILED",
                               erp);
@@ -2892,102 +2894,87 @@
  * DESCRIPTION
  *   An error occurred again and an ERP has been detected which is already
  *   used to handle this error (e.g. retries). 
- *   All prior ERP's are set to status DONE and the retry counter is
- *   decremented.
- *   If retry counter is already 0, it has to checked if further action
- *   is needed (besides retry) or if the ERP has failed.
+ *   All prior ERP's are asumed to be successful and therefore removed
+ *   from queue.
+ *   If retry counter of matching erp is already 0, it is checked if further 
+ *   action is needed (besides retry) or if the ERP has failed.
  *
  * PARAMETER
  *   erp_head           first ERP in ERP-chain
- *   erp_match          ERP that handles the actual error.
+ *   erp                ERP that handles the actual error.
+ *                      (matching erp)
  *
  * RETURN VALUES
- *   none                
+ *   erp                modified/additional ERP
  */
-void
+ccw_req_t *
 dasd_3990_erp_handle_match_erp (ccw_req_t *erp_head,
-				ccw_req_t *erp_match)
+				ccw_req_t *erp)
 {
 
 	dasd_device_t *device   = erp_head->device;
-	ccw_req_t     *erp_done = erp_head;
+	ccw_req_t     *erp_done = erp_head;  /* finished req */
         ccw_req_t     *erp_free = NULL;      /* req to be freed */    
-
+        
 	/* loop over successful ERPs and remove them from chanq */
-	while ((erp_done != erp_match) &&
-	       (erp_done != NULL)) {
+	while (erp_done != erp) {
 
-#ifdef ERP_DEBUG
-                DASD_MESSAGE (KERN_WARNING, device,
-                              "successful ERP - dequeue and free request %p",
-                              (void *) erp_done);
-#endif /* ERP_DEBUG */
-
-		check_then_set (&erp_done->status,
-                                CQR_STATUS_ERROR,
-                                CQR_STATUS_DONE);
+                if (erp_done == NULL) 	/* end of chain reached */
+                        panic (PRINTK_HEADER "Programming error in ERP! The "
+                               "original request was lost\n");
 
 		/* remove the request from the device queue */
 		dasd_chanq_deq (&device->queue,
 				erp_done);
-
+                
                 erp_free = erp_done;
 		erp_done = erp_done->refers;
                 
 		/* free the finished erp request */
-		dasd_free_request (erp_free);
+		dasd_free_request (erp_free, erp_free->device);
 
-	}
-
-	if (erp_done == NULL) 	/* erp_done should never be NULL! */
-		panic (PRINTK_HEADER "Programming error in ERP! The original "
-                       "request was lost\n");
+	} /* end while */
 
-#ifdef ERP_DEBUG
-	/* handle matching ERP */
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "handle matching erp %p",
-                      (void *) erp_done);
-#endif
-        
-        if (erp_done->retries > 0) {
+        if (erp->retries > 0) {
+                
+                char *sense = erp->dstat->ii.sense.data;
                 
                 /* check for special retries */
-                if (erp_done->function == dasd_3990_erp_action_4) {
-                        char *sense = erp_done->dstat->ii.sense.data;
-                        erp_done = dasd_3990_erp_action_4 (erp_done,
-                                                           sense);
-                        
-                } else if (erp_done->function == dasd_3990_erp_action_1B_32) {
-                        char *sense = erp_done->dstat->ii.sense.data;
-                        erp_done = dasd_3990_update_1B (erp_done,
-                                                        sense);
-
-#ifdef ERP_FULL_ERP
-                } else if (erp_done->function == dasd_3990_erp_int_req) {
-                        erp_done = dasd_3990_erp_int_req (erp_done);
-#endif /* ERP_FULL_ERP */  
+                if (erp->function == dasd_3990_erp_action_4) {
+                        
+                        erp = dasd_3990_erp_action_4 (erp,
+                                                      sense);
+                        
+                } else if (erp->function == dasd_3990_erp_action_1B_32) {
+                        
+                        erp = dasd_3990_update_1B (erp,
+                                                   sense);
+
+                } else if (erp->function == dasd_3990_erp_int_req) {
+
+                        erp = dasd_3990_erp_int_req (erp);
                         
                 } else {
                         /* simple retry   */
-                        DASD_MESSAGE (KERN_WARNING, device,
+                        DASD_MESSAGE (KERN_DEBUG, device,
                                       "%i retries left for erp %p",
-                                      erp_done->retries,
-                                      (void *) erp_done);
+                                      erp->retries,
+                                      erp);
                         
                         /* handle the request again... */
-                        check_then_set (&erp_done->status,
+                        check_then_set (&erp->status,
                                         CQR_STATUS_ERROR,
                                         CQR_STATUS_QUEUED);
                 }
+                
         } else {
                 /* no retry left - check for further necessary action    */
                 /* if no further actions, handle rest as permanent error */
-                erp_done = dasd_3990_erp_further_erp (erp_done);
+                erp = dasd_3990_erp_further_erp (erp);
 	}
 
-        erp_head = erp_done;
-
+        return erp;
+        
 } /* end dasd_3990_erp_handle_match_erp */
 
 /*
@@ -3004,30 +2991,27 @@
  *   erp                erp-pointer to the head of the ERP action chain.
  *                      This means:
  *                       - either a ptr to an additional ERP cqr or
- *                       - the original given cqr (which's status might be modified)
+ *                       - the original given cqr (which's status might 
+ *                         be modified)
  */
 ccw_req_t *
 dasd_3990_erp_action (ccw_req_t *cqr)
 {
+
 	ccw_req_t     *erp    = NULL;
 	dasd_device_t *device = cqr->device;
+        __u32         cpa     = cqr->dstat->cpa;    
 
 #ifdef ERP_DEBUG 
-        __u32 cpa = cqr->dstat->cpa;    
-#endif /* ERP_DEBUG */
-
-#ifdef ERP_DEBUG 
-
-	printk (KERN_WARNING PRINTK_HEADER
-		"entering 3990 ERP for "
-		"0x%04X on sch %d = /dev/%s \n",
-		device->devinfo.devno,
-		device->devinfo.irq,
-		device->name);
+        DASD_MESSAGE (KERN_DEBUG, device,
+                      "entering 3990 ERP for "
+                      "0x%04X on sch %d = /dev/%s ",
+                      device->devinfo.devno,
+                      device->devinfo.irq,
+                      device->name);
 
 	/* print current erp_chain */
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
+        DASD_MESSAGE (KERN_DEBUG, device, "%s",
                       "ERP chain at BEGINNING of ERP-ACTION");
         {
                 ccw_req_t *temp_erp = NULL;
@@ -3035,23 +3019,24 @@
                      temp_erp != NULL; 
                      temp_erp = temp_erp->refers){
 
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "      erp %p refers to %p \n",
+                        DASD_MESSAGE (KERN_DEBUG, device,
+                                      "      erp %p refers to %p",
                                       temp_erp,
                                       temp_erp->refers);
                 }
         } 
-#endif
+#endif /* ERP_DEBUG */
 
 	/* double-check if current erp/cqr was successfull */
-	if ((cqr->dstat->cstat == 0x00) &&
-	    (cqr->dstat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))) {
-                DASD_MESSAGE (KERN_WARNING, device,
+	if ((cqr->dstat->cstat == 0x00                                 ) &&
+	    (cqr->dstat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))   ) {
+
+                DASD_MESSAGE (KERN_DEBUG, device,
                               "ERP called for successful request %p"
                               " - NO ERP necessary",
                               cqr);
                 
-                check_then_set (&erp->status,
+                check_then_set (&cqr->status,
                                 CQR_STATUS_ERROR,
                                 CQR_STATUS_DONE);
 
@@ -3059,12 +3044,12 @@
 	}
 	/* check if sense data are available */
 	if (!cqr->dstat->ii.sense.data) {
-		DASD_MESSAGE (KERN_WARNING, device,
+		DASD_MESSAGE (KERN_DEBUG, device,
 			"ERP called witout sense data avail ..."
 			"request %p - NO ERP possible",
 			cqr);
 
-                check_then_set (&erp->status,
+                check_then_set (&cqr->status,
                                 CQR_STATUS_ERROR,
                                 CQR_STATUS_FAILED);
 
@@ -3080,38 +3065,178 @@
 		erp = dasd_3990_erp_additional_erp (cqr);
 	} else {
 		/* matching erp found - set all leading erp's to DONE */
-		dasd_3990_erp_handle_match_erp (cqr, erp);
-		erp = cqr;
+		erp = dasd_3990_erp_handle_match_erp (cqr, 
+                                                      erp);
 	}
 
 #ifdef ERP_DEBUG
 	/* print current erp_chain */
-        DASD_MESSAGE (KERN_WARNING, device,
-                      "%s",
+        DASD_MESSAGE (KERN_DEBUG, device, "%s",
                       "ERP chain at END of ERP-ACTION");
         {
                 ccw_req_t *temp_erp = NULL;
                 for (temp_erp = erp; 
                      temp_erp != NULL; 
-                     temp_erp = temp_erp->refers){
+                     temp_erp = temp_erp->refers) {
 
-                        DASD_MESSAGE (KERN_WARNING, device,
-                                      "      erp %p refers to %p \n",
+                        DASD_MESSAGE (KERN_DEBUG, device,
+                                      "      erp %p refers to %p",
                                       temp_erp,
                                       temp_erp->refers);
                 }
         }
 #endif /* ERP_DEBUG */
 
-#ifdef ERP_DEBUG
         if (erp->status == CQR_STATUS_FAILED) {
-                log_erp_chain (erp, 1, cpa);
+
+                log_erp_chain (erp,
+                               1,
+                               cpa);
+        }
+
+        /* enqueue added ERP request */
+        if ((erp != cqr                      ) &&
+            (erp->status == CQR_STATUS_FILLED)   ){
+
+                dasd_chanq_enq_head (&device->queue,
+                                     erp);
+        } else {
+                if ((erp->status == CQR_STATUS_FILLED )||
+                    (erp != cqr                       )  ){
+                        /* something strange happened - log the error and throw a BUG() */
+                        DASD_MESSAGE (KERN_ERR, device, "%s",
+                                      "Problems with ERP chain!!! BUG");
+
+                        /* print current erp_chain */
+                        DASD_MESSAGE (KERN_DEBUG, device, "%s",
+                                      "ERP chain at END of ERP-ACTION");
+                        {
+                                ccw_req_t *temp_erp = NULL;
+                                for (temp_erp = erp; 
+                                     temp_erp != NULL; 
+                                     temp_erp = temp_erp->refers) {
+
+                                        DASD_MESSAGE (KERN_DEBUG, device,
+                                                      "      erp %p (function %p) refers to %p",
+                                                      temp_erp,
+                                                      temp_erp->function,
+                                                      temp_erp->refers);
+                                }
+                        }
+                        BUG();
+                }
+
         }
-#endif /* ERP_DEBUG */
 
 	return erp;
 
 } /* end dasd_3990_erp_action */
+
+/*
+ * DASD_3990_ERP_POSTACTION
+ *
+ * DESCRIPTION
+ *   Frees all ERPs of the current ERP Chain and set the status
+ *   of the original CQR either to CQR_STATUS_DONE if ERP was successful
+ *   or to CQR_STATUS_FAILED if ERP was NOT successful.
+ *
+ * PARAMETER
+ *   erp                current erp_head
+ *
+ * RETURN VALUES
+ *   cqr                pointer to the original CQR
+ */
+ccw_req_t *
+dasd_3990_erp_postaction (ccw_req_t *erp)
+{
+
+	ccw_req_t     *cqr      = NULL, 
+                      *free_erp = NULL;
+	dasd_device_t *device   = erp->device;
+	int           success;
+
+	if (erp->refers   == NULL || 
+            erp->function == NULL   ) {
+
+		BUG ();
+	}
+
+	if (erp->status == CQR_STATUS_DONE)
+		success = 1;
+	else
+		success = 0;
+
+#ifdef ERP_DEBUG
+
+	/* print current erp_chain */
+	printk (KERN_DEBUG PRINTK_HEADER
+		"3990 ERP postaction called for erp chain:\n");
+	{
+		ccw_req_t *temp_erp = NULL;
+
+		for (temp_erp = erp; 
+                     temp_erp != NULL;
+		     temp_erp = temp_erp->refers) {
+
+			printk (KERN_DEBUG PRINTK_HEADER
+				"       erp %p refers to %p with erp function %p\n",
+				temp_erp, temp_erp->refers, temp_erp->function);
+		}
+	}
+
+#endif /* ERP_DEBUG */
+
+	/* free all ERPs - but NOT the original cqr */
+	while (erp->refers != NULL) {
+
+		free_erp = erp;
+		erp      = erp->refers;
+
+		/* remove the request from the device queue */
+		dasd_chanq_deq (&device->queue,
+                                free_erp);
+
+		/* free the finished erp request */
+		dasd_free_request (free_erp, free_erp->device);
+	}
+
+	/* save ptr to original cqr */
+	cqr = erp;
+
+	/* set corresponding status to original cqr */
+	if (success) {
+
+		check_then_set (&cqr->status, 
+                                CQR_STATUS_ERROR,
+				CQR_STATUS_DONE);
+	} else {
+
+		check_then_set (&cqr->status,
+				CQR_STATUS_ERROR, 
+                                CQR_STATUS_FAILED);
+	}
+
+#ifdef ERP_DEBUG
+	/* print current erp_chain */
+	printk (KERN_DEBUG PRINTK_HEADER
+		"3990 ERP postaction finished with remaining chain:\n");
+	{
+		ccw_req_t *temp_erp = NULL;
+
+		for (temp_erp = cqr; 
+                     temp_erp != NULL;
+		     temp_erp = temp_erp->refers) {
+
+			printk (KERN_DEBUG PRINTK_HEADER
+				" erp %p refers to %p \n", temp_erp,
+				temp_erp->refers);
+		}
+	}
+#endif /* ERP_DEBUG */
+
+	return cqr;
+
+} /* end dasd_3990_erp_postaction */
 
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
diff -urN linux/drivers/s390/block/dasd_3990_erp.h linux-2.4.7/drivers/s390/block/dasd_3990_erp.h
--- linux/drivers/s390/block/dasd_3990_erp.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_3990_erp.h	Mon Dec 17 13:41:19 2001
@@ -10,7 +10,6 @@
 #ifndef DASD_3990_ERP_H
 #define DASD_3990_ERP_H
 
-
 dasd_era_t dasd_3990_erp_examine (ccw_req_t *, devstat_t *);
 
 ccw_req_t *dasd_3990_erp_action (ccw_req_t *);
@@ -19,10 +18,9 @@
 void dasd_3990_erp_restart_queue (unsigned long);
 
 typedef struct DCTL_data_t {
-	unsigned char  subcommand;  /* e.g Inhibit Write, Enable Write,... */
-	unsigned char  modifier;    /* Subcommand modifier                 */
-	unsigned short res;	    /* reserved */
+	unsigned char subcommand;	/* e.g Inhibit Write, Enable Write,... */
+	unsigned char modifier;	/* Subcommand modifier                 */
+	unsigned short res;	/* reserved */
 } __attribute__ ((packed)) DCTL_data_t;
 
-
-#endif /* DASD_3990_ERP_H */
+#endif				/* DASD_3990_ERP_H */
diff -urN linux/drivers/s390/block/dasd_9336_erp.c linux-2.4.7/drivers/s390/block/dasd_9336_erp.c
--- linux/drivers/s390/block/dasd_9336_erp.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/block/dasd_9336_erp.c	Mon Dec 17 13:41:19 2001
@@ -6,7 +6,8 @@
  */
 
 #include <asm/ccwcache.h>
-#include <asm/dasd.h>
+#include "dasd_int.h"
+#include "dasd_9336_erp.h"
 
 #ifdef PRINTK_HEADER
 #undef PRINTK_HEADER
@@ -29,15 +30,12 @@
  *   dasd_era_fatal     for all fatal (unrecoverable errors)
  *   dasd_era_recover   for all others.
  */
-dasd_era_t
-dasd_9336_erp_examine (ccw_req_t * cqr, devstat_t * stat)
+dasd_era_t dasd_9336_erp_examine (ccw_req_t * cqr, devstat_t * stat)
 {
-	char *sense = stat->ii.sense.data;
-
 	/* check for successful execution first */
 	if (stat->cstat == 0x00 &&
 	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
-		return dasd_era_none;
+		    return dasd_era_none;
 
 	/* examine the 24 byte sense data */
 	return dasd_era_recover;
diff -urN linux/drivers/s390/block/dasd_9336_erp.h linux-2.4.7/drivers/s390/block/dasd_9336_erp.h
--- linux/drivers/s390/block/dasd_9336_erp.h	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/drivers/s390/block/dasd_9336_erp.h	Mon Dec 17 13:41:19 2001
@@ -0,0 +1,15 @@
+/* 
+ * File...........: linux/drivers/s390/block/dasd_9336_erp.h
+ * Author(s)......: Horst Hummel <Horst Hummel@de.ibm.com>
+ * Bugreports.to..: <Linux390@de.ibm.com>
+ * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 2000
+ *
+ * History of changes (starts July 2000)
+ */
+
+#ifndef DASD_9336_ERP_H
+#define DASD_9336_ERP_H
+
+dasd_era_t dasd_9336_erp_examine (ccw_req_t *, devstat_t *);
+
+#endif				/* DASD_3990_ERP_H */
diff -urN linux/drivers/s390/block/dasd_9343_erp.c linux-2.4.7/drivers/s390/block/dasd_9343_erp.c
--- linux/drivers/s390/block/dasd_9343_erp.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/block/dasd_9343_erp.c	Mon Dec 17 13:41:19 2001
@@ -6,18 +6,17 @@
  */
 
 #include <asm/ccwcache.h>
-#include <asm/dasd.h>
+#include "dasd_int.h"
 
 #ifdef PRINTK_HEADER
 #undef PRINTK_HEADER
 #define PRINTK_HEADER "dasd_erp(9343)"
 #endif				/* PRINTK_HEADER */
 
-dasd_era_t
-dasd_9343_erp_examine (ccw_req_t * cqr, devstat_t * stat)
+dasd_era_t dasd_9343_erp_examine (ccw_req_t * cqr, devstat_t * stat)
 {
 	if (stat->cstat == 0x00 &&
 	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
-		return dasd_era_none;
+		    return dasd_era_none;
 	return dasd_era_recover;
 }
diff -urN linux/drivers/s390/block/dasd_9343_erp.h linux-2.4.7/drivers/s390/block/dasd_9343_erp.h
--- linux/drivers/s390/block/dasd_9343_erp.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_9343_erp.h	Mon Dec 17 13:41:19 2001
@@ -10,9 +10,8 @@
 #ifndef DASD_9343_ERP_H
 #define DASD_9343_ERP_H
 
-
 dasd_era_t dasd_9343_erp_examine (ccw_req_t *, devstat_t *);
 
 ccw_req_t *dasd_9343_erp_action (ccw_req_t *);
 
-#endif /* DASD_9343_ERP_H */
+#endif				/* DASD_9343_ERP_H */
diff -urN linux/drivers/s390/block/dasd_diag.c linux-2.4.7/drivers/s390/block/dasd_diag.c
--- linux/drivers/s390/block/dasd_diag.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_diag.c	Mon Dec 17 13:42:41 2001
@@ -14,11 +14,12 @@
  *          fixed partition handling and HDIO_GETGEO
  */
 
+#include <linux/config.h>
 #include <linux/stddef.h>
 #include <linux/kernel.h>
 #include <asm/debug.h>
 
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/hdreg.h>	/* HDIO_GETGEO                      */
 #include <linux/blk.h>
 #include <asm/ccwcache.h>
@@ -29,6 +30,7 @@
 #include <asm/irq.h>
 #include <asm/s390dyn.h>
 
+#include "dasd_int.h"
 #include "dasd_diag.h"
 
 #ifdef PRINTK_HEADER
@@ -39,7 +41,7 @@
 dasd_discipline_t dasd_diag_discipline;
 
 typedef struct
-dasd_diag_private_t {
+    dasd_diag_private_t {
 	dasd_diag_characteristics_t rdc_data;
 	diag_rw_io_t iob;
 	diag_init_io_t iib;
@@ -64,10 +66,8 @@
 			      ".previous\n"
 			      ".section __ex_table,\"a\"\n"
 			      "    .align 4\n"
-			      "    .long 0b,2b\n"
-			      ".previous\n"
-			      :"=d"   (rc)
-			      :"d"    ((void *) __pa (devchar))
+			      "    .long 0b,2b\n" ".previous\n":"=d" (rc)
+			      :"d" ((void *) __pa (devchar))
 			      :"1");
 	return rc;
 }
@@ -75,11 +75,11 @@
 static __inline__ int
 dia250 (void *iob, int cmd)
 {
- 	__asm__ __volatile__ ("    lr    0,%1\n"
-                              "    diag  0,%0,0x250\n"
-                              "0:  ipm   %0\n"
-                              "    srl   %0,28\n"
- 			      "    or    %0,1\n"
+	__asm__ __volatile__ ("    lr    0,%1\n"
+			      "    diag  0,%0,0x250\n"
+			      "0:  ipm   %0\n"
+			      "    srl   %0,28\n"
+			      "    or    %0,1\n"
 			      "1:\n"
 			      ".section .fixup,\"ax\"\n"
 			      "2:  lhi   %0,3\n"
@@ -90,12 +90,10 @@
 			      ".previous\n"
 			      ".section __ex_table,\"a\"\n"
 			      "    .align 4\n"
-                              "    .long 0b,2b\n"
-                              ".previous\n"
-                              : "+d" (cmd)
-                              : "d" ((void *) __pa (iob))
-                              : "0", "1", "cc" );
- 	return cmd;
+			      "    .long 0b,2b\n" ".previous\n":"+d" (cmd)
+			      :"d" ((void *) __pa (iob))
+			      :"0", "1", "cc");
+	return cmd;
 }
 
 static __inline__ int
@@ -115,7 +113,7 @@
 
 	rc = dia250 (iib, INIT_BIO);
 
-	return rc&3;
+	return rc & 3;
 }
 
 static __inline__ int
@@ -128,7 +126,7 @@
 	memset (iib, 0, sizeof (diag_init_io_t));
 	iib->dev_nr = device->devinfo.devno;
 	rc = dia250 (iib, TERM_BIO);
-	return rc&3;
+	return rc & 3;
 }
 
 int
@@ -154,20 +152,14 @@
 	if (rc > 8) {
 		PRINT_WARN ("dia250 returned CC %d\n", rc);
 		check_then_set (&cqr->status,
-					       CQR_STATUS_QUEUED,
-					       CQR_STATUS_ERROR);
-        } else if (rc == 0 ) {                                     
-               check_then_set(&cqr->status,        
-                                             CQR_STATUS_QUEUED,   
-                                             CQR_STATUS_DONE);    
-               dasd_schedule_bh(device);                                
-	 } else {
-		if (cqr->expires) {
-			cqr->expires += cqr->startclk;
-		}
+				CQR_STATUS_QUEUED, CQR_STATUS_ERROR);
+	} else if (rc == 0) {
+		check_then_set (&cqr->status,
+				CQR_STATUS_QUEUED, CQR_STATUS_DONE);
+		dasd_schedule_bh (device);
+	} else {
 		check_then_set (&cqr->status,
-					       CQR_STATUS_QUEUED,
-					       CQR_STATUS_IN_IO);
+				CQR_STATUS_QUEUED, CQR_STATUS_IN_IO);
 		rc = 0;
 	}
 	return rc;
@@ -176,32 +168,40 @@
 void
 dasd_ext_handler (struct pt_regs *regs, __u16 code)
 {
+    	int cpu = smp_processor_id();
 	ccw_req_t *cqr;
 	int ip = S390_lowcore.ext_params;
-	char status = *((char *) S390_lowcore.ext_params + 5);
+	char status = *((char *) &S390_lowcore.ext_params + 5);
 	dasd_device_t *device;
 	int done_fast_io = 0;
 	int devno;
+        unsigned long flags;
+
+
+	irq_enter(cpu, -1);
 
 	if (!ip) {		/* no intparm: unsolicited interrupt */
 		printk (KERN_WARNING PRINTK_HEADER
 			"caught unsolicited interrupt\n");
+		irq_exit(cpu, -1);
 		return;
 	}
 	if (ip & 0x80000001) {
 		printk (KERN_WARNING PRINTK_HEADER
-			"caught spurious interrupt with parm %08x\n",
-			ip);
+			"caught spurious interrupt with parm %08x\n", ip);
+		irq_exit(cpu, -1);
 		return;
 	}
 	cqr = (ccw_req_t *) ip;
 	device = (dasd_device_t *) cqr->device;
+
 	devno = device->devinfo.devno;
 	if (device == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
 			" INT on devno 0x%04X  = /dev/%s (%d:%d)"
 			" belongs to NULL device\n",
-			devno, device->name, MAJOR (device->kdev), MINOR (device->kdev));
+			devno, device->name, MAJOR (device->kdev),
+			MINOR (device->kdev));
 	}
 	if (strncmp (device->discipline->ebcname, (char *) &cqr->magic, 4)) {
 		printk (KERN_WARNING PRINTK_HEADER
@@ -211,18 +211,21 @@
 			devno, device->name,
 			MAJOR (device->kdev), MINOR (device->kdev),
 			cqr->magic, *(int *) (&device->discipline->name));
+		irq_exit(cpu, -1);
 		return;
 	}
+
+        /* get irq lock to modify request queue */
+        s390irq_spin_lock_irqsave (device->devinfo.irq, 
+                                   flags);
+
 	asm volatile ("STCK %0":"=m" (cqr->stopclk));
+
 	switch (status) {
 	case 0x00:
 		check_then_set (&cqr->status,
-					       CQR_STATUS_IN_IO,
-					       CQR_STATUS_DONE);
-		if ( device->level == DASD_DEVICE_LEVEL_ANALYSIS_PENDING)
-					device->level = DASD_DEVICE_LEVEL_ANALYSIS_PREPARED;
-		if (cqr->next &&
-		    (cqr->next->status == CQR_STATUS_QUEUED)) {
+				CQR_STATUS_IN_IO, CQR_STATUS_DONE);
+		if (cqr->next && (cqr->next->status == CQR_STATUS_QUEUED)) {
 			if (dasd_start_diag (cqr->next) == 0) {
 				done_fast_io = 1;
 			}
@@ -233,12 +236,17 @@
 	case 0x03:
 	default:
 		check_then_set (&cqr->status,
-					       CQR_STATUS_IN_IO,
-					       CQR_STATUS_FAILED);
+				CQR_STATUS_IN_IO, CQR_STATUS_FAILED);
 		break;
 	}
+
+        s390irq_spin_unlock_irqrestore (device->devinfo.irq, 
+                                        flags);
+
 	wake_up (&device->wait_q);
 	dasd_schedule_bh (device);
+	irq_exit(cpu, -1);
+
 }
 
 static int
@@ -255,47 +263,46 @@
 
 	if (device == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
-		   "Null device pointer passed to characteristics checker\n");
+			"Null device pointer passed to characteristics checker\n");
 		return -ENODEV;
 	}
-	if (device->private != NULL) {
-                kfree (device->private);
-        } 
-        device->private = kmalloc (sizeof (dasd_diag_private_t), GFP_KERNEL);
-        if (device->private == NULL) {
-                printk (KERN_WARNING PRINTK_HEADER
-                        "memory allocation failed for private data\n");
-                return -ENOMEM;
+	device->private = kmalloc (sizeof (dasd_diag_private_t), GFP_KERNEL);
+	if (device->private == NULL) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"memory allocation failed for private data\n");
+		rc = -ENOMEM;
+                goto fail;
 	}
 	private = (dasd_diag_private_t *) device->private;
 	rdc_data = (void *) &(private->rdc_data);
-        
+
 	rdc_data->dev_nr = device->devinfo.devno;
 	rdc_data->rdc_len = sizeof (dasd_diag_characteristics_t);
-        
-	if (dia210 (rdc_data) != 0) {
-                goto nodiag;
+
+        rc = dia210 (rdc_data);
+	if ( rc != 0) {
+		goto fail;
 	}
 	if (rdc_data->vdev_class != DEV_CLASS_FBA &&
 	    rdc_data->vdev_class != DEV_CLASS_ECKD &&
 	    rdc_data->vdev_class != DEV_CLASS_CKD) {
-                goto nodiag;
+                rc = -ENOTSUPP;
+		goto fail;
 	}
 #if 0
 	printk (KERN_INFO PRINTK_HEADER
 		"%04X: %04X on real %04X/%02X\n",
 		rdc_data->dev_nr,
-		rdc_data->vdev_type,
-		rdc_data->rdev_type, rdc_data->rdev_model);
+		rdc_data->vdev_type, rdc_data->rdev_type, rdc_data->rdev_model);
 #endif
 	/* Figure out position of label block */
 	if (private->rdc_data.vdev_class == DEV_CLASS_FBA) {
-		label_block = 1;
+		device->sizes.pt_block = 1;
 	} else if (private->rdc_data.vdev_class == DEV_CLASS_ECKD ||
 		   private->rdc_data.vdev_class == DEV_CLASS_CKD) {
-		label_block = 2;
+		device->sizes.pt_block = 2;
 	} else {
-                goto nodiag;
+                BUG();
 	}
 	private->label = (long *) get_free_page (GFP_KERNEL);
 	label = private->label;
@@ -304,86 +311,69 @@
 	for (bsize = 512; bsize <= PAGE_SIZE; bsize <<= 1) {
 		diag_bio_t *bio;
 		diag_rw_io_t *iob = &private->iob;
-                
+
 		rc = mdsk_init_io (device, bsize, 0, 64);
 		if (rc > 4) {
 			continue;
 		}
-		cqr = ccw_alloc_request (dasd_diag_discipline.name, sizeof(diag_bio_t)/sizeof(ccw1_t), 0);
+		cqr = dasd_alloc_request (dasd_diag_discipline.name,
+                                         sizeof (diag_bio_t) / sizeof (ccw1_t),
+                                         0, device);
 		if (cqr == NULL) {
 			printk (KERN_WARNING PRINTK_HEADER
-                                "No memory to allocate initialization request\n");
-                        free_page((long)private->label);
-                        kfree(private);
-                        device->private = NULL;
-                        return -ENOMEM;
+				"No memory to allocate initialization request\n");
+			free_page ((long) private->label);
+                        rc = -ENOMEM;
+                        goto fail;
 		}
 		bio = (diag_bio_t *) (cqr->cpaddr);
 		memset (bio, 0, sizeof (diag_bio_t));
 		bio->type = MDSK_READ_REQ;
-		bio->block_number = label_block + 1;
+		bio->block_number = device->sizes.pt_block + 1;
 		bio->buffer = __pa (private->label);
 		cqr->device = device;
-		cqr->status= CQR_STATUS_FILLED;
+		cqr->status = CQR_STATUS_FILLED;
 		memset (iob, 0, sizeof (diag_rw_io_t));
 		iob->dev_nr = rdc_data->dev_nr;
 		iob->block_count = 1;
-		iob->interrupt_params = (u32)cqr;
+		iob->interrupt_params = (u32) cqr;
 		iob->bio_list = __pa (bio);
 		rc = dia250 (iob, RW_BIO);
 		if (rc == 0) {
-			if (label[3] != bsize) {
-                                goto nodiag;
-			}
-			if (label[0] != 0xc3d4e2f1) {	/* != CMS1 */
-                                goto nodiag;
-			}
-			if (label[13] == 0) {
-                                goto nodiag;
+			if (label[3] != bsize ||
+                            label[0] != 0xc3d4e2f1 ||	/* != CMS1 */
+                            label[13] == 0 ){
+                                rc = -EMEDIUMTYPE;
+				goto fail;
 			}
 			break;
 		}
 		mdsk_term_io (device);
 	}
-        if ( bsize > PAGE_SIZE )
-                goto nodiag;
+        if (bsize > PAGE_SIZE) {
+                rc = -EMEDIUMTYPE;
+		goto fail;
+        }
+	device->sizes.blocks = label[7];
 	device->sizes.bp_block = bsize;
 	device->sizes.s2b_shift = 0;	/* bits to shift 512 to get a block */
 	for (sb = 512; sb < bsize; sb = sb << 1)
 		device->sizes.s2b_shift++;
-        goto good;
- nodiag:
-        kfree(private);
-        device -> private = NULL;
-        rc = -ENODEV;
- good:
-	return rc;
-}
-
-static int
-dasd_diag_do_analysis (struct dasd_device_t *device)
-{
-	dasd_diag_private_t *private = (dasd_diag_private_t *) device->private;
-
-	long *label = private->label;
-
-	/* real size of the volume */
-	device->sizes.blocks = label[7];
-        if (private->rdc_data.vdev_class == DEV_CLASS_FBA) {
-		device->sizes.pt_block = 1;
-	} else if (private->rdc_data.vdev_class == DEV_CLASS_ECKD ||
-		   private->rdc_data.vdev_class == DEV_CLASS_CKD) {
-		device->sizes.pt_block = 2;
-	} else {
-		return -EINVAL;
-        }
 	printk (KERN_INFO PRINTK_HEADER
 		"/dev/%s (%04X): capacity (%dkB blks): %ldkB\n",
 		device->name, device->devinfo.devno,
 		(device->sizes.bp_block >> 10),
 		(device->sizes.blocks << device->sizes.s2b_shift) >> 1);
-        free_page((long)private->label);
-	return 0;
+	free_page ((long) private->label);
+        rc = 0;
+	goto out;
+ fail:
+        if ( rc ) {
+                kfree (device->private);
+                device->private = NULL;
+        }
+ out:
+	return rc;
 }
 
 static int
@@ -418,23 +408,6 @@
 	return dasd_era_fatal;
 }
 
-static dasd_erp_action_fn_t
-dasd_diag_erp_action (ccw_req_t * cqr)
-{
-	return default_erp_action;
-}
-
-static dasd_erp_postaction_fn_t
-dasd_diag_erp_postaction (ccw_req_t * cqr)
-{
-	if (cqr->function == default_erp_action)
-		return default_erp_postaction;
-	printk (KERN_WARNING PRINTK_HEADER
-		"unknown ERP action %p\n",
-		cqr->function);
-	return NULL;
-}
-
 static ccw_req_t *
 dasd_diag_build_cp_from_req (dasd_device_t * device, struct request *req)
 {
@@ -459,14 +432,12 @@
 	}
 	bhct = 0;
 	for (bh = req->bh; bh; bh = bh->b_reqnext) {
-		if (bh->b_size > byt_per_blk)
-			for (size = 0; size < bh->b_size; size += byt_per_blk)
-				bhct++;
-		else
-			bhct++;
+		if (bh->b_size < byt_per_blk)
+                        BUG();
+                bhct += bh->b_size >> (device->sizes.s2b_shift+9);
 	}
 	/* Build the request */
-	rw_cp = dasd_alloc_request (dasd_diag_discipline.name, bhct << 1, 0);
+	rw_cp = dasd_alloc_request (dasd_diag_discipline.name, bhct << 1, 0, device);
 	if (!rw_cp) {
 		return NULL;
 	}
@@ -474,28 +445,36 @@
 
 	block = req->sector >> device->sizes.s2b_shift;
 	for (bh = req->bh; bh; bh = bh->b_reqnext) {
-		if (bh->b_size >= byt_per_blk) {
-			memset (bio, 0, sizeof (diag_bio_t));
-			for (size = 0; size < bh->b_size; size += byt_per_blk) {
-				bio->type = rw_cmd;
-				bio->block_number = block + 1;
-				bio->buffer = __pa (bh->b_data + size);
-				bio++;
-				block++;
-			}
-		} else {
-			PRINT_WARN ("Cannot fulfill request smaller than block\n");
-			ccw_free_request (rw_cp);
-			return NULL;
-		}
+                memset (bio, 0, sizeof (diag_bio_t));
+                for (size = 0; size < bh->b_size; size += byt_per_blk) {
+                        bio->type = rw_cmd;
+                        bio->block_number = block + 1;
+                        bio->buffer = __pa (bh->b_data + size);
+                        bio++;
+                        block++;
+                }
 	}
+	asm volatile ("STCK %0":"=m" (rw_cp->buildclk));
 	rw_cp->device = device;
-	rw_cp->expires = 50 * TOD_SEC;		/* 50 seconds */
+	rw_cp->expires = 50 * TOD_SEC;	/* 50 seconds */
 	rw_cp->req = req;
 	check_then_set (&rw_cp->status, CQR_STATUS_EMPTY, CQR_STATUS_FILLED);
 	return rw_cp;
 }
 
+static int
+dasd_diag_fill_info (dasd_device_t * device, dasd_information_t * info)
+{
+	int rc = 0;
+	info->FBA_layout = 1;
+	info->characteristics_size = sizeof (dasd_diag_characteristics_t);
+	memcpy (info->characteristics,
+		&((dasd_diag_private_t *) device->private)->rdc_data,
+		sizeof (dasd_diag_characteristics_t));
+	info->confdata_size = 0;
+	return rc;
+}
+
 static char *
 dasd_diag_dump_sense (struct dasd_device_t *device, ccw_req_t * req)
 {
@@ -511,21 +490,19 @@
 	return page;
 }
 
-dasd_discipline_t dasd_diag_discipline =
-{
+dasd_discipline_t dasd_diag_discipline = {
+        owner: THIS_MODULE,
 	name:"DIAG",
 	ebcname:"DIAG",
-	max_blocks:PAGE_SIZE/sizeof(diag_bio_t),
+	max_blocks:PAGE_SIZE / sizeof (diag_bio_t),
 	check_characteristics:dasd_diag_check_characteristics,
-	do_analysis:dasd_diag_do_analysis,
 	fill_geometry:dasd_diag_fill_geometry,
 	start_IO:dasd_start_diag,
 	examine_error:dasd_diag_examine_error,
-	erp_action:dasd_diag_erp_action,
-	erp_postaction:dasd_diag_erp_postaction,
 	build_cp_from_req:dasd_diag_build_cp_from_req,
 	dump_sense:dasd_diag_dump_sense,
-	int_handler:dasd_ext_handler
+	int_handler:dasd_ext_handler,
+	fill_info:dasd_diag_fill_info,
 };
 
 int
@@ -534,32 +511,55 @@
 	int rc = 0;
 	if (MACHINE_IS_VM) {
 		printk (KERN_INFO PRINTK_HEADER
-		   "%s discipline initializing\n", dasd_diag_discipline.name);
+			"%s discipline initializing\n",
+			dasd_diag_discipline.name);
 		ASCEBC (dasd_diag_discipline.ebcname, 4);
 		ctl_set_bit (0, 9);
 		register_external_interrupt (0x2603, dasd_ext_handler);
-		dasd_discipline_enq (&dasd_diag_discipline);
+		dasd_discipline_add (&dasd_diag_discipline);
 	} else {
 		printk (KERN_INFO PRINTK_HEADER
-			"Machine is not VM: %s discipline not initializing\n", dasd_diag_discipline.name);
+			"Machine is not VM: %s discipline not initializing\n",
+			dasd_diag_discipline.name);
 		rc = -EINVAL;
 	}
 	return rc;
 }
 
 void
-dasd_diag_cleanup( void ) {
-        if ( MACHINE_IS_VM ) {
-          printk ( KERN_INFO PRINTK_HEADER
-                   "%s discipline cleaning up\n", dasd_diag_discipline.name);
-          dasd_discipline_deq(&dasd_diag_discipline);
-          unregister_external_interrupt (0x2603, dasd_ext_handler);
-          ctl_clear_bit (0, 9);
-        } else {
-          printk ( KERN_INFO PRINTK_HEADER
-                   "Machine is not VM: %s discipline not initializing\n", dasd_diag_discipline.name);
-        }
+dasd_diag_cleanup (void)
+{
+	if (MACHINE_IS_VM) {
+		printk (KERN_INFO PRINTK_HEADER
+			"%s discipline cleaning up\n",
+			dasd_diag_discipline.name);
+		dasd_discipline_del (&dasd_diag_discipline);
+		unregister_external_interrupt (0x2603, dasd_ext_handler);
+		ctl_clear_bit (0, 9);
+	} else {
+		printk (KERN_INFO PRINTK_HEADER
+			"Machine is not VM: %s discipline not initializing\n",
+			dasd_diag_discipline.name);
+	}
 }
+
+#ifdef MODULE
+int
+init_module (void)
+{
+	int rc = 0;
+	rc = dasd_diag_init ();
+	return rc;
+}
+
+void
+cleanup_module (void)
+{
+	dasd_diag_cleanup ();
+	return;
+}
+#endif
+
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically
diff -urN linux/drivers/s390/block/dasd_diag.h linux-2.4.7/drivers/s390/block/dasd_diag.h
--- linux/drivers/s390/block/dasd_diag.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/block/dasd_diag.h	Mon Dec 17 13:41:19 2001
@@ -29,9 +29,9 @@
 	u8 rdev_type;
 	u8 rdev_model;
 	u8 rdev_features;
-} __attribute__             ((packed, aligned (4))) 
+} __attribute__ ((packed, aligned (4)))
 
-dasd_diag_characteristics_t;
+    dasd_diag_characteristics_t;
 
 typedef struct diag_bio_t {
 	u8 type;
@@ -40,9 +40,9 @@
 	u32 block_number;
 	u32 alet;
 	u32 buffer;
-} __attribute__ ((packed, aligned (8))) 
+} __attribute__ ((packed, aligned (8)))
 
-diag_bio_t;
+    diag_bio_t;
 
 typedef struct diag_init_io_t {
 	u16 dev_nr;
@@ -52,9 +52,9 @@
 	u32 start_block;
 	u32 end_block;
 	u32 spare2[6];
-} __attribute__ ((packed, aligned (8))) 
+} __attribute__ ((packed, aligned (8)))
 
-diag_init_io_t;
+    diag_init_io_t;
 
 typedef struct diag_rw_io_t {
 	u16 dev_nr;
@@ -67,9 +67,9 @@
 	u32 bio_list;
 	u32 interrupt_params;
 	u32 spare3[5];
-} __attribute__ ((packed, aligned (8))) 
+} __attribute__ ((packed, aligned (8)))
 
-diag_rw_io_t;
+    diag_rw_io_t;
 
 int dasd_diag_init (void);
-void dasd_diag_cleanup(void);
+void dasd_diag_cleanup (void);
diff -urN linux/drivers/s390/block/dasd_eckd.c linux-2.4.7/drivers/s390/block/dasd_eckd.c
--- linux/drivers/s390/block/dasd_eckd.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_eckd.c	Mon Dec 17 13:42:47 2001
@@ -1,6 +1,7 @@
 /* 
  * File...........: linux/drivers/s390/block/dasd_eckd.c
  * Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
+                    Carsten Otte <Cotte@de.ibm.com>
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
 
@@ -22,27 +23,25 @@
 #include <linux/config.h>
 #include <linux/stddef.h>
 #include <linux/kernel.h>
-#include <asm/debug.h>
-
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/hdreg.h>	/* HDIO_GETGEO                      */
 #include <linux/blk.h>
+
+#include <asm/debug.h>
 #include <asm/ccwcache.h>
 #include <asm/idals.h>
-#include <asm/dasd.h>
-
 #include <asm/ebcdic.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/s390dyn.h>
 
+#include "dasd_int.h"
 #include "dasd_eckd.h"
 
 #ifdef PRINTK_HEADER
 #undef PRINTK_HEADER
 #endif				/* PRINTK_HEADER */
-#define PRINTK_HEADER DASD_NAME"(eckd): "
-#undef DASD_CDL // Support compatible disk layout
+#define PRINTK_HEADER DASD_NAME"(eckd):"
 #undef CDL_PRINTK
 
 #define ECKD_C0(i) (i->home_bytes)
@@ -62,55 +61,39 @@
 dasd_eckd_private_t {
 	dasd_eckd_characteristics_t rdc_data;
 	dasd_eckd_confdata_t conf_data;
-#ifdef DASD_CDL
-        eckd_count_t count_area[5];
-#else
-	eckd_count_t count_area;
-#endif
-	ccw_req_t *init_cqr;
-#ifdef DASD_CDL
-        int uses_cdl; 
-#endif
+	eckd_count_t count_area[5];
+	int uses_cdl;
 } dasd_eckd_private_t;
 
 #ifdef CONFIG_DASD_DYNAMIC
 static
-devreg_t dasd_eckd_known_devices[] =
-{
-	{
-		ci:
-		{hc:
-		 {ctype:0x3990}},
-		flag: (DEVREG_MATCH_CU_TYPE |
-                       DEVREG_NO_DEV_INFO| 
-                       DEVREG_TYPE_DEVCHARS),
-		oper_func:dasd_oper_handler
-	},
+devreg_t dasd_eckd_known_devices[] = {
+        {
+                ci: { hc: {ctype:0x3880, dtype: 3390}},
+                flag:(DEVREG_MATCH_CU_TYPE | DEVREG_MATCH_DEV_TYPE | 
+                      DEVREG_TYPE_DEVCHARS),
+                oper_func:dasd_oper_handler
+        },
+        {
+                ci: { hc: {ctype:0x3990}},
+                flag:(DEVREG_MATCH_CU_TYPE | DEVREG_TYPE_DEVCHARS),
+                oper_func:dasd_oper_handler
+        },
 	{
-		ci:
-		{hc:
-		 {ctype:0x2105}},
-		flag:(DEVREG_MATCH_CU_TYPE |
-                       DEVREG_NO_DEV_INFO| 
-                       DEVREG_TYPE_DEVCHARS),
-		oper_func:dasd_oper_handler
-	},
+                ci: { hc: {ctype:0x2105}},
+                flag:(DEVREG_MATCH_CU_TYPE | DEVREG_TYPE_DEVCHARS),
+                oper_func:dasd_oper_handler
+        },
 	{
-		ci:
-		{hc:
-		 {ctype:0x9343}},
-		flag:(DEVREG_MATCH_CU_TYPE |
-                       DEVREG_NO_DEV_INFO| 
-                       DEVREG_TYPE_DEVCHARS),
-		oper_func:dasd_oper_handler
-	}
+                ci: { hc: {ctype:0x9343}},
+                flag:(DEVREG_MATCH_CU_TYPE | DEVREG_TYPE_DEVCHARS),
+                oper_func:dasd_oper_handler
+        }
 };
 #endif
 
-#ifdef DASD_CDL
-int sizes_trk0[]={28,148,84};
+int sizes_trk0[] = { 28, 148, 84 };
 #define LABEL_SIZE 140
-#endif
 
 static inline unsigned int
 round_up_multiple (unsigned int no, unsigned int mult)
@@ -126,8 +109,7 @@
 }
 
 static inline int
-bytes_per_record (dasd_eckd_characteristics_t * rdc,
-		  int kl,	/* key length */
+bytes_per_record (dasd_eckd_characteristics_t * rdc, int kl,	/* key length */
 		  int dl /* data length */ )
 {
 	int bpr = 0;
@@ -194,8 +176,7 @@
 				       9 + ceil_quot (kl + 6 * kn, 34) +
 				       9 + ceil_quot (dl + 6 * dn, 34));
 		} else
-			return 1729 / (10 +
-				       9 + ceil_quot (dl + 6 * dn, 34));
+			return 1729 / (10 + 9 + ceil_quot (dl + 6 * dn, 34));
 	case 0x9345:
 		dn = ceil_quot (dl + 6, 232) + 1;
 		if (kl) {
@@ -204,21 +185,17 @@
 				       7 + ceil_quot (kl + 6 * kn, 34) +
 				       ceil_quot (dl + 6 * dn, 34));
 		} else
-			return 1420 / (18 +
-				       7 + ceil_quot (dl + 6 * dn, 34));
+			return 1420 / (18 + 7 + ceil_quot (dl + 6 * dn, 34));
 	}
 	return rpt;
 }
 
-
-static inline void
+static inline int
 define_extent (ccw1_t * de_ccw,
 	       DE_eckd_data_t * data,
-	       int trk,
-	       int totrk,
-	       int cmd,
-	       dasd_device_t * device)
+	       int trk, int totrk, int cmd, dasd_device_t * device, ccw_req_t* cqr)
 {
+        int rc=0;
 	ch_t geo, beg, end;
 	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
 
@@ -232,7 +209,8 @@
 	memset (de_ccw, 0, sizeof (ccw1_t));
 	de_ccw->cmd_code = DASD_ECKD_CCW_DEFINE_EXTENT;
 	de_ccw->count = 16;
-	set_normalized_cda (de_ccw, __pa (data));
+	if ((rc=dasd_set_normalized_cda (de_ccw, __pa (data), cqr, device))) 
+                return rc;
 
 	memset (data, 0, sizeof (DE_eckd_data_t));
 	switch (cmd) {
@@ -259,6 +237,7 @@
 	case DASD_ECKD_CCW_WRITE_CKD_MT:
 		data->attributes.operation = 0x1;	/* format through cache */
 		break;
+	case DASD_ECKD_CCW_ERASE:
 	case DASD_ECKD_CCW_WRITE_HOME_ADDRESS:
 	case DASD_ECKD_CCW_WRITE_RECORD_ZERO:
 		data->mask.perm = 0x3;
@@ -270,46 +249,66 @@
 		break;
 	}
 	data->attributes.mode = 0x3;
-	if (private->rdc_data.cu_type == 0x2105 
-#ifdef DASD_CDL
-            && !(private->uses_cdl && trk < 2)
-#endif
-            ) {
+	if (private->rdc_data.cu_type == 0x2105
+	    && !(private->uses_cdl && trk < 2)
+	    ) {
 		data->reserved |= 0x40;
 	}
 	data->beg_ext.cyl = beg.cyl;
 	data->beg_ext.head = beg.head;
 	data->end_ext.cyl = end.cyl;
 	data->end_ext.head = end.head;
+        return rc;
 }
 
-static inline void
+static inline int
 locate_record (ccw1_t * lo_ccw,
 	       LO_eckd_data_t * data,
 	       int trk,
 	       int rec_on_trk,
-	       int no_rec,
-	       int cmd,
-	       dasd_device_t * device,
-	       int reclen)
+	       int no_rec, int cmd, dasd_device_t * device, int reclen, ccw_req_t* cqr)
 {
+        int rc=0;
 	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-	ch_t geo =
-	{private->rdc_data.no_cyl,
-	 private->rdc_data.trk_per_cyl};
-	ch_t seek =
-	{trk / (geo.head), trk % (geo.head)};
-	int sector;
+	ch_t geo = { private->rdc_data.no_cyl,
+		private->rdc_data.trk_per_cyl
+	};
+	ch_t seek = { trk / (geo.head), trk % (geo.head) };
+	int sector = 0;
 
 #ifdef CDL_PRINTK
-        printk ("Locate: trk %d, rec %d, no_rec %d, cmd %d, reclen %d\n",trk,rec_on_trk,no_rec,cmd,reclen);
+	printk ("Locate: trk %d, rec %d, no_rec %d, cmd %d, reclen %d\n", trk,
+		rec_on_trk, no_rec, cmd, reclen);
 #endif
 	memset (lo_ccw, 0, sizeof (ccw1_t));
 	lo_ccw->cmd_code = DASD_ECKD_CCW_LOCATE_RECORD;
 	lo_ccw->count = 16;
-	set_normalized_cda (lo_ccw, __pa (data));
+	if ((rc=dasd_set_normalized_cda (lo_ccw, __pa (data), cqr, device)))
+                return rc;
 
 	memset (data, 0, sizeof (LO_eckd_data_t));
+        if (rec_on_trk) {
+                switch (private->rdc_data.dev_type) {
+                case 0x3390:{
+                        int dn, d;
+                        dn = ceil_quot (reclen + 6, 232);
+                        d = 9 + ceil_quot (reclen + 6 * (dn + 1), 34);
+                        sector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;
+                        break;
+                }
+                case 0x3380:{
+                        int d;
+                        d = 7 + ceil_quot (reclen + 12, 32);
+                        sector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;
+                        break;
+                }
+                case 0x9345:
+                default:
+                        sector = 0;
+                }
+        }
+        data->sector = sector;
+	data->count = no_rec;
 	switch (cmd) {
 	case DASD_ECKD_CCW_WRITE_HOME_ADDRESS:
 		data->operation.orientation = 0x3;
@@ -360,32 +359,18 @@
 	case DASD_ECKD_CCW_READ_COUNT:
 		data->operation.operation = 0x06;
 		break;
+	case DASD_ECKD_CCW_ERASE:
+                data->length = reclen;
+                data->auxiliary.last_bytes_used = 0x1;
+		data->operation.operation = 0x0b;
+		break;
 	default:
 		INTERNAL_ERROR ("unknown opcode 0x%x\n", cmd);
 	}
-	switch (private->rdc_data.dev_type) {
-	case 0x3390:{
-			int dn, d;
-			dn = ceil_quot (reclen + 6, 232);
-			d = 9 + ceil_quot (reclen + 6 * (dn + 1), 34);
-			sector = (49 + (rec_on_trk - 1) * (10 + d)) / 8;
-			break;
-		}
-	case 0x3380:{
-			int d;
-			d = 7 + ceil_quot (reclen + 12, 32);
-			sector = (39 + (rec_on_trk - 1) * (8 + d)) / 7;
-			break;
-		}
-	case 0x9345:
-	default:
-		sector = 0;
-	}
-	data->sector = sector;
 	memcpy (&(data->seek_addr), &seek, sizeof (ch_t));
 	memcpy (&(data->search_arg), &seek, sizeof (ch_t));
 	data->search_arg.record = rec_on_trk;
-	data->count += no_rec;
+        return rc;
 }
 
 static int
@@ -393,12 +378,10 @@
 {
 	if (info->sid_data.cu_type == 0x3990 ||
 	    info->sid_data.cu_type == 0x2105)
-		if (info->sid_data.dev_type == 0x3390)
-			return 0;
+		    if (info->sid_data.dev_type == 0x3390) return 0;
 	if (info->sid_data.cu_type == 0x3990 ||
 	    info->sid_data.cu_type == 0x2105)
-		if (info->sid_data.dev_type == 0x3380)
-			return 0;
+		    if (info->sid_data.dev_type == 0x3380) return 0;
 	if (info->sid_data.cu_type == 0x9343)
 		if (info->sid_data.dev_type == 0x9345)
 			return 0;
@@ -408,7 +391,7 @@
 static int
 dasd_eckd_check_characteristics (struct dasd_device_t *device)
 {
-	int rc = -ENODEV;
+	int rc = 0;
 	void *conf_data;
 	void *rdc_data;
 	int conf_len;
@@ -416,82 +399,89 @@
 
 	if (device == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
-		   "Null device pointer passed to characteristics checker\n");
-		return -ENODEV;
+			"Null device pointer passed to characteristics checker\n");
+                return -ENODEV;
+	}
+	device->private = kmalloc (sizeof (dasd_eckd_private_t), GFP_KERNEL);
+	if (device->private == NULL) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"memory allocation failed for private data\n");
+		rc = -ENOMEM;
+                goto fail;
 	}
-        if (device->private != NULL) {
-                kfree(device->private);
-        }
-        device->private = kmalloc (sizeof (dasd_eckd_private_t), GFP_KERNEL);
-        if (device->private == NULL) {
-                printk (KERN_WARNING PRINTK_HEADER
-                        "memory allocation failed for private data\n");
-                return -ENOMEM;
-        }
 	private = (dasd_eckd_private_t *) device->private;
 	rdc_data = (void *) &(private->rdc_data);
 	rc = read_dev_chars (device->devinfo.irq, &rdc_data, 64);
 	if (rc) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"Read device characteristics returned error %d\n", rc);
-		return rc;
-	}
+                goto fail;
+        }
 	printk (KERN_INFO PRINTK_HEADER
-	    "%04X on sch %d: %04X/%02X(CU:%04X/%02X) Cyl:%d Head:%d Sec:%d\n",
+		"%04X on sch %d: %04X/%02X(CU:%04X/%02X) "
+                "Cyl:%d Head:%d Sec:%d\n",
 		device->devinfo.devno, device->devinfo.irq,
 		private->rdc_data.dev_type, private->rdc_data.dev_model,
 		private->rdc_data.cu_type, private->rdc_data.cu_model.model,
 		private->rdc_data.no_cyl, private->rdc_data.trk_per_cyl,
 		private->rdc_data.sec_per_trk);
-	rc = 0 ? 0 : read_conf_data (device->devinfo.irq, &conf_data, &conf_len, LPM_ANYPATH);
+	rc = read_conf_data (device->devinfo.irq, &conf_data, &conf_len,
+                             LPM_ANYPATH);
+
+        if (rc == -EOPNOTSUPP) {
+                rc = 0; /* this one is ok */
+        }
 	if (rc) {
-		if (rc == -EOPNOTSUPP)
-			return 0;
 		printk (KERN_WARNING PRINTK_HEADER
 			"Read configuration data returned error %d\n", rc);
-		return rc;
-	}
-	if (conf_len != sizeof (dasd_eckd_confdata_t)) {
-		printk (KERN_WARNING PRINTK_HEADER
-			"sizes of configuration data mismatch %d (read) vs %ld (expected)\n",
-			conf_len, sizeof (dasd_eckd_confdata_t));
-		return rc;
+                goto fail;
 	}
-	if (conf_data == NULL) {
+        if (conf_data == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"No configuration data retrieved\n");
-		return -ENOMEM;
-	}
-	memcpy (&private->conf_data, conf_data, sizeof (dasd_eckd_confdata_t));
-	printk (KERN_INFO PRINTK_HEADER
-                "%04X on sch %d: %04X/%02X(CU:%04X/%02X): Configuration data read\n",
-		device->devinfo.devno, device->devinfo.irq,
-		private->rdc_data.dev_type, private->rdc_data.dev_model,
-		private->rdc_data.cu_type, private->rdc_data.cu_model.model);
-	device->sizes.bp_block = 4096;
-	device->sizes.s2b_shift = 3;
-	device->sizes.blocks = (private->rdc_data.no_cyl *
-				private->rdc_data.trk_per_cyl *
-				recs_per_track (&private->rdc_data,
-						0, device->sizes.bp_block));
-	return 0;
+                goto out; /* no errror */
+	} 
+        if (conf_len != sizeof (dasd_eckd_confdata_t)) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"sizes of configuration data mismatch"
+                        "%d (read) vs %ld (expected)\n",
+			conf_len, sizeof (dasd_eckd_confdata_t));
+                goto out; /* no errror */
+	} 
+        memcpy (&private->conf_data, conf_data, 
+                sizeof (dasd_eckd_confdata_t));
+        printk (KERN_INFO PRINTK_HEADER
+                "%04X on sch %d: %04X/%02X(CU:%04X/%02X): "
+                "Configuration data read\n",
+                device->devinfo.devno, device->devinfo.irq,
+                private->rdc_data.dev_type, 
+                private->rdc_data.dev_model,
+                private->rdc_data.cu_type, 
+                private->rdc_data.cu_model.model);
+        goto out;
+ fail:
+        if ( rc ) {
+                kfree (device->private);
+                device->private = NULL;
+        }
+ out:
+	return rc;
 }
 
-#ifdef DASD_CDL
 static inline int
-dasd_eckd_cdl_reclen (dasd_device_t* device,int recid) {
-        dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-        int byt_per_blk = device->sizes.bp_block;
-        int blk_per_trk = recs_per_track (&(private->rdc_data), 0, byt_per_blk);
-        if (recid < 3) 
-                return sizes_trk0[recid];
-        if (recid < blk_per_trk)
-                return byt_per_blk;
-        if (recid < 2*blk_per_trk )
-                return LABEL_SIZE;
-        return byt_per_blk;
+dasd_eckd_cdl_reclen (dasd_device_t * device, int recid)
+{
+	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
+	int byt_per_blk = device->sizes.bp_block;
+	int blk_per_trk = recs_per_track (&(private->rdc_data), 0, byt_per_blk);
+	if (recid < 3)
+		return sizes_trk0[recid];
+	if (recid < blk_per_trk)
+		return byt_per_blk;
+	if (recid < 2 * blk_per_trk)
+		return LABEL_SIZE;
+	return byt_per_blk;
 }
-#endif
 
 static ccw_req_t *
 dasd_eckd_init_analysis (struct dasd_device_t *device)
@@ -500,76 +490,82 @@
 	ccw1_t *ccw;
 	DE_eckd_data_t *DE_data;
 	LO_eckd_data_t *LO_data;
-	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-#ifdef DASD_CDL
-        eckd_count_t *count_data = private->count_area;
-#else
-	eckd_count_t *count_data = &(private->count_area);
-#endif
-#ifdef DASD_CDL
-        cqr = ccw_alloc_request (dasd_eckd_discipline.name, 8 + 1, 
-                                 sizeof (DE_eckd_data_t) + 
-                                 2*sizeof (LO_eckd_data_t));
-#else
-	cqr = ccw_alloc_request (dasd_eckd_discipline.name, 3 + 1, 
-                                 sizeof (DE_eckd_data_t) + 
-                                 sizeof (LO_eckd_data_t));
-#endif
+	dasd_eckd_private_t *private = (dasd_eckd_private_t *)device->private;
+	eckd_count_t *count_data = private->count_area;
+
+	cqr = dasd_alloc_request (dasd_eckd_discipline.name, 8 + 1,
+				 sizeof (DE_eckd_data_t) +
+				 2 * sizeof (LO_eckd_data_t),
+                                 device);
 	if (cqr == NULL) {
-		printk (KERN_WARNING PRINTK_HEADER
-			"No memory to allocate initialization request\n");
-		return NULL;
-	} else {
-		private->init_cqr = cqr;
+                printk (KERN_WARNING PRINTK_HEADER
+                        "No memory to allocate initialization request\n");
+                goto out;
 	}
 	DE_data = cqr->data;
 	LO_data = cqr->data + sizeof (DE_eckd_data_t);
 	ccw = cqr->cpaddr;
-#ifdef DASD_CDL
-        define_extent (ccw, DE_data, 0, 2, DASD_ECKD_CCW_READ_COUNT, device);
-#else
-	define_extent (ccw, DE_data, 0, 0, DASD_ECKD_CCW_READ_COUNT, device);
-#endif
+	if (define_extent (ccw, DE_data, 0, 2, DASD_ECKD_CCW_READ_COUNT, device, cqr)) {
+                goto clear_cqr;
+        }        
 	ccw->flags |= CCW_FLAG_CC;
 	ccw++;
-#ifdef DASD_CDL
-        locate_record (ccw, LO_data++, 0, 0, 4, DASD_ECKD_CCW_READ_COUNT, device, 0);
-#else
-	locate_record (ccw, LO_data, 0, 0, 1, DASD_ECKD_CCW_READ_COUNT, device, 0);
-#endif
-#ifdef DASD_CDL
+	if (locate_record (ccw, LO_data++, 0, 0, 4, DASD_ECKD_CCW_READ_COUNT,
+                           device, 0, cqr)) {
+                goto clear_cqr;
+        }       
 	ccw->flags |= CCW_FLAG_CC;
 	ccw++;
 	ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
 	ccw->count = 8;
-        set_normalized_cda (ccw, __pa (count_data++));
-        ccw->flags |= CCW_FLAG_CC;
-        ccw++;
-        ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
-        ccw->count = 8;
-        set_normalized_cda (ccw, __pa (count_data++));
-        ccw->flags |= CCW_FLAG_CC;
-        ccw++;
-        ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
-        ccw->count = 8;
-        set_normalized_cda (ccw, __pa (count_data++));
-        ccw->flags |= CCW_FLAG_CC;
-        ccw++;
-        ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
-        ccw->count = 8;
-        set_normalized_cda (ccw, __pa (count_data++));
-        ccw->flags |= CCW_FLAG_CC;
-        ccw++;
-        locate_record (ccw, LO_data++, 2, 0, 1, DASD_ECKD_CCW_READ_COUNT, device, 0);
-#endif
-        ccw->flags |= CCW_FLAG_CC;
-        ccw++;
-        ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
-        ccw->count = 8;
-        set_normalized_cda (ccw, __pa (count_data));
+	if (dasd_set_normalized_cda (ccw, __pa (count_data++), cqr, device)) {
+                goto clear_cqr;
+        }
+	ccw->flags |= CCW_FLAG_CC;
+	ccw++;
+	ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
+	ccw->count = 8;
+	if (dasd_set_normalized_cda (ccw, __pa (count_data++), cqr, device)) {
+                goto clear_cqr;
+        }
+	ccw->flags |= CCW_FLAG_CC;
+	ccw++;
+	ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
+	ccw->count = 8;
+	if (dasd_set_normalized_cda (ccw, __pa (count_data++), cqr, device)) {
+                goto clear_cqr;
+        }
+	ccw->flags |= CCW_FLAG_CC;
+	ccw++;
+	ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
+	ccw->count = 8;
+	if (dasd_set_normalized_cda (ccw, __pa (count_data++), cqr, device)) {
+                goto clear_cqr;
+        }
+	ccw->flags |= CCW_FLAG_CC;
+	ccw++;
+	if (locate_record (ccw, LO_data++, 2, 0, 1, DASD_ECKD_CCW_READ_COUNT,
+                           device, 0, cqr)) {
+                goto clear_cqr;
+        }       
+	ccw->flags |= CCW_FLAG_CC;
+	ccw++;
+	ccw->cmd_code = DASD_ECKD_CCW_READ_COUNT;
+	ccw->count = 8;
+	if (dasd_set_normalized_cda (ccw, __pa (count_data), cqr, device)) {
+                goto clear_cqr;
+        }
 	cqr->device = device;
 	cqr->retries = 0;
 	cqr->status = CQR_STATUS_FILLED;
+        dasd_chanq_enq (&device->queue, cqr);
+        goto out;
+ clear_cqr:
+        dasd_free_request (cqr,device);
+        printk (KERN_WARNING PRINTK_HEADER
+                "No memory to allocate initialization request\n");
+        cqr=NULL;
+ out:
 	return cqr;
 }
 
@@ -578,105 +574,91 @@
 {
 	int sb, rpt;
 	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-        eckd_count_t *count_area = NULL;
-        char *cdl_msg;
-#ifdef DASD_CDL /* BAD HACK SO FIX ME UP */
-        int i;
-        private -> uses_cdl = 1;
-
-        /* Free the cqr and cleanup device->sizes */
-        dasd_chanq_deq (&device->queue, private->init_cqr);
-        ccw_free_request (private->init_cqr);
-        private->init_cqr = NULL;
-        memset (&(device->sizes), 0, sizeof (dasd_sizes_t));
-        /* Check Track 0 for Compatible Disk Layout */
-        for (i = 0; i < 3; i++) { 
-                if ((i < 3) &&
-                    ((private->count_area[i].kl != 4) ||
-                     (private->count_area[i].dl != 
-                      dasd_eckd_cdl_reclen (device,i) - 4))) {
-                        private -> uses_cdl = 0;
-                        break;
-                } 
-        }
-        if ( i == 3 ) {
-                count_area = &private->count_area[4];
-        }
-        if (private->uses_cdl == 0) { 
-                for (i = 0; i < 5; i++) {
-                        if ((private->count_area[i].kl != 0) ||
-                            (private->count_area[i].dl != 
-                             private->count_area[0].dl)) {
-                                break;
-                        }
-                }
-                if ( i == 5 ) {
-                        count_area = &private->count_area[0];
-                }
-        } else {
-                if (private->count_area[3].record == 1) {
-                        DASD_MESSAGE(KERN_WARNING,device,"%s",
-                                     "Trk 0: no records after VTOC!");
-                }
+	eckd_count_t *count_area = NULL;
+	char *cdl_msg;
+        int status;
+	int i;
+	private->uses_cdl = 1;
+        status = device->init_cqr->status;
+	dasd_chanq_deq (&device->queue, device->init_cqr);
+	dasd_free_request (device->init_cqr, device);
+	/* Free the cqr and cleanup device->sizes */
+        if ( status != CQR_STATUS_DONE ) {
+                DASD_MESSAGE (KERN_WARNING,device,"%s",
+                              "volume analysis returned fatal error");
+                return -EMEDIUMTYPE;
         }
-        if (count_area != NULL && /* we found notthing violating our disk layout */
-            count_area ->kl == 0) { 
+	/* Check Track 0 for Compatible Disk Layout */
+	for (i = 0; i < 3; i++) {
+		if ((i < 3) &&
+		    ((private->count_area[i].kl != 4) ||
+		     (private->count_area[i].dl !=
+		      dasd_eckd_cdl_reclen (device, i) - 4))) {
+			private->uses_cdl = 0;
+			break;
+		}
+	}
+	if (i == 3) {
+		count_area = &private->count_area[4];
+	}
+	if (private->uses_cdl == 0) {
+		for (i = 0; i < 5; i++) {
+			if ((private->count_area[i].kl != 0) ||
+			    (private->count_area[i].dl !=
+			     private->count_area[0].dl)) {
+				break;
+			}
+		}
+		if (i == 5) {
+			count_area = &private->count_area[0];
+		}
+	} else {
+		if (private->count_area[3].record == 1) {
+			DASD_MESSAGE (KERN_WARNING, device, "%s",
+				      "Trk 0: no records after VTOC!");
+		}
+	}
+	if (count_area != NULL &&	/* we found notthing violating our disk layout */
+	    count_area->kl == 0) {
                 /* find out blocksize */
                 switch (count_area->dl) {
                 case 512:
-                case 1024:
-                case 2048:
-                case 4096:
-                        device->sizes.bp_block = count_area->dl;
-                        break;
-                }
-        }
-#else
-	dasd_chanq_deq (&device->queue, private->init_cqr);
-	ccw_free_request (private->init_cqr);
-	private->init_cqr = NULL;
-	memset (&(device->sizes), 0, sizeof (dasd_sizes_t));
-	switch (private->count_area.dl) {
-	case 512:
-	case 1024:
-	case 2048:
-	case 4096:
-		device->sizes.bp_block = private->count_area.dl;
-		break;
+		case 1024:
+		case 2048:
+		case 4096:
+			device->sizes.bp_block = count_area->dl;
+			break;
+		}
+	}
+	if (device->sizes.bp_block == 0) {
+		DASD_MESSAGE (KERN_WARNING, device, "%s\n",
+			      "Volume has incompatible disk layout");
+		return -EMEDIUMTYPE;
 	}
-#endif
-        if ( device->sizes.bp_block == 0 ) {
-                DASD_MESSAGE(KERN_WARNING, device,"%s\n",
-                             "Volume has incompatible disk layout");
-                return -EMEDIUMTYPE;
-        }
 	device->sizes.s2b_shift = 0;	/* bits to shift 512 to get a block */
-        device->sizes.pt_block = 2;
+	device->sizes.pt_block = 2;
 	for (sb = 512; sb < device->sizes.bp_block; sb = sb << 1)
 		device->sizes.s2b_shift++;
 
 	rpt = recs_per_track (&private->rdc_data, 0, device->sizes.bp_block);
-	device->sizes.blocks = (private->rdc_data.no_cyl * 
-                                private->rdc_data.trk_per_cyl *
-                                recs_per_track (&private->rdc_data, 0, 
-                                                device->sizes.bp_block));
-#ifdef DASD_CDL
-        cdl_msg = private->uses_cdl?"compatible disk layout":"classic disk layout";
-#else
-        cdl_msg = "classic disk layout";
-#endif           
-                  
-        DASD_MESSAGE(KERN_INFO,device,"(%dkB blks): %dkB at %dkB/trk %s",
-                     (device->sizes.bp_block >> 10),
-                     (private->rdc_data.no_cyl * 
-                      private->rdc_data.trk_per_cyl *
-                      recs_per_track (&private->rdc_data, 0, 
-                                      device->sizes.bp_block) *
-                      (device->sizes.bp_block >> 9)) >> 1,
-                     (recs_per_track (&private->rdc_data, 0, 
-                                      device->sizes.bp_block) * 
-                      device->sizes.bp_block) >> 10,
-                     cdl_msg);
+	device->sizes.blocks = (private->rdc_data.no_cyl *
+				private->rdc_data.trk_per_cyl *
+				recs_per_track (&private->rdc_data, 0,
+						device->sizes.bp_block));
+	cdl_msg =
+	    private->
+	    uses_cdl ? "compatible disk layout" : "classic disk layout";
+
+	DASD_MESSAGE (KERN_INFO, device, "(%dkB blks): %dkB at %dkB/trk %s",
+		      (device->sizes.bp_block >> 10),
+		      (private->rdc_data.no_cyl *
+		       private->rdc_data.trk_per_cyl *
+		       recs_per_track (&private->rdc_data, 0,
+				       device->sizes.bp_block) *
+		       (device->sizes.bp_block >> 9)) >> 1,
+		      (recs_per_track (&private->rdc_data, 0,
+				       device->sizes.bp_block) *
+		       device->sizes.bp_block) >> 10, cdl_msg);
 	return 0;
 }
 
@@ -690,13 +672,14 @@
 	case 1024:
 	case 2048:
 	case 4096:
-		break;
+            geo->sectors = recs_per_track (&(private->rdc_data), 
+                                           0, device->sizes.bp_block);
+            break;
 	default:
-		return -EINVAL;
+            break;
 	}
 	geo->cylinders = private->rdc_data.no_cyl;
 	geo->heads = private->rdc_data.trk_per_cyl;
-	geo->sectors = recs_per_track (&(private->rdc_data), 0, device->sizes.bp_block);
 	return rc;
 }
 
@@ -713,95 +696,89 @@
 	ccw1_t *last_ccw = NULL;
 	void *last_data = NULL;
 	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-	int trk = fdata->start_unit;
-	int bs = fdata->blksize == DASD_FORMAT_DEFAULT_BLOCKSIZE ? 4096 : fdata->blksize;
-	int flags = fdata->intensity == DASD_FORMAT_DEFAULT_INTENSITY ? 0 : fdata->intensity;
-
-	int rpt = recs_per_track (&(private->rdc_data), 0, bs);
-	int cyl = trk / private->rdc_data.trk_per_cyl;
-	int head = trk % private->rdc_data.trk_per_cyl;
+
+	int rpt = recs_per_track (&(private->rdc_data), 0, fdata->blksize);
+	int cyl = fdata->start_unit / private->rdc_data.trk_per_cyl;
+	int head = fdata->start_unit % private->rdc_data.trk_per_cyl;
 	int wrccws = rpt;
 	int datasize = sizeof (DE_eckd_data_t) + sizeof (LO_eckd_data_t);
-#ifdef DASD_CDL
-        int formatCDL=0;
-#endif
-
-	if (((fdata->stop_unit == DASD_FORMAT_DEFAULT_STOP_UNIT) &&
-	 trk >= (private->rdc_data.no_cyl * private->rdc_data.trk_per_cyl)) ||
-	    ((fdata->stop_unit != DASD_FORMAT_DEFAULT_STOP_UNIT) &&
-	     trk > fdata->stop_unit)) {
-		DASD_MESSAGE(KERN_INFO, device,"Track %d reached! ending.", trk);
+        
+	if (fdata->start_unit >= (private->rdc_data.no_cyl * private->rdc_data.trk_per_cyl)){
+                DASD_MESSAGE (KERN_INFO, device, "Track no %d too big!", fdata->start_unit);
+                return NULL;
+        }
+        if ( fdata->start_unit > fdata->stop_unit) {
+                DASD_MESSAGE (KERN_INFO, device, "Track %d reached! ending.",
+                              fdata->start_unit);
 		return NULL;
 	}
-	switch (bs) {
+	switch (fdata->blksize) {
 	case 512:
 	case 1024:
 	case 2048:
 	case 4096:
 		break;
 	default:
-		printk (KERN_WARNING PRINTK_HEADER "Invalid blocksize %d...terminating!\n", bs);
+		printk (KERN_WARNING PRINTK_HEADER
+			"Invalid blocksize %d...terminating!\n", fdata->blksize);
 		return NULL;
 	}
-	switch (flags) {
+	switch (fdata->intensity) {
 	case 0x00:
 	case 0x01:
 	case 0x03:
 	case 0x04:		/* make track invalid */
-                break;
-#ifdef DASD_CDL /* Format compatible disk Layout */
-        case 0x08:
-        case 0x09:
-        case 0x0b:
-        case 0x0c:
-                formatCDL=1;
+	case 0x08:
+	case 0x09:
+	case 0x0b:
+	case 0x0c:
 		break;
-#endif
 	default:
-		printk (KERN_WARNING PRINTK_HEADER "Invalid flags 0x%x...terminating!\n", flags);
+		printk (KERN_WARNING PRINTK_HEADER
+			"Invalid flags 0x%x...terminating!\n", fdata->intensity);
 		return NULL;
 	}
 
 	/* print status line */
 	if ((private->rdc_data.no_cyl < 20) ?
-	    (trk % private->rdc_data.no_cyl == 0) :
-	    (trk % private->rdc_data.no_cyl == 0 &&
-	     (trk / private->rdc_data.no_cyl) %
+	    (fdata->start_unit % private->rdc_data.no_cyl == 0) :
+	    (fdata->start_unit % private->rdc_data.no_cyl == 0 &&
+	     (fdata->start_unit / private->rdc_data.no_cyl) %
 	     (private->rdc_data.no_cyl / 20))) {
-		DASD_MESSAGE(KERN_INFO, device, "Format Cylinder: %d Flags: %d\n",
-			trk / private->rdc_data.trk_per_cyl,
-			flags);
+		DASD_MESSAGE (KERN_INFO, device,
+			      "Format Cylinder: %d Flags: %d\n",
+			      fdata->start_unit / private->rdc_data.trk_per_cyl, fdata->intensity);
 	}
-	if (flags & 0x04) {
-                rpt = 1;
+	if ((fdata->intensity & ~0x8) & 0x04) {
 		wrccws = 1;
-                bs = 8;
+		rpt = 1;
 	} else {
-		if (flags & 0x1) {
+		if (fdata->intensity & 0x1) {
 			wrccws++;
 			datasize += sizeof (eckd_count_t);
 		}
-		if (flags & 0x2) {
+		if (fdata->intensity & 0x2) {
 			wrccws++;
 			datasize += sizeof (eckd_home_t);
 		}
 	}
-	fcp = ccw_alloc_request (dasd_eckd_discipline.name,
+	fcp = dasd_alloc_request (dasd_eckd_discipline.name,
 				 wrccws + 2 + 1,
-				 datasize + rpt * sizeof (eckd_count_t));
+				 datasize + rpt * sizeof (eckd_count_t),
+                                 device );
 	if (fcp != NULL) {
 		fcp->device = device;
-                fcp->retries = 2;       /* set retry counter to enable ERP */
+		fcp->retries = 2;	/* set retry counter to enable ERP */
 		last_data = fcp->data;
 		DE_data = (DE_eckd_data_t *) last_data;
 		last_data = (void *) (DE_data + 1);
 		LO_data = (LO_eckd_data_t *) last_data;
 		last_data = (void *) (LO_data + 1);
-		if (flags & 0x2) {
+		if (fdata->intensity & 0x2) {
 			ha_data = (eckd_home_t *) last_data;
 			last_data = (void *) (ha_data + 1);
 		}
-		if (flags & 0x1) {
+		if (fdata->intensity & 0x1) {
 			r0_data = (eckd_count_t *) last_data;
 			last_data = (void *) (r0_data + 1);
 		}
@@ -809,63 +786,65 @@
 
 		last_ccw = fcp->cpaddr;
 
-		switch (flags) {
+		switch (fdata->intensity & ~0x08) {
 		case 0x03:
-                case 0x0b:
-			define_extent (last_ccw, DE_data, trk, trk,
-				    DASD_ECKD_CCW_WRITE_HOME_ADDRESS, device);
+			if (define_extent (last_ccw, DE_data, fdata->start_unit, fdata->start_unit,
+				       DASD_ECKD_CCW_WRITE_HOME_ADDRESS,
+                                           device, fcp)) {
+                                goto clear_fcp;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
-			locate_record (last_ccw, LO_data, trk, 0, wrccws,
-				       DASD_ECKD_CCW_WRITE_HOME_ADDRESS, device, device->sizes.bp_block);
+			if (locate_record (last_ccw, LO_data, fdata->start_unit, 0, wrccws,
+				       DASD_ECKD_CCW_WRITE_HOME_ADDRESS, device,
+                                           device->sizes.bp_block, fcp)) {
+                                goto clear_fcp;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
 			break;
 		case 0x01:
-                case 0x09:
-			define_extent (last_ccw, DE_data, trk, trk,
-				     DASD_ECKD_CCW_WRITE_RECORD_ZERO, device);
+			if (define_extent (last_ccw, DE_data, fdata->start_unit, fdata->start_unit,
+                                           DASD_ECKD_CCW_WRITE_RECORD_ZERO, device, fcp)) {
+                                goto clear_fcp;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
-			locate_record (last_ccw, LO_data, trk, 0, wrccws,
-				       DASD_ECKD_CCW_WRITE_RECORD_ZERO, device, device->sizes.bp_block);
+			if (locate_record (last_ccw, LO_data, fdata->start_unit, 0, wrccws,
+				       DASD_ECKD_CCW_WRITE_RECORD_ZERO, device,
+                                           device->sizes.bp_block, fcp)) {
+                                goto clear_fcp;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
 			memset (r0_data, 0, sizeof (eckd_count_t));
 			break;
-		case 0x00:
-                case 0x08:
-			define_extent (last_ccw, DE_data, trk, trk,
-				       DASD_ECKD_CCW_WRITE_CKD, device);
-			last_ccw->flags |= CCW_FLAG_CC;
-			last_ccw++;
-			locate_record (last_ccw, LO_data, trk, 0, wrccws,
-				       DASD_ECKD_CCW_WRITE_CKD, device, device->sizes.bp_block);
-			LO_data->length = bs;
-			last_ccw->flags |= CCW_FLAG_CC;
-			last_ccw++;
-			break;
 		case 0x04:
-                case 0x0c:
-			define_extent (last_ccw, DE_data, trk, trk,
-				       DASD_ECKD_CCW_WRITE_CKD, device);
+                        fdata->blksize = 8;
+		case 0x00:
+			if (define_extent (last_ccw, DE_data, fdata->start_unit, fdata->start_unit,
+                                           DASD_ECKD_CCW_WRITE_CKD, device, fcp)) {
+                                dasd_free_request (fcp, device);
+                                return NULL;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
-			locate_record (last_ccw, LO_data, trk, 0, wrccws,
-				       DASD_ECKD_CCW_WRITE_CKD, device, 0);
-			LO_data->length = bs;
+			if (locate_record (last_ccw, LO_data, fdata->start_unit, 0, wrccws,
+                                           DASD_ECKD_CCW_WRITE_CKD, device, fdata->blksize, fcp)) {
+                                goto clear_fcp;
+                        }
 			last_ccw->flags |= CCW_FLAG_CC;
 			last_ccw++;
 			break;
 		default:
-			PRINT_WARN ("Unknown format flags...%d\n", flags);
+			PRINT_WARN ("Unknown format flags...%d\n", fdata->intensity);
 			return NULL;
 		}
-		if (flags & 0x02) {
-			PRINT_WARN ("Unsupported format flag...%d\n", flags);
+		if (fdata->intensity & 0x02) {
+			PRINT_WARN ("Unsupported format flag...%d\n", fdata->intensity);
 			return NULL;
 		}
-		if (flags & 0x01) {	/* write record zero */
+		if (fdata->intensity & 0x01) {	/* write record zero */
 			r0_data->cyl = cyl;
 			r0_data->head = head;
 			r0_data->record = 0;
@@ -874,49 +853,73 @@
 			last_ccw->cmd_code = DASD_ECKD_CCW_WRITE_RECORD_ZERO;
 			last_ccw->count = 8;
 			last_ccw->flags |= CCW_FLAG_CC | CCW_FLAG_SLI;
-			set_normalized_cda (last_ccw, __pa (r0_data));
+			if (dasd_set_normalized_cda (last_ccw, __pa (r0_data), fcp, device)) {
+                                goto clear_fcp;
+                        }
 			last_ccw++;
 		}
-		/* write remaining records */
-		for (i = 0; i < rpt; i++) {
-			memset (ct_data + i, 0, sizeof (eckd_count_t));
-			(ct_data + i)->cyl = cyl;
-			(ct_data + i)->head = head;
-			(ct_data + i)->record = i + 1;
-			(ct_data + i)->kl = 0;
-#ifdef DASD_CDL
-                        if (formatCDL) { 
-                            // special handling when formatting CDL
-                            switch (trk) {
-                            case 0:
-                                if (i<3) {
-                                    (ct_data + i)->kl = 4;
-                                    (ct_data + i)->dl = sizes_trk0[i]-4;
-                                } else 
-                                    (ct_data + i)->dl = bs;
-                                break;
-                            case 1:
-                                (ct_data + i)->kl = 44;
-                                (ct_data + i)->dl = LABEL_SIZE-44;
-                                break;
-                            default:
-                                (ct_data + i)->dl = bs;
-                                break;
-                            }
-                        }
-                        else
-#endif                            
-                        (ct_data + i)->dl = bs;
+		if ((fdata->intensity & ~0x08) & 0x04) {	/* erase track */
+			memset (ct_data, 0, sizeof (eckd_count_t));
+			ct_data->cyl = cyl;
+			ct_data->head = head;
+			ct_data->record = 1;
+			ct_data->kl = 0;
+			ct_data->dl = 0;
 			last_ccw->cmd_code = DASD_ECKD_CCW_WRITE_CKD;
-			last_ccw->flags |= CCW_FLAG_CC | CCW_FLAG_SLI;
 			last_ccw->count = 8;
-			set_normalized_cda (last_ccw, __pa (ct_data + i));
+			last_ccw->flags |= CCW_FLAG_CC | CCW_FLAG_SLI;
+			if (dasd_set_normalized_cda (last_ccw, __pa (ct_data), fcp, device)) {
+                                goto clear_fcp;
+                        }
 			last_ccw++;
+		} else {	/* write remaining records */
+			for (i = 0; i < rpt; i++) {
+				memset (ct_data + i, 0, sizeof (eckd_count_t));
+				(ct_data + i)->cyl = cyl;
+				(ct_data + i)->head = head;
+				(ct_data + i)->record = i + 1;
+				(ct_data + i)->kl = 0;
+				if (fdata->intensity & 0x08) {
+					// special handling when formatting CDL
+					switch (fdata->start_unit) {
+					case 0:
+						if (i < 3) {
+							(ct_data + i)->kl = 4;
+							
+							    (ct_data + i)->dl =
+							    sizes_trk0[i] - 4;
+						} else
+							(ct_data + i)->dl = fdata->blksize;
+						break;
+					case 1:
+						(ct_data + i)->kl = 44;
+						(ct_data + i)->dl = LABEL_SIZE - 44;
+						break;
+					default:
+						(ct_data + i)->dl = fdata->blksize;
+						break;
+					}
+				} else
+					(ct_data + i)->dl = fdata->blksize;
+				last_ccw->cmd_code = DASD_ECKD_CCW_WRITE_CKD;
+				last_ccw->flags |= CCW_FLAG_CC | CCW_FLAG_SLI;
+				last_ccw->count = 8;
+				if (dasd_set_normalized_cda (last_ccw,
+                                                             __pa (ct_data + i), fcp, device)) {
+                                goto clear_fcp;
+                                }
+				last_ccw++;
+			}
 		}
 		(last_ccw - 1)->flags &= ~(CCW_FLAG_CC | CCW_FLAG_DC);
 		fcp->device = device;
 		fcp->status = CQR_STATUS_FILLED;
 	}
+        goto out;
+ clear_fcp:
+        dasd_free_request (fcp, device);
+        fcp=NULL;
+ out:
 	return fcp;
 }
 
@@ -927,7 +930,7 @@
 
 	if (stat->cstat == 0x00 &&
 	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
-		return dasd_era_none;
+		    return dasd_era_none;
 
 	switch (device->devinfo.sid_data.cu_type) {
 	case 0x3990:
@@ -946,56 +949,56 @@
 dasd_eckd_erp_action (ccw_req_t * cqr)
 {
 	dasd_device_t *device = (dasd_device_t *) cqr->device;
-        
+
 	switch (device->devinfo.sid_data.cu_type) {
 	case 0x3990:
 	case 0x2105:
 		return dasd_3990_erp_action;
 	case 0x9343:
-                /* Return dasd_9343_erp_action; */
+		/* Return dasd_9343_erp_action; */
 	default:
-		return default_erp_action;
+		return dasd_default_erp_action;
 	}
 }
 
 static dasd_erp_postaction_fn_t
 dasd_eckd_erp_postaction (ccw_req_t * cqr)
 {
-	return default_erp_postaction;
+	return dasd_default_erp_postaction;
 }
 
 
-#ifdef DASD_CDL
 inline unsigned char
-dasd_eckd_cdl_cmd(dasd_device_t *device,int recid,int cmd) {
-    dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
-    int byt_per_blk = device->sizes.bp_block;
-    int blk_per_trk = recs_per_track (&(private->rdc_data), 0, byt_per_blk);
-    switch (cmd) {
-    case READ:
-        if (recid < 3) 
-            return DASD_ECKD_CCW_READ_KD_MT;
-        if (recid < blk_per_trk)
-            return DASD_ECKD_CCW_READ_MT;
-        if (recid < 2*blk_per_trk)
-            return DASD_ECKD_CCW_READ_KD_MT;
-        return DASD_ECKD_CCW_READ_MT;
-        break;
-    case WRITE:
-        if (recid < 3)
-            return DASD_ECKD_CCW_WRITE_KD_MT;
-        if (recid < blk_per_trk)
-            return DASD_ECKD_CCW_WRITE_MT;
-        if (recid < 2*blk_per_trk)
-            return DASD_ECKD_CCW_WRITE_KD_MT;
-        return DASD_ECKD_CCW_WRITE_MT;
-        break;
-    default:
-        BUG();
-    }
-    return 0; // never executed
+dasd_eckd_cdl_cmd (dasd_device_t * device, int recid, int cmd)
+{
+	dasd_eckd_private_t *private = (dasd_eckd_private_t *) device->private;
+	int byt_per_blk = device->sizes.bp_block;
+	int blk_per_trk = recs_per_track (&(private->rdc_data), 0, byt_per_blk);
+	switch (cmd) {
+	case READ:
+		if (recid < 3)
+			return DASD_ECKD_CCW_READ_KD_MT;
+		if (recid < blk_per_trk)
+			return DASD_ECKD_CCW_READ_MT;
+		if (recid < 2 * blk_per_trk)
+			return DASD_ECKD_CCW_READ_KD_MT;
+		return DASD_ECKD_CCW_READ_MT;
+		break;
+	case WRITE:
+		if (recid < 3)
+			return DASD_ECKD_CCW_WRITE_KD_MT;
+		if (recid < blk_per_trk)
+			return DASD_ECKD_CCW_WRITE_MT;
+		if (recid < 2 * blk_per_trk)
+			return DASD_ECKD_CCW_WRITE_KD_MT;
+		return DASD_ECKD_CCW_WRITE_MT;
+		break;
+	default:
+		BUG ();
+	}
+	return 0;		// never executed
 }
-#endif
+
 
 static ccw_req_t *
 dasd_eckd_build_cp_from_req (dasd_device_t * device, struct request *req)
@@ -1014,11 +1017,9 @@
 	int blk_per_trk = recs_per_track (&(private->rdc_data), 0, byt_per_blk);
 	int btrk = (req->sector >> shift) / blk_per_trk;
 	int etrk = ((req->sector + req->nr_sectors - 1) >> shift) / blk_per_trk;
-#ifdef DASD_CDL
-        int recid = req->sector >> shift;
-        int locate4k_set=0;
-        int nlocs=0;
-#endif
+	int recid = req->sector >> shift;
+	int locate4k_set = 0;
+	int nlocs = 0;
 
 	if (req->cmd == READ) {
 		rw_cmd = DASD_ECKD_CCW_READ_MT;
@@ -1032,142 +1033,84 @@
 	/* count bhs to prevent errors, when bh smaller than block */
 	bhct = 0;
 	for (bh = req->bh; bh; bh = bh->b_reqnext) {
-		if (bh->b_size > byt_per_blk)
-			for (size = 0; size < bh->b_size; size += byt_per_blk)
-				bhct++;
-		else
-			bhct++;
+		if (bh->b_size < byt_per_blk)
+                        BUG();
+                bhct+= bh->b_size >> (device->sizes.s2b_shift+9);
+	}
+	if (btrk < 2 && private->uses_cdl) {
+		if (etrk < 2)
+                        nlocs = bhct;
+                else
+                        nlocs = 2 * blk_per_trk - recid;
 	}
-#ifndef DASD_CDL
-	rw_cp = dasd_alloc_request (dasd_eckd_discipline.name,
-				    2 + bhct + 1,
-				    sizeof (DE_eckd_data_t) +
-				    sizeof (LO_eckd_data_t));
-#else
-        if (btrk<2 && private->uses_cdl) {
-            nlocs+= 2*blk_per_trk-recid;
-            if (etrk<2)
-                nlocs-=2*blk_per_trk-((req->sector + req->nr_sectors - 1) >> shift);
-        }
-        rw_cp = dasd_alloc_request (dasd_eckd_discipline.name,
+	rw_cp = dasd_alloc_request (dasd_eckd_discipline.name, 
                                     2 + nlocs + bhct + 1,
-                                    sizeof (DE_eckd_data_t) +
-                                    (1+nlocs)*sizeof (LO_eckd_data_t));
-#endif
+                                    sizeof (DE_eckd_data_t) + (1 +
+                                                               nlocs) *
+                                    sizeof (LO_eckd_data_t),
+                                    device);
 	if (!rw_cp) {
 		return NULL;
 	}
 	DE_data = rw_cp->data;
 	LO_data = rw_cp->data + sizeof (DE_eckd_data_t);
 	ccw = rw_cp->cpaddr;
-	define_extent (ccw, DE_data, btrk, etrk, rw_cmd, device);
-	ccw->flags |= CCW_FLAG_CC;
-#ifndef DASD_CDL
-	ccw++;
-        locate_record (ccw, LO_data, btrk, (req->sector >> shift) % blk_per_trk + 1,
-                       req->nr_sectors >> shift, rw_cmd, device, device->sizes.bp_block);
+	if (define_extent (ccw, DE_data, btrk, etrk, rw_cmd, device, rw_cp)) {
+                goto clear_rw_cp;
+        }
 	ccw->flags |= CCW_FLAG_CC;
-#endif
 	for (bh = req->bh; bh != NULL;) {
-		if (bh->b_size > byt_per_blk) {
-			for (size = 0; size < bh->b_size; size += byt_per_blk) {
-#ifdef DASD_CDL
-                                if (!locate4k_set) {
-                                    // we need to chain a locate record before our rw-ccw
-                                    ccw++;
-                                    if ((recid/blk_per_trk)<2 && private->uses_cdl) {
+                for (size = 0; size < bh->b_size; size += byt_per_blk) {
+                        if (!locate4k_set) {
+                                // we need to chain a locate record before our rw-ccw
+                                ccw++;
+                                if ((recid / blk_per_trk) < 2
+                                    && private->uses_cdl) {
                                         /* Do a locate record for our special blocks */
-                                        locate_record (ccw, LO_data++, recid/blk_per_trk, 
-                                                       recid % blk_per_trk + 1, 1, 
-                                                       dasd_eckd_cdl_cmd(device,recid,req->cmd), 
-                                                       device, 
-                                                       dasd_eckd_cdl_reclen(device,recid));
-                                    } else {
-                                        // Do a locate record for standard blocks */
-                                        locate_record (ccw, LO_data++, recid/blk_per_trk,
+                                        int cmd = dasd_eckd_cdl_cmd (device,recid, req->cmd);
+                                        if (locate_record (ccw, 
+                                                       LO_data++,
+                                                       recid / blk_per_trk, 
                                                        recid % blk_per_trk + 1, 
-                                                       (((req->sector + req->nr_sectors) >> shift)-recid),
-                                                       rw_cmd,device, device->sizes.bp_block);
-                                        locate4k_set=1;
-                                    }                                        
-                                    ccw->flags |= CCW_FLAG_CC;
+                                                       1, cmd, device,
+                                                           dasd_eckd_cdl_reclen(device, recid), rw_cp)) {
+                                                goto clear_rw_cp;
+                                        }
+                                } else {
+                                        // Do a locate record for standard blocks */
+                                        if (locate_record (ccw, 
+                                                       LO_data++,
+                                                       recid /blk_per_trk,
+                                                       recid %blk_per_trk + 1,
+                                                       (((req->sector +
+                                                          req->nr_sectors) >>
+                                                         shift) - recid), 
+                                                       rw_cmd, device,
+                                                           device->sizes.bp_block, rw_cp)) {
+                                                goto clear_rw_cp;
+                                        }
+                                        locate4k_set = 1;
                                 }
-#endif
-				ccw++;
-#ifndef DASD_CDL
-				ccw->flags |= CCW_FLAG_CC;
-				ccw->cmd_code= rw_cmd;
-				ccw->count = bh->b_size;
-#else
                                 ccw->flags |= CCW_FLAG_CC;
-                                ccw->cmd_code=locate4k_set?rw_cmd:
-                                    dasd_eckd_cdl_cmd(device,recid,req->cmd);
-                                ccw->count =locate4k_set?bh->b_size:
-                                    dasd_eckd_cdl_reclen(device,recid);
-#endif
-				set_normalized_cda (ccw, __pa (bh->b_data));
-				size += bh->b_size;
-				bh = bh->b_reqnext;
-#ifdef DASD_CDL
-                                recid++;
-#endif
-			}
-			bh = bh->b_reqnext;
-		} else {	/* group N bhs to fit into byt_per_blk */
-			for (size = 0; bh != NULL && size < byt_per_blk;) {
-#ifdef DASD_CDL
-                                if (!locate4k_set) {
-                                    // we need to chain a locate record before our rw-ccw
-                                    ccw++;
-                                    if ((recid/blk_per_trk)<2 && private->uses_cdl) {
-                                        /* Do a locate record for our special blocks */
-                                        locate_record (ccw, LO_data++, recid/blk_per_trk, 
-                                                       recid % blk_per_trk + 1, 1, 
-                                                       dasd_eckd_cdl_cmd(device,recid,req->cmd), 
-                                                       device, 
-                                                       dasd_eckd_cdl_reclen(device,recid));
-                                    } else {
-                                        // Do a locate record for standard blocks */
-                                        locate_record (ccw, LO_data++, recid/blk_per_trk,
-                                                       recid % blk_per_trk + 1, 
-                                                       (((req->sector + req->nr_sectors) >> shift)-recid),
-                                                       rw_cmd,device, device->sizes.bp_block);
-                                        locate4k_set=1;
-                                    }                                        
-                                    ccw->flags |= CCW_FLAG_CC;
+                        }
+                        ccw++;
+                        ccw->flags |= CCW_FLAG_CC;
+                        ccw->cmd_code = locate4k_set ? rw_cmd :
+                                dasd_eckd_cdl_cmd (device, recid, req->cmd);
+                        ccw->count = byt_per_blk;
+                        if (!locate4k_set) {
+                                ccw->count = dasd_eckd_cdl_reclen (device,recid);
+                                if (ccw->count < byt_per_blk) {
+                                    memset (bh->b_data + size + ccw->count,
+                                            0xE5, byt_per_blk - ccw->count);
                                 }
-#endif
-				ccw++;
-#ifndef DASD_CDL
-				ccw->flags |= CCW_FLAG_DC;
-				ccw->cmd_code= rw_cmd;
-				ccw->count = bh->b_size;
-#else
-                                ccw->flags |= locate4k_set?CCW_FLAG_DC:CCW_FLAG_CC;
-                                ccw->cmd_code=locate4k_set?rw_cmd:
-                                    dasd_eckd_cdl_cmd(device,recid,req->cmd);
-                                ccw->count =locate4k_set?bh->b_size:
-                                    dasd_eckd_cdl_reclen(device,recid);
-#endif
-				set_normalized_cda (ccw, __pa (bh->b_data));
-				size += bh->b_size;
-				bh = bh->b_reqnext;
-#ifdef DASD_CDL
-                                recid++;
-#endif
-			}
-			if (size != byt_per_blk) {
-				PRINT_WARN ("Cannot fulfill small request %ld vs. %d (%ld sects)\n",
-					    size,
-					    byt_per_blk,
-					    req->nr_sectors);
-
-				ccw_free_request (rw_cp);
-				return NULL;
-			}
-			ccw->flags &= ~CCW_FLAG_DC;
-			ccw->flags |= CCW_FLAG_CC;
-		}
+                        }
+                        if (dasd_set_normalized_cda (ccw, __pa (bh->b_data+size), rw_cp, device)) {
+                                goto clear_rw_cp;
+                        }
+                        recid++;
+                }
+                bh = bh->b_reqnext;
 	}
 	ccw->flags &= ~(CCW_FLAG_DC | CCW_FLAG_CC);
 	rw_cp->device = device;
@@ -1176,11 +1119,15 @@
 	rw_cp->lpm = LPM_ANYPATH;
 	rw_cp->retries = 2;
 	asm volatile ("STCK %0":"=m" (rw_cp->buildclk));
-	check_then_set (&rw_cp->status,
-				       CQR_STATUS_EMPTY,
-				       CQR_STATUS_FILLED);
+	check_then_set (&rw_cp->status, CQR_STATUS_EMPTY, CQR_STATUS_FILLED);
+        goto out;
+ clear_rw_cp:
+        dasd_free_request (rw_cp, device);
+        rw_cp=NULL;
+ out:
 	return rw_cp;
 }
+
 #if 0
 int
 dasd_eckd_cleanup_request (ccw_req_t * cqr)
@@ -1197,7 +1144,8 @@
 				ccw->flags |= CCW_FLAG_CC;
 				ccw->cmd_code = rw_cmd;
 				ccw->count = byt_per_blk;
-				set_normalized_cda (ccw, __pa (bh->b_data + size));
+				set_normalized_cda (ccw,
+						    __pa (bh->b_data + size));
 			}
 			bh = bh->b_reqnext;
 		} else {	/* group N bhs to fit into byt_per_blk */
@@ -1215,106 +1163,179 @@
 	return ret;
 }
 #endif
+
+/*
+ * DASD_ECKD_RESERVE
+ *
+ * DESCRIPTION
+ *    Buils a channel programm to reserve a device.
+ *    Options are set to 'synchronous wait for interrupt' and
+ *    'timeout the request'. This leads to an terminate IO if 
+ *    the interrupt is outstanding for a certain time. 
+ */
 ccw_req_t *
 dasd_eckd_reserve (struct dasd_device_t * device)
 {
-	ccw_req_t *cqr = ccw_alloc_request (dasd_eckd_discipline.name, 1 + 1, 0);
+	ccw_req_t *cqr =
+	    dasd_alloc_request (dasd_eckd_discipline.name, 1 + 1, 0, device);
 	if (cqr == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"No memory to allocate initialization request\n");
 		return NULL;
 	}
 	cqr->cpaddr->cmd_code = DASD_ECKD_CCW_RESERVE;
-	cqr->device = device;
+	cqr->device  = device;
 	cqr->retries = 0;
-	cqr->status = CQR_STATUS_FILLED;
-	return cqr;
+	cqr->expires = 10 * TOD_SEC;
+        cqr->options = (DOIO_WAIT_FOR_INTERRUPT | DOIO_TIMEOUT); /* timeout reqest */
+	cqr->status  = CQR_STATUS_FILLED;
+	return cqr; 
 }
 
+/*
+ * DASD_ECKD_RELEASE
+ *
+ * DESCRIPTION
+ *    Buils a channel programm to releases a prior reserved 
+ *    (see dasd_eckd_reserve) device.
+ */
 ccw_req_t *
 dasd_eckd_release (struct dasd_device_t * device)
 {
-	ccw_req_t *cqr = ccw_alloc_request (dasd_eckd_discipline.name, 1 + 1, 0);
+	ccw_req_t *cqr =
+	    dasd_alloc_request (dasd_eckd_discipline.name, 1 + 1, 0, device);
 	if (cqr == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
 			"No memory to allocate initialization request\n");
 		return NULL;
 	}
 	cqr->cpaddr->cmd_code = DASD_ECKD_CCW_RELEASE;
-	cqr->device = device;
+	cqr->device  = device;
 	cqr->retries = 0;
-	cqr->status = CQR_STATUS_FILLED;
+	cqr->expires = 10 * TOD_SEC;
+        cqr->options = (DOIO_WAIT_FOR_INTERRUPT | DOIO_TIMEOUT); /* timeout reqest */
+	cqr->status  = CQR_STATUS_FILLED;
 	return cqr;
 
 }
 
+/*
+ * DASD_ECKD_STEAL_LOCK
+ *
+ * DESCRIPTION
+ *    Buils a channel programm to break a device's reservation. 
+ *    (unconditional reserve)
+ */
+ccw_req_t *
+dasd_eckd_steal_lock (struct dasd_device_t * device)
+{
+	ccw_req_t *cqr =
+	    dasd_alloc_request (dasd_eckd_discipline.name, 1 + 1, 0, device);
+	if (cqr == NULL) {
+		printk (KERN_WARNING PRINTK_HEADER
+			"No memory to allocate initialization request\n");
+		return NULL;
+	}
+	cqr->cpaddr->cmd_code = DASD_ECKD_CCW_SLCK;
+	cqr->device  = device;
+	cqr->retries = 0;
+	cqr->expires = 10 * TOD_SEC;
+        cqr->options = (DOIO_WAIT_FOR_INTERRUPT | DOIO_TIMEOUT); /* timeout reqest */
+	cqr->status  = CQR_STATUS_FILLED;
+	return cqr;
+}
+
 static inline ccw1_t *
 dasd_eckd_find_cmd (ccw_req_t * cqr, int cmd)
 {
 	ccw1_t *cp;
 
 	cp = cqr->cpaddr;
-        do {
+	do {
 		if (cp->cmd_code == cmd)
 			return cp;
 		if (cp->cmd_code == CCW_CMD_TIC) {
-			cp = (ccw1_t *)cp->cda;
-                        continue;
-		} 
-                if ( cp->flags & (CCW_FLAG_DC | CCW_FLAG_CC) ) {
-                        cp ++;
-                        continue;
-		}
-                break;
-	} while ( 1 );
-        return NULL;
+			cp = (ccw1_t *) (long) cp->cda;
+			continue;
+		}
+		if (cp->flags & (CCW_FLAG_DC | CCW_FLAG_CC)) {
+			cp++;
+			continue;
+		}
+		break;
+	} while (1);
+	return NULL;
 }
 
-ccw_req_t *
-dasd_eckd_merge_cp ( dasd_device_t *device )
+static ccw_req_t *
+dasd_eckd_merge_cp (dasd_device_t * device)
 {
-        return NULL;
+	return NULL;
 }
 
-static char *
-dasd_eckd_dump_sense (struct dasd_device_t *device, ccw_req_t * req)
+static int
+dasd_eckd_fill_info (dasd_device_t * device, dasd_information_t * info)
 {
+	int rc = 0;
+	info->label_block = 2;
+	if (((dasd_eckd_private_t *) device->private)->uses_cdl)
+		info->FBA_layout = 0;
+	else
+		info->FBA_layout = 1;
+	info->characteristics_size = sizeof (dasd_eckd_characteristics_t);
+	memcpy (info->characteristics,
+		&((dasd_eckd_private_t *) device->private)->rdc_data,
+		sizeof (dasd_eckd_characteristics_t));
+	info->confdata_size = sizeof (dasd_eckd_confdata_t);
+	memcpy (info->configuration_data,
+		&((dasd_eckd_private_t *) device->private)->conf_data,
+		sizeof (dasd_eckd_confdata_t));
+	return rc;
+}
+
+static char*
+dasd_eckd_dump_sense (struct dasd_device_t *device, 
+                      ccw_req_t            *req)
+{
+
 	char *page = (char *) get_free_page (GFP_ATOMIC);
 	devstat_t *stat = &device->dev_status;
 	char *sense = stat->ii.sense.data;
 	int len, sl, sct;
 
 	if (page == NULL) {
+                printk (KERN_ERR PRINTK_HEADER
+                        "No memory to dump sense data\n");
 		return NULL;
 	}
-	len = sprintf (page, KERN_WARNING PRINTK_HEADER
+
+	len = sprintf (page, KERN_ERR PRINTK_HEADER
 		       "device %04X on irq %d: I/O status report:\n",
 		       device->devinfo.devno, device->devinfo.irq);
-	len += sprintf (page + len, KERN_WARNING PRINTK_HEADER
+	len += sprintf (page + len, KERN_ERR PRINTK_HEADER
 			"in req: %p CS: 0x%02X DS: 0x%02X\n",
 			req, stat->cstat, stat->dstat);
-	len += sprintf (page + len, KERN_WARNING PRINTK_HEADER
-			"Failing CCW: %p\n", (void *) stat->cpa);
-        {
-            ccw1_t *act = req -> cpaddr;
-            int i = req -> cplength;
-            do {
-#ifdef ERP_DEBUB
-                printk ( KERN_INFO "CCW %p: %08X %08X\n", 
-                         act,((int*)act)[0],((int*)act)[1]);
-                printk ( KERN_INFO "DAT: %08X %08X %08X %08X\n", 
-                         ((int*)act->cda)[0],((int*)act->cda)[1],
-                         ((int*)act->cda)[2],((int*)act->cda)[3]);
-#endif /* ERP_DEBUG */
-                act ++;
-            } while ( --i );
-        }
+	len += sprintf (page + len, KERN_ERR PRINTK_HEADER
+			"Failing CCW: %p\n", (void *) (long) stat->cpa);
+	{
+		ccw1_t *act = req->cpaddr;
+		int i = req->cplength;
+		do {
+#ifdef ERP_DEBUG
+			printk (KERN_ERR "CCW %p: %08X %08X\n",
+				act, ((int *) act)[0], ((int *) act)[1]);
+			printk (KERN_ERR "DAT: %08X %08X %08X %08X\n",
+				((int *) act->cda)[0], ((int *) act->cda)[1],
+				((int *) act->cda)[2], ((int *) act->cda)[3]);
+#endif				/* ERP_DEBUG */
+			act++;
+		} while (--i);
+	}
 	if (stat->flag & DEVSTAT_FLAG_SENSE_AVAIL) {
 		for (sl = 0; sl < 4; sl++) {
-			len += sprintf (page + len, KERN_WARNING PRINTK_HEADER
+			len += sprintf (page + len, KERN_ERR PRINTK_HEADER
 					"Sense(hex) %2d-%2d:",
-					(8 * sl),
-					((8 * sl) + 7));
+					(8 * sl), ((8 * sl) + 7));
 
 			for (sct = 0; sct < 8; sct++) {
 				len += sprintf (page + len, " %02x",
@@ -1325,22 +1346,29 @@
 
 		if (sense[27] & DASD_SENSE_BIT_0) {
 			/* 24 Byte Sense Data */
-			len += sprintf (page + len, KERN_WARNING PRINTK_HEADER
-				     "24 Byte: %x MSG %x, %s MSGb to SYSOP\n",
+			len += sprintf (page + len, KERN_ERR PRINTK_HEADER
+					"24 Byte: %x MSG %x, %s MSGb to SYSOP\n",
 					sense[7] >> 4, sense[7] & 0x0f,
 					sense[1] & 0x10 ? "" : "no");
 		} else {
 			/* 32 Byte Sense Data */
-			len += sprintf (page + len, KERN_WARNING PRINTK_HEADER
-				   "32 Byte: Format: %x Exception class %x\n",
+			len += sprintf (page + len, KERN_ERR PRINTK_HEADER
+					"32 Byte: Format: %x Exception class %x\n",
 					sense[6] & 0x0f, sense[22] >> 4);
 		}
 	}
-	return page;
+
+        printk ("Sense data:\n%s", 
+                page);
+
+        free_page ((unsigned long) page);
+        
+	return NULL;
 }
 
-dasd_discipline_t dasd_eckd_discipline =
-{
+
+dasd_discipline_t dasd_eckd_discipline = {
+        owner: THIS_MODULE,
 	name:"ECKD",
 	ebcname:"ECKD",
 	max_blocks:255,
@@ -1350,6 +1378,7 @@
 	do_analysis:dasd_eckd_do_analysis,
 	fill_geometry:dasd_eckd_fill_geometry,
 	start_IO:dasd_start_IO,
+	term_IO:dasd_term_IO,
 	format_device:dasd_eckd_format_device,
 	examine_error:dasd_eckd_examine_error,
 	erp_action:dasd_eckd_erp_action,
@@ -1359,7 +1388,9 @@
 	int_handler:dasd_int_handler,
 	reserve:dasd_eckd_reserve,
 	release:dasd_eckd_release,
-	merge_cp:dasd_eckd_merge_cp
+        steal_lock:dasd_eckd_steal_lock,
+	merge_cp:dasd_eckd_merge_cp,
+	fill_info:dasd_eckd_fill_info,
 };
 
 int
@@ -1369,40 +1400,62 @@
 	printk (KERN_INFO PRINTK_HEADER
 		"%s discipline initializing\n", dasd_eckd_discipline.name);
 	ASCEBC (dasd_eckd_discipline.ebcname, 4);
-	dasd_discipline_enq (&dasd_eckd_discipline);
+	dasd_discipline_add (&dasd_eckd_discipline);
 #ifdef CONFIG_DASD_DYNAMIC
-        {
-	int i;
-	for (i = 0; i < sizeof (dasd_eckd_known_devices) / sizeof (devreg_t); i++) {
-                printk (KERN_INFO PRINTK_HEADER
-                        "We are interested in: CU %04X/%02x\n",
-			dasd_eckd_known_devices[i].ci.hc.ctype,
-			dasd_eckd_known_devices[i].ci.hc.cmode);
-		s390_device_register (&dasd_eckd_known_devices[i]);
-        }
-        }
+	{
+		int i;
+		for (i = 0;
+		     i < sizeof (dasd_eckd_known_devices) / sizeof (devreg_t);
+		     i++) {
+			printk (KERN_INFO PRINTK_HEADER
+				"We are interested in: CU %04X/%02x\n",
+				dasd_eckd_known_devices[i].ci.hc.ctype,
+				dasd_eckd_known_devices[i].ci.hc.cmode);
+			s390_device_register (&dasd_eckd_known_devices[i]);
+		}
+	}
 #endif				/* CONFIG_DASD_DYNAMIC */
 	return rc;
 }
 
 void
-dasd_eckd_cleanup( void ) {
-        printk ( KERN_INFO PRINTK_HEADER
-                 "%s discipline cleaning up\n", dasd_eckd_discipline.name);
+dasd_eckd_cleanup (void)
+{
+	printk (KERN_INFO PRINTK_HEADER
+		"%s discipline cleaning up\n", dasd_eckd_discipline.name);
 #ifdef CONFIG_DASD_DYNAMIC
-        {
-	int i;
-        for ( i=0; i<sizeof(dasd_eckd_known_devices)/sizeof(devreg_t); i++) {
-		printk (KERN_INFO PRINTK_HEADER
-			"We were interested in: CU %04X/%02x\n",
-			dasd_eckd_known_devices[i].ci.hc.ctype,
-			dasd_eckd_known_devices[i].ci.hc.cmode);
-		s390_device_unregister(&dasd_eckd_known_devices[i]);
-	}
-        } 
-#endif /* CONFIG_DASD_DYNAMIC */
-        dasd_discipline_deq(&dasd_eckd_discipline);
+	{
+		int i;
+		for (i = 0;
+		     i < sizeof (dasd_eckd_known_devices) / sizeof (devreg_t);
+		     i++) {
+			printk (KERN_INFO PRINTK_HEADER
+				"We were interested in: CU %04X/%02x\n",
+				dasd_eckd_known_devices[i].ci.hc.ctype,
+				dasd_eckd_known_devices[i].ci.hc.cmode);
+			s390_device_unregister (&dasd_eckd_known_devices[i]);
+		}
+	}
+#endif				/* CONFIG_DASD_DYNAMIC */
+	dasd_discipline_del (&dasd_eckd_discipline);
+}
+
+#ifdef MODULE
+int
+init_module (void)
+{
+	int rc = 0;
+	rc = dasd_eckd_init ();
+	return rc;
 }
+
+void
+cleanup_module (void)
+{
+	dasd_eckd_cleanup ();
+	return;
+}
+#endif
 
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
diff -urN linux/drivers/s390/block/dasd_eckd.h linux-2.4.7/drivers/s390/block/dasd_eckd.h
--- linux/drivers/s390/block/dasd_eckd.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_eckd.h	Mon Dec 17 13:41:49 2001
@@ -10,6 +10,7 @@
 #define DASD_ECKD_CCW_READ_HOME_ADDRESS 0x0a
 #define DASD_ECKD_CCW_WRITE_KD 0x0d
 #define DASD_ECKD_CCW_READ_KD 0x0e
+#define DASD_ECKD_CCW_ERASE 0x11
 #define DASD_ECKD_CCW_READ_COUNT 0x12
 #define DASD_ECKD_CCW_WRITE_RECORD_ZERO 0x15
 #define DASD_ECKD_CCW_READ_RECORD_ZERO 0x16
@@ -25,53 +26,53 @@
 #define DASD_ECKD_CCW_READ_CKD_MT 0x9e
 #define DASD_ECKD_CCW_WRITE_CKD_MT 0x9d
 #define DASD_ECKD_CCW_RESERVE 0xB4
+#define DASD_ECKD_CCW_SLCK 0x14	/* steal lock - unconditional reserve */
 
-
-typedef 
-struct eckd_count_t {
+typedef
+    struct eckd_count_t {
 	__u16 cyl;
 	__u16 head;
 	__u8 record;
 	__u8 kl;
 	__u16 dl;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-eckd_count_t;
+    eckd_count_t;
 
 typedef
-struct ch_t {
+    struct ch_t {
 	__u16 cyl;
 	__u16 head;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-ch_t;
+    ch_t;
 
 typedef
-struct chs_t {
+    struct chs_t {
 	__u16 cyl;
 	__u16 head;
 	__u32 sector;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-chs_t;
+    chs_t;
 
 typedef
-struct chr_t {
+    struct chr_t {
 	__u16 cyl;
 	__u16 head;
 	__u8 record;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-chr_t;
+    chr_t;
 
 typedef
-struct geom_t {
+    struct geom_t {
 	__u16 cyl;
 	__u16 head;
 	__u32 sector;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-geom_t;
+    geom_t;
 
 typedef struct eckd_home_t {
 	__u8 skip_control[14];
@@ -82,12 +83,12 @@
 	__u8 reserved;
 	__u8 key_length;
 	__u8 reserved2[2];
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-eckd_home_t;
+    eckd_home_t;
 
 typedef
-struct DE_eckd_data_t {
+    struct DE_eckd_data_t {
 	struct {
 		unsigned char perm:2;	/* Permissions on this extent */
 		unsigned char reserved:1;
@@ -108,12 +109,12 @@
 	__u8 reserved;
 	ch_t beg_ext;
 	ch_t end_ext;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-DE_eckd_data_t;
+    DE_eckd_data_t;
 
 typedef
-struct LO_eckd_data_t {
+    struct LO_eckd_data_t {
 	struct {
 		unsigned char orientation:2;
 		unsigned char operation:6;
@@ -129,12 +130,12 @@
 	chr_t search_arg;
 	__u8 sector;
 	__u16 length;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-LO_eckd_data_t;
+    LO_eckd_data_t;
 
 typedef
-struct dasd_eckd_characteristics_t {
+    struct dasd_eckd_characteristics_t {
 	__u16 cu_type;
 	struct {
 		unsigned char support:2;
@@ -204,9 +205,9 @@
 	__u8 factor8;
 	__u8 reserved2[3];
 	__u8 reserved3[10];
-} __attribute__             ((packed)) 
+} __attribute__ ((packed))
 
-dasd_eckd_characteristics_t;
+    dasd_eckd_characteristics_t;
 
 typedef struct dasd_eckd_confdata_t {
 	struct {
@@ -323,10 +324,10 @@
 		__u8 log_dev_address;
 		unsigned char reserved2[12];
 	} __attribute__ ((packed)) neq;
-} __attribute__      ((packed)) 
+} __attribute__ ((packed))
 
-dasd_eckd_confdata_t;
+    dasd_eckd_confdata_t;
 
 int dasd_eckd_init (void);
-void dasd_eckd_cleanup(void);
+void dasd_eckd_cleanup (void);
 #endif				/* DASD_ECKD_H */
diff -urN linux/drivers/s390/block/dasd_fba.c linux-2.4.7/drivers/s390/block/dasd_fba.c
--- linux/drivers/s390/block/dasd_fba.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/dasd_fba.c	Mon Dec 17 13:42:41 2001
@@ -12,19 +12,21 @@
 #include <linux/kernel.h>
 #include <asm/debug.h>
 
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/hdreg.h>	/* HDIO_GETGEO                      */
 #include <linux/blk.h>
+
 #include <asm/ccwcache.h>
 #include <asm/idals.h>
-#include <asm/dasd.h>
-
 #include <asm/ebcdic.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/s390dyn.h>
 
+#include "dasd_int.h"
 #include "dasd_fba.h"
+#include "dasd_3370_erp.h"
+#include "dasd_9336_erp.h"
 
 #ifdef PRINTK_HEADER
 #undef PRINTK_HEADER
@@ -39,44 +41,38 @@
 dasd_discipline_t dasd_fba_discipline;
 
 typedef struct
-dasd_fba_private_t {
+    dasd_fba_private_t {
 	dasd_fba_characteristics_t rdc_data;
 } dasd_fba_private_t;
 
 #ifdef CONFIG_DASD_DYNAMIC
 static
-devreg_t dasd_fba_known_devices[] =
-{
+devreg_t dasd_fba_known_devices[] = {
 	{
-		ci:
-		{hc:
-		 {ctype:0x6310,
-                  dtype:0x9336}},
-		flag:(DEVREG_MATCH_CU_TYPE |
-                      DEVREG_MATCH_DEV_TYPE| 
-                      DEVREG_TYPE_DEVCHARS),
-		oper_func:dasd_oper_handler
-	},
+	      ci: { hc: {ctype:0x6310, dtype:0x9336}},
+	      flag:(DEVREG_MATCH_CU_TYPE |
+                    DEVREG_MATCH_DEV_TYPE | DEVREG_TYPE_DEVCHARS),
+              oper_func:dasd_oper_handler
+        },
 	{
-		ci:
-		{hc:
-		 {ctype:0x3880,
-                  dtype:0x3370}},
-		flag:(DEVREG_MATCH_CU_TYPE |
-                      DEVREG_MATCH_DEV_TYPE| 
-                      DEVREG_TYPE_DEVCHARS),
-		oper_func:dasd_oper_handler
-	}
+                ci: { hc: {ctype:0x3880, dtype:0x3370}},
+                flag:(DEVREG_MATCH_CU_TYPE |
+                      DEVREG_MATCH_DEV_TYPE | DEVREG_TYPE_DEVCHARS),
+                oper_func:dasd_oper_handler
+        }
 };
 #endif
-static inline void
+static inline int
 define_extent (ccw1_t * ccw, DE_fba_data_t * DE_data, int rw,
-	       int blksize, int beg, int nr)
+	       int blksize, int beg, int nr, ccw_req_t* cqr,
+               dasd_device_t* device)
 {
+        int rc=0;
 	memset (DE_data, 0, sizeof (DE_fba_data_t));
 	ccw->cmd_code = DASD_FBA_CCW_DEFINE_EXTENT;
 	ccw->count = 16;
-	set_normalized_cda (ccw, __pa (DE_data));
+	if ((rc=dasd_set_normalized_cda (ccw, __pa (DE_data), cqr, device)))
+                return rc;
 	if (rw == WRITE)
 		(DE_data->mask).perm = 0x0;
 	else if (rw == READ)
@@ -86,16 +82,17 @@
 	DE_data->blk_size = blksize;
 	DE_data->ext_loc = beg;
 	DE_data->ext_end = nr - 1;
+        return rc;
 }
 
 static inline void
 locate_record (ccw1_t * ccw, LO_fba_data_t * LO_data, int rw, int block_nr,
-	       int block_ct)
+	       int block_ct, ccw_req_t* cqr, dasd_device_t* device)
 {
 	memset (LO_data, 0, sizeof (LO_fba_data_t));
 	ccw->cmd_code = DASD_FBA_CCW_LOCATE;
 	ccw->count = 8;
-	set_normalized_cda (ccw, __pa (LO_data));
+	dasd_set_normalized_cda (ccw, __pa (LO_data), cqr, device);
 	if (rw == WRITE)
 		LO_data->operation.cmd = 0x5;
 	else if (rw == READ)
@@ -109,9 +106,9 @@
 static int
 dasd_fba_id_check (s390_dev_info_t * info)
 {
-        if (info->sid_data.cu_type == 0x3880)
-                if (info->sid_data.dev_type == 0x3370)
-                        return 0;
+	if (info->sid_data.cu_type == 0x3880)
+		if (info->sid_data.dev_type == 0x3370)
+			return 0;
 	if (info->sid_data.cu_type == 0x6310)
 		if (info->sid_data.dev_type == 0x9336)
 			return 0;
@@ -127,37 +124,43 @@
 
 	if (device == NULL) {
 		printk (KERN_WARNING PRINTK_HEADER
-		   "Null device pointer passed to characteristics checker\n");
-		return -ENODEV;
+			"Null device pointer passed to characteristics checker\n");
+                return -ENODEV;
 	}
-        if ( device->private != NULL ) {
-                kfree(device->private);
-        }
-        device->private = kmalloc (sizeof (dasd_fba_private_t), GFP_KERNEL);
+	device->private = kmalloc (sizeof (dasd_fba_private_t), GFP_KERNEL);
 	if (device->private == NULL) {
-                printk (KERN_WARNING PRINTK_HEADER
-                        "memory allocation failed for private data\n");
-                return -ENOMEM;
+		printk (KERN_WARNING PRINTK_HEADER
+			"memory allocation failed for private data\n");
+                rc = -ENOMEM;
+                goto fail;
 	}
 	private = (dasd_fba_private_t *) device->private;
 	rdc_data = (void *) &(private->rdc_data);
 	rc = read_dev_chars (device->devinfo.irq, &rdc_data, 32);
 	if (rc) {
-            printk (KERN_WARNING PRINTK_HEADER
-                    "Read device characteristics returned error %d\n", rc);
-            kfree(private);
-            device->private=NULL;
-            return rc;
+		printk (KERN_WARNING PRINTK_HEADER
+			"Read device characteristics returned error %d\n", rc);
+                goto fail;
 	}
 	printk (KERN_INFO PRINTK_HEADER
 		"%04X on sch %d: %04X/%02X(CU:%04X/%02X) %dMB at(%d B/blk)\n",
 		device->devinfo.devno, device->devinfo.irq,
-                device->devinfo.sid_data.dev_type, device->devinfo.sid_data.dev_model,
-                device->devinfo.sid_data.cu_type, device->devinfo.sid_data.cu_model,
+		device->devinfo.sid_data.dev_type,
+		device->devinfo.sid_data.dev_model,
+		device->devinfo.sid_data.cu_type,
+		device->devinfo.sid_data.cu_model,
 		(private->rdc_data.blk_bdsa *
 		 (private->rdc_data.blk_size >> 9)) >> 11,
 		private->rdc_data.blk_size);
-	return 0;
+        goto out;
+ fail:
+        if ( rc ) {
+                kfree(device->private);
+                device->private = NULL;
+        }
+        
+ out:
+	return rc;
 }
 
 static int
@@ -187,7 +190,7 @@
 		device->sizes.s2b_shift++;
 
 	device->sizes.blocks = (private->rdc_data.blk_bdsa);
-        device->sizes.pt_block = 1;
+	device->sizes.pt_block = 1;
 
 	return rc;
 }
@@ -221,7 +224,7 @@
 	dasd_device_t *device = (dasd_device_t *) cqr->device;
 	if (stat->cstat == 0x00 &&
 	    stat->dstat == (DEV_STAT_CHN_END | DEV_STAT_DEV_END))
-		return dasd_era_none;
+		    return dasd_era_none;
 
 	switch (device->devinfo.sid_data.dev_model) {
 	case 0x3370:
@@ -236,17 +239,16 @@
 static dasd_erp_action_fn_t
 dasd_fba_erp_action (ccw_req_t * cqr)
 {
-	return default_erp_action;
+	return dasd_default_erp_action;
 }
 
 static dasd_erp_postaction_fn_t
 dasd_fba_erp_postaction (ccw_req_t * cqr)
 {
-	if (cqr->function == default_erp_action)
-		return default_erp_postaction;
+	if (cqr->function == dasd_default_erp_action)
+		return dasd_default_erp_postaction;
 	printk (KERN_WARNING PRINTK_HEADER
-		"unknown ERP action %p\n",
-		cqr->function);
+		"unknown ERP action %p\n", cqr->function);
 	return NULL;
 }
 
@@ -255,7 +257,7 @@
 {
 	ccw_req_t *rw_cp = NULL;
 	int rw_cmd;
-	int bhct, i;
+	int bhct, i = 0;
 	long size;
 	ccw1_t *ccw;
 	DE_fba_data_t *DE_data;
@@ -263,7 +265,7 @@
 	struct buffer_head *bh;
 	dasd_fba_private_t *private = (dasd_fba_private_t *) device->private;
 	int byt_per_blk = device->sizes.bp_block;
-
+        
 	if (req->cmd == READ) {
 		rw_cmd = DASD_FBA_CCW_READ;
 	} else if (req->cmd == WRITE) {
@@ -273,20 +275,30 @@
 		return NULL;
 	}
 	/* Build the request */
-	/* count bhs to prevent errors, when bh smaller than block */
+	/* count hs to prevent errors, when bh smaller than block */
+        bh = req -> bh;
 	bhct = 0;
-	for (bh = req->bh; bh; bh = bh->b_reqnext) {
-		if (bh->b_size > byt_per_blk)
-			for (size = 0; size < bh->b_size; size += byt_per_blk)
-				bhct++;
-		else
-			bhct++;
-	}
-
-	rw_cp = dasd_alloc_request (dasd_fba_discipline.name,
-				    1 + 2*bhct,
-				    sizeof (DE_fba_data_t) +
-				    bhct*sizeof (LO_fba_data_t));
+        while ( bh != NULL ) {
+                if (bh->b_size < byt_per_blk) {
+                        BUG();
+                }
+                bhct += bh->b_size >> (device->sizes.s2b_shift+9);
+                bh = bh->b_reqnext;
+        }
+        
+        if (private->rdc_data.mode.bits.data_chain) {
+                rw_cp = dasd_alloc_request (dasd_fba_discipline.name,
+                                            2 + bhct,
+                                            sizeof (DE_fba_data_t) +
+                                            sizeof (LO_fba_data_t),
+                                            device);
+        } else {
+                rw_cp = dasd_alloc_request (dasd_fba_discipline.name,
+                                            1 + 2 * bhct,
+                                            sizeof (DE_fba_data_t) +
+                                            bhct * sizeof (LO_fba_data_t),
+                                            device);
+        }
 	if (!rw_cp) {
 		return NULL;
 	}
@@ -294,64 +306,77 @@
 	LO_data = rw_cp->data + sizeof (DE_fba_data_t);
 	ccw = rw_cp->cpaddr;
 
-	define_extent (ccw, DE_data, req->cmd, byt_per_blk,
-		       req->sector, req->nr_sectors);
+	if (define_extent (ccw, DE_data, req->cmd, byt_per_blk,
+                           req->sector, req->nr_sectors, rw_cp, device)) {
+                goto clear_rw_cp;
+        }
 	ccw->flags |= CCW_FLAG_CC;
-
-	for (i = 0, bh = req->bh; bh;) {
-		if (bh->b_size > byt_per_blk) {
-			for (size = 0; size < bh->b_size; size += byt_per_blk) {
-                                ccw++;
-                                locate_record (ccw, LO_data, req->cmd, i, 1);
-                                ccw->flags |= CCW_FLAG_CC;
-				ccw++;
-                                ccw->flags |= CCW_FLAG_CC|CCW_FLAG_SLI;
-				ccw->cmd_code = rw_cmd;
-				ccw->count = byt_per_blk;
-				set_normalized_cda (ccw, __pa (bh->b_data + size));
-                                i++;
-                                LO_data++;
-			}
-			bh = bh->b_reqnext;
-		} else {	/* group N bhs to fit into byt_per_blk */
-			for (size = 0; bh != NULL && size < byt_per_blk;) {
-                                ccw++;
-                                locate_record (ccw, LO_data, req->cmd, i, 1);
+        ccw ++;
+        locate_record (ccw, LO_data, req->cmd, 0, 
+                       private->rdc_data.mode.bits.data_chain ? bhct : 1, rw_cp, device);
+        if (ccw->cda == 0) {
+                goto clear_rw_cp;
+        }
+        ccw->flags |= CCW_FLAG_CC;
+        
+        bh = req -> bh;
+        i = 0;
+        while ( bh != NULL ) {
+                for (size = 0; size < bh->b_size; size += byt_per_blk) {
+                        ccw ++;
+                        ccw->cmd_code = rw_cmd;
+                        ccw->count = byt_per_blk;
+                        if (dasd_set_normalized_cda (ccw,__pa (bh->b_data + size), rw_cp, device)) {
+                                goto clear_rw_cp;
+                        }
+                        if (private->rdc_data.mode.bits.data_chain) {
+                                ccw->flags |= CCW_FLAG_DC;
+                        } else {
                                 ccw->flags |= CCW_FLAG_CC;
-				ccw++;
-				if (private->rdc_data.mode.bits.data_chain) {
-					ccw->flags |= CCW_FLAG_DC|CCW_FLAG_SLI;
-				} else {
-					PRINT_WARN ("Cannot chain chunks smaller than one block\n");
-					ccw_free_request (rw_cp);
-					return NULL;
-				}
-				ccw->cmd_code = rw_cmd;
-				ccw->count = bh->b_size;
-				set_normalized_cda (ccw, __pa (bh->b_data));
-				size += bh->b_size;
-				bh = bh->b_reqnext;
-                                i++;
-                                LO_data++;
-			}
-			ccw->flags &= ~CCW_FLAG_DC;
-			ccw->flags |= CCW_FLAG_CC|CCW_FLAG_SLI;
-			if (size != byt_per_blk) {
-				PRINT_WARN ("Cannot fulfill request smaller than block\n");
-				ccw_free_request (rw_cp);
-				return NULL;
-			}
-		}
-	}
+                        }
+                }
+                bh = bh->b_reqnext;
+                if ( bh != NULL &&
+                     !(private->rdc_data.mode.bits.data_chain)) {
+                        ccw++;
+                        i++;
+                        LO_data++;
+                        locate_record (ccw, LO_data, req->cmd, i, 1, rw_cp, device);
+                        if (ccw->cda == 0) {
+                                goto clear_rw_cp;
+                        }
+                        ccw->flags |= CCW_FLAG_CC;
+                }
+        }
 	ccw->flags &= ~(CCW_FLAG_DC | CCW_FLAG_CC);
 
 	rw_cp->device = device;
 	rw_cp->expires = 5 * TOD_MIN;		/* 5 minutes */
 	rw_cp->req = req;
 	check_then_set (&rw_cp->status, CQR_STATUS_EMPTY, CQR_STATUS_FILLED);
+        goto out;
+ clear_rw_cp:
+        dasd_free_request (rw_cp, device);
+        rw_cp = NULL;
+ out:
 	return rw_cp;
 }
 
+static int
+dasd_fba_fill_info (dasd_device_t * device, dasd_information_t * info)
+{
+	int rc = 0;
+	info->label_block = 1;
+	info->FBA_layout = 1;
+	info->characteristics_size = sizeof (dasd_fba_characteristics_t);
+	memcpy (info->characteristics,
+		&((dasd_fba_private_t *) device->private)->rdc_data,
+		sizeof (dasd_fba_characteristics_t));
+	info->confdata_size = 0;
+	return rc;
+}
+
+
 static char *
 dasd_fba_dump_sense (struct dasd_device_t *device, ccw_req_t * req)
 {
@@ -367,25 +392,26 @@
 	return page;
 }
 
-dasd_discipline_t dasd_fba_discipline =
-{
+dasd_discipline_t dasd_fba_discipline = {
+        owner: THIS_MODULE,
 	name:"FBA ",
 	ebcname:"FBA ",
-	max_blocks:((PAGE_SIZE >> 1)/sizeof(ccw1_t)-1),
+	max_blocks:((PAGE_SIZE >> 1) / sizeof (ccw1_t) - 1),
 	id_check:dasd_fba_id_check,
 	check_characteristics:dasd_fba_check_characteristics,
 	do_analysis:dasd_fba_do_analysis,
 	fill_geometry:dasd_fba_fill_geometry,
 	start_IO:dasd_start_IO,
+	term_IO:dasd_term_IO,
 	examine_error:dasd_fba_examine_error,
 	erp_action:dasd_fba_erp_action,
 	erp_postaction:dasd_fba_erp_postaction,
 	build_cp_from_req:dasd_fba_build_cp_from_req,
 	dump_sense:dasd_fba_dump_sense,
-	int_handler:dasd_int_handler
+	int_handler:dasd_int_handler,
+	fill_info:dasd_fba_fill_info,
 };
 
-
 int
 dasd_fba_init (void)
 {
@@ -393,18 +419,22 @@
 	printk (KERN_INFO PRINTK_HEADER
 		"%s discipline initializing\n", dasd_fba_discipline.name);
 	ASCEBC (dasd_fba_discipline.ebcname, 4);
-	dasd_discipline_enq (&dasd_fba_discipline);
-#ifdef CONFIG_DASD_DYNAMIC 
-        {
-            int i;
-            for (i = 0; i < sizeof (dasd_fba_known_devices) / sizeof (devreg_t); i++) {
-		printk (KERN_INFO PRINTK_HEADER
-			"We are interested in: CU %04X/%02x\n",
-			dasd_fba_known_devices[i].ci.hc.ctype,
-			dasd_fba_known_devices[i].ci.hc.cmode);
-		s390_device_register (&dasd_fba_known_devices[i]);
-            }
-        }
+	dasd_discipline_add (&dasd_fba_discipline);
+#ifdef CONFIG_DASD_DYNAMIC
+	{
+		int i;
+		for (i = 0;
+		     i < sizeof (dasd_fba_known_devices) / sizeof (devreg_t);
+		     i++) {
+			printk (KERN_INFO PRINTK_HEADER
+				"We are interested in: Dev %04X/%02X @ CU %04X/%02x\n",
+				dasd_fba_known_devices[i].ci.hc.dtype,
+				dasd_fba_known_devices[i].ci.hc.dmode,
+				dasd_fba_known_devices[i].ci.hc.ctype,
+				dasd_fba_known_devices[i].ci.hc.cmode);
+			s390_device_register (&dasd_fba_known_devices[i]);
+		}
+	}
 #endif				/* CONFIG_DASD_DYNAMIC */
         return rc;
 }
@@ -417,16 +447,31 @@
         {
 	int i;
         for ( i=0; i<sizeof(dasd_fba_known_devices)/sizeof(devreg_t); i++) {
-                printk (KERN_INFO PRINTK_HEADER
-                        "We were interested in: CU %04X/%02x\n",
-                        dasd_fba_known_devices[i].ci.hc.ctype,
-                        dasd_fba_known_devices[i].ci.hc.cmode);
                 s390_device_unregister(&dasd_fba_known_devices[i]);
         }
         }
 #endif /* CONFIG_DASD_DYNAMIC */
-        dasd_discipline_deq(&dasd_fba_discipline);
+        dasd_discipline_del(&dasd_fba_discipline);
+}
+
+#ifdef MODULE
+int
+init_module (void)
+{
+	int rc = 0;
+	rc = dasd_fba_init ();
+	return rc;
 }
+
+void
+cleanup_module (void)
+{
+	dasd_fba_cleanup ();
+	return;
+}
+#endif
+
+
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
  * Emacs will notice this stuff at the end of the file and automatically
diff -urN linux/drivers/s390/block/dasd_fba.h linux-2.4.7/drivers/s390/block/dasd_fba.h
--- linux/drivers/s390/block/dasd_fba.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/block/dasd_fba.h	Mon Dec 17 13:41:19 2001
@@ -3,7 +3,7 @@
 #define DASD_FBA_H
 
 typedef
-struct DE_fba_data_t {
+    struct DE_fba_data_t {
 	struct {
 		unsigned char perm:2;	/* Permissions on this extent */
 		unsigned char zero:2;	/* Must be zero */
@@ -16,12 +16,12 @@
 	__u32 ext_loc;		/* Extent locator */
 	__u32 ext_beg;		/* logical number of block 0 in extent */
 	__u32 ext_end;		/* logocal number of last block in extent */
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-DE_fba_data_t;
+    DE_fba_data_t;
 
 typedef
-struct LO_fba_data_t {
+    struct LO_fba_data_t {
 	struct {
 		unsigned char zero:4;
 		unsigned char cmd:4;
@@ -29,12 +29,12 @@
 	__u8 auxiliary;
 	__u16 blk_ct;
 	__u32 blk_nr;
-} __attribute__ ((packed)) 
+} __attribute__ ((packed))
 
-LO_fba_data_t;
+    LO_fba_data_t;
 
 typedef
-struct dasd_fba_characteristics_t {
+    struct dasd_fba_characteristics_t {
 	union {
 		__u8 c;
 		struct {
@@ -67,10 +67,10 @@
 	__u16 blk_ce;
 	__u32 reserved2;
 	__u16 reserved3;
-} __attribute__            ((packed)) 
+} __attribute__ ((packed))
 
-dasd_fba_characteristics_t;
+    dasd_fba_characteristics_t;
 
 int dasd_fba_init (void);
-void dasd_fba_cleanup(void);
+void dasd_fba_cleanup (void);
 #endif				/* DASD_FBA_H */
diff -urN linux/drivers/s390/block/dasd_int.h linux-2.4.7/drivers/s390/block/dasd_int.h
--- linux/drivers/s390/block/dasd_int.h	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/drivers/s390/block/dasd_int.h	Mon Dec 17 13:43:29 2001
@@ -0,0 +1,392 @@
+/* 
+ * File...........: linux/drivers/s390/block/dasd.c
+ * Author(s)......: Holger Smolinski <Holger.Smolinski@de.ibm.com>
+ * Bugreports.to..: <Linux390@de.ibm.com>
+ * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
+ *
+ * History of changes (starts July 2000)
+ * 02/01/01 added dynamic registration of ioctls
+ */
+
+#ifndef DASD_INT_H
+#define DASD_INT_H
+
+#define DASD_API_VERSION 0
+
+#include <asm/dasd.h>
+
+#define CONFIG_DASD_DYNAMIC
+
+typedef int(*dasd_ioctl_fn_t) (void *inp, int no, long args);
+int dasd_ioctl_no_register(struct module *, int no, dasd_ioctl_fn_t handler);
+int dasd_ioctl_no_unregister(struct module *, int no, dasd_ioctl_fn_t handler);
+
+#define DASD_NAME "dasd"
+#define DASD_PER_MAJOR ( 1U<<(MINORBITS-DASD_PARTN_BITS))
+
+
+#define DASD_FORMAT_INTENS_WRITE_RECZERO 0x01
+#define DASD_FORMAT_INTENS_WRITE_HOMEADR 0x02
+
+#define DASD_STATE_DEL   -1
+#define DASD_STATE_NEW    0
+#define DASD_STATE_KNOWN  1
+#define DASD_STATE_ACCEPT 2
+#define DASD_STATE_INIT   3
+#define DASD_STATE_READY  4
+#define DASD_STATE_ONLINE 5
+
+
+#define DASD_FORMAT_INTENS_WRITE_RECZERO 0x01
+#define DASD_FORMAT_INTENS_WRITE_HOMEADR 0x02
+#define DASD_FORMAT_INTENS_INVALIDATE    0x04
+#define DASD_FORMAT_INTENS_CDL 0x08
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/major.h>
+#include <linux/wait.h>
+#include <linux/blk.h> 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
+#include <linux/blkdev.h> 
+#include <linux/devfs_fs_kernel.h>
+#endif
+#include <linux/genhd.h>
+#include <linux/hdreg.h>
+#include <linux/compatmac.h>
+
+#include <asm/ccwcache.h>
+#include <asm/irq.h>
+#include <asm/s390dyn.h>
+#include <asm/todclk.h>
+#include <asm/debug.h>
+
+/* Kernel Version Compatibility section */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
+typedef struct request *request_queue_t;
+#define block_device_operations file_operations
+#define __setup(x,y) struct dasd_device_t
+#define devfs_register_blkdev(major,name,ops) register_blkdev(major,name,ops)
+#define register_disk(dd,dev,partn,ops,size) \
+do { \
+	dd->sizes[MINOR(dev)] = size >> 1; \
+	resetup_one_dev(dd,MINOR(dev)>>DASD_PARTN_BITS); \
+} while(0)
+#define init_waitqueue_head(x) do { *x = NULL; } while(0)
+#define blk_cleanup_queue(x) do {} while(0)
+#define blk_init_queue(x...) do {} while(0)
+#define blk_queue_headactive(x...) do {} while(0)
+#define blk_queue_make_request(x) do {} while(0)
+#define list_empty(x) (0)
+#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
+do { \
+        blk_dev[d_major].request_fn = d_request_fn; \
+        blk_dev[d_major].queue = d_queue_fn; \
+        blk_dev[d_major].current_request = d_current; \
+} while(0)
+#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
+	major:D_MAJOR, \
+	major_name:D_NAME, \
+	minor_shift:D_PARTN_BITS, \
+	max_p:1 << D_PARTN_BITS, \
+	max_nr:D_PER_MAJOR, \
+	nr_real:D_PER_MAJOR,
+static inline struct request * 
+dasd_next_request( request_queue_t *queue ) 
+{
+    return *queue;
+}
+static inline void 
+dasd_dequeue_request( request_queue_t * q, struct request *req )
+{
+        *q = req->next;
+        req->next = NULL;
+}
+#else
+#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
+do { \
+        blk_dev[d_major].queue = d_queue_fn; \
+} while(0)
+#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
+	major:D_MAJOR, \
+	major_name:D_NAME, \
+	minor_shift:D_PARTN_BITS, \
+	max_p:1 << D_PARTN_BITS, \
+	nr_real:D_PER_MAJOR, \
+        fops:&dasd_device_operations, 
+static inline struct request * 
+dasd_next_request( request_queue_t *queue ) 
+{
+        return blkdev_entry_next_request(&queue->queue_head);
+}
+static inline void 
+dasd_dequeue_request( request_queue_t * q, struct request *req )
+{
+        blkdev_dequeue_request (req);
+}
+#endif
+
+/* dasd_range_t are used for dynamic device att-/detachment */
+typedef struct dasd_devreg_t {
+        devreg_t devreg; /* the devreg itself */
+        /* build a linked list of devregs, needed for cleanup */
+        struct list_head list;
+} dasd_devreg_t;
+
+typedef struct {
+	struct list_head list;
+	struct module *owner;
+	int no;
+	dasd_ioctl_fn_t handler;
+} dasd_ioctl_list_t;
+
+typedef enum {
+	dasd_era_fatal = -1,	/* no chance to recover              */
+	dasd_era_none = 0,	/* don't recover, everything alright */
+	dasd_era_msg = 1,	/* don't recover, just report...     */
+	dasd_era_recover = 2	/* recovery action recommended       */
+} dasd_era_t;
+
+/* BIT DEFINITIONS FOR SENSE DATA */
+#define DASD_SENSE_BIT_0 0x80
+#define DASD_SENSE_BIT_1 0x40
+#define DASD_SENSE_BIT_2 0x20
+#define DASD_SENSE_BIT_3 0x10
+
+#define check_then_set(where,from,to) \
+do { \
+        if ((*(where)) != (from) ) { \
+                printk (KERN_ERR PRINTK_HEADER "was %d\n", *(where)); \
+                BUG(); \
+        } \
+        (*(where)) = (to); \
+} while (0)
+
+#define DASD_MESSAGE(d_loglevel,d_device,d_string,d_args...)\
+do { \
+        int d_devno = d_device->devinfo.devno; \
+        int d_irq = d_device->devinfo.irq; \
+        char *d_name = d_device->name; \
+        int d_major = MAJOR(d_device->kdev); \
+        int d_minor = MINOR(d_device->kdev); \
+        printk(d_loglevel PRINTK_HEADER \
+               "/dev/%s(%d:%d),%04x@0x%x:" \
+               d_string "\n",d_name,d_major,d_minor,d_devno,d_irq,d_args ); \
+} while(0)
+
+/* 
+ * struct dasd_sizes_t
+ * represents all data needed to access dasd with properly set up sectors
+ */
+typedef
+struct dasd_sizes_t {
+	unsigned long blocks; /* size of volume in blocks */
+	unsigned int bp_block; /* bytes per block */
+	unsigned int s2b_shift; /* log2 (bp_block/512) */
+        unsigned int pt_block; /* from which block to read the partn table */
+} dasd_sizes_t;
+
+/* 
+ * struct dasd_chanq_t 
+ * represents a queue of channel programs related to a single device
+ */
+typedef
+struct dasd_chanq_t {
+	ccw_req_t *head;
+	ccw_req_t *tail;
+} dasd_chanq_t;
+
+#define DASD_DEVICE_FORMAT_STRING "Device: %p"
+#define DASD_DEVICE_DEBUG_EVENT(d_level, d_device, d_str, d_data...)\
+do {\
+        if ( d_device->debug_area != NULL )\
+        debug_sprintf_event(d_device->debug_area,d_level,\
+                    DASD_DEVICE_FORMAT_STRING d_str "\n",\
+                    d_device, d_data);\
+} while(0);
+#define DASD_DEVICE_DEBUG_EXCEPTION(d_level, d_device, d_str, d_data...)\
+do {\
+        if ( d_device->debug_area != NULL )\
+        debug_sprintf_exception(d_device->debug_area,d_level,\
+                        DASD_DEVICE_FORMAT_STRING d_str "\n",\
+                        d_device, d_data);\
+} while(0);
+
+#define DASD_DRIVER_FORMAT_STRING "Driver: <[%p]>"
+#define DASD_DRIVER_DEBUG_EVENT(d_level, d_fn, d_str, d_data...)\
+do {\
+        if ( dasd_debug_area != NULL )\
+        debug_sprintf_event(dasd_debug_area, d_level,\
+                    DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
+                    d_fn, d_data);\
+} while(0);
+#define DASD_DRIVER_DEBUG_EXCEPTION(d_level, d_fn, d_str, d_data...)\
+do {\
+        if ( dasd_debug_area != NULL )\
+        debug_sprintf_exception(dasd_debug_area, d_level,\
+                        DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
+                        d_fn, d_data);\
+} while(0);
+
+struct dasd_device_t;
+struct request;
+
+/* 
+ * signatures for the functions of dasd_discipline_t 
+ * make typecasts much easier
+ */
+typedef ccw_req_t *(*dasd_erp_action_fn_t) (ccw_req_t * cqr);
+typedef ccw_req_t *(*dasd_erp_postaction_fn_t) (ccw_req_t * cqr);
+
+typedef int (*dasd_ck_id_fn_t) (s390_dev_info_t *);
+typedef int (*dasd_ck_characteristics_fn_t) (struct dasd_device_t *);
+typedef int (*dasd_fill_geometry_fn_t) (struct dasd_device_t *, struct hd_geometry *);
+typedef ccw_req_t *(*dasd_format_fn_t) (struct dasd_device_t *, struct format_data_t *);
+typedef ccw_req_t *(*dasd_init_analysis_fn_t) (struct dasd_device_t *);
+typedef int (*dasd_do_analysis_fn_t) (struct dasd_device_t *);
+typedef int (*dasd_io_starter_fn_t) (ccw_req_t *);
+typedef int (*dasd_io_stopper_fn_t) (ccw_req_t *);
+typedef void (*dasd_int_handler_fn_t)(int irq, void *, struct pt_regs *);
+typedef dasd_era_t (*dasd_error_examine_fn_t) (ccw_req_t *, devstat_t * stat);
+typedef dasd_erp_action_fn_t (*dasd_error_analyse_fn_t) (ccw_req_t *);
+typedef dasd_erp_postaction_fn_t (*dasd_erp_analyse_fn_t) (ccw_req_t *);
+typedef ccw_req_t *(*dasd_cp_builder_fn_t)(struct dasd_device_t *,struct request *);
+typedef char *(*dasd_dump_sense_fn_t)(struct dasd_device_t *,ccw_req_t *);
+typedef ccw_req_t *(*dasd_reserve_fn_t)(struct dasd_device_t *);
+typedef ccw_req_t *(*dasd_release_fn_t)(struct dasd_device_t *);
+typedef ccw_req_t *(*dasd_steal_lock_fn_t)(struct dasd_device_t *);
+typedef ccw_req_t *(*dasd_merge_cp_fn_t)(struct dasd_device_t *);
+typedef int (*dasd_info_fn_t) (struct dasd_device_t *, dasd_information_t *);
+typedef int (*dasd_use_count_fn_t) (int);
+
+/*
+ * the dasd_discipline_t is
+ * sth like a table of virtual functions, if you think of dasd_eckd
+ * inheriting dasd...
+ * no, currently we are not planning to reimplement the driver in C++
+ */
+typedef struct dasd_discipline_t {
+        struct module *owner;
+	char ebcname[8]; /* a name used for tagging and printks */
+        char name[8];		/* a name used for tagging and printks */
+	int max_blocks;	/* maximum number of blocks to be chained */
+	dasd_ck_id_fn_t id_check;	/* to check sense data */
+	dasd_ck_characteristics_fn_t check_characteristics;	/* to check the characteristics */
+	dasd_init_analysis_fn_t init_analysis;	/* to start the analysis of the volume */
+	dasd_do_analysis_fn_t do_analysis;	/* to complete the analysis of the volume */
+	dasd_fill_geometry_fn_t fill_geometry;	/* to set up hd_geometry */
+	dasd_io_starter_fn_t start_IO;
+	dasd_io_stopper_fn_t term_IO;
+        dasd_format_fn_t format_device;		/* to format the device */
+	dasd_error_examine_fn_t examine_error;
+	dasd_error_analyse_fn_t erp_action;
+	dasd_erp_analyse_fn_t erp_postaction;
+        dasd_cp_builder_fn_t build_cp_from_req;
+        dasd_dump_sense_fn_t dump_sense;
+        dasd_int_handler_fn_t int_handler;
+        dasd_reserve_fn_t reserve;
+        dasd_release_fn_t release;
+        dasd_steal_lock_fn_t steal_lock;
+        dasd_merge_cp_fn_t merge_cp;
+        dasd_info_fn_t fill_info;
+	struct list_head list;	/* used for list of disciplines */
+} dasd_discipline_t;
+
+#define DASD_DEFAULT_FEATURES 0
+#define DASD_FEATURE_READONLY 1
+
+/* dasd_range_t are used for ordering the DASD devices */
+typedef struct dasd_range_t {
+	unsigned int from;	/* first DASD in range */
+	unsigned int to;	/* last DASD in range */
+	char discipline[4];	/* placeholder to force discipline */
+        int features;
+	struct list_head list;	/* next one in linked list */
+} dasd_range_t;
+
+
+
+#define DASD_MAJOR_INFO_REGISTERED 1
+#define DASD_MAJOR_INFO_IS_STATIC 2
+
+typedef struct major_info_t {
+	struct list_head list;
+	struct dasd_device_t **dasd_device;
+	int flags;
+	struct gendisk gendisk; /* actually contains the major number */
+} __attribute__ ((packed)) major_info_t;
+
+typedef struct dasd_device_t {
+	s390_dev_info_t devinfo;
+	dasd_discipline_t *discipline;
+	int level;
+        atomic_t open_count;
+        kdev_t kdev;
+        major_info_t *major_info;
+	struct dasd_chanq_t queue;
+        wait_queue_head_t wait_q;
+        request_queue_t *request_queue;
+        struct timer_list timer;      
+	devstat_t dev_status; /* needed ONLY!! for request_irq */
+        dasd_sizes_t sizes;
+        char name[16]; /* The name of the device in /dev */
+	char *private;	/* to be used by the discipline internally */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
+        devfs_handle_t devfs_entry;
+#endif /* LINUX_IS_24 */
+	struct tq_struct bh_tq;
+        atomic_t bh_scheduled;
+        debug_info_t *debug_area;
+        dasd_profile_info_t profile;
+        ccw_req_t *init_cqr;
+        atomic_t plugged;
+        void* lowmem_cqr;
+        void* lowmem_ccws;
+        void* lowmem_idals;
+        void* lowmem_idal_ptr;
+}  dasd_device_t;
+
+int dasd_init (void);
+void dasd_discipline_add(dasd_discipline_t *);
+void dasd_discipline_del(dasd_discipline_t *);
+int dasd_start_IO (ccw_req_t *);
+int dasd_term_IO (ccw_req_t *);
+void dasd_int_handler (int , void *, struct pt_regs *);
+ccw_req_t *dasd_default_erp_action (ccw_req_t *);
+ccw_req_t *dasd_default_erp_postaction (ccw_req_t *);
+inline void dasd_chanq_deq (dasd_chanq_t *, ccw_req_t *);
+inline void dasd_chanq_enq (dasd_chanq_t *, ccw_req_t *);
+inline void dasd_chanq_enq_head (dasd_chanq_t *, ccw_req_t *);
+ccw_req_t *dasd_alloc_request (char *, int, int, dasd_device_t *);
+void dasd_free_request (ccw_req_t *, dasd_device_t *);
+int dasd_oper_handler (int irq, devreg_t * devreg);
+void dasd_schedule_bh (dasd_device_t *);
+int dasd_sleep_on_req(ccw_req_t*);
+int  dasd_set_normalized_cda ( ccw1_t * cp, unsigned long address, ccw_req_t* request, dasd_device_t* device );
+dasd_device_t * dasd_device_from_kdev (kdev_t kdev);
+
+extern debug_info_t *dasd_debug_area;
+extern int (*genhd_dasd_name) (char *, int, int, struct gendisk *);
+
+#endif /* __KERNEL__ */
+
+#endif				/* DASD_H */
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-indent-level: 4 
+ * c-brace-imaginary-offset: 0
+ * c-brace-offset: -4
+ * c-argdecl-indent: 4
+ * c-label-offset: -4
+ * c-continued-statement-offset: 4
+ * c-continued-brace-offset: 0
+ * indent-tabs-mode: nil
+ * tab-width: 8
+ * End:
+ */
diff -urN linux/drivers/s390/block/xpram.c linux-2.4.7/drivers/s390/block/xpram.c
--- linux/drivers/s390/block/xpram.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/block/xpram.c	Mon Dec 17 13:42:41 2001
@@ -74,7 +74,7 @@
 #endif /* V24 */
 #include <linux/sched.h>
 #include <linux/kernel.h> /* printk() */
-#include <linux/malloc.h> /* kmalloc() */
+#include <linux/slab.h>   /* kmalloc() */
 #if (XPRAM_VERSION == 24)
 #  include <linux/devfs_fs_kernel.h>
 #endif /* V24 */
@@ -92,6 +92,7 @@
 #if (XPRAM_VERSION == 24)
 #define MAJOR_NR xpram_major /* force definitions on in blk.h */
 int xpram_major;   /* must be declared before including blk.h */
+devfs_handle_t xpram_devfs_handle;
 
 #define DEVICE_NR(device) MINOR(device)   /* xpram has no partition bits */
 #define DEVICE_NAME "xpram"               /* name for messaging */
@@ -999,12 +1000,18 @@
 #elif (XPRAM_VERSION == 24)
 	result = devfs_register_blkdev(xpram_major, "xpram", &xpram_devops);
 #endif /* V22/V24 */
-	
 	if (result < 0) {
 		PRINT_ERR("Can't get major %d\n",xpram_major);
                 PRINT_ERR("Giving up xpram\n");
 		return result;
 	}
+#if (XPRAM_VERSION == 24)
+	xpram_devfs_handle = devfs_mk_dir (NULL, "slram", NULL);
+	devfs_register_series (xpram_devfs_handle, "%u", XPRAM_MAX_DEVS,
+			       DEVFS_FL_DEFAULT, XPRAM_MAJOR, 0,
+			       S_IFBLK | S_IRUSR | S_IWUSR,
+			       &xpram_devops, NULL);
+#endif /* V22/V24 */
 	if (xpram_major == 0) xpram_major = result; /* dynamic */
 	major = xpram_major; /* Use `major' later on to save typing */
 
@@ -1226,6 +1233,12 @@
 	kfree(xpram_offsets);
 
 				/* finally, the usual cleanup */
+#if (XPRAM_VERSION == 22)
 	unregister_blkdev(major, "xpram");
+#elif (XPRAM_VERSION == 24)
+	devfs_unregister(xpram_devfs_handle);
+	if (devfs_unregister_blkdev(MAJOR_NR, "xpram"))
+		printk(KERN_WARNING "xpram: cannot unregister blkdev\n");
+#endif /* V22/V24 */
 	kfree(xpram_devices);
 }
diff -urN linux/drivers/s390/ccwcache.c linux-2.4.7/drivers/s390/ccwcache.c
--- linux/drivers/s390/ccwcache.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/ccwcache.c	Mon Dec 17 13:42:47 2001
@@ -10,7 +10,7 @@
  */
 
 #include <linux/module.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/version.h>
 
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
@@ -252,8 +252,6 @@
 
 	/* allocate a debug area */
 	debug_area = debug_register( "ccwcache", 2, 4,sizeof(void*));
-	if ( debug_area == NULL )
-                BUG();
 
         debug_register_view(debug_area,&debug_hex_ascii_view);
         debug_register_view(debug_area,&debug_raw_view);
diff -urN linux/drivers/s390/char/Makefile linux-2.4.7/drivers/s390/char/Makefile
--- linux/drivers/s390/char/Makefile	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/Makefile	Mon Dec 17 13:41:19 2001
@@ -1,42 +1,33 @@
-# Makefile for the S/390 supported character devices
 #
-# 4 January 2001 Richard Hitt
-# Modeled after similar files of Michael Elizabeth Chastain
-# Rewritten to use lists instead of if-statements.
+# S/390 character devices
+#
 
-O_TARGET	:= s390-char.o
+O_TARGET := s390-char.o
 
-export-objs     :=
 list-multi	:= tub3270.o tape390.o
 
-obj-y		:=
-obj-m		:=
-obj-n		:=
-obj-		:=
-
-tub3270-objs			:= tuball.o tubfs.o tubtty.o \
-					tubttyaid.o tubttybld.o tubttyrcl.o \
-					tubttyscl.o tubttysiz.o
+tub3270-objs := tuball.o tubfs.o tubtty.o \
+                     tubttyaid.o tubttybld.o tubttyscl.o \
+                     tubttyrcl.o tubttysiz.o
+
+tape390-$(CONFIG_S390_TAPE_CHAR) += tapechar.o
+tape390-$(CONFIG_S390_TAPE_BLOCK) += tapeblock.o
+tape390-$(CONFIG_S390_TAPE_3480) += tape3480.o tape34xx.o
+tape390-$(CONFIG_S390_TAPE_3490) += tape3490.o tape34xx.o
+tape390-objs := tape.o $(sort $(tape390-y))
 
 obj-y += ctrlchar.o
-obj-$(CONFIG_3215_CONSOLE)	+= con3215.o
-obj-$(CONFIG_HWC)		+= hwc_con.o hwc_rw.o hwc_tty.o
-obj-$(CONFIG_3270)		+= tub3270.o
-
-tape-y				:= tape.o
-tape-$(CONFIG_S390_TAPE_CHAR)	+= tapechar.o
-tape-$(CONFIG_S390_TAPE_BLOCK)	+= tapeblock.o
-tape-$(CONFIG_S390_TAPE_3480)	+= tape3480.o tape34xx.o
-tape-$(CONFIG_S390_TAPE_3490)	+= tape3490.o tape34xx.o
-tape390-objs			:= $(sort $(tape-y))
-obj-$(CONFIG_S390_TAPE)		+= tape390.o
-
-# Hand off to Rules.make.
+obj-$(CONFIG_TN3215) += con3215.o
+obj-$(CONFIG_HWC) += hwc_con.o hwc_rw.o hwc_tty.o
+obj-$(CONFIG_HWC_CPI) += hwc_cpi.o
+obj-$(CONFIG_TN3270) += tub3270.o
+obj-$(CONFIG_S390_TAPE) += tape390.o
 
 include $(TOPDIR)/Rules.make
 
-tub3270.o:	$(tub3270-objs)
+tub3270.o: $(tub3270-objs)
 	$(LD) -r -o $@ $(tub3270-objs)
 
-tape390.o:	$(tape390-objs)
+tape390.o: $(tape390-objs)
 	$(LD) -r -o $@ $(tape390-objs)
+
diff -urN linux/drivers/s390/char/con3215.c linux-2.4.7/drivers/s390/char/con3215.c
--- linux/drivers/s390/char/con3215.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/con3215.c	Mon Dec 17 13:41:19 2001
@@ -30,6 +30,7 @@
 #include <asm/delay.h>
 #include <asm/cpcmd.h>
 #include <asm/irq.h>
+#include <asm/setup.h>
 
 #include "ctrlchar.h"
 
@@ -115,18 +116,6 @@
 #define MIN(a,b)	((a) < (b) ? (a) : (b))
 #endif
 
-static int __init con3215_setup(char *str)
-{
-        int vdev;
-
-        vdev = simple_strtoul(str,&str,0);
-        if (vdev >= 0 && vdev < 65536)
-                raw3215_condevice = vdev;
-        return 1;
-}
-
-__setup("condev=", con3215_setup);
-
 /*
  * Get a request structure from the free list
  */
@@ -765,7 +754,7 @@
         while (count <= number && irq != -ENODEV) {
                 if (get_dev_info(irq, &dinfo) == -ENODEV)
                         break;
-                if (dinfo.devno == raw3215_condevice ||
+                if (dinfo.devno == console_device ||
                     dinfo.sid_data.cu_type == 0x3215) {
                         count++;
                     if (count > number)
@@ -776,7 +765,7 @@
         return -1;            /* console not found */
 }
 
-#ifdef CONFIG_3215_CONSOLE
+#ifdef CONFIG_TN3215_CONSOLE
 
 /*
  * Write a string to the 3215 console
@@ -1070,14 +1059,19 @@
 {
 	raw3215_info *raw;
 	raw3215_req *req;
+	int irq;
 	int i;
 
-	if (!MACHINE_IS_VM && !MACHINE_IS_P390)
-                return;
-        if (MACHINE_IS_VM) {
-	        cpcmd("TERM CONMODE 3215", NULL, 0);
-	        cpcmd("TERM AUTOCR OFF", NULL, 0);
-        }
+	/* Check if 3215 is to be the console */
+	if (!CONSOLE_IS_3215)
+		return;
+	irq = raw3215_find_dev(0);
+
+	/* Set the console mode for VM */
+	if (MACHINE_IS_VM) {
+		cpcmd("TERM CONMODE 3215", NULL, 0);
+		cpcmd("TERM AUTOCR OFF", NULL, 0);
+	}
 
 	/* allocate 3215 request structures */
 	raw3215_freelist = NULL;
@@ -1090,7 +1084,7 @@
 
 	ctrlchar_init();
 
-#ifdef CONFIG_3215_CONSOLE
+#ifdef CONFIG_TN3215_CONSOLE
         raw3215[0] = raw = (raw3215_info *)
                 alloc_bootmem_low(sizeof(raw3215_info));
 	memset(raw, 0, sizeof(raw3215_info));
@@ -1126,8 +1120,6 @@
  */
 void __init tty3215_init(void)
 {
-	if (!MACHINE_IS_VM && !MACHINE_IS_P390)
-                return;
 	/*
 	 * Initialize the tty_driver structure
 	 * Entries in tty3215_driver that are NOT initialized:
diff -urN linux/drivers/s390/char/ctrlchar.c linux-2.4.7/drivers/s390/char/ctrlchar.c
--- linux/drivers/s390/char/ctrlchar.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/ctrlchar.c	Mon Dec 17 13:42:42 2001
@@ -1,5 +1,5 @@
 /*
- *  drivers/s390/char/controlchar.c
+ *  drivers/s390/char/ctrlchar.c
  *  Unified handling of special chars.
  *
  *    Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
@@ -38,7 +38,7 @@
 		return;
 	INIT_LIST_HEAD(&ctrlchar_tq.list);
 	ctrlchar_tq.sync = 0;
-	ctrlchar_tq.routine = ctrlchar_handle_sysrq;
+	ctrlchar_tq.routine = (void (*)(void *)) ctrlchar_handle_sysrq;
 #endif
 }
 
diff -urN linux/drivers/s390/char/ctrlchar.h linux-2.4.7/drivers/s390/char/ctrlchar.h
--- linux/drivers/s390/char/ctrlchar.h	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/char/ctrlchar.h	Mon Dec 17 13:41:19 2001
@@ -1,5 +1,5 @@
 /*
- *  drivers/s390/char/controlchar.c
+ *  drivers/s390/char/ctrlchar.c
  *  Unified handling of special chars.
  *
  *    Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
@@ -7,6 +7,7 @@
  *
  */
 
+#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/tty.h>
 
diff -urN linux/drivers/s390/char/hwc.h linux-2.4.7/drivers/s390/char/hwc.h
--- linux/drivers/s390/char/hwc.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/hwc.h	Mon Dec 17 13:41:19 2001
@@ -4,7 +4,7 @@
  *
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Peschke <peschke@fh-brandenburg.de>
+ *    Author(s): Martin Peschke <mpeschke@de.ibm.com>
  *
  * 
  * 
@@ -13,17 +13,22 @@
 #ifndef __HWC_H__
 #define __HWC_H__
 
+#define HWC_EXT_INT_PARAM_ADDR	0xFFFFFFF8
+#define HWC_EXT_INT_PARAM_PEND 0x00000001
+
 #define ET_OpCmd		0x01
 #define ET_Msg		0x02
 #define ET_StateChange	0x08
 #define ET_PMsgCmd		0x09
 #define ET_CntlProgOpCmd	0x20
+#define ET_CntlProgIdent	0x0B
 
 #define ET_OpCmd_Mask	0x80000000
 #define ET_Msg_Mask		0x40000000
 #define ET_StateChange_Mask	0x01000000
 #define ET_PMsgCmd_Mask	0x00800000
 #define ET_CtlProgOpCmd_Mask	0x00000001
+#define ET_CtlProgIdent_Mask	0x00200000
 
 #define GMF_DOM		0x8000
 #define GMF_SndAlrm	0x4000
@@ -210,7 +215,7 @@
 	0x0000,
 	sizeof (_hwcb_mask_t),
 	ET_OpCmd_Mask | ET_PMsgCmd_Mask | ET_StateChange_Mask,
-	ET_Msg_Mask | ET_PMsgCmd_Mask
+	ET_Msg_Mask | ET_PMsgCmd_Mask | ET_CtlProgIdent_Mask
 };
 
 typedef struct {
diff -urN linux/drivers/s390/char/hwc_con.c linux-2.4.7/drivers/s390/char/hwc_con.c
--- linux/drivers/s390/char/hwc_con.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/hwc_con.c	Mon Dec 17 13:41:19 2001
@@ -4,7 +4,7 @@
  *
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Peschke <peschke@fh-brandenburg.de>
+ *    Author(s): Martin Peschke <mpeschke@de.ibm.com>
  */
 
 #include <linux/config.h>
@@ -17,7 +17,6 @@
 #include <linux/fs.h>
 #include <linux/init.h>
 
-#include "ctrlchar.h"
 #include "hwc_rw.h"
 
 #ifdef CONFIG_HWC_CONSOLE
@@ -82,20 +81,14 @@
 void __init 
 hwc_console_init (void)
 {
-
-#if defined(CONFIG_3215_CONSOLE) || defined(CONFIG_3270_CONSOLE)
-	if (MACHINE_IS_VM)
-		return;
-#endif
-	if (MACHINE_IS_P390)
+	if (!MACHINE_HAS_HWC)
 		return;
 
-	ctrlchar_init ();
-  
 	if (hwc_init () == 0) {
 #ifdef CONFIG_HWC_CONSOLE
 
-		register_console (&hwc_console);
+		if (CONSOLE_IS_HWC)
+			register_console (&hwc_console);
 #endif
 	} else
 		panic (HWC_CON_PRINT_HEADER "hwc initialisation failed !");
diff -urN linux/drivers/s390/char/hwc_cpi.c linux-2.4.7/drivers/s390/char/hwc_cpi.c
--- linux/drivers/s390/char/hwc_cpi.c	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/drivers/s390/char/hwc_cpi.c	Mon Dec 17 13:41:49 2001
@@ -0,0 +1,211 @@
+
+/*
+ * Author: Martin Peschke <mpeschke@de.ibm.com>
+ * Copyright (C) 2001 IBM Entwicklung GmbH, IBM Corporation
+ */
+
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/malloc.h>
+#include <linux/version.h>
+#include <asm/semaphore.h>
+#include <asm/ebcdic.h>
+#include "hwc_rw.h"
+#include "hwc.h"
+
+#define CPI_RETRIES		3
+#define CPI_SLEEP_TICKS		50
+
+#define CPI_LENGTH_SYSTEM_TYPE	8
+#define CPI_LENGTH_SYSTEM_NAME	8
+#define CPI_LENGTH_SYSPLEX_NAME	8
+
+typedef struct {
+	_EBUF_HEADER
+	u8 id_format;
+	u8 reserved0;
+	u8 system_type[CPI_LENGTH_SYSTEM_TYPE];
+	u64 reserved1;
+	u8 system_name[CPI_LENGTH_SYSTEM_NAME];
+	u64 reserved2;
+	u64 system_level;
+	u64 reserved3;
+	u8 sysplex_name[CPI_LENGTH_SYSPLEX_NAME];
+	u8 reserved4[16];
+} __attribute__ ((packed)) 
+
+cpi_evbuf_t;
+
+typedef struct _cpi_hwcb_t {
+	_HWCB_HEADER
+	cpi_evbuf_t cpi_evbuf;
+} __attribute__ ((packed)) 
+
+cpi_hwcb_t;
+
+cpi_hwcb_t *cpi_hwcb;
+
+static int __init cpi_module_init (void);
+static void __exit cpi_module_exit (void);
+
+module_init (cpi_module_init);
+module_exit (cpi_module_exit);
+
+MODULE_AUTHOR (
+		      "Martin Peschke, IBM Deutschland Entwicklung GmbH "
+		      "<mpeschke@de.ibm.com>");
+
+MODULE_DESCRIPTION (
+  "identify this operating system instance to the S/390 or zSeries hardware");
+
+static char *system_name = NULL;
+MODULE_PARM (system_name, "s");
+MODULE_PARM_DESC (system_name, "e.g. hostname - max. 8 characters");
+
+static char *sysplex_name = NULL;
+#ifdef ALLOW_SYSPLEX_NAME
+MODULE_PARM (sysplex_name, "s");
+MODULE_PARM_DESC (sysplex_name, "if applicable - max. 8 characters");
+#endif
+
+static char *system_type = "LINUX";
+
+hwc_request_t cpi_request =
+{};
+
+hwc_callback_t cpi_callback;
+
+static DECLARE_MUTEX_LOCKED (sem);
+
+static int __init 
+cpi_module_init (void)
+{
+	int retval;
+	int system_type_length;
+	int system_name_length;
+	int sysplex_name_length = 0;
+	int retries;
+
+	if (!MACHINE_HAS_HWC) {
+		printk ("cpi: bug: hardware console not present\n");
+		retval = -EINVAL;
+		goto out;
+	}
+	if (!system_type) {
+		printk ("cpi: bug: no system type specified\n");
+		retval = -EINVAL;
+		goto out;
+	}
+	system_type_length = strlen (system_type);
+	if (system_type_length > CPI_LENGTH_SYSTEM_NAME) {
+		printk ("cpi: bug: system type has length of %i characters - "
+			"only %i characters supported\n",
+			system_type_length,
+			CPI_LENGTH_SYSTEM_TYPE);
+		retval = -EINVAL;
+		goto out;
+	}
+	if (!system_name) {
+		printk ("cpi: no system name specified\n");
+		retval = -EINVAL;
+		goto out;
+	}
+	system_name_length = strlen (system_name);
+	if (system_name_length > CPI_LENGTH_SYSTEM_NAME) {
+		printk ("cpi: system name has length of %i characters - "
+			"only %i characters supported\n",
+			system_name_length,
+			CPI_LENGTH_SYSTEM_NAME);
+		retval = -EINVAL;
+		goto out;
+	}
+	if (sysplex_name) {
+		sysplex_name_length = strlen (sysplex_name);
+		if (sysplex_name_length > CPI_LENGTH_SYSPLEX_NAME) {
+			printk ("cpi: sysplex name has length of %i characters - "
+				"only %i characters supported\n",
+				sysplex_name_length,
+				CPI_LENGTH_SYSPLEX_NAME);
+			retval = -EINVAL;
+			goto out;
+		}
+	}
+	cpi_hwcb = kmalloc (sizeof (cpi_hwcb_t), GFP_KERNEL);
+	if (!cpi_hwcb) {
+		printk ("cpi: no storage to fulfill request\n");
+		retval = -ENOMEM;
+		goto out;
+	}
+	memset (cpi_hwcb, 0, sizeof (cpi_hwcb_t));
+
+	cpi_hwcb->length = sizeof (cpi_hwcb_t);
+	cpi_hwcb->cpi_evbuf.length = sizeof (cpi_evbuf_t);
+	cpi_hwcb->cpi_evbuf.type = 0x0B;
+
+	memset (cpi_hwcb->cpi_evbuf.system_type, ' ', CPI_LENGTH_SYSTEM_TYPE);
+	memcpy (cpi_hwcb->cpi_evbuf.system_type, system_type, system_type_length);
+	HWC_ASCEBC_STR (cpi_hwcb->cpi_evbuf.system_type, CPI_LENGTH_SYSTEM_TYPE);
+	EBC_TOUPPER (cpi_hwcb->cpi_evbuf.system_type, CPI_LENGTH_SYSTEM_TYPE);
+
+	memset (cpi_hwcb->cpi_evbuf.system_name, ' ', CPI_LENGTH_SYSTEM_NAME);
+	memcpy (cpi_hwcb->cpi_evbuf.system_name, system_name, system_name_length);
+	HWC_ASCEBC_STR (cpi_hwcb->cpi_evbuf.system_name, CPI_LENGTH_SYSTEM_NAME);
+	EBC_TOUPPER (cpi_hwcb->cpi_evbuf.system_name, CPI_LENGTH_SYSTEM_NAME);
+
+	cpi_hwcb->cpi_evbuf.system_level = LINUX_VERSION_CODE;
+
+	if (sysplex_name) {
+		memset (cpi_hwcb->cpi_evbuf.sysplex_name, ' ', CPI_LENGTH_SYSPLEX_NAME);
+		memcpy (cpi_hwcb->cpi_evbuf.sysplex_name, sysplex_name, sysplex_name_length);
+		HWC_ASCEBC_STR (cpi_hwcb->cpi_evbuf.sysplex_name, CPI_LENGTH_SYSPLEX_NAME);
+		EBC_TOUPPER (cpi_hwcb->cpi_evbuf.sysplex_name, CPI_LENGTH_SYSPLEX_NAME);
+	}
+	cpi_request.block = cpi_hwcb;
+	cpi_request.word = HWC_CMDW_WRITEDATA;
+	cpi_request.callback = cpi_callback;
+
+	for (retries = CPI_RETRIES; retries; retries--) {
+		retval = hwc_send (&cpi_request);
+		if (retval) {
+
+			set_current_state (TASK_INTERRUPTIBLE);
+			schedule_timeout (CPI_SLEEP_TICKS);
+		} else {
+
+			down (&sem);
+
+			switch (cpi_hwcb->response_code) {
+			case 0x0020:
+				printk ("cpi: succeeded\n");
+				break;
+			default:
+				printk ("cpi: failed with response code 0x%x\n",
+					cpi_hwcb->response_code);
+			}
+			goto free;
+		}
+	}
+
+	printk ("cpi: failed (%i)\n", retval);
+
+      free:
+	kfree (cpi_hwcb);
+
+      out:
+	return retval;
+}
+
+static void __exit 
+cpi_module_exit (void)
+{
+	printk ("cpi: exit\n");
+}
+
+void 
+cpi_callback (hwc_request_t * req)
+{
+	up (&sem);
+}
diff -urN linux/drivers/s390/char/hwc_rw.c linux-2.4.7/drivers/s390/char/hwc_rw.c
--- linux/drivers/s390/char/hwc_rw.c	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/drivers/s390/char/hwc_rw.c	Mon Dec 17 13:41:49 2001
@@ -4,7 +4,7 @@
  *
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Peschke <peschke@fh-brandenburg.de>
+ *    Author(s): Martin Peschke <mpeschke@de.ibm.com>
  *
  * 
  *
@@ -20,6 +20,7 @@
 #include <linux/mm.h>
 #include <linux/timer.h>
 #include <linux/bootmem.h>
+#include <linux/module.h>
 
 #include <asm/ebcdic.h>
 #include <asm/uaccess.h>
@@ -28,28 +29,25 @@
 #include <asm/setup.h>
 #include <asm/page.h>
 #include <asm/s390_ext.h>
+#include <asm/irq.h>
 
 #ifndef MIN
 #define MIN(a,b) (((a<b) ? a : b))
 #endif
 
-#define HWC_ASCEBC(x) ((MACHINE_IS_VM ? _ascebc[x] : _ascebc_500[x]))
-
-#define HWC_EBCASC_STR(s,c) ((MACHINE_IS_VM ? EBCASC(s,c) : EBCASC_500(s,c)))
-
 #define HWC_RW_PRINT_HEADER "hwc low level driver: "
 
 #define  USE_VM_DETECTION
 
 #define  DEFAULT_CASE_DELIMITER '%'
 
-#define DUMP_HWC_INIT_ERROR
+#undef DUMP_HWC_INIT_ERROR
 
-#define DUMP_HWC_WRITE_ERROR
+#undef DUMP_HWC_WRITE_ERROR
 
-#define DUMP_HWC_WRITE_LIST_ERROR
+#undef DUMP_HWC_WRITE_LIST_ERROR
 
-#define DUMP_HWC_READ_ERROR
+#undef DUMP_HWC_READ_ERROR
 
 #undef DUMP_HWCB_INPUT
 
@@ -179,6 +177,8 @@
 
 	hwc_high_level_calls_t *calls;
 
+	hwc_request_t *request;
+
 	spinlock_t lock;
 
 	struct timer_list write_timer;
@@ -222,6 +222,7 @@
 	    0,
 	    0,
 	    0,
+	    NULL,
 	    NULL
 
 };
@@ -237,17 +238,18 @@
 				unsigned int,
 				unsigned char);
 
+unsigned char hwc_ip_buf[512];
+
 static asmlinkage int 
 internal_print (char write_time, char *fmt,...)
 {
 	va_list args;
 	int i;
-	unsigned char buf[512];
 
 	va_start (args, fmt);
-	i = vsprintf (buf, fmt, args);
+	i = vsprintf (hwc_ip_buf, fmt, args);
 	va_end (args);
-	return do_hwc_write (0, buf, i, write_time);
+	return do_hwc_write (0, hwc_ip_buf, i, write_time);
 }
 
 int 
@@ -255,15 +257,14 @@
 {
 	va_list args;
 	int i;
-	unsigned char buf[512];
 	unsigned long flags;
 	int retval;
 
 	spin_lock_irqsave (&hwc_data.lock, flags);
 
-	i = vsprintf (buf, fmt, args);
+	i = vsprintf (hwc_ip_buf, fmt, args);
 	va_end (args);
-	retval = do_hwc_write (0, buf, i, IMMEDIATE_WRITE);
+	retval = do_hwc_write (0, hwc_ip_buf, i, IMMEDIATE_WRITE);
 
 	spin_unlock_irqrestore (&hwc_data.lock, flags);
 
@@ -327,15 +328,15 @@
 	return condition_code;
 }
 
-static inline unsigned char *
-ext_int_param (void)
+static inline unsigned long 
+hwc_ext_int_param (void)
 {
 	u32 param;
 
 	__asm__ __volatile__ ("L %0,128\n\t"
 			      :"=r" (param));
 
-	return ((unsigned char *) param);
+	return (unsigned long) param;
 }
 
 static int 
@@ -417,11 +418,11 @@
 		internal_print (
 				       DELAYED_WRITE,
 				       HWC_RW_PRINT_HEADER
-			"found invalid HWCB at address 0x%x. List corrupted. "
+		       "found invalid HWCB at address 0x%lx. List corrupted. "
 			   "Lost %i HWCBs with %i characters within up to %i "
 			   "messages. Saved %i HWCB with last %i characters i"
 				       "within up to %i messages.\n",
-				       (unsigned int) bad_addr,
+				       (unsigned long) bad_addr,
 				       lost_hwcb, lost_char, lost_msg,
 				       hwc_data.hwcb_count,
 				       ALL_HWCB_CHAR, ALL_HWCB_MTO);
@@ -747,24 +748,22 @@
 }
 
 static int 
-write_event_data_2 (void)
+write_event_data_2 (u32 ext_int_param)
 {
 	write_hwcb_t *hwcb;
 	int retval = 0;
 
 #ifdef DUMP_HWC_WRITE_ERROR
-	unsigned char *param;
-
-	param = ext_int_param ();
-	if (param != hwc_data.current_hwcb) {
+	if ((ext_int_param & HWC_EXT_INT_PARAM_ADDR)
+	    != (unsigned long) hwc_data.current_hwcb) {
 		internal_print (
 				       DELAYED_WRITE,
 				       HWC_RW_PRINT_HEADER
-				       "write_event_mask_2 : "
+				       "write_event_data_2 : "
 				       "HWCB address does not fit "
-				       "(expected: 0x%x, got: 0x%x).\n",
-				       hwc_data.current_hwcb,
-				       param);
+				       "(expected: 0x%lx, got: 0x%lx).\n",
+				       (unsigned long) hwc_data.current_hwcb,
+				       ext_int_param);
 		return -EINVAL;
 	}
 #endif
@@ -1707,7 +1706,7 @@
 }
 
 static int 
-unconditional_read_2 (void)
+unconditional_read_2 (u32 ext_int_param)
 {
 	read_hwcb_t *hwcb = (read_hwcb_t *) hwc_data.page;
 
@@ -1844,7 +1843,7 @@
 }
 
 static int 
-write_event_mask_2 (void)
+write_event_mask_2 (u32 ext_int_param)
 {
 	init_hwcb_t *hwcb = (init_hwcb_t *) hwc_data.page;
 	int retval = 0;
@@ -1991,7 +1990,7 @@
 	return retval;
 }
 
-void do_hwc_interrupt (struct pt_regs *regs, __u16 code);
+void hwc_interrupt_handler (struct pt_regs *regs, __u16 code);
 
 int 
 hwc_init (void)
@@ -2005,7 +2004,7 @@
 
 #endif
 
-	if (register_external_interrupt (0x2401, do_hwc_interrupt) != 0)
+	if (register_external_interrupt (0x2401, hwc_interrupt_handler) != 0)
 		panic ("Couldn't request external interrupts 0x2401");
 
 	spin_lock_init (&hwc_data.lock);
@@ -2083,60 +2082,161 @@
 	return 0;
 }
 
+int 
+hwc_send (hwc_request_t * req)
+{
+	unsigned long flags;
+	int retval;
+	int cc;
+
+	spin_lock_irqsave (&hwc_data.lock, flags);
+	if (!req || !req->callback || !req->block) {
+		retval = -EINVAL;
+		goto unlock;
+	}
+	if (hwc_data.request) {
+		retval = -ENOTSUPP;
+		goto unlock;
+	}
+	cc = service_call (req->word, req->block);
+	switch (cc) {
+	case 0:
+		hwc_data.request = req;
+		hwc_data.current_servc = req->word;
+		hwc_data.current_hwcb = req->block;
+		retval = 0;
+		break;
+	case 2:
+		retval = -EBUSY;
+		break;
+	default:
+		retval = -ENOSYS;
+
+	}
+      unlock:
+	spin_unlock_irqrestore (&hwc_data.lock, flags);
+	return retval;
+}
+
+EXPORT_SYMBOL (hwc_send);
+
 void 
-do_hwc_interrupt (struct pt_regs *regs, __u16 code)
+do_hwc_callback (u32 ext_int_param)
 {
+	if (!hwc_data.request || !hwc_data.request->callback)
+		return;
+	if ((ext_int_param & HWC_EXT_INT_PARAM_ADDR)
+	    != (unsigned long) hwc_data.request->block)
+		return;
+	hwc_data.request->callback (hwc_data.request);
+	hwc_data.request = NULL;
+	hwc_data.current_hwcb = NULL;
+	hwc_data.current_servc = 0;
+}
 
-	if (hwc_data.flags & HWC_INIT) {
+void 
+hwc_do_interrupt (u32 ext_int_param)
+{
+	u32 finished_hwcb = ext_int_param & HWC_EXT_INT_PARAM_ADDR;
+	u32 evbuf_pending = ext_int_param & HWC_EXT_INT_PARAM_PEND;
 
-		hwc_data.flags |= HWC_INTERRUPT;
-	} else if (hwc_data.flags & HWC_BROKEN) {
+	if (hwc_data.flags & HWC_PTIMER_RUNS) {
+		del_timer (&hwc_data.poll_timer);
+		hwc_data.flags &= ~HWC_PTIMER_RUNS;
+	}
+	if (finished_hwcb) {
 
-		if (!do_hwc_init ()) {
-			hwc_data.flags &= ~HWC_BROKEN;
-			internal_print (DELAYED_WRITE,
-					HWC_RW_PRINT_HEADER
-					"delayed HWC setup after"
-					" temporary breakdown\n");
+		if ((unsigned long) hwc_data.current_hwcb != finished_hwcb) {
+			internal_print (
+					       DELAYED_WRITE,
+					       HWC_RW_PRINT_HEADER
+					       "interrupt: mismatch: "
+					       "ext. int param. (0x%x) vs. "
+					       "current HWCB (0x%x)\n",
+					       ext_int_param,
+					       hwc_data.current_hwcb);
+		} else {
+			if (hwc_data.request) {
+
+				do_hwc_callback (ext_int_param);
+			} else {
+
+				switch (hwc_data.current_servc) {
+
+				case HWC_CMDW_WRITEMASK:
+
+					write_event_mask_2 (ext_int_param);
+					break;
+
+				case HWC_CMDW_WRITEDATA:
+
+					write_event_data_2 (ext_int_param);
+					break;
+
+				case HWC_CMDW_READDATA:
+
+					unconditional_read_2 (ext_int_param);
+					break;
+				default:
+				}
+			}
 		}
 	} else {
-		spin_lock (&hwc_data.lock);
 
-		if (hwc_data.flags & HWC_PTIMER_RUNS) {
-			del_timer (&hwc_data.poll_timer);
-			hwc_data.flags &= ~HWC_PTIMER_RUNS;
+		if (hwc_data.current_hwcb) {
+			internal_print (
+					       DELAYED_WRITE,
+					       HWC_RW_PRINT_HEADER
+					       "interrupt: mismatch: "
+					       "ext. int. param. (0x%x) vs. "
+					       "current HWCB (0x%x)\n",
+					       ext_int_param,
+					       hwc_data.current_hwcb);
 		}
-		if (!hwc_data.current_servc) {
+	}
 
-			unconditional_read_1 ();
+	if (evbuf_pending) {
 
-		} else {
+		unconditional_read_1 ();
+	} else {
 
-			switch (hwc_data.current_servc) {
+		write_event_data_1 ();
+	}
 
-			case HWC_CMDW_WRITEMASK:
+	if (!hwc_data.calls || !hwc_data.calls->wake_up)
+		return;
+	(hwc_data.calls->wake_up) ();
+}
 
-				write_event_mask_2 ();
-				break;
+void 
+hwc_interrupt_handler (struct pt_regs *regs, __u16 code)
+{
+	int cpu = smp_processor_id ();
 
-			case HWC_CMDW_WRITEDATA:
+	u32 ext_int_param = hwc_ext_int_param ();
 
-				write_event_data_2 ();
-				break;
+	irq_enter (cpu, 0x2401);
 
-			case HWC_CMDW_READDATA:
+	if (hwc_data.flags & HWC_INIT) {
 
-				unconditional_read_2 ();
-				break;
-			}
+		hwc_data.flags |= HWC_INTERRUPT;
+	} else if (hwc_data.flags & HWC_BROKEN) {
 
-			write_event_data_1 ();
+		if (!do_hwc_init ()) {
+			hwc_data.flags &= ~HWC_BROKEN;
+			internal_print (DELAYED_WRITE,
+					HWC_RW_PRINT_HEADER
+					"delayed HWC setup after"
+					" temporary breakdown"
+					" (ext. int. parameter=0x%x)\n",
+					ext_int_param);
 		}
-		if (hwc_data.calls != NULL)
-			if (hwc_data.calls->wake_up != NULL)
-				(hwc_data.calls->wake_up) ();
+	} else {
+		spin_lock (&hwc_data.lock);
+		hwc_do_interrupt (ext_int_param);
 		spin_unlock (&hwc_data.lock);
 	}
+	irq_exit (cpu, 0x2401);
 }
 
 void 
diff -urN linux/drivers/s390/char/hwc_rw.h linux-2.4.7/drivers/s390/char/hwc_rw.h
--- linux/drivers/s390/char/hwc_rw.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/char/hwc_rw.h	Mon Dec 17 13:41:19 2001
@@ -4,7 +4,7 @@
  *
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Peschke <peschke@fh-brandenburg.de>
+ *    Author(s): Martin Peschke <mpeschke@de.ibm.com>
  */
 
 #ifndef __HWC_RW_H__
@@ -19,6 +19,25 @@
 	void (*wake_up) (void);
 } hwc_high_level_calls_t;
 
+struct _hwc_request;
+
+typedef void hwc_callback_t (struct _hwc_request *);
+
+typedef struct _hwc_request {
+	void *block;
+	u32 word;
+	hwc_callback_t *callback;
+	void *data;
+} __attribute__ ((packed)) 
+
+hwc_request_t;
+
+#define HWC_ASCEBC(x) ((MACHINE_IS_VM ? _ascebc[x] : _ascebc_500[x]))
+
+#define HWC_EBCASC_STR(s,c) ((MACHINE_IS_VM ? EBCASC(s,c) : EBCASC_500(s,c)))
+
+#define HWC_ASCEBC_STR(s,c) ((MACHINE_IS_VM ? ASCEBC(s,c) : ASCEBC_500(s,c)))
+
 #define IN_HWCB      1
 #define IN_WRITE_BUF 2
 #define IN_BUFS_TOTAL        (IN_HWCB | IN_WRITE_BUF)
@@ -105,6 +124,8 @@
 extern signed int hwc_register_calls (hwc_high_level_calls_t *);
 
 extern signed int hwc_unregister_calls (hwc_high_level_calls_t *);
+
+extern int hwc_send (hwc_request_t *);
 
 #endif
 
diff -urN linux/drivers/s390/char/hwc_tty.c linux-2.4.7/drivers/s390/char/hwc_tty.c
--- linux/drivers/s390/char/hwc_tty.c	Tue May 22 13:23:16 2001
+++ linux-2.4.7/drivers/s390/char/hwc_tty.c	Mon Dec 17 13:41:19 2001
@@ -4,7 +4,7 @@
  *
  *  S390 version
  *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Peschke <peschke@fh-brandenburg.de>
+ *    Author(s): Martin Peschke <mpeschke@de.ibm.com>
  *
  *  Thanks to Martin Schwidefsky.
  */
@@ -22,6 +22,7 @@
 #include <asm/uaccess.h>
 
 #include "hwc_rw.h"
+#include "ctrlchar.h"
 
 #define HWC_TTY_PRINT_HEADER "hwc tty driver: "
 
@@ -217,12 +218,10 @@
 void 
 hwc_tty_init (void)
 {
-#if defined(CONFIG_3215_CONSOLE) || defined(CONFIG_3270_CONSOLE)
-	if (MACHINE_IS_VM)
-		return;
-#endif
-	if (MACHINE_IS_P390)
+	if (!CONSOLE_IS_HWC)
 		return;
+
+	ctrlchar_init ();
 
 	memset (&hwc_tty_driver, 0, sizeof (struct tty_driver));
 	memset (&hwc_tty_data, 0, sizeof (hwc_tty_data_struct));
diff -urN linux/drivers/s390/char/tape.c linux-2.4.7/drivers/s390/char/tape.c
--- linux/drivers/s390/char/tape.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape.c	Mon Dec 17 13:41:19 2001
@@ -18,6 +18,7 @@
 #include <linux/kernel.h>
 #include <linux/version.h>
 #include <linux/proc_fs.h>
+#include <linux/init.h>
 #include <asm/types.h>
 #include <asm/ccwcache.h>
 #include <asm/idals.h>
@@ -26,9 +27,7 @@
 #ifdef MODULE
 #include <linux/module.h>
 #endif   
-#ifdef TAPE_DEBUG
 #include <asm/debug.h>
-#endif
 #ifdef CONFIG_S390_TAPE_DYNAMIC
 #include <asm/s390dyn.h>
 #endif
@@ -50,15 +49,19 @@
 #endif
 #define PRINTK_HEADER "T390:"
 
+
 /* state handling routines */
-inline void tapestate_set (tape_info_t * tape, int newstate);
-inline int tapestate_get (tape_info_t * tape);
-void tapestate_event (tape_info_t * tape, int event);
+inline void tapestate_set (tape_info_t * ti, int newstate);
+inline int tapestate_get (tape_info_t * ti);
+void tapestate_event (tape_info_t * ti, int event);
 
 /* our globals */
 tape_info_t *first_tape_info = NULL;
 tape_discipline_t *first_discipline = NULL;
 tape_frontend_t *first_frontend = NULL;
+devreg_t* tape_devreg[128];
+int devregct=0;
+
 #ifdef TAPE_DEBUG
 debug_info_t *tape_debug_area = NULL;
 #endif
@@ -107,17 +110,17 @@
 devfs_handle_t tape_devfs_root_entry;
 
 inline void
-tape_mkdevfsroots (tape_info_t* tape) 
+tape_mkdevfsroots (tape_info_t* ti) 
 {
     char devno [5];
-    sprintf (devno,"%04X",tape->devinfo.devno);
-    tape->devfs_dir=devfs_mk_dir (tape_devfs_root_entry, devno, tape);
+    sprintf (devno,"%04x",ti->devinfo.devno);
+    ti->devfs_dir=devfs_mk_dir (tape_devfs_root_entry, devno, ti);
 }
 
 inline void
-tape_rmdevfsroots (tape_info_t* tape)
+tape_rmdevfsroots (tape_info_t* ti)
 {
-    devfs_unregister (tape->devfs_dir);
+    devfs_unregister (ti->devfs_dir);
 }
 #endif
 
@@ -135,14 +138,14 @@
 tape_devices_open (struct inode *inode, struct file *file)
 {
     int size=80;
-    tape_info_t* tape;
+    tape_info_t* ti;
     tempinfo_t* tempinfo;
     char* data;
     int pos=0;
     tempinfo = kmalloc (sizeof(tempinfo_t),GFP_KERNEL);
     if (!tempinfo)
         return -ENOMEM;
-    for (tape=first_tape_info;tape!=NULL;tape=tape->next)
+    for (ti=first_tape_info;ti!=NULL;ti=ti->next)
         size+=80; // FIXME: Guess better!
     data=vmalloc(size);
     if (!data) {
@@ -150,13 +153,13 @@
         return -ENOMEM;
     }
     pos+=sprintf(data+pos,"TapeNo\tDevNo\tCuType\tCuModel\tDevType\tDevModel\tState\n");
-    for (tape=first_tape_info;tape!=NULL;tape=tape->next) {
-        pos+=sprintf(data+pos,"%d\t%04X\t%04X\t%02X\t%04X\t%02X\t\t%s\n",tape->rew_minor/2,
-                     tape->devinfo.devno,tape->devinfo.sid_data.cu_type,
-                     tape->devinfo.sid_data.cu_model,tape->devinfo.sid_data.dev_type,
-                     tape->devinfo.sid_data.dev_model,((tapestate_get(tape) >= 0) &&
-                                                       (tapestate_get(tape) < TS_SIZE)) ?
-                     state_verbose[tapestate_get (tape)] : "TS UNKNOWN");
+    for (ti=first_tape_info;ti!=NULL;ti=ti->next) {
+        pos+=sprintf(data+pos,"%d\t%04X\t%04X\t%02X\t%04X\t%02X\t\t%s\n",ti->rew_minor/2,
+                     ti->devinfo.devno,ti->devinfo.sid_data.cu_type,
+                     ti->devinfo.sid_data.cu_model,ti->devinfo.sid_data.dev_type,
+                     ti->devinfo.sid_data.dev_model,((tapestate_get(ti) >= 0) &&
+                                                       (tapestate_get(ti) < TS_SIZE)) ?
+                     state_verbose[tapestate_get (ti)] : "TS UNKNOWN");
     }
     tempinfo->len=pos;
     tempinfo->data=data;
@@ -215,6 +218,183 @@
 };
 #endif /* CONFIG_PROC_FS */
 
+/* SECTION: Parameters for tape */
+char *tape[256] = { NULL, };
+
+#ifndef MODULE
+static char tape_parm_string[1024] __initdata = { 0, };
+static void
+tape_split_parm_string (char *str)
+{
+	char *tmp = str;
+	int count = 0;
+	while (tmp != NULL && *tmp != '\0') {
+		char *end;
+		int len;
+		end = strchr (tmp, ',');
+		if (end == NULL) {
+			len = strlen (tmp) + 1;
+		} else {
+			len = (long) end - (long) tmp + 1;
+			*end = '\0';
+			end++;
+		}
+		tape[count] = kmalloc (len * sizeof (char), GFP_ATOMIC);
+		if (tape[count] == NULL) {
+			printk (KERN_WARNING PRINTK_HEADER
+				"can't store tape= parameter no %d\n",
+				count + 1);
+			break;
+		}
+		memset (tape[count], 0, len * sizeof (char));
+		memcpy (tape[count], tmp, len * sizeof (char));
+		count++;
+		tmp = end;
+	};
+}
+
+void __init
+tape_parm_setup (char *str, int *ints)
+{
+	int len = strlen (tape_parm_string);
+	if (len != 0) {
+		strcat (tape_parm_string, ",");
+	}
+	strcat (tape_parm_string, str);
+}
+
+int __init
+tape_parm_call_setup (char *str)
+{
+	int dummy;
+	tape_parm_setup (str, &dummy);
+	return 1;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,2,16))
+__setup("tape=", tape_parm_call_setup);
+#endif   /* kernel <2.2.19 */
+#endif   /* not defined MODULE */
+
+static inline int
+tape_parm_strtoul (char *str, char **stra)
+{
+	char *temp = str;
+	int val;
+	if (*temp == '0') {
+		temp++;		/* strip leading zero */
+		if (*temp == 'x')
+			temp++;	/* strip leading x */
+	}
+	val = simple_strtoul (temp, &temp, 16);	/* interpret anything as hex */
+	*stra = temp;
+	return val;
+}
+
+static inline devreg_t *
+tape_create_devreg (int devno)
+{
+	devreg_t *devreg = kmalloc (sizeof (devreg_t), GFP_KERNEL);
+	if (devreg != NULL) {
+		memset (devreg, 0, sizeof (devreg_t));
+		devreg->ci.devno = devno;
+		devreg->flag = DEVREG_TYPE_DEVNO;
+		devreg->oper_func = tape_oper_handler;
+	}
+	return devreg;
+}
+
+static inline void
+tape_parm_parse (char **str)
+{
+	char *temp;
+	int from, to,i,irq=0,rc,retries=0,tape_num=0;
+        s390_dev_info_t dinfo;
+        tape_info_t* ti,*tempti;
+        tape_discipline_t* disc;
+        long lockflags;
+	if (*str==NULL) {
+            /* no params present -> leave */
+            return;
+	}
+	while (*str) {
+		temp = *str;
+		from = 0;
+		to = 0;
+
+                /* turn off autodetect mode, if any range is present */
+                from = tape_parm_strtoul (temp, &temp);
+                to = from;
+                if (*temp == '-') {
+                    temp++;
+                    to = tape_parm_strtoul (temp, &temp);
+                }
+                for (i=from;i<=to;i++) {
+                    retries=0;
+                    // register for attch/detach of a devno
+                    tape_devreg[devregct]=tape_create_devreg(i);
+                    if (tape_devreg[devregct]==NULL) {
+                        PRINT_WARN ("Could not create devreg for devno %04x, dyn. attach for this devno deactivated.\n",i);
+                    } else {
+                        s390_device_register (tape_devreg[devregct++]);
+                    }
+                    // we are activating a device if it is present
+                    for (irq = get_irq_first(); irq!=-ENODEV; irq=get_irq_next(irq)) {
+                        rc = get_dev_info_by_irq (irq, &dinfo);
+                     
+                        disc = first_discipline;
+                        while ((dinfo.devno == i) && (disc != NULL) && (disc->cu_type != dinfo.sid_data.cu_type))
+                            disc = (tape_discipline_t *) (disc->next);
+                        if ((disc == NULL) || (rc == -ENODEV) || (i!=dinfo.devno)) {
+                            continue;
+                        }
+#ifdef TAPE_DEBUG
+                        debug_text_event (tape_debug_area,3,"det irq:  ");
+                        debug_int_event (tape_debug_area,3,irq);
+                        debug_text_event (tape_debug_area,3,"cu:       ");
+                        debug_int_event (tape_debug_area,3,disc->cu_type);
+#endif /* TAPE_DEBUG */
+                        PRINT_INFO ("using devno %04x with discipline %04x on irq %d as tape device %d\n",dinfo.devno,dinfo.sid_data.cu_type,irq,tape_num/2);
+                        /* Allocate tape structure  */
+                        ti = kmalloc (sizeof (tape_info_t), GFP_ATOMIC);
+                        if (ti == NULL) {
+#ifdef TAPE_DEBUG
+                            debug_text_exception (tape_debug_area,3,"ti:no mem ");
+#endif /* TAPE_DEBUG */
+                            PRINT_INFO ("tape: can't allocate memory for "
+                                        "tape info structure\n");
+                            continue;
+                        }
+                        memset(ti,0,sizeof(tape_info_t));
+                        ti->discipline = disc;
+                        disc->tape = ti;
+                        rc = tape_setup (ti, irq, tape_num);
+                        if (rc) {
+#ifdef TAPE_DEBUG
+                            debug_text_event (tape_debug_area,3,"tsetup err");
+                            debug_int_exception (tape_debug_area,3,rc);
+#endif /* TAPE_DEBUG */
+                            kfree (ti);
+                        } else {
+                            s390irq_spin_lock_irqsave (irq, lockflags);
+                            if (first_tape_info == NULL) {
+                                first_tape_info = ti;
+                            } else {
+                                tempti = first_tape_info;
+                                while (tempti->next != NULL)
+                                    tempti = tempti->next;
+                                tempti->next = ti;
+                            }
+                            s390irq_spin_unlock_irqrestore (irq, lockflags);
+                        }
+                    }
+                    tape_num+=2;
+                }
+                str++;
+        }
+}
+
+
 /* SECTION: Managing wrappers for ccwcache */
 
 #define TAPE_EMERGENCY_REQUESTS 16
@@ -286,7 +466,6 @@
 		*((ccw_req_t **) (request->cache)) = request;
 	} else {
 		clear_normalized_cda ((ccw1_t *) (request->cpaddr));	// avoid memory leak caused by modeset_byte
-
 		ccw_free_request (request);
 	}
 }
@@ -296,12 +475,12 @@
  */
 inline
  ccw_req_t *
-tape_alloc_ccw_req (tape_info_t * tape, int cplength, int datasize)
+tape_alloc_ccw_req (tape_info_t * ti, int cplength, int datasize)
 {
 	char tape_magic_id[] = "tape";
 	ccw_req_t *cqr = NULL;
 
-	if (!tape)
+	if (!ti)
 		return NULL;
 	cqr = tape_alloc_request (tape_magic_id, cplength, datasize);
 
@@ -311,7 +490,7 @@
 #endif
 	}
 	cqr->magic = TAPE_MAGIC;	/* sets an identifier for tape driver   */
-	cqr->device = tape;	/* save pointer to tape info    */
+	cqr->device = ti;	/* save pointer to tape info    */
 	return cqr;
 }
 
@@ -321,15 +500,15 @@
 static inline tape_info_t *
 tapedev_find_info (int irq)
 {
-	tape_info_t *tape;
+	tape_info_t *ti;
 
-	tape = first_tape_info;
-	if (tape != NULL)
+	ti = first_tape_info;
+	if (ti != NULL)
 		do {
-			if (tape->devinfo.irq == irq)
+			if (ti->devinfo.irq == irq)
 				break;
-		} while ((tape = (tape_info_t *) tape->next) != NULL);
-	return tape;
+		} while ((ti = (tape_info_t *) ti->next) != NULL);
+	return ti;
 }
 
 #define QUEUE_THRESHOLD 5
@@ -340,32 +519,31 @@
 void
 tape_irq (int irq, void *int_parm, struct pt_regs *regs)
 {
-	tape_info_t *tape = tapedev_find_info (irq);
+	tape_info_t *ti = tapedev_find_info (irq);
 
 	/* analyse devstat and fire event */
-	if (tape->devstat.dstat & DEV_STAT_UNIT_CHECK) {
-		tapestate_event (tape, TE_ERROR);
-	} else if (tape->devstat.dstat & (DEV_STAT_DEV_END)) {
-		tapestate_event (tape, TE_DONE);
+	if (ti->devstat.dstat & DEV_STAT_UNIT_CHECK) {
+		tapestate_event (ti, TE_ERROR);
+	} else if (ti->devstat.dstat & (DEV_STAT_DEV_END)) {
+		tapestate_event (ti, TE_DONE);
 	} else
-		tapestate_event (tape, TE_OTHER);
+		tapestate_event (ti, TE_OTHER);
 }
 
 int 
 tape_oper_handler ( int irq, struct _devreg *dreg) {
-    tape_info_t* tape=first_tape_info;
+    tape_info_t* ti=first_tape_info;
     tape_info_t* newtape;
-    int rc,tape_num,retries=0;
+    int rc,tape_num,retries=0,i;
     s390_dev_info_t dinfo;
     tape_discipline_t* disc;
 #ifdef CONFIG_DEVFS_FS
     tape_frontend_t* frontend;
 #endif
     long lockflags;
-    PRINT_WARN ("oper handler was called\n");
-    while ((tape!=NULL) && (tape->devinfo.irq!=irq)) 
-        tape=tape->next;
-    if (tape!=NULL) {
+    while ((ti!=NULL) && (ti->devinfo.irq!=irq)) 
+        ti=ti->next;
+    if (ti!=NULL) {
         // irq is (still) used by tape. tell ingo to try again later
         PRINT_WARN ("Oper handler for irq %d called while irq still (internaly?) used.\n",irq);
         return -EAGAIN;
@@ -384,51 +562,61 @@
     while ((disc != NULL) && (disc->cu_type != dinfo.sid_data.cu_type))
         disc = (tape_discipline_t *) (disc->next);
     if (disc == NULL)
-        PRINT_WARN ("No matching discipline for cu_type %x found\n",dinfo.sid_data.cu_type);
+        PRINT_WARN ("No matching discipline for cu_type %x found, ignoring device %04x.\n",dinfo.sid_data.cu_type,dinfo.devno);
     if (rc == -ENODEV) 
         PRINT_WARN ("No device information for new dev. could be retrieved.\n");
     if ((disc == NULL) || (rc == -ENODEV))
         return -ENODEV;
     
     /* Allocate tape structure  */
-    tape = kmalloc (sizeof (tape_info_t), GFP_ATOMIC);
-    if (tape == NULL) {
-        PRINT_INFO (KERN_ERR "tape: can't allocate memory for "
+    ti = kmalloc (sizeof (tape_info_t), GFP_ATOMIC);
+    if (ti == NULL) {
+        PRINT_INFO ( "tape: can't allocate memory for "
                     "tape info structure\n");
         return -ENOBUFS;
     }
-    memset(tape,0,sizeof(tape_info_t));
-    tape->discipline = disc;
-    disc->tape = tape;
+    memset(ti,0,sizeof(tape_info_t));
+    ti->discipline = disc;
+    disc->tape = ti;
     tape_num=0;
-    newtape=first_tape_info;
-    while (newtape!=NULL) {
-        if (newtape->rew_minor==tape_num) {
-            // tape num in use. try next one
-            tape_num+=2;
-            newtape=first_tape_info;
-        } else {
-            // tape num not used by newtape. look at next tape info
-            newtape=newtape->next;
+    if (*tape) {
+        // we have static device ranges, so fingure out the tape_num of the attached tape
+        for (i=0;i<devregct;i++)
+            if (tape_devreg[i]->ci.devno==dinfo.devno) {
+                tape_num=2*i;
+                break;
+            }
+    } else {
+        // we are running in autoprobe mode, find a free tape_num
+        newtape=first_tape_info;
+        while (newtape!=NULL) {
+            if (newtape->rew_minor==tape_num) {
+                // tape num in use. try next one
+                tape_num+=2;
+                newtape=first_tape_info;
+            } else {
+                // tape num not used by newtape. look at next tape info
+                newtape=newtape->next;
+            }
         }
     }
-    rc = tape_setup (tape, irq, tape_num);
+    rc = tape_setup (ti, irq, tape_num);
     if (rc) {
-        kfree (tape);
+        kfree (ti);
         return -ENOBUFS;
     }
 #ifdef CONFIG_DEVFS_FS
     for (frontend=first_frontend;frontend!=NULL;frontend=frontend->next) 
-        frontend->mkdevfstree(tape);
+        frontend->mkdevfstree(ti);
 #endif
     s390irq_spin_lock_irqsave (irq,lockflags);
     if (first_tape_info == NULL) {
-        first_tape_info = tape;
+        first_tape_info = ti;
     } else {
         newtape = first_tape_info;
         while (newtape->next != NULL)
             newtape = newtape->next;
-        newtape->next = tape;
+        newtape->next = ti;
     }
     s390irq_spin_unlock_irqrestore (irq, lockflags);
     return 0;
@@ -492,8 +680,11 @@
 void
 tape_dump_sense (devstat_t * stat)
 {
-	int sl;
+#ifdef TAPE_DEBUG
+        int sl;
+#endif
 #if 0
+
 	PRINT_WARN ("------------I/O resulted in unit check:-----------\n");
 	for (sl = 0; sl < 4; sl++) {
 		PRINT_WARN ("Sense:");
@@ -542,6 +733,10 @@
 	long lockflags;
 	int rc = 0;
 
+        if (minor>254) {
+            PRINT_WARN ("Device id %d on irq %d will not be accessible since this driver is restricted to 128 devices.\n",minor/2,irq);
+            return -EINVAL;
+        }
 	rc = get_dev_info_by_irq (irq, &(ti->devinfo));
 	if (rc == -ENODEV) {	/* end of device list */
 		return rc;
@@ -560,10 +755,8 @@
 #endif
 	s390irq_spin_lock_irqsave (irq, lockflags);
 	ti->next = NULL;
-	if (rc) {
-		PRINT_WARN ("Cannot register irq %d, rc=%d\n", irq, rc);
-	} else
-		PRINT_WARN ("Register irq %d for using with discipline %x dev #%d\n", irq, ti->discipline->cu_type,ti->blk_minor/2);
+	if (rc)
+            PRINT_WARN ("Cannot register irq %d, rc=%d\n", irq, rc);
 	init_waitqueue_head (&ti->wq);
 	ti->kernbuf = ti->userbuf = ti->discdata = NULL;
 	tapestate_set (ti, TS_UNUSED);
@@ -599,7 +792,7 @@
 #endif /* TAPE_DEBUG */
 
         /* print banner */        
-        PRINT_WARN ("IBM S/390 Tape Device Driver (BETA).\n");
+        PRINT_WARN ("IBM S/390 Tape Device Driver (v1.01).\n");
         PRINT_WARN ("(C) IBM Deutschland Entwicklung GmbH, 2000\n");
         opt_char=opt_block=opt_3480=opt_3490="not present";
 #ifdef CONFIG_S390_TAPE_CHAR
@@ -620,18 +813,33 @@
         PRINT_WARN ("support for 3480 compatible : %s\n",opt_3480);
         PRINT_WARN ("support for 3490 compatible : %s\n",opt_3490);
         
-
+#ifndef MODULE
+        tape_split_parm_string(tape_parm_string);
+#endif
+        if (*tape) 
+            PRINT_INFO ("Using ranges supplied in parameters, disabling autoprobe mode.\n");
+        else
+            PRINT_INFO ("No parameters supplied, enabling autoprobe mode for all supported devices.\n");
 #ifdef CONFIG_S390_TAPE_3490
-	first_discipline = tape3490_init ();
+        if (*tape)
+            first_discipline = tape3490_init (0); // no autoprobe for devices
+        else
+            first_discipline = tape3490_init (1); // do autoprobe since no parm specified
 	first_discipline->next = NULL;
 #endif
 
 #ifdef CONFIG_S390_TAPE_3480
         if (first_discipline == NULL) {
-            first_discipline = tape3480_init ();
+            if (*tape)
+                first_discipline = tape3480_init (0); // no autoprobe for devices
+            else 
+                first_discipline = tape3480_init (1); // do autoprobe since no parm specified
             first_discipline->next = NULL;
         } else {
-            first_discipline->next = tape3480_init ();
+            if (*tape)
+                first_discipline->next = tape3480_init (0); // no autoprobe for devices
+            else
+                first_discipline->next = tape3480_init (1); // do autoprobe since no parm specified
             ((tape_discipline_t*) (first_discipline->next))->next=NULL;
         }
 #endif
@@ -643,33 +851,32 @@
         debug_text_event (tape_debug_area,3,"dev detect");
 #endif /* TAPE_DEBUG */
 	/* Allocate the tape structures */
-	for (irq = 0; irq < NR_IRQS; irq++) {
+        if (*tape!=NULL) {
+            // we have parameters, continue with parsing the parameters and set the devices online
+            tape_parm_parse (tape);
+        } else {
+            // we are running in autodetect mode, search all devices for compatibles
+            for (irq = get_irq_first(); irq!=-ENODEV; irq=get_irq_next(irq)) {
 		rc = get_dev_info_by_irq (irq, &dinfo);
-
-		if (rc == -ENODEV) {
-			retries++;
-			if (retries > 5)
-				irq = NR_IRQS;
-		}
 		disc = first_discipline;
 		while ((disc != NULL) && (disc->cu_type != dinfo.sid_data.cu_type))
-			disc = (tape_discipline_t *) (disc->next);
-
+                    disc = (tape_discipline_t *) (disc->next);
 		if ((disc == NULL) || (rc == -ENODEV))
-			continue;
+                    continue;
 #ifdef TAPE_DEBUG
                 debug_text_event (tape_debug_area,3,"det irq:  ");
                 debug_int_event (tape_debug_area,3,irq);
                 debug_text_event (tape_debug_area,3,"cu:       ");
                 debug_int_event (tape_debug_area,3,disc->cu_type);
 #endif /* TAPE_DEBUG */
+                PRINT_INFO ("using devno %04x with discipline %04x on irq %d as tape device %d\n",dinfo.devno,dinfo.sid_data.cu_type,irq,tape_num/2);
 		/* Allocate tape structure  */
 		ti = kmalloc (sizeof (tape_info_t), GFP_ATOMIC);
 		if (ti == NULL) {
 #ifdef TAPE_DEBUG
                     debug_text_exception (tape_debug_area,3,"ti:no mem ");
 #endif /* TAPE_DEBUG */
-                    PRINT_INFO (KERN_ERR "tape: can't allocate memory for "
+                    PRINT_INFO ("tape: can't allocate memory for "
 				    "tape info structure\n");
                     continue;
 		}
@@ -679,25 +886,26 @@
 		rc = tape_setup (ti, irq, tape_num);
 		if (rc) {
 #ifdef TAPE_DEBUG
-                        debug_text_event (tape_debug_area,3,"tsetup err");
-                        debug_int_exception (tape_debug_area,3,rc);
+                    debug_text_event (tape_debug_area,3,"tsetup err");
+                    debug_int_exception (tape_debug_area,3,rc);
 #endif /* TAPE_DEBUG */
-			kfree (ti);
+                    kfree (ti);
 		} else {
-			s390irq_spin_lock_irqsave (irq, lockflags);
-			if (first_tape_info == NULL) {
-				first_tape_info = ti;
-			} else {
-				tempti = first_tape_info;
-				while (tempti->next != NULL)
-					tempti = tempti->next;
-				tempti->next = ti;
-			}
-			tape_num += 2;
-			s390irq_spin_unlock_irqrestore (irq, lockflags);
+                    s390irq_spin_lock_irqsave (irq, lockflags);
+                    if (first_tape_info == NULL) {
+                        first_tape_info = ti;
+                    } else {
+                        tempti = first_tape_info;
+                        while (tempti->next != NULL)
+                            tempti = tempti->next;
+                        tempti->next = ti;
+                    }
+                    tape_num += 2;
+                    s390irq_spin_unlock_irqrestore (irq, lockflags);
 		}
-	}
-
+            }
+        }
+            
 	/* Allocate local buffer for the ccwcache       */
 	tape_init_emergency_req ();
 #ifdef CONFIG_PROC_FS
@@ -733,6 +941,7 @@
 #ifdef MODULE
 MODULE_AUTHOR("(C) 2001 IBM Deutschland Entwicklung GmbH by Carsten Otte (cotte@de.ibm.com)");
 MODULE_DESCRIPTION("Linux for S/390 channel attached tape device driver");
+MODULE_PARM (tape, "1-" __MODULE_STRING (256) "s");
 
 int
 init_module (void)
@@ -749,17 +958,24 @@
 void
 cleanup_module (void)
 {
-        tape_info_t *tape ,*temp;
+        tape_info_t *ti ,*temp;
         tape_frontend_t* frontend, *tempfe;
         tape_discipline_t* disc ,*tempdi;
+        int i;
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"cleaup mod");
 #endif /* TAPE_DEBUG */
 
-	tape = first_tape_info;
-	while (tape != NULL) {
-		temp = tape;
-		tape = tape->next;
+        if (*tape) {
+            // we are running with parameters. we'll now deregister from our devno's
+            for (i=0;i<devregct;i++) {
+                s390_device_unregister(tape_devreg[devregct]);
+            }
+        }
+	ti = first_tape_info;
+	while (ti != NULL) {
+		temp = ti;
+		ti = ti->next;
                 //cleanup a device 
 #ifdef TAPE_DEBUG
                 debug_text_event (tape_debug_area,6,"free irq:");
@@ -781,7 +997,7 @@
 #endif CONFIG_DEVFS_FS
 #ifdef CONFIG_PROC_FS
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	remove_proc_entry ("devices", &proc_root);
+	remove_proc_entry ("tapedevices", &proc_root);
 #else
 	proc_unregister (&proc_root, tape_devices_entry->low_ino);
 	kfree (tape_devices_entry);
@@ -801,6 +1017,10 @@
 	}
         disc=first_discipline;
 	while (disc != NULL) {
+                if (*tape)
+                    disc->shutdown(0);
+                else
+                    disc->shutdown(1);
 		tempdi = disc;
 		disc = disc->next;
 		kfree (tempdi);
@@ -814,9 +1034,9 @@
 #endif				/* MODULE */
 
 inline void
-tapestate_set (tape_info_t * tape, int newstate)
+tapestate_set (tape_info_t * ti, int newstate)
 {
-    if (tape->tape_state == TS_NOT_OPER) {
+    if (ti->tape_state == TS_NOT_OPER) {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,3,"ts_set err");
         debug_text_exception (tape_debug_area,3,"dev n.oper");
@@ -824,11 +1044,11 @@
     } else {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,4,"ts. dev:  ");
-        debug_int_event (tape_debug_area,4,tape->blk_minor);
+        debug_int_event (tape_debug_area,4,ti->blk_minor);
         debug_text_event (tape_debug_area,4,"old ts:   ");
-        debug_text_event (tape_debug_area,4,(((tapestate_get (tape) < TS_SIZE) &&
-                                             (tapestate_get (tape) >=0 )) ?
-                                            state_verbose[tapestate_get (tape)] :
+        debug_text_event (tape_debug_area,4,(((tapestate_get (ti) < TS_SIZE) &&
+                                             (tapestate_get (ti) >=0 )) ?
+                                            state_verbose[tapestate_get (ti)] :
                                             "UNKNOWN TS"));
         debug_text_event (tape_debug_area,4,"new ts:   ");
         debug_text_event (tape_debug_area,4,(((newstate < TS_SIZE) &&
@@ -836,46 +1056,46 @@
                                              state_verbose[newstate] :
                                              "UNKNOWN TS"));
 #endif /* TAPE_DEBUG */
-	tape->tape_state = newstate;
+	ti->tape_state = newstate;
     }
 }
 
 inline int
-tapestate_get (tape_info_t * tape)
+tapestate_get (tape_info_t * ti)
 {
-	return (tape->tape_state);
+	return (ti->tape_state);
 }
 
 void
-tapestate_event (tape_info_t * tape, int event)
+tapestate_event (tape_info_t * ti, int event)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"te! dev:  ");
-        debug_int_event (tape_debug_area,6,tape->blk_minor);
+        debug_int_event (tape_debug_area,6,ti->blk_minor);
         debug_text_event (tape_debug_area,6,"event:");
         debug_text_event (tape_debug_area,6,((event >=0) &&
                                             (event < TE_SIZE)) ?
                          event_verbose[event] : "TE UNKNOWN");
         debug_text_event (tape_debug_area,6,"state:");
-        debug_text_event (tape_debug_area,6,((tapestate_get(tape) >= 0) &&
-                                            (tapestate_get(tape) < TS_SIZE)) ?
-                         state_verbose[tapestate_get (tape)] :
+        debug_text_event (tape_debug_area,6,((tapestate_get(ti) >= 0) &&
+                                            (tapestate_get(ti) < TS_SIZE)) ?
+                         state_verbose[tapestate_get (ti)] :
                          "TS UNKNOWN");
 #endif /* TAPE_DEBUG */    
         if (event == TE_ERROR) { 
-            tape->discipline->error_recovery(tape);
+            ti->discipline->error_recovery(ti);
         } else {
             if ((event >= 0) &&
                 (event < TE_SIZE) &&
-                (tapestate_get (tape) >= 0) &&
-                (tapestate_get (tape) < TS_SIZE) &&
-                ((*(tape->discipline->event_table))[tapestate_get (tape)][event] != NULL))
-		((*(tape->discipline->event_table))[tapestate_get (tape)][event]) (tape);
+                (tapestate_get (ti) >= 0) &&
+                (tapestate_get (ti) < TS_SIZE) &&
+                ((*(ti->discipline->event_table))[tapestate_get (ti)][event] != NULL))
+		((*(ti->discipline->event_table))[tapestate_get (ti)][event]) (ti);
             else {
 #ifdef TAPE_DEBUG
                 debug_text_exception (tape_debug_area,3,"TE UNEXPEC");
 #endif /* TAPE_DEBUG */
-		tape->discipline->default_handler (tape);
+		ti->discipline->default_handler (ti);
             }
         }
 }
diff -urN linux/drivers/s390/char/tape.h linux-2.4.7/drivers/s390/char/tape.h
--- linux/drivers/s390/char/tape.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape.h	Mon Dec 17 13:41:19 2001
@@ -63,11 +63,12 @@
     TE_START=0, TE_DONE, TE_FAILED, TE_ERROR, TE_OTHER,
     TE_SIZE } tape_events;
 
+typedef void (*tape_disc_shutdown_t) (int);
 typedef void (*tape_event_handler_t) (struct _tape_info_t*);
-typedef ccw_req_t* (*tape_ccwgen_t)(struct _tape_info_t* tape,int count);
-typedef ccw_req_t* (*tape_reqgen_t)(struct request* req,struct _tape_info_t* tape,int tapeblock_major);
-typedef ccw_req_t* (*tape_rwblock_t)(const char* data,size_t count,struct _tape_info_t* tape);
-typedef void (*tape_freeblock_t)(ccw_req_t* cqr,struct _tape_info_t* tape);
+typedef ccw_req_t* (*tape_ccwgen_t)(struct _tape_info_t* ti,int count);
+typedef ccw_req_t* (*tape_reqgen_t)(struct request* req,struct _tape_info_t* ti,int tapeblock_major);
+typedef ccw_req_t* (*tape_rwblock_t)(const char* data,size_t count,struct _tape_info_t* ti);
+typedef void (*tape_freeblock_t)(ccw_req_t* cqr,struct _tape_info_t* ti);
 typedef void (*tape_setup_assist_t) (struct _tape_info_t*);
 #ifdef CONFIG_DEVFS_FS
 typedef void (*tape_devfs_handler_t) (struct _tape_info_t*);
@@ -108,6 +109,7 @@
     tape_ccwgen_t mtmkpart;
     tape_ccwgen_t mtiocget;
     tape_ccwgen_t mtiocpos;
+    tape_disc_shutdown_t shutdown;
     int (*discipline_ioctl_overload)(struct inode *,struct file*, unsigned int,unsigned long);
     tape_event_table_t* event_table;
     tape_event_handler_t default_handler;
@@ -145,6 +147,7 @@
     struct request* current_request;
     int blk_retries;
     long position;
+    int medium_is_unloaded;  // Becomes true when a unload-type operation was issued, false again when medium-insert was detected
     ccw_req_t* cqr;
     atomic_t bh_scheduled;
     struct tq_struct bh_tq;
@@ -167,7 +170,7 @@
 int tape_setup (tape_info_t * ti, int irq, int minor);
 
 /* functoins for alloc'ing ccw stuff */
-inline  ccw_req_t * tape_alloc_ccw_req (tape_info_t* tape, int cplength, int datasize);
+inline  ccw_req_t * tape_alloc_ccw_req (tape_info_t* ti, int cplength, int datasize);
 void tape_free_request (ccw_req_t * request);
 
 /* a function for dumping device sense info */
@@ -179,9 +182,9 @@
 #endif
 
 /* functions for handling the status of a device */
-inline void tapestate_set (tape_info_t * tape, int newstate);
-inline int tapestate_get (tape_info_t * tape);
-void tapestate_event (tape_info_t * tape, int event);
+inline void tapestate_set (tape_info_t * ti, int newstate);
+inline int tapestate_get (tape_info_t * ti);
+void tapestate_event (tape_info_t * ti, int event);
 extern char* state_verbose[TS_SIZE];
 extern char* event_verbose[TE_SIZE];
 
diff -urN linux/drivers/s390/char/tape3480.c linux-2.4.7/drivers/s390/char/tape3480.c
--- linux/drivers/s390/char/tape3480.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape3480.c	Mon Dec 17 13:41:19 2001
@@ -72,22 +72,29 @@
 
 
 void
-tape3480_setup_assist (tape_info_t * tape)
+tape3480_setup_assist (tape_info_t * ti)
 {
 	tape3480_disc_data_t *data = NULL;
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,6,"3480 dsetu");
     debug_text_event (tape_debug_area,6,"dev:");
-    debug_int_event (tape_debug_area,6,tape->blk_minor);
+    debug_int_event (tape_debug_area,6,ti->blk_minor);
 #endif /* TAPE_DEBUG */
 	while (data == NULL)
 		data = kmalloc (sizeof (tape3480_disc_data_t), GFP_KERNEL);
 	data->modeset_byte = 0x00;
-	tape->discdata = (void *) data;
+	ti->discdata = (void *) data;
+}
+
+
+void
+tape3480_shutdown (int autoprobe) {
+    if (autoprobe)
+	s390_device_unregister(&tape3480_devreg);
 }
 
 tape_discipline_t *
-tape3480_init (void)
+tape3480_init (int autoprobe)
 {
 	tape_discipline_t *disc;
 #ifdef TAPE_DEBUG
@@ -132,6 +139,7 @@
 	disc->mtmkpart = tape34xx_mtmkpart;
 	disc->mtiocget = tape34xx_mtiocget;
 	disc->mtiocpos = tape34xx_mtiocpos;
+	disc->shutdown = tape3480_shutdown;
 	disc->discipline_ioctl_overload = tape34xx_ioctl_overload;
 	disc->event_table = &tape3480_event_handler_table;
 	disc->default_handler = tape34xx_default_handler;
@@ -139,7 +147,8 @@
 	disc->free_bread = tape34xx_free_bread;
 	disc->tape = NULL;	/* pointer for backreference */
 	disc->next = NULL;
-	s390_device_register(&tape3480_devreg);
+	if (autoprobe)
+	    s390_device_register(&tape3480_devreg);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,3,"3480 regis");
 #endif /* TAPE_DEBUG */
diff -urN linux/drivers/s390/char/tape3480.h linux-2.4.7/drivers/s390/char/tape3480.h
--- linux/drivers/s390/char/tape3480.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape3480.h	Mon Dec 17 13:41:19 2001
@@ -19,5 +19,5 @@
 typedef struct _tape3480_disc_data_t {
     __u8 modeset_byte;
 } tape3480_disc_data_t  __attribute__ ((packed, aligned(8)));
-tape_discipline_t * tape3480_init (void);
+tape_discipline_t * tape3480_init (int);
 #endif // _TAPE3480_H
diff -urN linux/drivers/s390/char/tape3490.c linux-2.4.7/drivers/s390/char/tape3490.c
--- linux/drivers/s390/char/tape3490.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape3490.c	Mon Dec 17 13:41:19 2001
@@ -71,22 +71,30 @@
 };
 
 void
-tape3490_setup_assist (tape_info_t * tape)
+tape3490_setup_assist (tape_info_t * ti)
 {
 	tape3490_disc_data_t *data = NULL;
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,6,"3490 dsetu");
     debug_text_event (tape_debug_area,6,"dev:");
-    debug_int_event (tape_debug_area,6,tape->blk_minor);
+    debug_int_event (tape_debug_area,6,ti->blk_minor);
 #endif /* TAPE_DEBUG */
 	while (data == NULL)
 		data = kmalloc (sizeof (tape3490_disc_data_t), GFP_KERNEL);
 	data->modeset_byte = 0x00;
-	tape->discdata = (void *) data;
+	ti->discdata = (void *) data;
 }
 
+
+void
+tape3490_shutdown (int autoprobe) {
+    if (autoprobe)
+	s390_device_unregister(&tape3490_devreg);
+}
+
+
 tape_discipline_t *
-tape3490_init (void)
+tape3490_init (int autoprobe)
 {
 	tape_discipline_t *disc;
 #ifdef TAPE_DEBUG
@@ -131,6 +139,7 @@
 	disc->mtmkpart = tape34xx_mtmkpart;
 	disc->mtiocget = tape34xx_mtiocget;
 	disc->mtiocpos = tape34xx_mtiocpos;
+	disc->shutdown = tape3490_shutdown;
 	disc->discipline_ioctl_overload = tape34xx_ioctl_overload;
 	disc->event_table = &tape3490_event_handler_table;
 	disc->default_handler = tape34xx_default_handler;
@@ -138,7 +147,8 @@
 	disc->free_bread = tape34xx_free_bread;
 	disc->tape = NULL;	/* pointer for backreference */
 	disc->next = NULL;
-	s390_device_register(&tape3490_devreg);
+	if (autoprobe)
+	    s390_device_register(&tape3490_devreg);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,3,"3490 regis");
 #endif /* TAPE_DEBUG */
diff -urN linux/drivers/s390/char/tape3490.h linux-2.4.7/drivers/s390/char/tape3490.h
--- linux/drivers/s390/char/tape3490.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape3490.h	Mon Dec 17 13:41:19 2001
@@ -20,5 +20,5 @@
 typedef struct _tape3490_disc_data_t {
     __u8 modeset_byte;
 } tape3490_disc_data_t  __attribute__ ((packed, aligned(8)));
-tape_discipline_t * tape3490_init (void);
+tape_discipline_t * tape3490_init (int);
 #endif // _TAPE3490_H
diff -urN linux/drivers/s390/char/tape34xx.c linux-2.4.7/drivers/s390/char/tape34xx.c
--- linux/drivers/s390/char/tape34xx.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape34xx.c	Mon Dec 17 13:42:47 2001
@@ -82,13 +82,13 @@
 }
 
 ccw_req_t *
-tape34xx_write_block (const char *data, size_t count, tape_info_t * tape)
+tape34xx_write_block (const char *data, size_t count, tape_info_t * ti)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
 	void *mem;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xwbl nomem");
@@ -115,7 +115,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 
 	ccw->cmd_code = WRITE_CMD;
@@ -127,11 +127,11 @@
 		tape_free_request (cqr);
 		return NULL;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = mem;
-	tape->userbuf = (void *) data;
-	tapestate_set (tape, TS_WRI_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = mem;
+	ti->userbuf = (void *) data;
+	tapestate_set (ti, TS_WRI_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xwbl ccwg");
 #endif /* TAPE_DEBUG */
@@ -139,31 +139,31 @@
 }
 
 void 
-tape34xx_free_write_block (ccw_req_t * cqr, tape_info_t * tape)
+tape34xx_free_write_block (ccw_req_t * cqr, tape_info_t * ti)
 {
 	unsigned long lockflags;
 	ccw1_t *ccw;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
 	ccw = cqr->cpaddr;
 	ccw++;
 	clear_normalized_cda (ccw);
-	kfree (tape->kernbuf);
+	kfree (ti->kernbuf);
 	tape_free_request (cqr);
-	tape->kernbuf = tape->userbuf = NULL;
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	ti->kernbuf = ti->userbuf = NULL;
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xfwb free");
 #endif /* TAPE_DEBUG */
 }
 
 ccw_req_t *
-tape34xx_read_block (const char *data, size_t count, tape_info_t * tape)
+tape34xx_read_block (const char *data, size_t count, tape_info_t * ti)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
 	void *mem;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xrbl nomem");
@@ -182,7 +182,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 
 	ccw->cmd_code = READ_FORWARD;
@@ -194,24 +194,25 @@
 		tape_free_request (cqr);
 		return NULL;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = mem;
-	tape->userbuf = (void *) data;
-	tapestate_set (tape, TS_RFO_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = mem;
+	ti->userbuf = (void *) data;
+	tapestate_set (ti, TS_RFO_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xrbl ccwg");
 #endif /* TAPE_DEBUG */
 	return cqr;
 }
+
 ccw_req_t *
-tape34xx_read_opposite (tape_info_t * tape,int novalue)
+tape34xx_read_opposite (tape_info_t * ti,int novalue)
 {
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
 	size_t count;
 	// first, retrieve the count from the old cqr.
-	cqr = tape->cqr;
+	cqr = ti->cqr;
 	ccw = cqr->cpaddr;
 	ccw++;
 	count=ccw->count;
@@ -219,7 +220,7 @@
 	clear_normalized_cda (ccw);
 	tape_free_request (cqr);
 	// build new cqr
-	cqr = tape_alloc_ccw_req (tape, 3, 0);
+	cqr = tape_alloc_ccw_req (ti, 3, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xrop nomem");
@@ -230,13 +231,13 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 
 	ccw->cmd_code = READ_BACKWARD;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = count;
-	set_normalized_cda (ccw, (unsigned long) tape->kernbuf);
+	set_normalized_cda (ccw, (unsigned long) ti->kernbuf);
 	if ((ccw->cda) == 0) {
 		tape_free_request (cqr);
 		return NULL;
@@ -251,7 +252,7 @@
 	ccw->flags = 0;
 	ccw->count = 1;
 	ccw->cda = (unsigned long)ccw;
-	tapestate_set (tape, TS_RBA_INIT);
+	tapestate_set (ti, TS_RBA_INIT);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xrop ccwg");
 #endif /* TAPE_DEBUG */
@@ -259,27 +260,27 @@
 }
 
 void 
-tape34xx_free_read_block (ccw_req_t * cqr, tape_info_t * tape)
+tape34xx_free_read_block (ccw_req_t * cqr, tape_info_t * ti)
 {
 	unsigned long lockflags;
 	size_t cpysize;
 	ccw1_t *ccw;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
 	ccw = cqr->cpaddr;
 	ccw++;
-	cpysize = ccw->count - tape->devstat.rescnt;
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-	if (copy_to_user (tape->userbuf, tape->kernbuf, cpysize)) {
+	cpysize = ccw->count - ti->devstat.rescnt;
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+	if (copy_to_user (ti->userbuf, ti->kernbuf, cpysize)) {
 #ifdef TAPE_DEBUG
 	    debug_text_exception (tape_debug_area,6,"xfrb segf.");
 #endif /* TAPE_DEBUG */
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
 	clear_normalized_cda (ccw);
-	kfree (tape->kernbuf);
+	kfree (ti->kernbuf);
 	tape_free_request (cqr);
-	tape->kernbuf = tape->userbuf = NULL;
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	ti->kernbuf = ti->userbuf = NULL;
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xfrb free");
 #endif /* TAPE_DEBUG */
@@ -294,7 +295,7 @@
  * at the EOT (End of Tape) side of the file mark.
  */
 ccw_req_t *
-tape34xx_mtfsf (tape_info_t * tape, int count)
+tape34xx_mtfsf (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -306,7 +307,7 @@
 #endif /* TAPE_DEBUG */
 		return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xfsf nomem");
@@ -317,7 +318,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = FORSPACEFILE;
@@ -330,11 +331,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_FSF_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_FSF_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xfsf ccwg");
 #endif /* TAPE_DEBUG */
@@ -346,7 +347,7 @@
  * the EOT (End of Tape) side of the last skipped file mark.
  */
 ccw_req_t *
-tape34xx_mtbsf (tape_info_t * tape, int count)
+tape34xx_mtbsf (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -358,7 +359,7 @@
 #endif /* TAPE_DEBUG */
 	        return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xbsf nomem");
@@ -369,7 +370,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = BACKSPACEFILE;
@@ -382,11 +383,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_BSF_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_BSF_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xbsf ccwg");
 #endif /* TAPE_DEBUG */
@@ -398,7 +399,7 @@
  * via MTSETBLK.
  */
 ccw_req_t *
-tape34xx_mtfsr (tape_info_t * tape, int count)
+tape34xx_mtfsr (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -410,7 +411,7 @@
 #endif /* TAPE_DEBUG */
 		return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xfsr nomem");
@@ -421,7 +422,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = FORSPACEBLOCK;
@@ -434,11 +435,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_FSB_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_FSB_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xfsr ccwgen");
 #endif /* TAPE_DEBUG */
@@ -450,7 +451,7 @@
  * (blocksize is set via MTSETBLK.
  */
 ccw_req_t *
-tape34xx_mtbsr (tape_info_t * tape, int count)
+tape34xx_mtbsr (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -462,7 +463,7 @@
 #endif /* TAPE_DEBUG */   
 	        return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xbsr nomem");
@@ -473,7 +474,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = BACKSPACEBLOCK;
@@ -486,11 +487,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_BSB_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_BSB_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xbsr ccwg");
 #endif /* TAPE_DEBUG */
@@ -501,7 +502,7 @@
  * MTWEOF: Write 'count' file marks at the current position.
  */
 ccw_req_t *
-tape34xx_mtweof (tape_info_t * tape, int count)
+tape34xx_mtweof (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -513,7 +514,7 @@
 #endif /* TAPE_DEBUG */
 		return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xweo nomem");
@@ -524,7 +525,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = WRITETAPEMARK;
@@ -538,11 +539,11 @@
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
 	ccw++;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_WTM_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_WTM_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xweo ccwg");
 #endif /* TAPE_DEBUG */
@@ -553,12 +554,12 @@
  * MTREW: Rewind the tape.
  */
 ccw_req_t *
-tape34xx_mtrew (tape_info_t * tape, int count)
+tape34xx_mtrew (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 3, 0);
+	cqr = tape_alloc_ccw_req (ti, 3, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xrew nomem");
@@ -569,7 +570,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = REWIND;
 	ccw->flags = CCW_FLAG_CC;
@@ -580,11 +581,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_REW_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_REW_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xrew ccwg");
 #endif /* TAPE_DEBUG */
@@ -596,12 +597,12 @@
  * Implement 'rewind unload'
  */
 ccw_req_t *
-tape34xx_mtoffl (tape_info_t * tape, int count)
+tape34xx_mtoffl (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 3, 32);
+	cqr = tape_alloc_ccw_req (ti, 3, 32);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xoff nomem");
@@ -612,7 +613,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = REWIND_UNLOAD;
 	ccw->flags = CCW_FLAG_CC;
@@ -623,11 +624,11 @@
 	ccw->flags = 0;
 	ccw->count = 32;
 	ccw->cda = (unsigned long) cqr->cpaddr;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_RUN_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_RUN_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xoff ccwg");
 #endif /* TAPE_DEBUG */
@@ -638,12 +639,12 @@
  * MTNOP: 'No operation'.
  */
 ccw_req_t *
-tape34xx_mtnop (tape_info_t * tape, int count)
+tape34xx_mtnop (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 1, 0);
+	cqr = tape_alloc_ccw_req (ti, 1, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xnop nomem");
@@ -655,11 +656,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) ccw->cmd_code;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xnop ccwg");
 #endif /* TAPE_DEBUG */
@@ -672,7 +673,7 @@
  * last skipped file mark.
  */
 ccw_req_t *
-tape34xx_mtbsfm (tape_info_t * tape, int count)
+tape34xx_mtbsfm (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -684,7 +685,7 @@
 #endif /* TAPE_DEBUG */
 		return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xbsm nomem");
@@ -695,7 +696,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = BACKSPACEFILE;
@@ -708,11 +709,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_BSF_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_BSF_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xbsm ccwg");
 #endif /* TAPE_DEBUG */
@@ -725,7 +726,7 @@
  * of the last skipped file mark.
  */
 ccw_req_t *
-tape34xx_mtfsfm (tape_info_t * tape, int count)
+tape34xx_mtfsfm (tape_info_t * ti, int count)
 {
 	long lockflags;
 	int i;
@@ -737,7 +738,7 @@
 #endif /* TAPE_DEBUG */
 		return NULL;
 	}
-	cqr = tape_alloc_ccw_req (tape, 2 + count, 0);
+	cqr = tape_alloc_ccw_req (ti, 2 + count, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xfsm nomem");
@@ -748,7 +749,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	for (i = 0; i < count; i++) {
 		ccw->cmd_code = FORSPACEFILE;
@@ -761,11 +762,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_FSF_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_FSF_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xfsm ccwg");
 #endif /* TAPE_DEBUG */
@@ -779,12 +780,12 @@
  * MTRETEN: Retension the tape, i.e. forward space to end of tape and rewind.
  */
 ccw_req_t *
-tape34xx_mteom (tape_info_t * tape, int count)
+tape34xx_mteom (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 4, 0);
+	cqr = tape_alloc_ccw_req (ti, 4, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xeom nomem");
@@ -795,7 +796,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = FORSPACEFILE;
 	ccw->flags = CCW_FLAG_CC;
@@ -811,11 +812,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (cqr->cpaddr);
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_FSF_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_FSF_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xeom ccwg");
 #endif /* TAPE_DEBUG */
@@ -826,12 +827,12 @@
  * MTERASE: erases the tape.
  */
 ccw_req_t *
-tape34xx_mterase (tape_info_t * tape, int count)
+tape34xx_mterase (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 5, 0);
+	cqr = tape_alloc_ccw_req (ti, 5, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xera nomem");
@@ -842,7 +843,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = REWIND;
 	ccw->flags = CCW_FLAG_CC;
@@ -863,11 +864,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_DSE_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_DSE_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xera ccwg");
 #endif /* TAPE_DEBUG */
@@ -878,12 +879,12 @@
  * MTSETDENSITY: set tape density.
  */
 ccw_req_t *
-tape34xx_mtsetdensity (tape_info_t * tape, int count)
+tape34xx_mtsetdensity (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xden nomem");
@@ -894,17 +895,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xden ccwg");
 #endif /* TAPE_DEBUG */
@@ -915,7 +916,7 @@
  * MTSEEK: seek to the specified block.
  */
 ccw_req_t *
-tape34xx_mtseek (tape_info_t * tape, int count)
+tape34xx_mtseek (tape_info_t * ti, int count)
 {
 	long lockflags;
 	__u8 *data;
@@ -936,7 +937,7 @@
 		kfree(data);
 		return NULL;
 	}
-	if (((tape34xx_disc_data_t *) tape->discdata)->modeset_byte & 0x08)	// IDRC on
+	if (((tape34xx_disc_data_t *) ti->discdata)->modeset_byte & 0x08)	// IDRC on
 
 		data[1] = data[1] | 0x80;
 	data[3] += count % 256;
@@ -946,7 +947,7 @@
 	debug_text_event (tape_debug_area,6,"xsee id:");
 	debug_int_event (tape_debug_area,6,count);
 #endif /* TAPE_DEBUG */
-	cqr = tape_alloc_ccw_req (tape, 3, 0);
+	cqr = tape_alloc_ccw_req (ti, 3, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xsee nomem");
@@ -958,7 +959,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = LOCATE;
 	ccw->flags = CCW_FLAG_CC;
@@ -969,11 +970,11 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = data;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_LBL_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = data;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_LBL_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xsee ccwg");
 #endif /* TAPE_DEBUG */
@@ -984,13 +985,13 @@
  * MTTELL: Tell block. Return the number of block relative to current file.
  */
 ccw_req_t *
-tape34xx_mttell (tape_info_t * tape, int count)
+tape34xx_mttell (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
 	void *mem;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xtel nomem");
@@ -1009,18 +1010,18 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 
 	ccw->cmd_code = READ_BLOCK_ID;
 	ccw->flags = 0;
 	ccw->count = 8;
 	set_normalized_cda (ccw, (unsigned long) mem);
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = mem;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_RBI_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = mem;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_RBI_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xtel ccwg");
 #endif /* TAPE_DEBUG */
@@ -1032,12 +1033,12 @@
  * Implement NOP.
  */
 ccw_req_t *
-tape34xx_mtsetdrvbuffer (tape_info_t * tape, int count)
+tape34xx_mtsetdrvbuffer (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xbuf nomem");
@@ -1048,17 +1049,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xbuf ccwg");
 #endif /* TAPE_DEBUG */
@@ -1070,12 +1071,12 @@
  * Implement NOP CCW command.
  */
 ccw_req_t *
-tape34xx_mtlock (tape_info_t * tape, int count)
+tape34xx_mtlock (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xloc nomem");
@@ -1086,17 +1087,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xloc ccwg");
 #endif /* TAPE_DEBUG */
@@ -1108,12 +1109,12 @@
  * Implement the NOP CCW command.
  */
 ccw_req_t *
-tape34xx_mtunlock (tape_info_t * tape, int count)
+tape34xx_mtunlock (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xulk nomem");
@@ -1124,17 +1125,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xulk ccwg");
 #endif /* TAPE_DEBUG */
@@ -1143,52 +1144,25 @@
 
 /*
  * MTLOAD: Loads the tape.
- * Implement the NOP CCW command.
+ * This function is not implemented and returns NULL, which causes the Frontend to wait for a medium being loaded.
+ *  The 3480/3490 type Tapes do not support a load command
  */
 ccw_req_t *
-tape34xx_mtload (tape_info_t * tape, int count)
+tape34xx_mtload (tape_info_t * ti, int count)
 {
-	long lockflags;
-	ccw_req_t *cqr;
-	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
-	if (!cqr) {
-#ifdef TAPE_DEBUG
-	        debug_text_exception (tape_debug_area,6,"xloa nomem");
-#endif /* TAPE_DEBUG */
-		return NULL;
-	}
-	ccw = cqr->cpaddr;
-	ccw->cmd_code = MODE_SET_DB;
-	ccw->flags = CCW_FLAG_CC;
-	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
-	ccw++;
-	ccw->cmd_code = NOP;
-	ccw->flags = 0;
-	ccw->count = 0;
-	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-#ifdef TAPE_DEBUG
-	debug_text_event (tape_debug_area,6,"xloa ccwg");
-#endif /* TAPE_DEBUG */
-	return cqr;
+         return NULL;
 }
 
 /*
  * MTUNLOAD: Rewind the tape and unload it.
  */
 ccw_req_t *
-tape34xx_mtunload (tape_info_t * tape, int count)
+tape34xx_mtunload (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 3, 32);
+	cqr = tape_alloc_ccw_req (ti, 3, 32);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xunl nomem");
@@ -1199,7 +1173,7 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = REWIND_UNLOAD;
 	ccw->flags = CCW_FLAG_CC;
@@ -1210,11 +1184,11 @@
 	ccw->flags = 0;
 	ccw->count = 32;
 	ccw->cda = (unsigned long) cqr->cpaddr;
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_RUN_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_RUN_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xunl ccwg");
 #endif /* TAPE_DEBUG */
@@ -1226,7 +1200,7 @@
  * Sets the IDRC on/off.
  */
 ccw_req_t *
-tape34xx_mtcompression (tape_info_t * tape, int count)
+tape34xx_mtcompression (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
@@ -1238,12 +1212,12 @@
 		return NULL;
 	}
 	if (count == 0)
-		((tape34xx_disc_data_t *) tape->discdata)->modeset_byte = 0x00;		// IDRC off
+		((tape34xx_disc_data_t *) ti->discdata)->modeset_byte = 0x00;		// IDRC off
 
 	else
-		((tape34xx_disc_data_t *) tape->discdata)->modeset_byte = 0x08;		// IDRC on
+		((tape34xx_disc_data_t *) ti->discdata)->modeset_byte = 0x08;		// IDRC on
 
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xcom nomem");
@@ -1254,17 +1228,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xcom ccwg");
 #endif /* TAPE_DEBUG */
@@ -1276,12 +1250,12 @@
  * Implement the NOP CCW command.
  */
 ccw_req_t *
-tape34xx_mtsetpart (tape_info_t * tape, int count)
+tape34xx_mtsetpart (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xspa nomem");
@@ -1292,17 +1266,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xspa ccwg");
 #endif /* TAPE_DEBUG */
@@ -1314,12 +1288,12 @@
  * Implement the NOP CCW command.
  */
 ccw_req_t *
-tape34xx_mtmkpart (tape_info_t * tape, int count)
+tape34xx_mtmkpart (tape_info_t * ti, int count)
 {
 	long lockflags;
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
-	cqr = tape_alloc_ccw_req (tape, 2, 0);
+	cqr = tape_alloc_ccw_req (ti, 2, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xnpa nomem");
@@ -1330,17 +1304,17 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
 	ccw++;
 	ccw->cmd_code = NOP;
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->kernbuf = NULL;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_NOP_INIT);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->kernbuf = NULL;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_NOP_INIT);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xnpa ccwg");
 #endif /* TAPE_DEBUG */
@@ -1351,7 +1325,7 @@
  * MTIOCGET: query the tape drive status.
  */
 ccw_req_t *
-tape34xx_mtiocget (tape_info_t * tape, int count)
+tape34xx_mtiocget (tape_info_t * ti, int count)
 {
 	return NULL;
 }
@@ -1360,22 +1334,22 @@
  * MTIOCPOS: query the tape position.
  */
 ccw_req_t *
-tape34xx_mtiocpos (tape_info_t * tape, int count)
+tape34xx_mtiocpos (tape_info_t * ti, int count)
 {
 	return NULL;
 }
 
-ccw_req_t * tape34xx_bread (struct request *req,tape_info_t* tape,int tapeblock_major) {
+ccw_req_t * tape34xx_bread (struct request *req,tape_info_t* ti,int tapeblock_major) {
 	ccw_req_t *cqr;
 	ccw1_t *ccw;
 	__u8 *data;
-	int s2b = blksize_size[tapeblock_major][tape->blk_minor]/hardsect_size[tapeblock_major][tape->blk_minor];
+	int s2b = blksize_size[tapeblock_major][ti->blk_minor]/hardsect_size[tapeblock_major][ti->blk_minor];
 	int realcount;
 	int size,bhct = 0;
 	struct buffer_head* bh;
 	for (bh = req->bh; bh; bh = bh->b_reqnext) {
-		if (bh->b_size > blksize_size[tapeblock_major][tape->blk_minor])
-			for (size = 0; size < bh->b_size; size += blksize_size[tapeblock_major][tape->blk_minor])
+		if (bh->b_size > blksize_size[tapeblock_major][ti->blk_minor])
+			for (size = 0; size < bh->b_size; size += blksize_size[tapeblock_major][ti->blk_minor])
 				bhct++;
 		else
 			bhct++;
@@ -1389,7 +1363,7 @@
 	data[0] = 0x01;
 	data[1] = data[2] = data[3] = 0x00;
 	realcount=req->sector/s2b;
-	if (((tape34xx_disc_data_t *) tape->discdata)->modeset_byte & 0x08)	// IDRC on
+	if (((tape34xx_disc_data_t *) ti->discdata)->modeset_byte & 0x08)	// IDRC on
 
 		data[1] = data[1] | 0x80;
 	data[3] += realcount % 256;
@@ -1399,7 +1373,7 @@
 	debug_text_event (tape_debug_area,6,"xBREDid:");
 	debug_int_event (tape_debug_area,6,realcount);
 #endif /* TAPE_DEBUG */
-	cqr = tape_alloc_ccw_req (tape, 2+bhct+1, 0);
+	cqr = tape_alloc_ccw_req (ti, 2+bhct+1, 0);
 	if (!cqr) {
 #ifdef TAPE_DEBUG
 	        debug_text_exception (tape_debug_area,6,"xBREDnomem");
@@ -1411,28 +1385,28 @@
 	ccw->cmd_code = MODE_SET_DB;
 	ccw->flags = CCW_FLAG_CC;
 	ccw->count = 1;
-	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)));
-	if (realcount!=tape->position) {
+	set_normalized_cda (ccw, (unsigned long) (&(((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)));
+	if (realcount!=ti->position) {
 	    ccw++;
 	    ccw->cmd_code = LOCATE;
 	    ccw->flags = CCW_FLAG_CC;
 	    ccw->count = 4;
 	    set_normalized_cda (ccw, (unsigned long) data);
 	}
-	tape->position=realcount+req->nr_sectors/s2b;
+	ti->position=realcount+req->nr_sectors/s2b;
 	for (bh=req->bh;bh!=NULL;) {
 	        ccw->flags = CCW_FLAG_CC;
-		if (bh->b_size >= blksize_size[tapeblock_major][tape->blk_minor]) {
-			for (size = 0; size < bh->b_size; size += blksize_size[tapeblock_major][tape->blk_minor]) {
+		if (bh->b_size >= blksize_size[tapeblock_major][ti->blk_minor]) {
+			for (size = 0; size < bh->b_size; size += blksize_size[tapeblock_major][ti->blk_minor]) {
 			        ccw++;
 				ccw->flags = CCW_FLAG_CC;
 				ccw->cmd_code = READ_FORWARD;
-				ccw->count = blksize_size[tapeblock_major][tape->blk_minor];
+				ccw->count = blksize_size[tapeblock_major][ti->blk_minor];
 				set_normalized_cda (ccw, __pa (bh->b_data + size));
 			}
 			bh = bh->b_reqnext;
 		} else {	/* group N bhs to fit into byt_per_blk */
-			for (size = 0; bh != NULL && size < blksize_size[tapeblock_major][tape->blk_minor];) {
+			for (size = 0; bh != NULL && size < blksize_size[tapeblock_major][ti->blk_minor];) {
 				ccw++;
 				ccw->flags = CCW_FLAG_DC;
 				ccw->cmd_code = READ_FORWARD;
@@ -1441,10 +1415,10 @@
 				size += bh->b_size;
 				bh = bh->b_reqnext;
 			}
-			if (size != blksize_size[tapeblock_major][tape->blk_minor]) {
+			if (size != blksize_size[tapeblock_major][ti->blk_minor]) {
 				PRINT_WARN ("Cannot fulfill small request %d vs. %d (%ld sects)\n",
 					    size,
-					    blksize_size[tapeblock_major][tape->blk_minor],
+					    blksize_size[tapeblock_major][ti->blk_minor],
 					    req->nr_sectors);
 				kfree(data);
 				tape_free_request (cqr);
@@ -1459,15 +1433,15 @@
 	ccw->flags = 0;
 	ccw->count = 0;
 	ccw->cda = (unsigned long) (&(ccw->cmd_code));
-	tape->kernbuf = data;
-	tape->userbuf = NULL;
-	tapestate_set (tape, TS_BLOCK_INIT);
+	ti->kernbuf = data;
+	ti->userbuf = NULL;
+	tapestate_set (ti, TS_BLOCK_INIT);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"xBREDccwg");
 #endif /* TAPE_DEBUG */
 	return cqr;
 }
-void tape34xx_free_bread (ccw_req_t* cqr,struct _tape_info_t* tape) {
+void tape34xx_free_bread (ccw_req_t* cqr,struct _tape_info_t* ti) {
     ccw1_t* ccw;
     for (ccw=(ccw1_t*)cqr->cpaddr;(ccw->flags & CCW_FLAG_CC)||(ccw->flags & CCW_FLAG_DC);ccw++) 
 	if ((ccw->cmd_code == MODE_SET_DB) ||
@@ -1475,49 +1449,60 @@
 	    (ccw->cmd_code == READ_FORWARD))
 	    clear_normalized_cda(ccw);
     tape_free_request(cqr);
-    kfree(tape->kernbuf);
-    tape->kernbuf=NULL;
+    kfree(ti->kernbuf);
+    ti->kernbuf=NULL;
 }
 
 /* event handlers */
 void
-tape34xx_default_handler (tape_info_t * tape)
+tape34xx_default_handler (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,6,"xdefhandle");
 #endif /* TAPE_DEBUG */
-	tapestate_set (tape, TS_FAILED);
 	PRINT_ERR ("TAPE34XX: An unexpected Unit Check occurred.\n");
 	PRINT_ERR ("TAPE34XX: Please read Documentation/s390/TAPE and report it!\n");
 	PRINT_ERR ("TAPE34XX: Current state is: %s",
-		   (((tapestate_get (tape) < TS_SIZE) && (tapestate_get (tape) >= 0)) ?
-		    state_verbose[tapestate_get (tape)] : "->UNKNOWN STATE<-"));
-	tape_dump_sense (&tape->devstat);
-	tape->rc = -EIO;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+		   (((tapestate_get (ti) < TS_SIZE) && (tapestate_get (ti) >= 0)) ?
+		    state_verbose[tapestate_get (ti)] : "->UNKNOWN STATE<-"));
+	tape_dump_sense (&ti->devstat);
+	ti->rc = -EIO;
+	ti->wanna_wakeup=1;
+        switch (tapestate_get(ti)) {
+        case TS_REW_RELEASE_INIT:
+            tapestate_set(ti,TS_FAILED);
+            wake_up (&ti->wq);
+            break;
+        case TS_BLOCK_INIT:
+            tapestate_set(ti,TS_FAILED);
+            schedule_tapeblock_exec_IO(ti);
+            break;
+        default:
+            tapestate_set(ti,TS_FAILED);
+            wake_up_interruptible (&ti->wq);
+        }      
 }
 
 void
-tape34xx_unexpect_uchk_handler (tape_info_t * tape)
+tape34xx_unexpect_uchk_handler (tape_info_t * ti)
 {
-	if ((tape->devstat.ii.sense.data[0] == 0x40) &&
-	    (tape->devstat.ii.sense.data[1] == 0x40) &&
-	    (tape->devstat.ii.sense.data[3] == 0x43)) {
+	if ((ti->devstat.ii.sense.data[0] == 0x40) &&
+	    (ti->devstat.ii.sense.data[1] == 0x40) &&
+	    (ti->devstat.ii.sense.data[3] == 0x43)) {
 		// no tape in the drive
-	        PRINT_INFO ("Drive %d not ready. No volume loaded.\n", tape->rew_minor / 2);
+	        PRINT_INFO ("Drive %d not ready. No volume loaded.\n", ti->rew_minor / 2);
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,3,"xuuh nomed");
 #endif /* TAPE_DEBUG */
-		tapestate_set (tape, TS_FAILED);
-		tape->rc = -ENOMEDIUM;
-		tape->wanna_wakeup=1;
-		wake_up_interruptible (&tape->wq);
-	} else if ((tape->devstat.ii.sense.data[0] == 0x42) &&
-		   (tape->devstat.ii.sense.data[1] == 0x44) &&
-		   (tape->devstat.ii.sense.data[3] == 0x3b)) {
+		tapestate_set (ti, TS_FAILED);
+		ti->rc = -ENOMEDIUM;
+		ti->wanna_wakeup=1;
+		wake_up_interruptible (&ti->wq);
+	} else if ((ti->devstat.ii.sense.data[0] == 0x42) &&
+		   (ti->devstat.ii.sense.data[1] == 0x44) &&
+		   (ti->devstat.ii.sense.data[3] == 0x3b)) {
        	        PRINT_INFO ("Media in drive %d was changed!\n",
-			    tape->rew_minor / 2);
+			    ti->rew_minor / 2);
 #ifdef TAPE_DEBUG
 		debug_text_event (tape_debug_area,3,"xuuh medchg");
 #endif
@@ -1526,261 +1511,273 @@
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,3,"xuuh unexp");
 	        debug_text_event (tape_debug_area,3,"state:");
-	        debug_text_event (tape_debug_area,3,((tapestate_get (tape) < TS_SIZE) && 
-						     (tapestate_get (tape) >= 0)) ?
-				  state_verbose[tapestate_get (tape)] : 
+	        debug_text_event (tape_debug_area,3,((tapestate_get (ti) < TS_SIZE) && 
+						     (tapestate_get (ti) >= 0)) ?
+				  state_verbose[tapestate_get (ti)] : 
 				  "TS UNKNOWN");
 #endif /* TAPE_DEBUG */
-		tape34xx_default_handler (tape);
+		tape34xx_default_handler (ti);
 	}
 }
 
 void
-tape34xx_unused_done (tape_info_t * tape)
+tape34xx_unused_done (tape_info_t * ti)
 {
-	if ((tape->devstat.ii.sense.data[0] == 0x40) &&
-	    (tape->devstat.ii.sense.data[1] == 0x40) &&
-	    (tape->devstat.ii.sense.data[3] == 0x43)) {
-	    // A medium was inserted in the drive!
+    if (ti->medium_is_unloaded) {
+	// A medium was inserted in the drive!
 #ifdef TAPE_DEBUG
-	    debug_text_event (tape_debug_area,6,"xuud med");
+	debug_text_event (tape_debug_area,6,"xuui med");
 #endif /* TAPE_DEBUG */
-	} else {
+	PRINT_WARN ("A medium was inserted into the tape.\n");
+	ti->medium_is_unloaded=0;
+    } else {
 #ifdef TAPE_DEBUG
-	        debug_text_event (tape_debug_area,3,"unsol.irq!");
-	        debug_text_event (tape_debug_area,3,"dev end");
-	        debug_int_exception (tape_debug_area,3,tape->devinfo.irq);
+        debug_text_event (tape_debug_area,3,"unsol.irq!");
+        debug_text_event (tape_debug_area,3,"dev end");
+        debug_int_exception (tape_debug_area,3,ti->devinfo.irq);
 #endif /* TAPE_DEBUG */
-		PRINT_WARN ("Unsolicited IRQ (Device End) caught in unused state.\n");
-		tape_dump_sense (&tape->devstat);
-	}
+	PRINT_WARN ("Unsolicited IRQ (Device End) caught in unused state.\n");
+	tape_dump_sense (&ti->devstat);
+    }
 }
 
 
 void
-tape34xx_idle_done (tape_info_t * tape)
+tape34xx_idle_done (tape_info_t * ti)
 {
+    if (ti->medium_is_unloaded) {
+	// A medium was inserted in the drive!
+#ifdef TAPE_DEBUG
+	debug_text_event (tape_debug_area,6,"xuud med");
+#endif /* TAPE_DEBUG */
+	PRINT_WARN ("A medium was inserted into the tape.\n");
+	ti->medium_is_unloaded=0;
+	wake_up_interruptible (&ti->wq);
+    } else {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,3,"unsol.irq!");
         debug_text_event (tape_debug_area,3,"dev end");
-        debug_int_exception (tape_debug_area,3,tape->devinfo.irq);
+        debug_int_exception (tape_debug_area,3,ti->devinfo.irq);
 #endif /* TAPE_DEBUG */
 	PRINT_WARN ("Unsolicited IRQ (Device End) caught in idle state.\n");
-	tape_dump_sense (&tape->devstat);
+	tape_dump_sense (&ti->devstat);
+    }
 }
 
 void
-tape34xx_block_done (tape_info_t * tape)
+tape34xx_block_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"x:bREQdone");
 #endif /* TAPE_DEBUG */
-	tapestate_set(tape,TS_DONE);
-	schedule_tapeblock_exec_IO(tape);
+	tapestate_set(ti,TS_DONE);
+	schedule_tapeblock_exec_IO(ti);
 }
 
 void
-tape34xx_bsf_init_done (tape_info_t * tape)
+tape34xx_bsf_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"bsf done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_dse_init_done (tape_info_t * tape)
+tape34xx_dse_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"dse done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_fsf_init_done (tape_info_t * tape)
+tape34xx_fsf_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"fsf done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_fsb_init_done (tape_info_t * tape)
+tape34xx_fsb_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"fsb done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_bsb_init_done (tape_info_t * tape)
+tape34xx_bsb_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"bsb done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_lbl_init_done (tape_info_t * tape)
+tape34xx_lbl_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"lbl done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
 	//s390irq_spin_unlock(tape->devinfo.irq);
-	tape->wanna_wakeup=1;
-	wake_up (&tape->wq);
+	ti->wanna_wakeup=1;
+	wake_up (&ti->wq);
 }
 
 void
-tape34xx_nop_init_done (tape_info_t * tape)
+tape34xx_nop_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"nop done..");
         debug_text_exception (tape_debug_area,6,"or rew/rel");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
 	//s390irq_spin_unlock(tape->devinfo.irq);
-	tape->wanna_wakeup=1;
-	wake_up (&tape->wq);
+	ti->wanna_wakeup=1;
+	wake_up (&ti->wq);
 }
 
 void
-tape34xx_rfo_init_done (tape_info_t * tape)
+tape34xx_rfo_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"rfo done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up (&ti->wq);
 }
 
 void
-tape34xx_rbi_init_done (tape_info_t * tape)
+tape34xx_rbi_init_done (tape_info_t * ti)
 {
 	__u8 *data;
+#ifdef TAPE_DEBUG
 	int i;
-	tapestate_set (tape, TS_FAILED);
-	data = tape->kernbuf;
-	tape->rc = data[3];
-	tape->rc += 256 * data[2];
-	tape->rc += 65536 * (data[1] & 0x3F);
+#endif
+	tapestate_set (ti, TS_FAILED);
+	data = ti->kernbuf;
+	ti->rc = data[3];
+	ti->rc += 256 * data[2];
+	ti->rc += 65536 * (data[1] & 0x3F);
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"rbi done");
         debug_text_event (tape_debug_area,6,"data:");
 	for (i=0;i<8;i++)
 	    debug_int_event (tape_debug_area,6,data[i]);
 #endif
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_rew_init_done (tape_info_t * tape)
+tape34xx_rew_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"rew done");
 #endif
 	//BH: use irqsave
 	//s390irq_spin_lock(tape->devinfo.irq);
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
 	//s390irq_spin_unlock(tape->devinfo.irq);
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_rew_release_init_done (tape_info_t * tape)
+tape34xx_rew_release_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"rewR done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
 	//s390irq_spin_unlock(tape->devinfo.irq);
-	tape->wanna_wakeup=1;
-	wake_up (&tape->wq);
+	ti->wanna_wakeup=1;
+	wake_up (&ti->wq);
 }
 
 void
-tape34xx_run_init_done (tape_info_t * tape)
+tape34xx_run_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"rew done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_wri_init_done (tape_info_t * tape)
+tape34xx_wri_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"wri done");
 #endif
 	//BH: use irqsave
-	//s390irq_spin_lock(tape->devinfo.irq);
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	//s390irq_spin_unlock(tape->devinfo.irq);
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	//s390irq_spin_lock(ti->devinfo.irq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	//s390irq_spin_unlock(ti->devinfo.irq);
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 void
-tape34xx_wtm_init_done (tape_info_t * tape)
+tape34xx_wtm_init_done (tape_info_t * ti)
 {
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,3,"wtm done");
 #endif
-	tapestate_set (tape, TS_DONE);
-	tape->rc = 0;
-	tape->wanna_wakeup=1;
-	wake_up_interruptible (&tape->wq);
+	tapestate_set (ti, TS_DONE);
+	ti->rc = 0;
+	ti->wanna_wakeup=1;
+	wake_up_interruptible (&ti->wq);
 }
 
 /* This function analyses the tape's sense-data in case of a unit-check. If possible,
    it tries to recover from the error. Else the user is informed about the problem. */
 void
-tape34xx_error_recovery (tape_info_t* tape)
+tape34xx_error_recovery (tape_info_t* ti)
 {
-    __u8* sense=tape->devstat.ii.sense.data;
+    __u8* sense=ti->devstat.ii.sense.data;
     int inhibit_cu_recovery=0;
-    int cu_type=tape->discipline->cu_type;
-    if ((((tape34xx_disc_data_t *) tape->discdata)->modeset_byte)&0x80) inhibit_cu_recovery=1;
-    if (tapestate_get(tape)==TS_BLOCK_INIT) {
+    int cu_type=ti->discipline->cu_type;
+    if ((((tape34xx_disc_data_t *) ti->discdata)->modeset_byte)&0x80) inhibit_cu_recovery=1;
+    if (tapestate_get(ti)==TS_BLOCK_INIT) {
 	// no recovery for block device, bottom half will retry...
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     }
     if (sense[0]&SENSE_COMMAND_REJECT)
-	switch (tapestate_get(tape)) {
+	switch (tapestate_get(ti)) {
 	case TS_BLOCK_INIT:
 	case TS_DSE_INIT:
 	case TS_EGA_INIT:
@@ -1788,33 +1785,33 @@
 	case TS_WTM_INIT:
 	    if (sense[1]&SENSE_WRITE_PROTECT) {
 		// trying to write, but medium is write protected
-		tape34xx_error_recovery_has_failed(tape,EACCES);
+		tape34xx_error_recovery_has_failed(ti,EACCES);
 		return;
 	    }
 	default:
-	    tape34xx_error_recovery_HWBUG(tape,1);
+	    tape34xx_error_recovery_HWBUG(ti,1);
 	    return;
 	}
     // special cases for various tape-states when reaching end of recorded area
     if (((sense[0]==0x08) || (sense[0]==0x10) || (sense[0]==0x12)) &&
 	((sense[1]==0x40) || (sense[1]==0x0c)))
-	switch (tapestate_get(tape)) {
+	switch (tapestate_get(ti)) {
 	case TS_FSF_INIT:
 	    // Trying to seek beyond end of recorded area
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	case TS_LBL_INIT:
 	    // Block could not be located.
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	case TS_RFO_INIT:
 	    // Try to read beyond end of recorded area -> 0 bytes read
-	    tape34xx_error_recovery_has_failed(tape,0);
+	    tape34xx_error_recovery_has_failed(ti,0);
 	    return;
 	}
     // Sensing special bits
     if (sense[0]&SENSE_BUS_OUT_CHECK) {
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     }
     if (sense[0]&SENSE_DATA_CHECK) {
@@ -1826,12 +1823,12 @@
 		(inhibit_cu_recovery)) {
 		// data check is not permanent, may be recovered. 
 		// We always use async-mode with cu-recovery, so this should *never* happen.
-		tape34xx_error_recovery_HWBUG(tape,2);
+		tape34xx_error_recovery_HWBUG(ti,2);
 		return;
 	    } else {
 		// data check is permanent, CU recovery has failed
 		PRINT_WARN("Permanent read error, recovery failed!\n");
-		tape34xx_error_recovery_has_failed(tape,EIO);
+		tape34xx_error_recovery_has_failed(ti,EIO);
 		return;
 	    }
 	case 0x25:
@@ -1840,38 +1837,38 @@
 		(inhibit_cu_recovery)) {
 		// data check is not permanent, may be recovered.
 		// We always use async-mode with cu-recovery, so this should *never* happen.
-		tape34xx_error_recovery_HWBUG(tape,3);
+		tape34xx_error_recovery_HWBUG(ti,3);
 		return;
 	    } else {
 		// data check is permanent, cu-recovery has failed
 		PRINT_WARN("Permanent write error, recovery failed!\n");
-		tape34xx_error_recovery_has_failed(tape,EIO);
+		tape34xx_error_recovery_has_failed(ti,EIO);
 		return;
 	    }
 	case 0x26:
 	    // Data Check (read opposite) occurred. We'll recover this.
-	    tape34xx_error_recovery_read_opposite(tape);
+	    tape34xx_error_recovery_read_opposite(ti);
 	    return;
 	case 0x28:
 	    // The ID-Mark at the beginning of the tape could not be written. This is fatal, we'll report and exit.
 	    PRINT_WARN("ID-Mark could not be written. Check your hardware!\n");
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	case 0x31:
 	    // Tape void. Tried to read beyond end of device. We'll report and exit.
 	    PRINT_WARN("Try to read beyond end of recorded area!\n");
-	    tape34xx_error_recovery_has_failed(tape,ENOSPC);
+	    tape34xx_error_recovery_has_failed(ti,ENOSPC);
 	    return;
 	case 0x41:
 	    // Record sequence error. cu detected incorrect block-id sequence on tape. We'll report and exit.
 	    PRINT_WARN("Illegal block-id sequence found!\n");
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	    default:
 	    // well, all data checks for 3480 should result in one of the above erpa-codes. if not -> bug
 	    // On 3490, other data-check conditions do exist.
 		if (cu_type==0x3480) {
-		    tape34xx_error_recovery_HWBUG(tape,4);
+		    tape34xx_error_recovery_HWBUG(ti,4);
 		    return;
 		}
 	}
@@ -1881,11 +1878,11 @@
 	switch (sense[3]) {
 	case 0x40: // overrun error
 	    PRINT_WARN ("Data overrun error between control-unit and drive. Use a faster channel connection, if possible! \n");
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	default:
 	    // Overrun bit is set, but erpa does not show overrun error. This is a bug.
-	    tape34xx_error_recovery_HWBUG(tape,5);
+	    tape34xx_error_recovery_HWBUG(ti,5);
 	    return;
 	}
     }
@@ -1894,11 +1891,11 @@
 	case 0x41:
 	    // Record sequence error. cu detected incorrect block-id sequence on tape. We'll report and exit.
 	    PRINT_WARN("Illegal block-id sequence found!\n");
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	default:
 	    // Record sequence error bit is set, but erpa does not show record sequence error. This is a bug.
-	    tape34xx_error_recovery_HWBUG(tape,6);
+	    tape34xx_error_recovery_HWBUG(ti,6);
 	    return;
 	}
     }
@@ -1911,119 +1908,119 @@
     case 0x21:
 	// Data streaming not operational. Cu switches to interlock mode, we reissue the command.
 	PRINT_WARN ("Data streaming not operational. Switching to interlock-mode! \n");
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x22:
 	// Path equipment check. Might be drive adapter error, buffer error on the lower interface, internal path not useable, or error during cartridge load.
 	// All of the above are not recoverable
 	PRINT_WARN ("A path equipment check occurred. One of the following conditions occurred:\n");
 	PRINT_WARN ("drive adapter error,buffer error on the lower interface, internal path not useable, error during cartridge load.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x23:
 	// Read data check. Should have been be covered earlier -> Bug!
-	tape34xx_error_recovery_HWBUG(tape,7);
+	tape34xx_error_recovery_HWBUG(ti,7);
 	return;
     case 0x24:
 	// Load display check. Load display was command was issued, but the drive is displaying a drive check message. Can be threated as "device end".
-	tape34xx_error_recovery_succeded(tape);
+	tape34xx_error_recovery_succeded(ti);
 	return;
     case 0x25:
 	// Write data check. Should have been covered earlier -> Bug!
-	tape34xx_error_recovery_HWBUG(tape,8);
+	tape34xx_error_recovery_HWBUG(ti,8);
 	return;
     case 0x26:
 	// Data check (read opposite). Should have been covered earlier -> Bug!
-	tape34xx_error_recovery_HWBUG(tape,9);
+	tape34xx_error_recovery_HWBUG(ti,9);
 	return;
     case 0x27:
 	// Command reject. May indicate illegal channel program or buffer over/underrun. 
 	// Since all channel programms are issued by this driver and ought be correct,
 	// we assume a over/underrun situaltion and retry the channel program.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x28:
 	// Write id mark check. Should have beed covered earlier -> bug!
-	tape34xx_error_recovery_HWBUG(tape,10);
+	tape34xx_error_recovery_HWBUG(ti,10);
 	return;
     case 0x29:
 	// Function incompatible. Either idrc is on but hardware not capable doing idrc 
 	// or a perform subsystem func is issued and the cu is not online. Anyway, this 
 	// cannot be recovered and is an I/O error.
 	PRINT_WARN ("Function incompatible. Try to switch off idrc! \n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x2a:
 	// Unsolicited environmental data. An internal counter overflows, we can ignore
 	// this and reissue the cmd.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x2b:
 	// Environmental data present. Indicates either unload completed ok or read buffered 
 	// log command completed ok. 
-	if (tapestate_get(tape)==TS_RUN_INIT) {
+	if (tapestate_get(ti)==TS_RUN_INIT) {
 	    // Rewind unload completed ok.
-	    tape34xx_error_recovery_succeded(tape);
+	    tape34xx_error_recovery_succeded(ti);
 	    return;
 	}
 	// Since we do not issue read buffered log commands, this should never occur -> bug.
-	tape34xx_error_recovery_HWBUG(tape,11);
+	tape34xx_error_recovery_HWBUG(ti,11);
 	return;
     case 0x2c:
 	// Permanent equipment check. cu has tried recovery, but did not succeed. This is an
 	// I/O error.
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x2d:
 	// Data security erase failure.
-	if (tapestate_get(tape)==TS_DSE_INIT) {
+	if (tapestate_get(ti)==TS_DSE_INIT) {
 	    // report an I/O error
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	}
 	// Data security erase failure, but no such command issued. This is a bug.
-	tape34xx_error_recovery_HWBUG(tape,12);
+	tape34xx_error_recovery_HWBUG(ti,12);
 	return;
     case 0x2e:
 	// Not capable. This indicates either that the drive fails reading the format id mark
 	// or that that format specified is not supported by the drive. We write a message and
 	// return an I/O error.
 	PRINT_WARN("Drive not capable processing the tape format!");
-	tape34xx_error_recovery_has_failed(tape,EMEDIUMTYPE);
+	tape34xx_error_recovery_has_failed(ti,EMEDIUMTYPE);
 	return;
     case 0x2f:
 	// This erpa is reserved. This is a bug.
-	tape34xx_error_recovery_HWBUG(tape,13);
+	tape34xx_error_recovery_HWBUG(ti,13);
 	return;
     case 0x30:
 	// The medium is write protected, while trying to write on it. We'll report this.
 	PRINT_WARN("Medium is write protected!\n");
-	tape34xx_error_recovery_has_failed(tape,EACCES);
+	tape34xx_error_recovery_has_failed(ti,EACCES);
 	return;
     case 0x31:
 	// Tape void. Should have beed covered ealier -> bug
-	tape34xx_error_recovery_HWBUG(tape,14);
+	tape34xx_error_recovery_HWBUG(ti,14);
 	return;
     case 0x32:
 	// Tension loss. We cannot recover this, it's an I/O error.
 	PRINT_WARN("The drive lost tape tension.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x33:
 	// Load Failure. The catridge was not inserted correctly or the tape is not threaded
 	// correctly. We cannot recover this, the user has to reload the catridge.
 	PRINT_WARN("Cartridge load failure. Reload the cartridge and try again.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x34:
 	// Unload failure. The drive cannot maintain tape tension and control tape movement 
 	// during an unload operation. 
 	PRINT_WARN("Failure during cartridge unload. Please try manually.\n");
-	if (tapestate_get(tape)!=TS_RUN_INIT) {
-	    tape34xx_error_recovery_HWBUG(tape,15);
+	if (tapestate_get(ti)!=TS_RUN_INIT) {
+	    tape34xx_error_recovery_HWBUG(ti,15);
 	    return;
 	}
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x35:
 	// Drive equipment check. One of the following:
@@ -2032,335 +2029,342 @@
 	// - the cartridge loader does not respond correctly
 	// - a failure occurs during an index, load, or unload cycle
 	PRINT_WARN("Equipment check! Please check the drive and the cartridge loader.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x36:
 	switch (cu_type) {
 	case 0x3480:
 	    // This erpa is reserved for 3480 -> BUG
-	    tape34xx_error_recovery_HWBUG(tape,16);
+	    tape34xx_error_recovery_HWBUG(ti,16);
 	    return;
 	case 0x3490:
 	    // End of data. This is a permanent I/O error, which cannot be recovered.
 	    // A read-type command has reached the end-of-data mark.
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	    return;
 	}
     case 0x37:
 	// Tape length error. The tape is shorter than reported in the beginning-of-tape data.
 	PRINT_WARN("Tape length error.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x38:
 	// Physical end of tape. A read/write operation reached the physical end of tape.
-	if (tapestate_get(tape)==TS_WRI_INIT) {
- 	    tape34xx_error_recovery_has_failed(tape,ENOSPC);
+	if (tapestate_get(ti)==TS_WRI_INIT ||
+	    tapestate_get(ti)==TS_DSE_INIT ||
+	    tapestate_get(ti)==TS_EGA_INIT ||
+	    tapestate_get(ti)==TS_WTM_INIT){
+ 	    tape34xx_error_recovery_has_failed(ti,ENOSPC);
+	} else {
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	}
 	return;
     case 0x39:
 	// Backward at BOT. The drive is at BOT and is requestet to move backward.
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x3a:
 	// Drive switched not ready, but the command needs the drive to be ready.
 	PRINT_WARN("Drive not ready. Turn the ready/not ready switch to ready position and try again.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x3b:
 	// Manual rewind or unload. This causes an I/O error.
-	PRINT_WARN("Medium is rewinded or unloaded manually.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	PRINT_WARN("Medium was rewound or unloaded manually. Expect errors! Please do only use the mtoffl and mtrew ioctl to unload tapes or rewind tapes.\n");
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x3c:
     case 0x3d:
     case 0x3e:
     case 0x3f:
 	// These erpas are reserved -> BUG
-	tape34xx_error_recovery_HWBUG(tape,17);
+	tape34xx_error_recovery_HWBUG(ti,17);
 	return;
     case 0x40:
 	// Overrun error. This should have been covered earlier -> bug.
-	tape34xx_error_recovery_HWBUG(tape,18);
+	tape34xx_error_recovery_HWBUG(ti,18);
 	return;
     case 0x41:
 	// Record sequence error. This should have been covered earlier -> bug.
-	tape34xx_error_recovery_HWBUG(tape,19);
+	tape34xx_error_recovery_HWBUG(ti,19);
 	return;
     case 0x42:
 	// Degraded mode. A condition that can cause degraded performace is detected.
 	PRINT_WARN("Subsystem is running in degraded mode. This may compromise your performace.\n");
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x43:
 	// Drive not ready. Probably swith the ready/not ready switch to ready?
 	PRINT_WARN("The drive is not ready. Maybe no medium in?\n");
-	tape34xx_error_recovery_has_failed(tape,ENOMEDIUM);
+	tape34xx_error_recovery_has_failed(ti,ENOMEDIUM);
 	return;
     case 0x44:
 	// Locate Block unsuccessfull. We'll report this.
-	if ((tapestate_get(tape)!=TS_BLOCK_INIT) &&
-	    (tapestate_get(tape)!=TS_LBL_INIT)) {
-	    tape34xx_error_recovery_HWBUG(tape,20); // No locate block was issued...
+	if ((tapestate_get(ti)!=TS_BLOCK_INIT) &&
+	    (tapestate_get(ti)!=TS_LBL_INIT)) {
+	    tape34xx_error_recovery_HWBUG(ti,20); // No locate block was issued...
 	    return;
 	}
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x45:
 	// The drive is assigned elsewhere [to a different channel path/computer].
 	PRINT_WARN("The drive is assigned elsewhere.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x46:
 	// Drive not online. Drive may be switched offline, the power supply may be switched off 
 	// or the drive address may not be set correctly.
 	PRINT_WARN("The drive is not online.");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x47:
 	// Volume fenced. cu reports volume integrity is lost! 
 	PRINT_WARN("Volume fenced. The volume integrity is lost! \n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x48:
 	// Log sense data and retry request. We'll do so...
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x49:
 	// Bus out check. A parity check error on the bus was found.	PRINT_WARN("Bus out check. A data transfer over the bus was corrupted.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x4a:
 	// Control unit erp failed. We'll report this.
 	PRINT_WARN("The control unit failed recovering an I/O error.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x4b:
 	// Cu and drive incompatible. The drive requests micro-program patches, which are not available on the cu.
 	PRINT_WARN("The drive needs microprogram patches from the control unit, which are not available.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x4c:
 	// Recovered Check-One failure. Cu develops a hardware error, but is able to recover. We'll reissue the command.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x4d:
 	switch (cu_type) {
 	case 0x3480:
 	    // This erpa is reserved for 3480 -> bug
-      	    tape34xx_error_recovery_HWBUG(tape,21);
+      	    tape34xx_error_recovery_HWBUG(ti,21);
 	    return;
 	case 0x3490:
 	    // Resetting event recieved. Since the driver does not support resetting event recovery
 	    // (which has to be handled by the I/O Layer), we'll report and retry our command.
-	    tape34xx_error_recovery_do_retry(tape);
+	    tape34xx_error_recovery_do_retry(ti);
 	    return;
 	}
     case 0x4e:
 	switch (cu_type) {
 	case 0x3480:
 	    // This erpa is reserved for 3480 -> bug.
-	    tape34xx_error_recovery_HWBUG(tape,22);
+	    tape34xx_error_recovery_HWBUG(ti,22);
 	    return;
 	case 0x3490:
 	    // Maximum block size exeeded. This indicates, that the block to be written is larger
 	    // than allowed for buffered mode. We'll report this...
 	    PRINT_WARN("Maximum block size for buffered mode exceeded.\n");
-	    tape34xx_error_recovery_has_failed(tape,ENOBUFS);
+	    tape34xx_error_recovery_has_failed(ti,ENOBUFS);
 	    return;
 	}
     case 0x4f:
 	// These erpas are reserved -> bug
-	tape34xx_error_recovery_HWBUG(tape,23);
+	tape34xx_error_recovery_HWBUG(ti,23);
 	return;
     case 0x50:
 	// Read buffered log (Overflow). Cu is running in extended beffered log mode, and a counter overflows.
 	// This should never happen, since we're never running in extended buffered log mode -> bug.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x51:
 	// Read buffered log (EOV). EOF processing occurs while the cu is in extended buffered log mode.
 	// This should never happen, since we're never running in extended buffered log mode -> bug.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x52:
 	// End of Volume complete. Rewind unload completed ok. We'll report to the user...
-	if (tapestate_get(tape)!=TS_RUN_INIT) {
-	    tape34xx_error_recovery_HWBUG(tape,24);
+	if (tapestate_get(ti)!=TS_RUN_INIT) {
+	    tape34xx_error_recovery_HWBUG(ti,24);
 	    return;
 	}
-	tape34xx_error_recovery_succeded(tape);
+	tape34xx_error_recovery_succeded(ti);
 	return;
     case 0x53:
 	// Global command intercept. We'll have to reissue our command.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x54:
 	// Channel interface recovery (temporary). This can be recovered by reissuing the command.
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	return;
     case 0x55:
 	// Channel interface recovery (permanent). This cannot be recovered, we'll inform the user.
 	PRINT_WARN("A permanent channel interface error occurred.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x56:
 	// Channel protocol error. This cannot be recovered.
 	PRINT_WARN("A channel protocol error occurred.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x57:
 	switch (cu_type) {
 	case 0x3480:
 	    // Attention intercept. We have to reissue the command.
 	    PRINT_WARN("An attention intercept occurred, which will be recovered.\n");
-	    tape34xx_error_recovery_do_retry(tape);
+	    tape34xx_error_recovery_do_retry(ti);
 	    return;
 	case 0x3490:
 	    // Global status intercept. We have to reissue the command.
 	    PRINT_WARN("An global status intercept was recieved, which will be recovered.\n");
-	    tape34xx_error_recovery_do_retry(tape);
+	    tape34xx_error_recovery_do_retry(ti);
 	    return;
 	}
     case 0x58:
     case 0x59:
 	// These erpas are reserved -> bug.
-	tape34xx_error_recovery_HWBUG(tape,25);
+	tape34xx_error_recovery_HWBUG(ti,25);
 	return;
     case 0x5a:
 	// Tape length incompatible. The tape inserted is too long, 
 	// which could cause damage to the tape or the drive.
 	PRINT_WARN("Tape length incompatible [should be IBM Cartridge System Tape]. May cause damage to drive or tape.n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x5b:
 	// Format 3480 XF incompatible
 	if (sense[1]&SENSE_BEGINNING_OF_TAPE) {
 	    // Everything is fine. The tape will be overwritten in a different format.
-	    tape34xx_error_recovery_do_retry(tape);
+	    tape34xx_error_recovery_do_retry(ti);
 	    return;
 	}
 	PRINT_WARN("Tape format is incompatible to the drive, which writes 3480-2 XF.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x5c:
 	// Format 3480-2 XF incompatible
 	PRINT_WARN("Tape format is incompatible to the drive. The drive cannot access 3480-2 XF volumes.\n");
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	return;
     case 0x5d:
 	// Tape length violation. 
 	PRINT_WARN("Tape length violation [should be IBM Enhanced Capacity Cartridge System Tape]. May cause damage to drive or tape.\n");
-	tape34xx_error_recovery_has_failed(tape,EMEDIUMTYPE);
+	tape34xx_error_recovery_has_failed(ti,EMEDIUMTYPE);
 	return;
     case 0x5e:
 	// Compaction algorithm incompatible.
 	PRINT_WARN("The volume is recorded using an incompatible compaction algorith, which is not supported by the control unit.\n");
-	tape34xx_error_recovery_has_failed(tape,EMEDIUMTYPE);
+	tape34xx_error_recovery_has_failed(ti,EMEDIUMTYPE);
 	return;
     default:
 	// Reserved erpas -> bug
-	tape34xx_error_recovery_HWBUG(tape,26);
+	tape34xx_error_recovery_HWBUG(ti,26);
 	return;
     }
 }
 
-void tape34xx_error_recovery_has_failed (tape_info_t* tape,int error_id) {
+void tape34xx_error_recovery_has_failed (tape_info_t* ti,int error_id) {
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,3,"xerp fail");
-    debug_text_event (tape_debug_area,3,(((tapestate_get (tape) < TS_SIZE) && 
-		      (tapestate_get (tape) >= 0)) ?
-	state_verbose[tapestate_get (tape)] : "UNKNOWN"));
+    debug_text_event (tape_debug_area,3,(((tapestate_get (ti) < TS_SIZE) && 
+		      (tapestate_get (ti) >= 0)) ?
+	state_verbose[tapestate_get (ti)] : "UNKNOWN"));
 #endif
-    if ((tapestate_get(tape)!=TS_UNUSED) && (tapestate_get(tape)!=TS_IDLE)) {
-	tape_dump_sense(&tape->devstat);
-	tape->rc = -error_id;
-	tape->wanna_wakeup=1;
-	switch (tapestate_get(tape)) {
+    if ((tapestate_get(ti)!=TS_UNUSED) && (tapestate_get(ti)!=TS_IDLE)) {
+	tape_dump_sense(&ti->devstat);
+	ti->rc = -error_id;
+	ti->wanna_wakeup=1;
+	switch (tapestate_get(ti)) {
 	case TS_REW_RELEASE_INIT:
-	    tapestate_set(tape,TS_FAILED);
-	    wake_up (&tape->wq);
+	case TS_RFO_INIT:
+	case TS_RBA_INIT:
+	    tapestate_set(ti,TS_FAILED);
+	    wake_up (&ti->wq);
 	    break;
 	case TS_BLOCK_INIT:
-	    tapestate_set(tape,TS_FAILED);
-	    schedule_tapeblock_exec_IO(tape);
+	    tapestate_set(ti,TS_FAILED);
+	    schedule_tapeblock_exec_IO(ti);
 	    break;
 	default:
-	    tapestate_set(tape,TS_FAILED);
-	    wake_up_interruptible (&tape->wq);
+	    tapestate_set(ti,TS_FAILED);
+	    wake_up_interruptible (&ti->wq);
 	}
     } else {
 	PRINT_WARN("Recieved an unsolicited IRQ.\n");
-	tape_dump_sense(&tape->devstat);
+	tape_dump_sense(&ti->devstat);
     }
 }    
 
-void tape34xx_error_recovery_succeded(tape_info_t* tape) {
+void tape34xx_error_recovery_succeded(tape_info_t* ti) {
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,3,"xerp done");
-    debug_text_event (tape_debug_area,3,(((tapestate_get (tape) < TS_SIZE) && 
-		      (tapestate_get (tape) >= 0)) ?
-	state_verbose[tapestate_get (tape)] : "UNKNOWN"));
+    debug_text_event (tape_debug_area,3,(((tapestate_get (ti) < TS_SIZE) && 
+		      (tapestate_get (ti) >= 0)) ?
+	state_verbose[tapestate_get (ti)] : "UNKNOWN"));
 #endif
-    if ((tapestate_get(tape)!=TS_UNUSED) && (tapestate_get(tape)!=TS_DONE)) {
-	tapestate_event (tape, TE_DONE);
+    if ((tapestate_get(ti)!=TS_UNUSED) && (tapestate_get(ti)!=TS_DONE)) {
+	tapestate_event (ti, TE_DONE);
     } else {
 	PRINT_WARN("Recieved an unsolicited IRQ.\n");
-	tape_dump_sense(&tape->devstat);
+	tape_dump_sense(&ti->devstat);
     }
 }
 
-void tape34xx_error_recovery_do_retry(tape_info_t* tape) {
+void tape34xx_error_recovery_do_retry(tape_info_t* ti) {
 #ifdef TAPE_DEBUG
     debug_text_event (tape_debug_area,3,"xerp retr");
-    debug_text_event (tape_debug_area,3,(((tapestate_get (tape) < TS_SIZE) && 
-					  (tapestate_get (tape) >= 0)) ?
-					 state_verbose[tapestate_get (tape)] : "UNKNOWN"));
+    debug_text_event (tape_debug_area,3,(((tapestate_get (ti) < TS_SIZE) && 
+					  (tapestate_get (ti) >= 0)) ?
+					 state_verbose[tapestate_get (ti)] : "UNKNOWN"));
 #endif
-    if ((tapestate_get(tape)!=TS_UNUSED) && (tapestate_get(tape)!=TS_IDLE)) {
-	tape_dump_sense(&tape->devstat);
-	while (do_IO (tape->devinfo.irq, tape->cqr->cpaddr, (unsigned long) tape->cqr, 0x00, tape->cqr->options));
+    if ((tapestate_get(ti)!=TS_UNUSED) && (tapestate_get(ti)!=TS_IDLE)) {
+	tape_dump_sense(&ti->devstat);
+	while (do_IO (ti->devinfo.irq, ti->cqr->cpaddr, (unsigned long) ti->cqr, 0x00, ti->cqr->options));
     } else {
 	PRINT_WARN("Recieved an unsolicited IRQ.\n");
-	tape_dump_sense(&tape->devstat);
+	tape_dump_sense(&ti->devstat);
     }
 }
     
 void 
-tape34xx_error_recovery_read_opposite (tape_info_t* tape) {
-    switch (tapestate_get(tape)) {
+tape34xx_error_recovery_read_opposite (tape_info_t* ti) {
+    switch (tapestate_get(ti)) {
     case TS_RFO_INIT:
 	// We did read forward, but the data could not be read *correctly*.
 	// We will read backward and then skip forward again.
-	tape->cqr=tape34xx_read_opposite(tape,0);
-	if (tape->cqr==NULL)
-	    tape34xx_error_recovery_has_failed(tape,EIO);
+	ti->cqr=tape34xx_read_opposite(ti,0);
+	if (ti->cqr==NULL)
+	    tape34xx_error_recovery_has_failed(ti,EIO);
 	else
-	    tape34xx_error_recovery_do_retry(tape);
+	    tape34xx_error_recovery_do_retry(ti);
 	break;
     case TS_RBA_INIT:
 	// We tried to read forward and backward, but hat no success -> failed.
-	tape34xx_error_recovery_has_failed(tape,EIO);
+	tape34xx_error_recovery_has_failed(ti,EIO);
 	break;
     case TS_BLOCK_INIT:
-	tape34xx_error_recovery_do_retry(tape);
+	tape34xx_error_recovery_do_retry(ti);
 	break;
     default:
 	PRINT_WARN("read_opposite_recovery_called_with_state:%s\n",
-		   (((tapestate_get (tape) < TS_SIZE) && 
-		     (tapestate_get (tape) >= 0)) ?
-		    state_verbose[tapestate_get (tape)] : "UNKNOWN"));
+		   (((tapestate_get (ti) < TS_SIZE) && 
+		     (tapestate_get (ti) >= 0)) ?
+		    state_verbose[tapestate_get (ti)] : "UNKNOWN"));
     }
 }
 
 void 
-tape34xx_error_recovery_HWBUG (tape_info_t* tape,int condno) {
-    devstat_t* stat=&tape->devstat;
+tape34xx_error_recovery_HWBUG (tape_info_t* ti,int condno) {
+    devstat_t* stat=&ti->devstat;
     PRINT_WARN("An unexpected condition #%d was caught in tape error recovery.\n",condno);
     PRINT_WARN("Please report this incident.\n");
     PRINT_WARN("State of the tape:%s\n",
-	       (((tapestate_get (tape) < TS_SIZE) && 
-		 (tapestate_get (tape) >= 0)) ?
-		state_verbose[tapestate_get (tape)] : "UNKNOWN"));
+	       (((tapestate_get (ti) < TS_SIZE) && 
+		 (tapestate_get (ti) >= 0)) ?
+		state_verbose[tapestate_get (ti)] : "UNKNOWN"));
     PRINT_INFO ("Sense data: %02X%02X%02X%02X %02X%02X%02X%02X "
 		" %02X%02X%02X%02X %02X%02X%02X%02X \n",
 		stat->ii.sense.data[0], stat->ii.sense.data[1],
@@ -2381,5 +2385,5 @@
 		stat->ii.sense.data[26], stat->ii.sense.data[27],
 		stat->ii.sense.data[28], stat->ii.sense.data[29],
 		stat->ii.sense.data[30], stat->ii.sense.data[31]);
-    tape34xx_error_recovery_has_failed(tape,EIO);
+    tape34xx_error_recovery_has_failed(ti,EIO);
 }
diff -urN linux/drivers/s390/char/tape34xx.h linux-2.4.7/drivers/s390/char/tape34xx.h
--- linux/drivers/s390/char/tape34xx.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tape34xx.h	Mon Dec 17 13:41:19 2001
@@ -115,69 +115,69 @@
 
 /* discipline functions */
 int tape34xx_ioctl_overload (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
-ccw_req_t * tape34xx_write_block (const char *data, size_t count, tape_info_t * tape);
-void tape34xx_free_write_block (ccw_req_t * cqr, tape_info_t * tape);
-ccw_req_t * tape34xx_read_block (const char *data, size_t count, tape_info_t * tape);
-void  tape34xx_free_read_block (ccw_req_t * cqr, tape_info_t * tape);
-void  tape34xx_clear_read_block (ccw_req_t * cqr, tape_info_t * tape);
-ccw_req_t * tape34xx_mtfsf (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtbsf (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtfsr (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtbsr (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtweof (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtrew (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtoffl (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtnop (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtbsfm (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtfsfm (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mteom (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mterase (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtsetdensity (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtseek (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mttell (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtsetdrvbuffer (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtlock (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtunlock (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtload (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtunload (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtcompression (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtsetpart (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtmkpart (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtiocget (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_mtiocpos (tape_info_t * tape, int count);
-ccw_req_t * tape34xx_bread (struct request *req, tape_info_t* tape,int tapeblock_major);
-ccw_req_t * tape34xx_bwrite (struct request *req, tape_info_t* tape,int tapeblock_major);
+ccw_req_t * tape34xx_write_block (const char *data, size_t count, tape_info_t * ti);
+void tape34xx_free_write_block (ccw_req_t * cqr, tape_info_t * ti);
+ccw_req_t * tape34xx_read_block (const char *data, size_t count, tape_info_t * ti);
+void  tape34xx_free_read_block (ccw_req_t * cqr, tape_info_t * ti);
+void  tape34xx_clear_read_block (ccw_req_t * cqr, tape_info_t * ti);
+ccw_req_t * tape34xx_mtfsf (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtbsf (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtfsr (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtbsr (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtweof (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtrew (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtoffl (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtnop (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtbsfm (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtfsfm (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mteom (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mterase (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtsetdensity (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtseek (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mttell (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtsetdrvbuffer (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtlock (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtunlock (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtload (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtunload (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtcompression (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtsetpart (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtmkpart (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtiocget (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_mtiocpos (tape_info_t * ti, int count);
+ccw_req_t * tape34xx_bread (struct request *req, tape_info_t* ti,int tapeblock_major);
+ccw_req_t * tape34xx_bwrite (struct request *req, tape_info_t* ti,int tapeblock_major);
 void tape34xx_free_bread (ccw_req_t*,struct _tape_info_t*);
 void tape34xx_free_bwrite (ccw_req_t*,struct _tape_info_t*);
 
 /* Event handlers */
-void tape34xx_default_handler (tape_info_t * tape);
-void tape34xx_unexpect_uchk_handler (tape_info_t * tape);
-void tape34xx_unused_done(tape_info_t* tape);
-void tape34xx_idle_done(tape_info_t* tape);
-void tape34xx_block_done(tape_info_t* tape);
-void tape34xx_bsf_init_done(tape_info_t* tape);
-void tape34xx_dse_init_done(tape_info_t* tape);
-void tape34xx_fsf_init_done(tape_info_t* tape);
-void tape34xx_bsb_init_done(tape_info_t* tape);
-void tape34xx_fsb_init_done(tape_info_t* tape);
-void tape34xx_lbl_init_done(tape_info_t* tape);
-void tape34xx_nop_init_done(tape_info_t* tape);
-void tape34xx_rfo_init_done(tape_info_t* tape);
-void tape34xx_rbi_init_done(tape_info_t* tape);
-void tape34xx_rew_init_done(tape_info_t* tape);
-void tape34xx_rew_release_init_done(tape_info_t* tape);
-void tape34xx_run_init_done(tape_info_t* tape);
-void tape34xx_wri_init_done(tape_info_t* tape);
-void tape34xx_wtm_init_done(tape_info_t* tape);
+void tape34xx_default_handler (tape_info_t * ti);
+void tape34xx_unexpect_uchk_handler (tape_info_t * ti);
+void tape34xx_unused_done(tape_info_t* ti);
+void tape34xx_idle_done(tape_info_t* ti);
+void tape34xx_block_done(tape_info_t* ti);
+void tape34xx_bsf_init_done(tape_info_t* ti);
+void tape34xx_dse_init_done(tape_info_t* ti);
+void tape34xx_fsf_init_done(tape_info_t* ti);
+void tape34xx_bsb_init_done(tape_info_t* ti);
+void tape34xx_fsb_init_done(tape_info_t* ti);
+void tape34xx_lbl_init_done(tape_info_t* ti);
+void tape34xx_nop_init_done(tape_info_t* ti);
+void tape34xx_rfo_init_done(tape_info_t* ti);
+void tape34xx_rbi_init_done(tape_info_t* ti);
+void tape34xx_rew_init_done(tape_info_t* ti);
+void tape34xx_rew_release_init_done(tape_info_t* ti);
+void tape34xx_run_init_done(tape_info_t* ti);
+void tape34xx_wri_init_done(tape_info_t* ti);
+void tape34xx_wtm_init_done(tape_info_t* ti);
 
-extern void schedule_tapeblock_exec_IO (tape_info_t *tape);
+extern void schedule_tapeblock_exec_IO (tape_info_t *ti);
 
 // the error recovery stuff:
-void tape34xx_error_recovery (tape_info_t* tape);
-void tape34xx_error_recovery_has_failed (tape_info_t* tape,int error_id);
-void tape34xx_error_recovery_succeded(tape_info_t* tape);
-void tape34xx_error_recovery_do_retry(tape_info_t* tape);
-void tape34xx_error_recovery_read_opposite (tape_info_t* tape);
-void  tape34xx_error_recovery_HWBUG (tape_info_t* tape,int condno);
+void tape34xx_error_recovery (tape_info_t* ti);
+void tape34xx_error_recovery_has_failed (tape_info_t* ti,int error_id);
+void tape34xx_error_recovery_succeded(tape_info_t* ti);
+void tape34xx_error_recovery_do_retry(tape_info_t* ti);
+void tape34xx_error_recovery_read_opposite (tape_info_t* ti);
+void  tape34xx_error_recovery_HWBUG (tape_info_t* ti,int condno);
 #endif // _TAPE34XX_H
diff -urN linux/drivers/s390/char/tapeblock.c linux-2.4.7/drivers/s390/char/tapeblock.c
--- linux/drivers/s390/char/tapeblock.c	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/char/tapeblock.c	Mon Dec 17 13:41:19 2001
@@ -56,29 +56,29 @@
 
 #ifdef CONFIG_DEVFS_FS
 void
-tapeblock_mkdevfstree (tape_info_t* tape) {
-    tape->devfs_block_dir=devfs_mk_dir (tape->devfs_dir, "block", tape);
-    tape->devfs_disc=devfs_register(tape->devfs_block_dir, "disc",DEVFS_FL_DEFAULT,
-				    tapeblock_major, tape->blk_minor,
-				    TAPEBLOCK_DEFAULTMODE, &tapeblock_fops, tape);
+tapeblock_mkdevfstree (tape_info_t* ti) {
+    ti->devfs_block_dir=devfs_mk_dir (ti->devfs_dir, "block", ti);
+    ti->devfs_disc=devfs_register(ti->devfs_block_dir, "disc",DEVFS_FL_DEFAULT,
+				    tapeblock_major, ti->blk_minor,
+				    TAPEBLOCK_DEFAULTMODE, &tapeblock_fops, ti);
 }
 
 void
-tapeblock_rmdevfstree (tape_info_t* tape) {
-    devfs_unregister(tape->devfs_disc);
-    devfs_unregister(tape->devfs_block_dir);
+tapeblock_rmdevfstree (tape_info_t* ti) {
+    devfs_unregister(ti->devfs_disc);
+    devfs_unregister(ti->devfs_block_dir);
 }
 #endif
 
 void 
-tapeblock_setup(tape_info_t* tape) {
-    blk_size[tapeblock_major][tape->blk_minor]=0; // this will be detected
-    blksize_size[tapeblock_major][tape->blk_minor]=2048; // blocks are 2k by default.
-    hardsect_size[tapeblock_major][tape->blk_minor]=512;
-    blk_init_queue (&tape->request_queue, tape_request_fn); 
-    blk_queue_headactive (&tape->request_queue, 0); 
+tapeblock_setup(tape_info_t* ti) {
+    blk_size[tapeblock_major][ti->blk_minor]=0; // this will be detected
+    blksize_size[tapeblock_major][ti->blk_minor]=2048; // blocks are 2k by default.
+    hardsect_size[tapeblock_major][ti->blk_minor]=512;
+    blk_init_queue (&ti->request_queue, tape_request_fn); 
+    blk_queue_headactive (&ti->request_queue, 0); 
 #ifdef CONFIG_DEVFS_FS
-    tapeblock_mkdevfstree(tape);
+    tapeblock_mkdevfstree(ti);
 #endif
 }
 
@@ -86,7 +86,7 @@
 tapeblock_init(void) {
     int result;
     tape_frontend_t* blkfront,*temp;
-    tape_info_t* tape;
+    tape_info_t* ti;
 
     tape_init();
     /* Register the tape major number to the kernel */
@@ -127,10 +127,10 @@
 	temp=temp->next;
 	temp->next=blkfront;
     }
-    tape=first_tape_info;
-    while (tape!=NULL) {
-	tapeblock_setup(tape);
-	tape=tape->next;
+    ti=first_tape_info;
+    while (ti!=NULL) {
+	tapeblock_setup(ti);
+	ti=ti->next;
     }
     return 0;
 }
@@ -171,7 +171,12 @@
         
 	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
         rc=tapeblock_mediumdetect(ti);
-        if (rc) return rc; // in case of errors, we don't have a size of the medium
+        if (rc) {
+	    s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	    tapestate_set (ti, TS_UNUSED);
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+	    return rc; // in case of errors, we don't have a size of the medium
+	}
 	dev = MKDEV (tapeblock_major, MINOR (inode->i_rdev));	/* Get the device */
 	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
 	ti->blk_filp = filp;
@@ -224,171 +229,171 @@
 }
 
 static void
-tapeblock_end_request(tape_info_t* tape) {
+tapeblock_end_request(tape_info_t* ti) {
     struct buffer_head *bh;
     int uptodate;
-    if ((tapestate_get(tape)!=TS_FAILED) &&
-	(tapestate_get(tape)!=TS_DONE))
+    if ((tapestate_get(ti)!=TS_FAILED) &&
+	(tapestate_get(ti)!=TS_DONE))
        BUG(); // A request has to be completed to end it
-    uptodate=(tapestate_get(tape)==TS_DONE); // is the buffer up to date?
+    uptodate=(tapestate_get(ti)==TS_DONE); // is the buffer up to date?
 #ifdef TAPE_DEBUG
     if (uptodate) {
 	debug_text_event (tape_debug_area,6,"b:done:");
-	debug_int_event (tape_debug_area,6,(long)tape->cqr);
+	debug_int_event (tape_debug_area,6,(long)ti->cqr);
     } else {
 	debug_text_event (tape_debug_area,3,"b:failed:");
-	debug_int_event (tape_debug_area,3,(long)tape->cqr);
+	debug_int_event (tape_debug_area,3,(long)ti->cqr);
     }
 #endif
     // now inform ll_rw_block about a request status
-    while ((bh = tape->current_request->bh) != NULL) {
-	tape->current_request->bh = bh->b_reqnext;
+    while ((bh = ti->current_request->bh) != NULL) {
+	ti->current_request->bh = bh->b_reqnext;
 	bh->b_reqnext = NULL;
 	bh->b_end_io (bh, uptodate);
     }
-    if (!end_that_request_first (tape->current_request, uptodate, "tBLK")) {
+    if (!end_that_request_first (ti->current_request, uptodate, "tBLK")) {
 #ifndef DEVICE_NO_RANDOM
-	add_blkdev_randomness (MAJOR (tape->current_request->rq_dev));
+	add_blkdev_randomness (MAJOR (ti->current_request->rq_dev));
 #endif
-	end_that_request_last (tape->current_request);
+	end_that_request_last (ti->current_request);
     }
-    tape->discipline->free_bread(tape->cqr,tape);
-    tape->cqr=NULL;
-    tape->current_request=NULL;
-    if (tapestate_get(tape)!=TS_NOT_OPER) tapestate_set(tape,TS_IDLE);
+    ti->discipline->free_bread(ti->cqr,ti);
+    ti->cqr=NULL;
+    ti->current_request=NULL;
+    if (tapestate_get(ti)!=TS_NOT_OPER) tapestate_set(ti,TS_IDLE);
     return;
 }
 
 static void
-tapeblock_exec_IO (tape_info_t* tape) {
+tapeblock_exec_IO (tape_info_t* ti) {
     int rc;
     struct request* req;
-    if (tape->cqr) { // process done/failed request
-	while ((tapestate_get(tape)==TS_FAILED) &&
-	    tape->blk_retries>0) {
-	    tape->blk_retries--;
-	    tape->position=-1;
-	    tapestate_set(tape,TS_BLOCK_INIT);
+    if (ti->cqr) { // process done/failed request
+	while ((tapestate_get(ti)==TS_FAILED) &&
+	    ti->blk_retries>0) {
+	    ti->blk_retries--;
+	    ti->position=-1;
+	    tapestate_set(ti,TS_BLOCK_INIT);
 #ifdef TAPE_DEBUG
 	    debug_text_event (tape_debug_area,3,"b:retryreq:");
-	    debug_int_event (tape_debug_area,3,(long)tape->cqr);
+	    debug_int_event (tape_debug_area,3,(long)ti->cqr);
 #endif
-	    rc = do_IO (tape->devinfo.irq, tape->cqr->cpaddr, (unsigned long) tape->cqr, 
-			0x00, tape->cqr->options);
+	    rc = do_IO (ti->devinfo.irq, ti->cqr->cpaddr, (unsigned long) ti->cqr, 
+			0x00, ti->cqr->options);
 	    if (rc) {
 #ifdef TAPE_DEBUG
 		debug_text_event (tape_debug_area,3,"b:doIOfail:");
-		debug_int_event (tape_debug_area,3,(long)tape->cqr);
+		debug_int_event (tape_debug_area,3,(long)ti->cqr);
 #endif 
 		continue; // one retry lost 'cause doIO failed
 	    }
 	    return;
 	}
-	tapeblock_end_request (tape); // check state, inform user, free mem, dev=idl
+	tapeblock_end_request (ti); // check state, inform user, free mem, dev=idl
     }
-    if (tape->cqr!=NULL) BUG(); // tape should be idle now, request should be freed!
-    if (tapestate_get (tape) == TS_NOT_OPER) {
-	tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	tape->devinfo.irq=-1;
+    if (ti->cqr!=NULL) BUG(); // tape should be idle now, request should be freed!
+    if (tapestate_get (ti) == TS_NOT_OPER) {
+	ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	ti->devinfo.irq=-1;
 	return;
     }
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	if (list_empty (&tape->request_queue.queue_head)) {
+	if (list_empty (&ti->request_queue.queue_head)) {
 #else
-	if (tape->request_queue==NULL) {
+	if (ti->request_queue==NULL) {
 #endif
 	// nothing more to do or device has dissapeared;)
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"b:Qempty");
 #endif
-	tapestate_set(tape,TS_IDLE);
+	tapestate_set(ti,TS_IDLE);
 	return;
     }
     // queue is not empty, fetch a request and start IO!
-    req=tape->current_request=tape_next_request(&tape->request_queue);
+    req=ti->current_request=tape_next_request(&ti->request_queue);
     if (req==NULL) {
 	BUG(); // Yo. The queue was not reported empy, but no request found. This is _bad_.
     }
     if (req->cmd!=READ) { // we only support reading
-	tapestate_set(tape,TS_FAILED);
-	tapeblock_end_request (tape); // check state, inform user, free mem, dev=idl
-	tapestate_set(tape,TS_BLOCK_INIT);
-	schedule_tapeblock_exec_IO(tape);
+	tapestate_set(ti,TS_FAILED);
+	tapeblock_end_request (ti); // check state, inform user, free mem, dev=idl
+	tapestate_set(ti,TS_BLOCK_INIT);
+	schedule_tapeblock_exec_IO(ti);
 	return;
     }
-    tape->cqr=tape->discipline->bread(req,tape,tapeblock_major); //build channel program from request
-    if (!tape->cqr) {
+    ti->cqr=ti->discipline->bread(req,ti,tapeblock_major); //build channel program from request
+    if (!ti->cqr) {
 	// ccw generation failed. we try again later.
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,3,"b:cqrNULL");
 #endif
-	schedule_tapeblock_exec_IO(tape);
-	tape->current_request=NULL;
+	schedule_tapeblock_exec_IO(ti);
+	ti->current_request=NULL;
 	return;
     }
-    tape->blk_retries = TAPEBLOCK_RETRIES;
-    rc= do_IO (tape->devinfo.irq, tape->cqr->cpaddr, 
-	       (unsigned long) tape->cqr, 0x00, tape->cqr->options);
+    ti->blk_retries = TAPEBLOCK_RETRIES;
+    rc= do_IO (ti->devinfo.irq, ti->cqr->cpaddr, 
+	       (unsigned long) ti->cqr, 0x00, ti->cqr->options);
     if (rc) {
 	// okay. ssch failed. we try later.
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,3,"b:doIOfail");
 #endif
-	tape->discipline->free_bread(tape->cqr,tape);
-	tape->cqr=NULL;
-	tape->current_request=NULL;
-	schedule_tapeblock_exec_IO(tape);
+	ti->discipline->free_bread(ti->cqr,ti);
+	ti->cqr=NULL;
+	ti->current_request=NULL;
+	schedule_tapeblock_exec_IO(ti);
 	return;
     }
     // our request is in IO. we remove it from the queue and exit
-    tape_dequeue_request (&tape->request_queue,req);
+    tape_dequeue_request (&ti->request_queue,req);
 }
 
 static void 
 do_tape_request (request_queue_t * queue) {
-    tape_info_t* tape;
+    tape_info_t* ti;
     long lockflags;
-    for (tape=first_tape_info;
-	 ((tape!=NULL) && ((&tape->request_queue)!=queue));
-	 tape=tape->next);
-    if (tape==NULL) BUG();
-    s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-    if (tapestate_get(tape)!=TS_IDLE) {
-	s390irq_spin_unlock_irqrestore(tape->devinfo.irq,lockflags);
+    for (ti=first_tape_info;
+	 ((ti!=NULL) && ((&ti->request_queue)!=queue));
+	 ti=ti->next);
+    if (ti==NULL) BUG();
+    s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+    if (tapestate_get(ti)!=TS_IDLE) {
+	s390irq_spin_unlock_irqrestore(ti->devinfo.irq,lockflags);
 	return;
     }
-    if (tapestate_get(tape)!=TS_IDLE) BUG();
-    tapestate_set(tape,TS_BLOCK_INIT);
-    tapeblock_exec_IO(tape);
-    s390irq_spin_unlock_irqrestore(tape->devinfo.irq,lockflags);
+    if (tapestate_get(ti)!=TS_IDLE) BUG();
+    tapestate_set(ti,TS_BLOCK_INIT);
+    tapeblock_exec_IO(ti);
+    s390irq_spin_unlock_irqrestore(ti->devinfo.irq,lockflags);
 }
 
 static void
-run_tapeblock_exec_IO (tape_info_t* tape) {
+run_tapeblock_exec_IO (tape_info_t* ti) {
     long flags_390irq,flags_ior;
     spin_lock_irqsave (&io_request_lock, flags_ior);
-    s390irq_spin_lock_irqsave(tape->devinfo.irq,flags_390irq);
-    atomic_set(&tape->bh_scheduled,0);
-    tapeblock_exec_IO(tape);
-    s390irq_spin_unlock_irqrestore(tape->devinfo.irq,flags_390irq);
+    s390irq_spin_lock_irqsave(ti->devinfo.irq,flags_390irq);
+    atomic_set(&ti->bh_scheduled,0);
+    tapeblock_exec_IO(ti);
+    s390irq_spin_unlock_irqrestore(ti->devinfo.irq,flags_390irq);
     spin_unlock_irqrestore (&io_request_lock, flags_ior);
 }
 
 void
-schedule_tapeblock_exec_IO (tape_info_t *tape)
+schedule_tapeblock_exec_IO (tape_info_t *ti)
 {
 	/* Protect against rescheduling, when already running */
-        if (atomic_compare_and_swap(0,1,&tape->bh_scheduled)) {
+        if (atomic_compare_and_swap(0,1,&ti->bh_scheduled)) {
                 return;
         }
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-	INIT_LIST_HEAD(&tape->bh_tq.list);
+	INIT_LIST_HEAD(&ti->bh_tq.list);
 #endif
-	tape->bh_tq.sync = 0;
-	tape->bh_tq.routine = (void *) (void *) run_tapeblock_exec_IO;
-	tape->bh_tq.data = tape;
+	ti->bh_tq.sync = 0;
+	ti->bh_tq.routine = (void *) (void *) run_tapeblock_exec_IO;
+	ti->bh_tq.data = ti;
 
-	queue_task (&tape->bh_tq, &tq_immediate);
+	queue_task (&ti->bh_tq, &tq_immediate);
 	mark_bh (IMMEDIATE_BH);
 	return;
 }
@@ -396,10 +401,10 @@
 /* wrappers around do_tape_request for different kernel versions */
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
 static void tape_request_fn (void) {
-    tape_info_t* tape=first_tape_info;
-    while (tape!=NULL) {
-	do_tape_request(&tape->request_queue);
-	tape=tape->next;
+    tape_info_t* ti=first_tape_info;
+    while (ti!=NULL) {
+	do_tape_request(&ti->request_queue);
+	ti=ti->next;
     }
 }
 #else
@@ -409,14 +414,14 @@
 #endif
 
 static request_queue_t* tapeblock_getqueue (kdev_t kdev) {
-    tape_info_t* tape=first_tape_info;
-    while ((tape!=NULL) && (MINOR(kdev)!=tape->blk_minor)) 
-        tape=tape->next;
-    if (tape!=NULL) return &tape->request_queue;
+    tape_info_t* ti=first_tape_info;
+    while ((ti!=NULL) && (MINOR(kdev)!=ti->blk_minor)) 
+        ti=ti->next;
+    if (ti!=NULL) return &ti->request_queue;
     return NULL;
 }
 
-int tapeblock_mediumdetect(tape_info_t* tape) {
+int tapeblock_mediumdetect(tape_info_t* ti) {
         ccw_req_t* cqr;
     int losize=1,hisize=1,rc;
     long lockflags;
@@ -426,168 +431,168 @@
     PRINT_WARN("Detecting media size. This will take _long_, so get yourself a coffee...\n");
     while (1) { //is interruped by break
 	hisize=hisize << 1; // try twice the size tested before 
-	cqr=tape->discipline->mtseek (tape, hisize);
+	cqr=ti->discipline->mtseek (ti, hisize);
 	if (cqr == NULL) {
 #ifdef TAPE_DEBUG
 	    debug_text_event (tape_debug_area,6,"b:ccwg fail");
 #endif
 	    return -ENOSPC;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->cqr = cqr;
-	tape->wanna_wakeup=0;
-	rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->cqr = cqr;
+	ti->wanna_wakeup=0;
+	rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	if (rc) return -EIO;
-	wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-	tape->cqr = NULL;
+	wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+	ti->cqr = NULL;
 	tape_free_request (cqr);
-	if (tape->kernbuf) {
-	    kfree (tape->kernbuf);
-	    tape->kernbuf=NULL;
+	if (ti->kernbuf) {
+	    kfree (ti->kernbuf);
+	    ti->kernbuf=NULL;
 	}
 	if (signal_pending (current)) {
-		tapestate_set (tape, TS_IDLE);
+		tapestate_set (ti, TS_IDLE);
 		return -ERESTARTSYS;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	if (tapestate_get (tape) == TS_FAILED) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	if (tapestate_get (ti) == TS_FAILED) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		break;
 	}
-	if (tapestate_get (tape) == TS_NOT_OPER) {
-	    tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	    tape->devinfo.irq=-1;
-	    s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+	if (tapestate_get (ti) == TS_NOT_OPER) {
+	    ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	    ti->devinfo.irq=-1;
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 	    return -ENODEV;
 	}
-	if (tapestate_get (tape) != TS_DONE) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	if (tapestate_get (ti) != TS_DONE) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		return -EIO;
 	}
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	losize=hisize;
     }
-    cqr = tape->discipline->mtrew (tape, 1);
+    cqr = ti->discipline->mtrew (ti, 1);
     if (cqr == NULL) {
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"b:ccwg fail");
 #endif
 	return -ENOSPC;
     }
-    s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-    tape->cqr = cqr;
-    tape->wanna_wakeup=0;
-    rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-    s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-    wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-    tape->cqr = NULL;
+    s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+    ti->cqr = cqr;
+    ti->wanna_wakeup=0;
+    rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+    wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+    ti->cqr = NULL;
     tape_free_request (cqr);
     if (signal_pending (current)) {
-	tapestate_set (tape, TS_IDLE);
+	tapestate_set (ti, TS_IDLE);
 	return -ERESTARTSYS;
     }
-    s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-    if (tapestate_get (tape) == TS_FAILED) {
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+    s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+    if (tapestate_get (ti) == TS_FAILED) {
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	return -EIO;
     }
-    if (tapestate_get (tape) == TS_NOT_OPER) {
-	tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	tape->devinfo.irq=-1;
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+    if (tapestate_get (ti) == TS_NOT_OPER) {
+	ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	ti->devinfo.irq=-1;
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 	return -ENODEV;
     }
-    if (tapestate_get (tape) != TS_DONE) {
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+    if (tapestate_get (ti) != TS_DONE) {
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	return -EIO;
     }
-    tapestate_set (tape, TS_IDLE);
-    s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+    tapestate_set (ti, TS_IDLE);
+    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
     while (losize!=hisize) {
-	cqr=tape->discipline->mtseek (tape, (hisize+losize)/2+1);
+	cqr=ti->discipline->mtseek (ti, (hisize+losize)/2+1);
 	if (cqr == NULL) {
 #ifdef TAPE_DEBUG
 	    debug_text_event (tape_debug_area,6,"b:ccwg fail");
 #endif
 	    return -ENOSPC;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->cqr = cqr;
-	tape->wanna_wakeup=0;
-	rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->cqr = cqr;
+	ti->wanna_wakeup=0;
+	rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	if (rc) return -EIO;
-	wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-	tape->cqr = NULL;
+	wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+	ti->cqr = NULL;
 	tape_free_request (cqr);
-	if (tape->kernbuf) {
-	    kfree (tape->kernbuf);
-	    tape->kernbuf=NULL;
+	if (ti->kernbuf) {
+	    kfree (ti->kernbuf);
+	    ti->kernbuf=NULL;
 	}
 	if (signal_pending (current)) {
-		tapestate_set (tape, TS_IDLE);
+		tapestate_set (ti, TS_IDLE);
 		return -ERESTARTSYS;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	if (tapestate_get (tape) == TS_NOT_OPER) {
-	    tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	    tape->devinfo.irq=-1;
-	    s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	if (tapestate_get (ti) == TS_NOT_OPER) {
+	    ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	    ti->devinfo.irq=-1;
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 	    return -ENODEV;
 	}
-	if (tapestate_get (tape) == TS_FAILED) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	if (tapestate_get (ti) == TS_FAILED) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		hisize=(hisize+losize)/2;
-		cqr = tape->discipline->mtrew (tape, 1);
+		cqr = ti->discipline->mtrew (ti, 1);
 		if (cqr == NULL) {
 #ifdef TAPE_DEBUG
 		    debug_text_event (tape_debug_area,6,"b:ccwg fail");
 #endif
 		    return -ENOSPC;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->cqr = cqr;
-		tape->wanna_wakeup=0;
-		rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-		tape->cqr = NULL;
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->cqr = cqr;
+		ti->wanna_wakeup=0;
+		rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+		ti->cqr = NULL;
 		tape_free_request (cqr);
 		if (signal_pending (current)) {
-		    tapestate_set (tape, TS_IDLE);
+		    tapestate_set (ti, TS_IDLE);
 		    return -ERESTARTSYS;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		if (tapestate_get (tape) == TS_FAILED) {
-		    tapestate_set (tape, TS_IDLE);
-		    s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		if (tapestate_get (ti) == TS_FAILED) {
+		    tapestate_set (ti, TS_IDLE);
+		    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		    return -EIO;
 		}
-		if (tapestate_get (tape) != TS_DONE) {
-		    tapestate_set (tape, TS_IDLE);
-		    s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		if (tapestate_get (ti) != TS_DONE) {
+		    tapestate_set (ti, TS_IDLE);
+		    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		    return -EIO;
 		}
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		continue;
 	}
-	if (tapestate_get (tape) != TS_DONE) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	if (tapestate_get (ti) != TS_DONE) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		return -EIO;
 	}
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	losize=(hisize+losize)/2+1;
     }
-    blk_size[tapeblock_major][tape->blk_minor]=(losize)*(blksize_size[tapeblock_major][tape->blk_minor]/1024);
+    blk_size[tapeblock_major][ti->blk_minor]=(losize)*(blksize_size[tapeblock_major][ti->blk_minor]/1024);
     return 0;
 }
diff -urN linux/drivers/s390/char/tapeblock.h linux-2.4.7/drivers/s390/char/tapeblock.h
--- linux/drivers/s390/char/tapeblock.h	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/char/tapeblock.h	Mon Dec 17 13:41:19 2001
@@ -25,11 +25,11 @@
 
 int tapeblock_open(struct inode *, struct file *);
 int tapeblock_release(struct inode *, struct file *);
-void tapeblock_setup(tape_info_t* tape);
-void schedule_tapeblock_exec_IO (tape_info_t *tape);
-int tapeblock_mediumdetect(tape_info_t* tape);
+void tapeblock_setup(tape_info_t* ti);
+void schedule_tapeblock_exec_IO (tape_info_t *ti);
+int tapeblock_mediumdetect(tape_info_t* ti);
 #ifdef CONFIG_DEVFS_FS
-void tapeblock_mkdevfstree (tape_info_t* tape);
+void tapeblock_mkdevfstree (tape_info_t* ti);
 #endif
 int tapeblock_init (void);
 void tapeblock_uninit (void);
diff -urN linux/drivers/s390/char/tapechar.c linux-2.4.7/drivers/s390/char/tapechar.c
--- linux/drivers/s390/char/tapechar.c	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/char/tapechar.c	Mon Dec 17 13:42:42 2001
@@ -58,30 +58,30 @@
 
 #ifdef CONFIG_DEVFS_FS
 void
-tapechar_mkdevfstree (tape_info_t* tape) {
-    tape->devfs_char_dir=devfs_mk_dir (tape->devfs_dir, "char", tape);
-    tape->devfs_nonrewinding=devfs_register(tape->devfs_char_dir, "nonrewinding",
+tapechar_mkdevfstree (tape_info_t* ti) {
+    ti->devfs_char_dir=devfs_mk_dir (ti->devfs_dir, "char", ti);
+    ti->devfs_nonrewinding=devfs_register(ti->devfs_char_dir, "nonrewinding",
 					    DEVFS_FL_DEFAULT,tape_major, 
-					    tape->nor_minor, TAPECHAR_DEFAULTMODE, 
-					    &tape_fops, tape);
-    tape->devfs_rewinding=devfs_register(tape->devfs_char_dir, "rewinding",
-					 DEVFS_FL_DEFAULT, tape_major, tape->rew_minor,
-					 TAPECHAR_DEFAULTMODE, &tape_fops, tape);
+					    ti->nor_minor, TAPECHAR_DEFAULTMODE, 
+					    &tape_fops, ti);
+    ti->devfs_rewinding=devfs_register(ti->devfs_char_dir, "rewinding",
+					 DEVFS_FL_DEFAULT, tape_major, ti->rew_minor,
+					 TAPECHAR_DEFAULTMODE, &tape_fops, ti);
 }
 
 void
-tapechar_rmdevfstree (tape_info_t* tape) {
-    devfs_unregister(tape->devfs_nonrewinding);
-    devfs_unregister(tape->devfs_rewinding);
-    devfs_unregister(tape->devfs_char_dir);
+tapechar_rmdevfstree (tape_info_t* ti) {
+    devfs_unregister(ti->devfs_nonrewinding);
+    devfs_unregister(ti->devfs_rewinding);
+    devfs_unregister(ti->devfs_char_dir);
 }
 #endif
 
 void
-tapechar_setup (tape_info_t * tape)
+tapechar_setup (tape_info_t * ti)
 {
 #ifdef CONFIG_DEVFS_FS
-    tapechar_mkdevfstree(tape);
+    tapechar_mkdevfstree(ti);
 #endif
 }
 
@@ -90,7 +90,7 @@
 {
 	int result;
 	tape_frontend_t *charfront,*temp;
-	tape_info_t* tape;
+	tape_info_t* ti;
 
 	tape_init();
 
@@ -137,10 +137,10 @@
 		temp=temp->next;
 	    temp->next=charfront;
 	}
-	tape=first_tape_info;
-	while (tape!=NULL) {
-	    tapechar_setup(tape);
-	    tape=tape->next;
+	ti=first_tape_info;
+	while (ti!=NULL) {
+	    tapechar_setup(ti);
+	    ti=ti->next;
 	}
 }
 
@@ -157,17 +157,17 @@
 tape_read (struct file *filp, char *data, size_t count, loff_t * ppos)
 {
 	long lockflags;
-	tape_info_t *tape;
+	tape_info_t *ti;
 	size_t block_size;
 	ccw_req_t *cqr;
 	int rc;
 #ifdef TAPE_DEBUG
         debug_text_event (tape_debug_area,6,"c:read");
 #endif /* TAPE_DEBUG */
-	tape = first_tape_info;
-	while ((tape != NULL) && (tape->rew_filp != filp) && (tape->nor_filp != filp))
-		tape = (tape_info_t *) tape->next;
-	if (tape == NULL) {
+	ti = first_tape_info;
+	while ((ti != NULL) && (ti->rew_filp != filp) && (ti->nor_filp != filp))
+		ti = (tape_info_t *) ti->next;
+	if (ti == NULL) {
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,6,"c:nodev");
 #endif /* TAPE_DEBUG */
@@ -180,62 +180,58 @@
 #endif /* TAPE_DEBUG */
 		return -EOVERFLOW;	/* errno=75 Value too large for def. data type */
 	}
-	if (tape->block_size == 0) {
+	if (ti->block_size == 0) {
 		block_size = count;
 	} else {
-		block_size = tape->block_size;
+		block_size = ti->block_size;
 	}
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:nbytes:");
 	debug_int_event (tape_debug_area,6,block_size);
 #endif
-	cqr = tape->discipline->read_block (data, block_size, tape);
+	cqr = ti->discipline->read_block (data, block_size, ti);
 	if (!cqr) {
 		return -ENOBUFS;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->cqr = cqr;
-	tape->wanna_wakeup=0;
-	rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->cqr = cqr;
+	ti->wanna_wakeup=0;
+	rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
 	if (rc) {
-	    tapestate_set(tape,TS_IDLE);
+	    tapestate_set(ti,TS_IDLE);
 	    kfree (cqr);
-	    s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	    return rc;
 	}
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-	wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-	tape->cqr = NULL;
-	tape->discipline->free_read_block (cqr, tape);
-	if (signal_pending (current)) {
-		tapestate_set (tape, TS_IDLE);
-		return -ERESTARTSYS;
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+	wait_event (ti->wq,ti->wanna_wakeup);
+	ti->cqr = NULL;
+	ti->discipline->free_read_block (cqr, ti);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	if (tapestate_get (ti) == TS_FAILED) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		return ti->rc;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	if (tapestate_get (tape) == TS_FAILED) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		return tape->rc;
-	}
-	if (tapestate_get (tape) == TS_NOT_OPER) {
-	    tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	    tape->devinfo.irq=-1;
-	    s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+	if (tapestate_get (ti) == TS_NOT_OPER) {
+	    ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	    ti->devinfo.irq=-1;
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 	    return -ENODEV;
 	}
-	if (tapestate_get (tape) != TS_DONE) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	if (tapestate_get (ti) != TS_DONE) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		return -EIO;
 	}
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:rbytes:");
-	debug_int_event (tape_debug_area,6,block_size - tape->devstat.rescnt);
+	debug_int_event (tape_debug_area,6,block_size - ti->devstat.rescnt);
 #endif	/* TAPE_DEBUG */
-	filp->f_pos += block_size - tape->devstat.rescnt;
-	return block_size - tape->devstat.rescnt;
+	filp->f_pos += block_size - ti->devstat.rescnt;
+	return block_size - ti->devstat.rescnt;
 }
 
 /*
@@ -245,7 +241,7 @@
 tape_write (struct file *filp, const char *data, size_t count, loff_t * ppos)
 {
 	long lockflags;
-	tape_info_t *tape;
+	tape_info_t *ti;
 	size_t block_size;
 	ccw_req_t *cqr;
 	int nblocks, i, rc;
@@ -253,10 +249,10 @@
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:write");
 #endif
-	tape = first_tape_info;
-	while ((tape != NULL) && (tape->nor_filp != filp) && (tape->rew_filp != filp))
-		tape = (tape_info_t *) tape->next;
-	if (tape == NULL)
+	ti = first_tape_info;
+	while ((ti != NULL) && (ti->nor_filp != filp) && (ti->rew_filp != filp))
+		ti = (tape_info_t *) ti->next;
+	if (ti == NULL)
 		return -ENODEV;
 	if (ppos != &filp->f_pos) {
 		/* "A request was outside the capabilities of the device." */
@@ -265,14 +261,14 @@
 #endif
 		return -EOVERFLOW;	/* errno=75 Value too large for def. data type */
 	}
-	if ((tape->block_size != 0) && (count % tape->block_size != 0))
+	if ((ti->block_size != 0) && (count % ti->block_size != 0))
 		return -EIO;
-	if (tape->block_size == 0) {
+	if (ti->block_size == 0) {
 		block_size = count;
 		nblocks = 1;
 	} else {
-		block_size = tape->block_size;
-		nblocks = count / (tape->block_size);
+		block_size = ti->block_size;
+		nblocks = count / (ti->block_size);
 	}
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,6,"c:nbytes:");
@@ -281,50 +277,50 @@
 	        debug_int_event (tape_debug_area,6,nblocks);
 #endif
 	for (i = 0; i < nblocks; i++) {
-		cqr = tape->discipline->write_block (data + i * block_size, block_size, tape);
+		cqr = ti->discipline->write_block (data + i * block_size, block_size, ti);
 		if (!cqr) {
 			return -ENOBUFS;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->cqr = cqr;
-		tape->wanna_wakeup=0;
-		rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-		tape->cqr = NULL;
-		tape->discipline->free_write_block (cqr, tape);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->cqr = cqr;
+		ti->wanna_wakeup=0;
+		rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+		ti->cqr = NULL;
+		ti->discipline->free_write_block (cqr, ti);
 		if (signal_pending (current)) {
-			tapestate_set (tape, TS_IDLE);
+			tapestate_set (ti, TS_IDLE);
 			return -ERESTARTSYS;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		if (tapestate_get (tape) == TS_FAILED) {
-			tapestate_set (tape, TS_IDLE);
-			s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-                        if ((tape->rc==-ENOSPC) && (i!=0))
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		if (tapestate_get (ti) == TS_FAILED) {
+			tapestate_set (ti, TS_IDLE);
+			s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+                        if ((ti->rc==-ENOSPC) && (i!=0))
 			  return i*block_size;
-			return tape->rc;
+			return ti->rc;
 		}
-		if (tapestate_get (tape) == TS_NOT_OPER) {
-		    tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-		    tape->devinfo.irq=-1;
-		    s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+		if (tapestate_get (ti) == TS_NOT_OPER) {
+		    ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+		    ti->devinfo.irq=-1;
+		    s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 		    return -ENODEV;
 		}
-		if (tapestate_get (tape) != TS_DONE) {
-			tapestate_set (tape, TS_IDLE);
-			s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		if (tapestate_get (ti) != TS_DONE) {
+			tapestate_set (ti, TS_IDLE);
+			s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 			return -EIO;
 		}
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,6,"c:wbytes:"); 
-		debug_int_event (tape_debug_area,6,block_size - tape->devstat.rescnt);
+		debug_int_event (tape_debug_area,6,block_size - ti->devstat.rescnt);
 #endif
-		filp->f_pos += block_size - tape->devstat.rescnt;
-		written += block_size - tape->devstat.rescnt;
-		if (tape->devstat.rescnt > 0)
+		filp->f_pos += block_size - ti->devstat.rescnt;
+		written += block_size - ti->devstat.rescnt;
+		if (ti->devstat.rescnt > 0)
 			return written;
 	}
 #ifdef TAPE_DEBUG
@@ -337,7 +333,7 @@
 static int
 tape_mtioctop (struct file *filp, short mt_op, int mt_count)
 {
-	tape_info_t *tape;
+	tape_info_t *ti;
 	ccw_req_t *cqr = NULL;
 	int rc;
 	long lockflags;
@@ -348,113 +344,118 @@
 	debug_text_event (tape_debug_area,6,"c:arg:");
 	debug_int_event (tape_debug_area,6,mt_count);
 #endif
-	tape = first_tape_info;
-	while ((tape != NULL) && (tape->rew_filp != filp) && (tape->nor_filp != filp))
-		tape = (tape_info_t *) tape->next;
-	if (tape == NULL)
+	ti = first_tape_info;
+	while ((ti != NULL) && (ti->rew_filp != filp) && (ti->nor_filp != filp))
+		ti = (tape_info_t *) ti->next;
+	if (ti == NULL)
 		return -ENODEV;
 	switch (mt_op) {
 	case MTREW:		// rewind
 
-		cqr = tape->discipline->mtrew (tape, mt_count);
+		cqr = ti->discipline->mtrew (ti, mt_count);
 		break;
 	case MTOFFL:		// put drive offline
 
-		cqr = tape->discipline->mtoffl (tape, mt_count);
+		cqr = ti->discipline->mtoffl (ti, mt_count);
 		break;
 	case MTUNLOAD:		// unload the tape
 
-		cqr = tape->discipline->mtunload (tape, mt_count);
+		cqr = ti->discipline->mtunload (ti, mt_count);
 		break;
 	case MTWEOF:		// write tapemark
 
-		cqr = tape->discipline->mtweof (tape, mt_count);
+		cqr = ti->discipline->mtweof (ti, mt_count);
 		break;
 	case MTFSF:		// forward space file
 
-		cqr = tape->discipline->mtfsf (tape, mt_count);
+		cqr = ti->discipline->mtfsf (ti, mt_count);
 		break;
 	case MTBSF:		// backward space file
 
-		cqr = tape->discipline->mtbsf (tape, mt_count);
+		cqr = ti->discipline->mtbsf (ti, mt_count);
 		break;
 	case MTFSFM:		// forward space file, stop at BOT side
 
-		cqr = tape->discipline->mtfsfm (tape, mt_count);
+		cqr = ti->discipline->mtfsfm (ti, mt_count);
 		break;
 	case MTBSFM:		// backward space file, stop at BOT side
 
-		cqr = tape->discipline->mtbsfm (tape, mt_count);
+		cqr = ti->discipline->mtbsfm (ti, mt_count);
 		break;
 	case MTFSR:		// forward space file
 
-		cqr = tape->discipline->mtfsr (tape, mt_count);
+		cqr = ti->discipline->mtfsr (ti, mt_count);
 		break;
 	case MTBSR:		// backward space file
 
-		cqr = tape->discipline->mtbsr (tape, mt_count);
+		cqr = ti->discipline->mtbsr (ti, mt_count);
 		break;
 	case MTNOP:
-		cqr = tape->discipline->mtnop (tape, mt_count);
+		cqr = ti->discipline->mtnop (ti, mt_count);
 		break;
 	case MTEOM:		// postion at the end of portion
 
 	case MTRETEN:		// retension the tape
 
-		cqr = tape->discipline->mteom (tape, mt_count);
+		cqr = ti->discipline->mteom (ti, mt_count);
 		break;
 	case MTERASE:
-		cqr = tape->discipline->mterase (tape, mt_count);
+		cqr = ti->discipline->mterase (ti, mt_count);
 		break;
 	case MTSETDENSITY:
-		cqr = tape->discipline->mtsetdensity (tape, mt_count);
+		cqr = ti->discipline->mtsetdensity (ti, mt_count);
 		break;
 	case MTSEEK:
-		cqr = tape->discipline->mtseek (tape, mt_count);
+		cqr = ti->discipline->mtseek (ti, mt_count);
 		break;
 	case MTSETDRVBUFFER:
-		cqr = tape->discipline->mtsetdrvbuffer (tape, mt_count);
+		cqr = ti->discipline->mtsetdrvbuffer (ti, mt_count);
 		break;
 	case MTLOCK:
-		cqr = tape->discipline->mtsetdrvbuffer (tape, mt_count);
+		cqr = ti->discipline->mtsetdrvbuffer (ti, mt_count);
 		break;
 	case MTUNLOCK:
-		cqr = tape->discipline->mtsetdrvbuffer (tape, mt_count);
+		cqr = ti->discipline->mtsetdrvbuffer (ti, mt_count);
 		break;
 	case MTLOAD:
-		cqr = tape->discipline->mtload (tape, mt_count);
-		break;
+		cqr = ti->discipline->mtload (ti, mt_count);
+		if (cqr!=NULL) break; // if backend driver has an load function ->use it
+		// if no medium is in, wait until it gets inserted
+		if (ti->medium_is_unloaded) {
+		    wait_event_interruptible (ti->wq,ti->medium_is_unloaded==0);
+		}
+		return 0;
 	case MTCOMPRESSION:
-		cqr = tape->discipline->mtcompression (tape, mt_count);
+		cqr = ti->discipline->mtcompression (ti, mt_count);
 		break;
 	case MTSETPART:
-		cqr = tape->discipline->mtsetpart (tape, mt_count);
+		cqr = ti->discipline->mtsetpart (ti, mt_count);
 		break;
 	case MTMKPART:
-		cqr = tape->discipline->mtmkpart (tape, mt_count);
+		cqr = ti->discipline->mtmkpart (ti, mt_count);
 		break;
 	case MTTELL:		// return number of block relative to current file
 
-		cqr = tape->discipline->mttell (tape, mt_count);
+		cqr = ti->discipline->mttell (ti, mt_count);
 		break;
 	case MTSETBLK:
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->block_size = mt_count;
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->block_size = mt_count;
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 		debug_text_event (tape_debug_area,6,"c:setblk:");
 	        debug_int_event (tape_debug_area,6,mt_count);
 #endif
 		return 0;
 	case MTRESET:
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->kernbuf = tape->userbuf = NULL;
-		tapestate_set (tape, TS_IDLE);
-		tape->block_size = 0;
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->kernbuf = ti->userbuf = NULL;
+		tapestate_set (ti, TS_IDLE);
+		ti->block_size = 0;
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 #ifdef TAPE_DEBUG
 		debug_text_event (tape_debug_area,6,"c:devreset:");
-		debug_int_event (tape_debug_area,6,tape->blk_minor);
+		debug_int_event (tape_debug_area,6,ti->blk_minor);
 #endif
 		return 0;
 	default:
@@ -469,43 +470,49 @@
 #endif
 		return -ENOSPC;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	tape->cqr = cqr;
-	tape->wanna_wakeup=0;
-	rc = do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-	wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-	tape->cqr = NULL;
-	if (tape->kernbuf != NULL) {
-		kfree (tape->kernbuf);
-		tape->kernbuf = NULL;
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	ti->cqr = cqr;
+	ti->wanna_wakeup=0;
+	rc = do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+	wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+	ti->cqr = NULL;
+	if (ti->kernbuf != NULL) {
+		kfree (ti->kernbuf);
+		ti->kernbuf = NULL;
 	}
 	tape_free_request (cqr);
+	// if medium was unloaded, update the corresponding variable.
+	switch (mt_op) {
+	case MTOFFL:
+	case MTUNLOAD:
+	    ti->medium_is_unloaded=1;
+	}
 	if (signal_pending (current)) {
-		tapestate_set (tape, TS_IDLE);
+		tapestate_set (ti, TS_IDLE);
 		return -ERESTARTSYS;
 	}
-	s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-	if (((mt_op == MTEOM) || (mt_op == MTRETEN)) && (tapestate_get (tape) == TS_FAILED))
-		tapestate_set (tape, TS_DONE);
-	if (tapestate_get (tape) == TS_FAILED) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		return tape->rc;
-	}
-	if (tapestate_get (tape) == TS_NOT_OPER) {
-	    tape->blk_minor=tape->rew_minor=tape->nor_minor=-1;
-	    tape->devinfo.irq=-1;
-	    s390irq_spin_unlock_irqrestore (tape->devinfo.irq,lockflags);
+	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+	if (((mt_op == MTEOM) || (mt_op == MTRETEN)) && (tapestate_get (ti) == TS_FAILED))
+		tapestate_set (ti, TS_DONE);
+	if (tapestate_get (ti) == TS_FAILED) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		return ti->rc;
+	}
+	if (tapestate_get (ti) == TS_NOT_OPER) {
+	    ti->blk_minor=ti->rew_minor=ti->nor_minor=-1;
+	    ti->devinfo.irq=-1;
+	    s390irq_spin_unlock_irqrestore (ti->devinfo.irq,lockflags);
 	    return -ENODEV;
 	}
-	if (tapestate_get (tape) != TS_DONE) {
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	if (tapestate_get (ti) != TS_DONE) {
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		return -EIO;
 	}
-	tapestate_set (tape, TS_IDLE);
-	s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+	tapestate_set (ti, TS_IDLE);
+	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 	switch (mt_op) {
 	case MTRETEN:		//need to rewind the tape after moving to eom
 
@@ -531,7 +538,7 @@
 	    unsigned int cmd, unsigned long arg)
 {
 	long lockflags;
-	tape_info_t *tape;
+	tape_info_t *ti;
 	ccw_req_t *cqr;
 	struct mtop op;		/* structure for MTIOCTOP */
 	struct mtpos pos;	/* structure for MTIOCPOS */
@@ -541,19 +548,19 @@
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:ioct");
 #endif
-	tape = first_tape_info;
-	while ((tape != NULL) &&
-	       (tape->rew_minor != MINOR (inode->i_rdev)) &&
-	       (tape->nor_minor != MINOR (inode->i_rdev)))
-		tape = (tape_info_t *) tape->next;
-	if (tape == NULL) {
+	ti = first_tape_info;
+	while ((ti != NULL) &&
+	       (ti->rew_minor != MINOR (inode->i_rdev)) &&
+	       (ti->nor_minor != MINOR (inode->i_rdev)))
+		ti = (tape_info_t *) ti->next;
+	if (ti == NULL) {
 #ifdef TAPE_DEBUG
 	        debug_text_event (tape_debug_area,6,"c:nodev");
 #endif
 		return -ENODEV;
 	}
 	// check for discipline ioctl overloading
-	if ((rc = tape->discipline->discipline_ioctl_overload (inode, filp, cmd, arg))
+	if ((rc = ti->discipline->discipline_ioctl_overload (inode, filp, cmd, arg))
 	    != -EINVAL) {
 #ifdef TAPE_DEBUG
 	    debug_text_event (tape_debug_area,6,"c:ioverloa");
@@ -563,71 +570,72 @@
 
 	switch (cmd) {
 	case MTIOCTOP:		/* tape op command */
-		if (copy_from_user (&op, (char *) arg, sizeof (struct mtop)))
+		if (copy_from_user (&op, (char *) arg, sizeof (struct mtop))) {
 			 return -EFAULT;
+		}
 		return (tape_mtioctop (filp, op.mt_op, op.mt_count));
 	case MTIOCPOS:		/* query tape position */
-		cqr = tape->discipline->mttell (tape, 0);
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->cqr = cqr;
-		tape->wanna_wakeup=0;
-		do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-		pos.mt_blkno = tape->rc;
-		tape->cqr = NULL;
-		if (tape->kernbuf != NULL) {
-			kfree (tape->kernbuf);
-			tape->kernbuf = NULL;
+		cqr = ti->discipline->mttell (ti, 0);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->cqr = cqr;
+		ti->wanna_wakeup=0;
+		do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+		pos.mt_blkno = ti->rc;
+		ti->cqr = NULL;
+		if (ti->kernbuf != NULL) {
+			kfree (ti->kernbuf);
+			ti->kernbuf = NULL;
 		}
 		tape_free_request (cqr);
 		if (signal_pending (current)) {
-			tapestate_set (tape, TS_IDLE);
+			tapestate_set (ti, TS_IDLE);
 			return -ERESTARTSYS;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		if (copy_to_user ((char *) arg, &pos, sizeof (struct mtpos)))
 			 return -EFAULT;
 		return 0;
 	case MTIOCGET:
-		get.mt_erreg = tape->rc;
-		cqr = tape->discipline->mttell (tape, 0);
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tape->cqr = cqr;
-		tape->wanna_wakeup=0;
-		do_IO (tape->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
-		wait_event_interruptible (tape->wq,tape->wanna_wakeup);
-		get.mt_blkno = tape->rc;
+		get.mt_erreg = ti->rc;
+		cqr = ti->discipline->mttell (ti, 0);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		ti->cqr = cqr;
+		ti->wanna_wakeup=0;
+		do_IO (ti->devinfo.irq, cqr->cpaddr, (unsigned long) cqr, 0x00, cqr->options);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+		wait_event_interruptible (ti->wq,ti->wanna_wakeup);
+		get.mt_blkno = ti->rc;
 		get.mt_fileno = 0;
 		get.mt_type = MT_ISUNKNOWN;
-		get.mt_resid = tape->devstat.rescnt;
-		get.mt_dsreg = tape->devstat.ii.sense.data[3];
+		get.mt_resid = ti->devstat.rescnt;
+		get.mt_dsreg = ti->devstat.ii.sense.data[3];
 		get.mt_gstat = 0;
-		if (tape->devstat.ii.sense.data[1] & 0x08)
+		if (ti->devstat.ii.sense.data[1] & 0x08)
 			get.mt_gstat &= GMT_BOT (1);	// BOT
 
-		if (tape->devstat.ii.sense.data[1] & 0x02)
+		if (ti->devstat.ii.sense.data[1] & 0x02)
 			get.mt_gstat &= GMT_WR_PROT (1);	// write protected
 
-		if (tape->devstat.ii.sense.data[1] & 0x40)
+		if (ti->devstat.ii.sense.data[1] & 0x40)
 			get.mt_gstat &= GMT_ONLINE (1);		//drive online
 
-		tape->cqr = NULL;
-		if (tape->kernbuf != NULL) {
-			kfree (tape->kernbuf);
-			tape->kernbuf = NULL;
+		ti->cqr = NULL;
+		if (ti->kernbuf != NULL) {
+			kfree (ti->kernbuf);
+			ti->kernbuf = NULL;
 		}
 		tape_free_request (cqr);
 		if (signal_pending (current)) {
-			tapestate_set (tape, TS_IDLE);
+			tapestate_set (ti, TS_IDLE);
 			return -ERESTARTSYS;
 		}
-		s390irq_spin_lock_irqsave (tape->devinfo.irq, lockflags);
-		tapestate_set (tape, TS_IDLE);
-		s390irq_spin_unlock_irqrestore (tape->devinfo.irq, lockflags);
+		s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
+		tapestate_set (ti, TS_IDLE);
+		s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
 		if (copy_to_user ((char *) arg, &get, sizeof (struct mtget)))
 			 return -EFAULT;
 		return 0;
@@ -696,7 +704,7 @@
 	long lockflags;
 	tape_info_t *ti,*lastti;
 	ccw_req_t *cqr = NULL;
-	int rc;
+	int rc = 0;
 
 	ti = first_tape_info;
 	while ((ti != NULL) && (ti->rew_minor != MINOR (inode->i_rdev)) && (ti->nor_minor != MINOR (inode->i_rdev)))
@@ -710,13 +718,14 @@
 		lastti->next=ti->next;
 	    }
 	    kfree(ti);    
-	    return 0;
+	    goto out;
 	}
 	if ((ti == NULL) || (tapestate_get (ti) != TS_IDLE)) {
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:notidle!");
 #endif
-		return -ENXIO;	/* error in tape_release */
+		rc = -ENXIO;	/* error in tape_release */
+		goto out;
 	}
 #ifdef TAPE_DEBUG
 	debug_text_event (tape_debug_area,6,"c:release:");
@@ -742,8 +751,9 @@
 	s390irq_spin_lock_irqsave (ti->devinfo.irq, lockflags);
 	tapestate_set (ti, TS_UNUSED);
 	s390irq_spin_unlock_irqrestore (ti->devinfo.irq, lockflags);
+out:
 #ifdef MODULE
 	MOD_DEC_USE_COUNT;
 #endif				/* MODULE */
-	return 0;
+	return rc;
 }
diff -urN linux/drivers/s390/char/tapechar.h linux-2.4.7/drivers/s390/char/tapechar.h
--- linux/drivers/s390/char/tapechar.h	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/char/tapechar.h	Mon Dec 17 13:41:19 2001
@@ -27,7 +27,7 @@
 int tape_open (struct inode *,struct file *);
 int tape_release (struct inode *,struct file *);
 #ifdef CONFIG_DEVFS_FS
-void tapechar_mkdevfstree (tape_info_t* tape);
+void tapechar_mkdevfstree (tape_info_t* ti);
 #endif
 void tapechar_init (void);
 void tapechar_uninit (void);
diff -urN linux/drivers/s390/char/tapedefs.h linux-2.4.7/drivers/s390/char/tapedefs.h
--- linux/drivers/s390/char/tapedefs.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tapedefs.h	Mon Dec 17 13:41:19 2001
@@ -11,15 +11,28 @@
  ***********************************************************************
  */
 
+/* Kernel Version Compatibility section */
+#include <linux/version.h>
+#include <linux/blkdev.h>
+#include <linux/blk.h>
+#include <asm/irq.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17))
 #define TAPE_DEBUG               // use s390 debug feature
+#else
+#undef TAPE_DEBUG                // debug feature not supported by our 2.2.16 code
+static inline void set_normalized_cda ( ccw1_t * cp, unsigned long address ) {
+    cp -> cda = address;
+}
+static inline void clear_normalized_cda ( ccw1_t * ccw ) {
+    ccw -> cda = 0;
+}
+#define BUG() PRINT_FATAL("tape390: CRITICAL INTERNAL ERROR OCCURED. REPORT THIS BACK TO LINUX390@DE.IBM.COM\n")
+#endif
 #define CONFIG_S390_TAPE_DYNAMIC // allow devices to be attached or detached on the fly
 #define TAPEBLOCK_RETRIES 20     // number of retries, when a block-dev request fails.
 
 
-/* Kernel Version Compatibility section */
-#include <linux/version.h>
-#include <linux/blkdev.h>
-#include <linux/blk.h>
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
 #define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
 do { \
diff -urN linux/drivers/s390/char/tuball.c linux-2.4.7/drivers/s390/char/tuball.c
--- linux/drivers/s390/char/tuball.c	Wed Apr 18 14:49:11 2001
+++ linux-2.4.7/drivers/s390/char/tuball.c	Mon Dec 17 13:42:42 2001
@@ -23,8 +23,7 @@
 
 /* Module parameters */
 int tubdebug;
-int tubscrolltime;
-int tubscrollparm;
+int tubscrolltime = -1;
 int tubxcorrect = 1;            /* Do correct ebc<->asc tables */
 #ifdef MODULE
 MODULE_PARM(tubdebug, "i");
@@ -67,14 +66,14 @@
 	  0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 	  0xf8, 0xf9, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f };
 
-static int tub3270_init(void);
+int tub3270_init(void);
 
 #ifndef MODULE
 
 /*
  * Can't have this driver a module & support console at the same time
  */
-#ifdef CONFIG_3270_CONSOLE
+#ifdef CONFIG_TN3270_CONSOLE
 static kdev_t tub3270_con_device(struct console *);
 static void tub3270_con_unblank(void);
 static void tub3270_con_write(struct console *, const char *,
@@ -94,62 +93,52 @@
 	NULL			/* next */
 };
 
-int tub3270_con_devno = -1;		/* set by tub3270_con_setup() */
-bcb_t tub3270_con_bcb;			/* Buffer that receives con writes */
-spinlock_t tub3270_con_bcblock;		/* Lock for the buffer */
+static bcb_t tub3270_con_bcb;		/* Buffer that receives con writes */
+static spinlock_t tub3270_con_bcblock;	/* Lock for the buffer */
 int tub3270_con_irq = -1;		/* set nonneg by _activate() */
 tub_t *tub3270_con_tubp;		/* set nonzero by _activate() */
 struct tty_driver tty3270_con_driver;	/* for /dev/console at 4, 64 */
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+int tub3270_con_devno = -1;		/* set by tub3270_con_setup() */
 __initfunc(void tub3270_con_setup(char *str, int *ints))
-#else
-static int __init tub3270_con_setup(char *str)
-#endif
 {
 	int vdev;
 
 	vdev = simple_strtoul(str, 0, 16);
 	if (vdev >= 0 && vdev < 65536)
 		tub3270_con_devno = vdev;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 	return;
-#else
-	return 1;
-#endif
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
-__setup("condev=", tub3270_con_setup);
-#endif
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 __initfunc (long tub3270_con_init(long kmem_start, long kmem_end))
-#else
-void __init tub3270_con_init(void)
-#endif
 {
 	tub3270_con_bcb.bc_len = 65536;
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 	if (!MACHINE_IS_VM && !MACHINE_IS_P390)
 		return kmem_start;
 	tub3270_con_bcb.bc_buf = (void *)kmem_start;
 	kmem_start += tub3270_con_bcb.bc_len;
 	register_console(&tub3270_con);
 	return kmem_start;
+}
 #else
-	if (!MACHINE_IS_VM && !MACHINE_IS_P390)
+#define tub3270_con_devno console_device
+
+void __init tub3270_con_init(void)
+{
+	tub3270_con_bcb.bc_len = 65536;
+	if (!CONSOLE_IS_3270)
 		return;
 	tub3270_con_bcb.bc_buf = (void *)alloc_bootmem_low(
 		tub3270_con_bcb.bc_len);
 	register_console(&tub3270_con);
-#endif
 }
+#endif
 
 static kdev_t
 tub3270_con_device(struct console *conp)
 {
-	return MKDEV(IBM_TTY3270_MAJOR, conp->index);
+	return MKDEV(IBM_TTY3270_MAJOR, conp->index + 1);
 }
 
 static void
@@ -164,7 +153,7 @@
 tub3270_con_write(struct console *conp,
 	const char *buf, unsigned int count)
 {
-	int flags;
+	long flags;
 	tub_t *tubp = tub3270_con_tubp;
 	void tty3270_sched_bh(tub_t *);
 	int rc;
@@ -176,7 +165,7 @@
 	obcb.bc_rd = 0;
 
 	spin_lock_irqsave(&tub3270_con_bcblock, flags);
-	rc = tub3270_movedata(&obcb, &tub3270_con_bcb);
+	rc = tub3270_movedata(&obcb, &tub3270_con_bcb, 0);
 	spin_unlock_irqrestore(&tub3270_con_bcblock, flags);
 
 	if (tubp && rc && TUBTRYLOCK(tubp->irq, flags)) {
@@ -187,27 +176,15 @@
 	
 int tub3270_con_copy(tub_t *tubp)
 {
-	int flags;
+	long flags;
 	int rc;
 
 	spin_lock_irqsave(&tub3270_con_bcblock, flags);
-	rc = tub3270_movedata(&tub3270_con_bcb, &tubp->tty_bcb);
+	rc = tub3270_movedata(&tub3270_con_bcb, &tubp->tty_bcb, 0);
 	spin_unlock_irqrestore(&tub3270_con_bcblock, flags);
 	return rc;
 }
-#endif /* CONFIG_3270_CONSOLE */
-
-
-
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-__initfunc(void tub3270_initfunc(void))
-#else
-void __init tub3270_initfunc(void)
-#endif
-{
-	tub3270_init();
-}
+#endif /* CONFIG_TN3270_CONSOLE */
 #else /* If generated as a MODULE */
 /*
  * module init:  find tubes; get a major nbr
@@ -249,22 +226,13 @@
 /*
  * tub3270_init() called by kernel or module initialization
  */
-static int
+int
 tub3270_init(void)
 {
 	s390_dev_info_t d;
 	int i, rc;
 
 	/*
-	 * Initialize default scrolltime to either -1 or the
-	 * module parameter tubscrolltime.
-	 */
-	if (tubscrolltime)
-		tubscrollparm = tubscrolltime;
-	else
-		tubscrollparm = -1;
-
-	/*
 	 * Copy and correct ebcdic - ascii translate tables
 	 */
 	memcpy(tub_ascebc, _ascebc, sizeof tub_ascebc);
@@ -283,30 +251,41 @@
 	if (rc != 0)
 		return rc;
 
+	if (fs3270_init() || tty3270_init()) {
+		printk(KERN_ERR "fs3270_init() or tty3270_init() failed\n");
+		fs3270_fini();
+		tty3270_fini();
+		tubfiniminors();
+		return -1;
+	}
+
 	for (i = get_irq_first(); i >= 0; i = get_irq_next(i)) {
 		if ((rc = get_dev_info_by_irq(i, &d)))
 			continue;
 		if (d.status)
 			continue;
-#ifdef CONFIG_3270_CONSOLE
+
+#ifdef CONFIG_TN3270_CONSOLE
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 		if (d.sid_data.cu_type == 0x3215 && MACHINE_IS_VM) {
 			cpcmd("TERM CONMODE 3270", NULL, 0);
 			d.sid_data.cu_type = 0x3270;
 		}
-#endif /* CONFIG_3270_CONSOLE */
+#else
+		if (d.sid_data.cu_type == 0x3215 && CONSOLE_IS_3270) {
+			cpcmd("TERM CONMODE 3270", NULL, 0);
+			d.sid_data.cu_type = 0x3270;
+		}
+#endif /* LINUX_VERSION_CODE */
+#endif /* CONFIG_TN3270_CONSOLE */
 		if ((d.sid_data.cu_type & 0xfff0) != 0x3270)
 			continue;
 
 		rc = tubmakemin(i, &d);
 		if (rc < 0) {
-			if (tubnummins == 1) {  /* if first time */
-				tubfiniminors();
-				printk(KERN_ERR "No kernel memory available"
-					" for 3270 tube devices.\n");
-				return rc;
-			}
-			printk(KERN_WARNING "3270 tube registration ran out of memory"
-				" after %d devices\n", tubnummins - 1);
+			printk(KERN_WARNING 
+			       "3270 tube registration ran out of memory"
+			       " after %d devices\n", tubnummins - 1);
 			break;
 		} else {
 			printk(KERN_INFO "3270: %.4x on sch %d, minor %d\n",
@@ -314,14 +293,6 @@
 		}
 	}
 
-	if (fs3270_init() || tty3270_init()) {
-		printk(KERN_ERR "fs3270_init() or tty3270_init() failed\n");
-		fs3270_fini();
-		tty3270_fini();
-		tubfiniminors();
-		return -1;
-	}
-
 	return 0;
 }
 
@@ -329,7 +300,7 @@
  * tub3270_movedata(bcb_t *, bcb_t *) -- Move data stream
  */
 int
-tub3270_movedata(bcb_t *ib, bcb_t *ob)
+tub3270_movedata(bcb_t *ib, bcb_t *ob, int fromuser)
 {
 	int count;			/* Total move length */
 	int rc;
@@ -354,11 +325,21 @@
 				len2 = ob->bc_len - ob->bc_wr;
 			if (len2 > len1)
 				len2 = len1;
-
-			memcpy(ob->bc_buf + ob->bc_wr,
-				ib->bc_buf + ib->bc_rd,
-				len2);
-
+			
+			if (fromuser) {
+				len2 -= copy_from_user(ob->bc_buf + ob->bc_wr,
+						       ib->bc_buf + ib->bc_rd,
+						       len2);
+				if (len2 == 0) {
+					if (!rc)
+						rc = -EFAULT;
+					break;
+				}
+			} else
+				memcpy(ob->bc_buf + ob->bc_wr,
+				       ib->bc_buf + ib->bc_rd,
+				       len2);
+			
 			ib->bc_rd += len2;
 			if (ib->bc_rd == ib->bc_len)
 				ib->bc_rd = 0;
@@ -422,7 +403,7 @@
 {
 	tub_t *tubp;
 	int minor;
-	int flags;
+	long flags;
 
 	if ((minor = ++tubnummins) == TUBMAXMINS)
 		return -ENODEV;
@@ -446,7 +427,7 @@
 
 	tubp->tty_bcb.bc_len = TTY_OUTPUT_SIZE;
 	tubp->tty_bcb.bc_buf = (void *)kmalloc(tubp->tty_bcb.bc_len,
-		GFP_KERNEL);
+		GFP_KERNEL|GFP_DMA);
 	if (tubp->tty_bcb.bc_buf == NULL) {
 		TUBUNLOCK(tubp->irq, flags);
 		tubdelbyirq(tubp, irq);
@@ -457,24 +438,34 @@
 	tubp->tty_bcb.bc_wr = 0;
 	tubp->tty_bcb.bc_rd = 0;
 	(*tubminors)[minor] = tubp;
-#ifdef CONFIG_3270_CONSOLE
-	if (tub3270_con_tubp == NULL && tub3270_con_bcb.bc_buf != NULL &&
-	    (tub3270_con_devno == -1 ||
-	     tub3270_con_devno == dp->devno)) {
-		extern void tty3270_int(tub_t *, devstat_t *);
- 
-		tubp->cmd = TBC_CONOPEN;
-		tubp->flags |= TUB_OPEN_STET;
-		tty3270_size(tubp, &flags);
-		tty3270_aid_init(tubp);
-		tty3270_scl_init(tubp);
-		tub3270_con_irq = tubp->irq;
-		tub3270_con_tubp = tubp;
-		tubp->intv = tty3270_int;
-		tubp->cmd = TBC_UPDSTAT;
-		tty3270_build(tubp);
+
+#ifdef CONFIG_TN3270_CONSOLE
+	if (CONSOLE_IS_3270) {
+		if (tub3270_con_tubp == NULL && 
+		    tub3270_con_bcb.bc_buf != NULL &&
+		    (tub3270_con_devno == -1 ||
+		     tub3270_con_devno == dp->devno)) {
+			extern void tty3270_int(tub_t *, devstat_t *);
+			
+			tub3270_con_devno = dp->devno;
+			tubp->cmd = TBC_CONOPEN;
+			tubp->flags |= TUB_OPEN_STET | TUB_INPUT_HACK;
+			tty3270_size(tubp, &flags);
+			tty3270_aid_init(tubp);
+			tty3270_scl_init(tubp);
+			tub3270_con_irq = tubp->irq;
+			tub3270_con_tubp = tubp;
+			tubp->intv = tty3270_int;
+			tubp->cmd = TBC_UPDSTAT;
+			tty3270_build(tubp);
+		}
 	}
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* CONFIG_TN3270_CONSOLE */
+
+#ifdef CONFIG_DEVFS_FS
+	fs3270_devfs_register(tubp);
+#endif
+
 	TUBUNLOCK(tubp->irq, flags);
 	return minor;
 }
@@ -495,6 +486,9 @@
 	for (i = 0; i < TUBMAXMINS; i++) {
 		tubpp = &(*tubminors)[i];
 		if ((tubp = *tubpp)) {
+#ifdef CONFIG_DEVFS_FS
+			fs3270_devfs_unregister(tubp);
+#endif
 			tubdelbyirq(tubp, tubp->irq);
 			tty3270_rcl_fini(tubp);
 			kfree(tubp->tty_bcb.bc_buf);
diff -urN linux/drivers/s390/char/tubfs.c linux-2.4.7/drivers/s390/char/tubfs.c
--- linux/drivers/s390/char/tubfs.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubfs.c	Mon Dec 17 13:41:49 2001
@@ -16,9 +16,9 @@
 static int fs3270_open(struct inode *, struct file *);
 static int fs3270_close(struct inode *, struct file *);
 static int fs3270_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
-static int fs3270_read(struct file *, char *, size_t, loff_t *);
-static int fs3270_write(struct file *, const char *, size_t, loff_t *);
-static int fs3270_wait(tub_t *, int *);
+static ssize_t fs3270_read(struct file *, char *, size_t, loff_t *);
+static ssize_t fs3270_write(struct file *, const char *, size_t, loff_t *);
+static int fs3270_wait(tub_t *, long *);
 static void fs3270_int(tub_t *tubp, devstat_t *dsp);
 extern void tty3270_refresh(tub_t *);
 
@@ -33,6 +33,42 @@
 	release:fs3270_close,	/* release */
 };
 
+#ifdef CONFIG_DEVFS_FS
+devfs_handle_t fs3270_devfs_dir;
+devfs_handle_t fs3270_devfs_tub;
+extern struct file_operations tty_fops;
+
+void fs3270_devfs_register(tub_t *tubp)
+{
+	char name[16];
+
+	sprintf(name, "tub%.3x", tubp->devno);
+	devfs_register(fs3270_devfs_dir, name, DEVFS_FL_DEFAULT,
+		       IBM_FS3270_MAJOR, tubp->minor,
+		       S_IFCHR | S_IRUSR | S_IWUSR, &fs3270_fops, NULL);
+	sprintf(name, "tty%.3x", tubp->devno);
+	tty_register_devfs_name(&tty3270_driver, 0, tubp->minor,
+				fs3270_devfs_dir, name);
+}
+
+void fs3270_devfs_unregister(tub_t *tubp)
+{
+	char name[16];
+	devfs_handle_t handle;
+
+	sprintf(name, "tub%.3x", tubp->devno);
+	handle = devfs_find_handle (fs3270_devfs_dir, name,
+				    IBM_FS3270_MAJOR, tubp->minor,
+				    DEVFS_SPECIAL_CHR, 0);
+	devfs_unregister (handle);
+	sprintf(name, "tty%.3x", tubp->devno);
+	handle = devfs_find_handle (fs3270_devfs_dir, name,
+				    IBM_TTY3270_MAJOR, tubp->minor,
+				    DEVFS_SPECIAL_CHR, 0);
+	devfs_unregister(handle);
+}
+#endif
+
 /*
  * fs3270_init() -- Initialize fullscreen tubes
  */
@@ -41,15 +77,29 @@
 {
 	int rc;
 
+#ifdef CONFIG_DEVFS_FS
+	rc = devfs_register_chrdev (IBM_FS3270_MAJOR, "fs3270", &fs3270_fops);
+	if (rc) {
+		printk(KERN_ERR "tubmod can't get major nbr %d: error %d\n",
+			IBM_FS3270_MAJOR, rc);
+		return -1;
+	}
+	fs3270_devfs_dir = devfs_mk_dir(NULL, "3270", NULL);
+	fs3270_devfs_tub = 
+		devfs_register(fs3270_devfs_dir, "tub", DEVFS_FL_DEFAULT,
+			       IBM_FS3270_MAJOR, 0,
+			       S_IFCHR | S_IRUGO | S_IWUGO, 
+			       &fs3270_fops, NULL);
+#else
 	rc = register_chrdev(IBM_FS3270_MAJOR, "fs3270", &fs3270_fops);
 	if (rc) {
 		printk(KERN_ERR "tubmod can't get major nbr %d: error %d\n",
 			IBM_FS3270_MAJOR, rc);
 		return -1;
-	} else {
-		fs3270_major = IBM_FS3270_MAJOR;
-		return 0;
 	}
+#endif
+	fs3270_major = IBM_FS3270_MAJOR;
+	return 0;
 }
 
 /*
@@ -59,6 +109,10 @@
 fs3270_fini(void)
 {
 	if (fs3270_major != -1) {
+#ifdef CONFIG_DEVFS_FS
+		devfs_unregister(fs3270_devfs_tub);
+		devfs_unregister(fs3270_devfs_dir);
+#endif
 		unregister_chrdev(fs3270_major, "fs3270");
 		fs3270_major = -1;
 	}
@@ -71,7 +125,7 @@
 fs3270_open(struct inode *ip, struct file *fp)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 
 	/* See INODE2TUB(ip) for handling of "/dev/3270/tub" */
 	if ((tubp = INODE2TUB(ip)) == NULL)
@@ -101,7 +155,7 @@
 fs3270_close(struct inode *ip, struct file *fp)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 
 	if ((tubp = INODE2TUB(ip)) == NULL)
 		return -ENODEV;
@@ -123,7 +177,7 @@
 void
 fs3270_release(tub_t *tubp)
 {
-	int flags;
+	long flags;
 
 	if (tubp->mode != TBM_FS)
 		return;
@@ -145,7 +199,7 @@
  *      * Value is 0 or -ERESTARTSYS
  */
 static int
-fs3270_wait(tub_t *tubp, int *flags)
+fs3270_wait(tub_t *tubp, long *flags)
 {
 	DECLARE_WAITQUEUE(wait, current);
 
@@ -185,7 +239,7 @@
 static void
 fs3270_bh(void *data)
 {
-	int flags;
+	long flags;
 	tub_t *tubp;
 
 	tubp = data;
@@ -283,7 +337,8 @@
 	unsigned int cmd, unsigned long arg)
 {
 	tub_t *tubp;
-	int rc = 0, flags;
+	int rc = 0;
+	long flags;
 
 	if ((tubp = INODE2TUB(ip)) == NULL)
 		return -ENODEV;
@@ -310,13 +365,14 @@
 /*
  * process read commands for the tube driver
  */
-static int
+static ssize_t
 fs3270_read(struct file *fp, char *dp, size_t len, loff_t *off)
 {
 	tub_t *tubp;
 	char *kp;
 	ccw1_t *cp;
-	int rc, flags;
+	int rc;
+	long flags;
 
 	if ((tubp = INODE2TUB((struct inode *)fp->private_data)) == NULL)
 		return -ENODEV;
@@ -325,7 +381,7 @@
 		return rc;
 	}
 
-	kp = kmalloc(len, GFP_KERNEL);
+	kp = kmalloc(len, GFP_KERNEL|GFP_DMA);
 	if (kp == NULL) {
 		TUBUNLOCK(tubp->irq, flags);
 		return -ENOMEM;
@@ -352,10 +408,10 @@
 	if (tubdebug & 1)
 		printk(KERN_DEBUG "minor %d: %.8x %.8x %.8x %.8x\n",
 			tubp->minor,
-			*(int*)((int)kp + 0),
-			*(int*)((int)kp + 4),
-			*(int*)((int)kp + 8),
-			*(int*)((int)kp + 12));
+			*(int*)((long)kp + 0),
+			*(int*)((long)kp + 4),
+			*(int*)((long)kp + 8),
+			*(int*)((long)kp + 12));
 	copy_to_user(dp, kp, len);
 	kfree(kp);
 	return len;
@@ -364,12 +420,13 @@
 /*
  * process write commands for the tube driver
  */
-static int
+static ssize_t
 fs3270_write(struct file *fp, const char *dp, size_t len, loff_t *off)
 {
 	tub_t *tubp;
 	ccw1_t *cp;
-	int rc, flags;
+	int rc;
+	long flags;
 	void *kb;
 
 	/* Locate the tube */
@@ -377,7 +434,7 @@
 		return -ENODEV;
 
 	/* Copy data to write from user address space */
-	if ((kb = kmalloc(len, GFP_KERNEL)) == NULL)
+	if ((kb = kmalloc(len, GFP_KERNEL|GFP_DMA)) == NULL)
 		return -ENOMEM;
 	if (copy_from_user(kb, dp, len) != 0) {
 		kfree(kb);
diff -urN linux/drivers/s390/char/tubio.h linux-2.4.7/drivers/s390/char/tubio.h
--- linux/drivers/s390/char/tubio.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubio.h	Mon Dec 17 13:42:42 2001
@@ -23,7 +23,7 @@
 #endif /* IBM_FS3270_MAJOR */
 
 
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <linux/console.h>
@@ -31,6 +31,9 @@
 #include <asm/ebcdic.h>
 #include <asm/uaccess.h>
 #include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
+#include <linux/devfs_fs_kernel.h>
+#endif
 
 #define TUB(x) (('3'<<8)|(x))
 #define TUBICMD TUB(3)
@@ -279,12 +282,17 @@
 #define	TUB_UNSOL_DE	0x0200
 #define	TUB_OPEN_STET	0x0400		/* No screen clear on open */
 #define	TUB_UE_BUSY	0x0800
+#define	TUB_INPUT_HACK	0x1000		/* Early init of command line */
 
-#ifdef CONFIG_3270_CONSOLE
+#ifdef CONFIG_TN3270_CONSOLE
 /*
  * Extra stuff for 3270 console support
  */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 #define	S390_CONSOLE_DEV MKDEV(TTY_MAJOR, 64)
+#else
+#define	S390_CONSOLE_DEV MKDEV(TTYAUX_MAJOR, 1)
+#endif
 extern int tub3270_con_devno;
 extern char (*tub3270_con_output)[];
 extern int tub3270_con_outputl;
@@ -293,7 +301,7 @@
 extern int tub3270_con_irq;
 extern tub_t *tub3270_con_tubp;
 extern struct tty_driver tty3270_con_driver;
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* CONFIG_TN3270_CONSOLE */
 
 extern int tubnummins;
 extern tub_t *(*tubminors)[TUBMAXMINS];
@@ -306,6 +314,12 @@
 extern int tty3270_major;
 extern int tty3270_proc_misc;
 extern enum tubwhat tty3270_proc_what;
+extern struct tty_driver tty3270_driver;
+#ifdef CONFIG_DEVFS_FS
+extern devfs_handle_t fs3270_devfs_dir;
+extern void fs3270_devfs_register(tub_t *);
+extern void fs3270_devfs_unregister(tub_t *);
+#endif
 
 #ifndef spin_trylock_irqsave
 #define spin_trylock_irqsave(lock, flags) \
@@ -343,67 +357,50 @@
  * Find tub_t * given fullscreen device's inode pointer
  * This algorithm takes into account /dev/3270/tub.
  */
-#ifdef CONFIG_3270_CONSOLE
-#define INODE2TUB(ip) \
-({ \
-	unsigned int minor; \
-	tub_t *tubp = NULL; \
-	minor = MINOR((ip)->i_rdev); \
-	if (minor == 0 && current->tty != NULL) { \
-		if (tub3270_con_tubp != NULL && \
-		    current->tty->device == S390_CONSOLE_DEV) \
-			minor = tub3270_con_tubp->minor; \
-		else if (MAJOR(current->tty->device) == IBM_TTY3270_MAJOR) \
-			minor = MINOR(current->tty->device); \
-	} \
-	if (minor <= tubnummins && minor > 0) \
-		tubp = (*tubminors)[minor]; \
-	tubp; \
-})
-#else /* not CONFIG_3270_CONSOLE */
-#define INODE2TUB(ip) \
-({ \
-	unsigned int minor; \
-	tub_t *tubp = NULL; \
-	minor = MINOR((ip)->i_rdev); \
-	if (minor == 0 && current->tty != NULL && \
-	    MAJOR(current->tty->device) == IBM_TTY3270_MAJOR) \
-		minor = MINOR(current->tty->device); \
-	if (minor <= tubnummins && minor > 0) \
-		tubp = (*tubminors)[minor]; \
-	tubp; \
-})
-#endif /* CONFIG_3270_CONSOLE or not */
+extern inline tub_t *INODE2TUB(struct inode *ip)
+{
+	unsigned int minor = MINOR(ip->i_rdev);
+	tub_t *tubp = NULL;
+	if (minor == 0 && current->tty != NULL) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+#ifdef CONFIG_TN3270_CONSOLE
+		if (tub3270_con_tubp != NULL &&
+		    current->tty->device == S390_CONSOLE_DEV)
+			minor = tub3270_con_tubp->minor;
+		else
+#endif
+#endif
+		if (MAJOR(current->tty->device) == IBM_TTY3270_MAJOR)
+			minor = MINOR(current->tty->device);
+	}
+	if (minor <= tubnummins && minor > 0)
+		tubp = (*tubminors)[minor];
+	return tubp;
+}
+
 /*
  * Find tub_t * given non-fullscreen (tty) device's tty_struct pointer
  */
-#ifdef CONFIG_3270_CONSOLE
-#define TTY2TUB(tty) \
-({ \
-	unsigned int minor; \
-	tub_t *tubp = NULL; \
-	minor = MINOR(tty->device); \
-	if (tty->device == S390_CONSOLE_DEV) \
-		tubp = tub3270_con_tubp; \
-	else if (minor <= tubnummins && minor > 0) \
-		tubp = (*tubminors)[minor]; \
-	tubp; \
-})
-#else /* if not CONFIG_3270_CONSOLE */
-#define TTY2TUB(tty) \
-({ \
-	unsigned int minor; \
-	tub_t *tubp = NULL; \
-	minor = MINOR(tty->device); \
-	if (minor <= tubnummins && minor > 0) \
-		tubp = (*tubminors)[minor]; \
-	tubp; \
-})
-#endif /* CONFIG_3270_CONSOLE or not */
+extern inline tub_t *TTY2TUB(struct tty_struct *tty)
+{
+	unsigned int minor = MINOR(tty->device);
+	tub_t *tubp = NULL;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+#ifdef CONFIG_TN3270_CONSOLE
+	if (tty->device == S390_CONSOLE_DEV)
+		tubp = tub3270_con_tubp;
+	else
+#endif
+#endif
+	if (minor <= tubnummins && minor > 0)
+		tubp = (*tubminors)[minor];
+	return tubp;
+}
 
 extern void tub_inc_use_count(void);
 extern void tub_dec_use_count(void);
-extern int tub3270_movedata(bcb_t *, bcb_t *);
+extern int tub3270_movedata(bcb_t *, bcb_t *, int);
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
 extern int tubmakemin(int, dev_info_t *);
 #else
@@ -418,7 +415,7 @@
 extern void tty3270_rcl_sync(tub_t *);
 extern void tty3270_rcl_purge(tub_t *);
 extern int tty3270_rcl_resize(tub_t *, int);
-extern int tty3270_size(tub_t *, int *);
+extern int tty3270_size(tub_t *, long *);
 extern int tty3270_aid_init(tub_t *);
 extern void tty3270_aid_fini(tub_t *);
 extern void tty3270_aid_reinit(tub_t *);
diff -urN linux/drivers/s390/char/tubtty.c linux-2.4.7/drivers/s390/char/tubtty.c
--- linux/drivers/s390/char/tubtty.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubtty.c	Mon Dec 17 13:42:42 2001
@@ -37,7 +37,7 @@
 /* tty3270 utility functions */
 static void tty3270_bh(void *);
        void tty3270_sched_bh(tub_t *);
-static int tty3270_wait(tub_t *, int *);
+static int tty3270_wait(tub_t *, long *);
        void tty3270_int(tub_t *, devstat_t *);
        int tty3270_try_logging(tub_t *);
 static void tty3270_start_input(tub_t *);
@@ -48,20 +48,19 @@
 static int tty3270_show_tube(int, char *, int);
 
 int tty3270_major = -1;
-char tty3270_major_string[16];
 struct tty_driver tty3270_driver;
 int tty3270_refcount;
 struct tty_struct *tty3270_table[TUBMAXMINS];
 struct termios *tty3270_termios[TUBMAXMINS];
 struct termios *tty3270_termios_locked[TUBMAXMINS];
-#ifdef CONFIG_3270_CONSOLE
+#ifdef CONFIG_TN3270_CONSOLE
 int con3270_major = -1;
 struct tty_driver con3270_driver;
 int con3270_refcount;
 struct tty_struct *con3270_table[1];
 struct termios *con3270_termios[1];
 struct termios *con3270_termios_locked[1];
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* CONFIG_TN3270_CONSOLE */
 
 int tty3270_proc_index;
 int tty3270_proc_data;
@@ -88,6 +87,9 @@
 	td->subtype = SYSTEM_TYPE_TTY;
 	td->init_termios = tty_std_termios;
 	td->flags = TTY_DRIVER_RESET_TERMIOS;
+#ifdef CONFIG_DEVFS_FS
+	td->flags |= TTY_DRIVER_NO_DEVFS;
+#endif
 	td->refcount = &tty3270_refcount;
 	td->table = tty3270_table;
 	td->termios = tty3270_termios;
@@ -121,32 +123,36 @@
 		printk(KERN_ERR "tty3270 registration failed with %d\n", rc);
 	} else {
 		tty3270_major = IBM_TTY3270_MAJOR;
-		sprintf(tty3270_major_string, "%d", tty3270_major);
 		if (td->proc_entry != NULL)
 			td->proc_entry->mode = S_IRUGO | S_IWUGO;
 	}
-#ifdef CONFIG_3270_CONSOLE
-	tty3270_con_driver = *td;
-	td = &tty3270_con_driver;
-	td->driver_name = "con3270";
-	td->name = "con3270";
-	td->major = MAJOR(S390_CONSOLE_DEV);
-	td->minor_start = MINOR(S390_CONSOLE_DEV);
-	td->num = 1;
-	td->refcount = &con3270_refcount;
-	td->table = con3270_table;
-	td->termios = con3270_termios;
-	td->termios_locked = con3270_termios_locked;
-
-	rc = tty_register_driver(td);
-	if (rc) {
-		printk(KERN_ERR "con3270 registration failed with %d\n", rc);
-	} else {
-		con3270_major = MAJOR(S390_CONSOLE_DEV);
-		if (td->proc_entry != NULL)
-			td->proc_entry->mode = S_IRUGO | S_IWUGO;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+#ifdef CONFIG_TN3270_CONSOLE
+	if (CONSOLE_IS_3270) {
+		tty3270_con_driver = *td;
+		td = &tty3270_con_driver;
+		td->driver_name = "con3270";
+		td->name = "con3270";
+		td->major = MAJOR(S390_CONSOLE_DEV);
+		td->minor_start = MINOR(S390_CONSOLE_DEV);
+		td->num = 1;
+		td->refcount = &con3270_refcount;
+		td->table = con3270_table;
+		td->termios = con3270_termios;
+		td->termios_locked = con3270_termios_locked;
+
+		rc = tty_register_driver(td);
+		if (rc) {
+			printk(KERN_ERR
+			       "con3270 registration failed with %d\n", rc);
+		} else {
+			con3270_major = MAJOR(S390_CONSOLE_DEV);
+			if (td->proc_entry != NULL)
+				td->proc_entry->mode = S_IRUGO | S_IWUGO;
+		}
 	}
-#endif /* if CONFIG_3270_CONSOLE */
+#endif /* ifdef CONFIG_TN3270_CONSOLE */
+#endif /* if LINUX_VERSION_CODE */
 
 	return rc;
 }
@@ -161,8 +167,8 @@
 		tty_unregister_driver(&tty3270_driver);
 		tty3270_major = -1;
 	}
-#ifdef CONFIG_3270_CONSOLE
-	if (con3270_major != -1) {
+#ifdef CONFIG_TN3270_CONSOLE
+	if (CONSOLE_IS_3270 && con3270_major != -1) {
 		tty_unregister_driver(&con3270_driver);
 		con3270_major = -1;
 	}
@@ -173,7 +179,7 @@
 tty3270_open(struct tty_struct *tty, struct file *filp)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 	int rc;
 	int cmd;
 
@@ -229,7 +235,7 @@
 tty3270_close(struct tty_struct *tty, struct file *filp)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 
 	if ((tubp = tty->driver_data) == NULL)
 		return;
@@ -252,24 +258,24 @@
 		const unsigned char *buf, int count)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 	bcb_t obcb;
 	int rc = 0;
 
 	if ((tubp = tty->driver_data) == NULL)
 		return -1;
 
-#ifdef CONFIG_3270_CONSOLE
-	if (tub3270_con_tubp == tubp)
+#ifdef CONFIG_TN3270_CONSOLE
+	if (CONSOLE_IS_3270 && tub3270_con_tubp == tubp)
 		tub3270_con_copy(tubp);
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* CONFIG_TN3270_CONSOLE */
 
 	obcb.bc_buf = (char *)buf;
 	obcb.bc_len = obcb.bc_cnt = obcb.bc_wr = count;
 	obcb.bc_rd = 0;
 
 	TUBLOCK(tubp->irq, flags);
-	rc = tub3270_movedata(&obcb, &tubp->tty_bcb);
+	rc = tub3270_movedata(&obcb, &tubp->tty_bcb, fromuser);
 	tty3270_try_logging(tubp);
 	TUBUNLOCK(tubp->irq, flags);
 	return rc;
@@ -278,7 +284,7 @@
 static void
 tty3270_put_char(struct tty_struct *tty, unsigned char ch)
 {
-	int flags;
+	long flags;
 	tub_t *tubp;
 	bcb_t *ob;
 
@@ -301,7 +307,7 @@
 tty3270_flush_chars(struct tty_struct *tty)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 
 	if ((tubp = tty->driver_data) == NULL)
 		return;
@@ -342,7 +348,7 @@
 		unsigned int cmd, unsigned long arg)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 	int ret = 0;
 	struct termios termios;
 
@@ -394,7 +400,7 @@
 tty3270_set_termios(struct tty_struct *tty, struct termios *old)
 {
 	tub_t *tubp;
-	int flags;
+	long flags;
 	int new;
 
 	if ((tubp = tty->driver_data) == NULL)
@@ -420,7 +426,7 @@
 {
 	tub_t *tubp;
 	bcb_t *ob;
-	int flags;
+	long flags;
 
 	if ((tubp = tty->driver_data) == NULL)
 		return;
@@ -452,7 +458,6 @@
 	int i;
 	int rc;
 	int len = 0;
-	char *majstr;
 
 	if (tty3270_proc_what == TW_CONFIG) {
 		/*
@@ -464,13 +469,14 @@
 		len += sprintf(buf + len, "0 %d 0\n", fs3270_major);
 		for (i = 1; i <= tubnummins; i++) {
 			tubp = (*tubminors)[i];
-			majstr = tty3270_major_string;
-#ifdef CONFIG_3270_CONSOLE
-			if (tubp == tub3270_con_tubp)
-				majstr = "CONSOLE";
-#endif /* CONFIG_3270_CONSOLE */
-			len += sprintf(buf + len, "%.3x %s %d\n",
-				tubp->devno, majstr, i);
+#ifdef CONFIG_TN3270_CONSOLE
+			if (CONSOLE_IS_3270 && tubp == tub3270_con_tubp)
+				len += sprintf(buf + len, "%.3x CONSOLE %d\n",
+					       tubp->devno, i);
+			else
+#endif
+				len += sprintf(buf + len, "%.3x %d %d\n",
+					       tubp->devno, tty3270_major, i);
 			if (begin + len > off + count)
 				break;
 			if (begin + len < off) {
@@ -536,10 +542,12 @@
 	if (device) {
 		if (MAJOR(device) == IBM_TTY3270_MAJOR)
 			tubp = (*tubminors)[MINOR(device)];
-#ifdef CONFIG_3270_CONSOLE
-		if (device == S390_CONSOLE_DEV)
+#ifdef CONFIG_TN3270_CONSOLE
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
+		if (CONSOLE_IS_3270 && device == S390_CONSOLE_DEV)
 			tubp = tub3270_con_tubp;
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* LINUX_VERSION_CODE */
+#endif /* CONFIG_TN3270_CONSOLE */
 	}
 	if (tubp) {
 		if ((rc = tty3270_aid_set(tubp, mybuf, mycount + 1)))
@@ -595,7 +603,7 @@
 static void
 tty3270_bh(void *data)
 {
-	int flags;
+	long flags;
 	tub_t *tubp;
 	struct tty_struct *tty;
 
@@ -675,7 +683,7 @@
  * On entry the lock must not be held; on exit it is held.
  */
 static int
-tty3270_wait(tub_t *tubp, int *flags)
+tty3270_wait(tub_t *tubp, long *flags)
 {
 	DECLARE_WAITQUEUE(wait, current);
 
@@ -766,10 +774,10 @@
 		return 0;
 	if (tubp->stat == TBS_MORE)
 		return 0;
-#ifdef CONFIG_3270_CONSOLE
-	if (tub3270_con_tubp == tubp)
+#ifdef CONFIG_TN3270_CONSOLE
+	if (CONSOLE_IS_3270 && tub3270_con_tubp == tubp)
 		tub3270_con_copy(tubp);
-#endif /* CONFIG_3270_CONSOLE */
+#endif /* CONFIG_TN3270_CONSOLE */
 	if (tubp->tty_bcb.bc_cnt == 0)
 		return 0;
 	if (tubp->intv != tty3270_int)
@@ -953,48 +961,44 @@
 	if (minor < 0 || minor > tubnummins ||
 	    (tubp = (*tubminors)[minor]) == NULL)
 		return sprintf(buf, "No tube at index=%d\n", minor);
-
+	
 	tty = tubp->tty;
 	len = 0;
 
-	len += sprintf(buf+len,
-"Info for tub_t[%d] at %.8x:\n",
-	minor, (int)tubp);
+	len += sprintf(buf+len, "Info for tub_t[%d] at %p:\n", minor, tubp);
 
-	len += sprintf(buf+len, "inattr is at %.8x\n",
-		(int)&tubp->tty_inattr);
+	len += sprintf(buf+len, "inattr is at %p\n", &tubp->tty_inattr);
 
 
-	len += sprintf(buf+len,
-"    geom:  rows=%.2d cols=%.2d model=%.1d\n",
-	tubp->geom_rows, tubp->geom_cols, tubp->tubiocb.model);
+	len += sprintf(buf+len, "    geom:  rows=%.2d cols=%.2d model=%.1d\n",
+		       tubp->geom_rows, tubp->geom_cols, tubp->tubiocb.model);
 
 	len += sprintf(buf+len,
-"    lnopen=%-2d     fsopen=%-2d   waitq=%.8x\n",
-	tubp->lnopen, tubp->fsopen, (int)&tubp->waitq);
+		       "    lnopen=%-2d     fsopen=%-2d   waitq=%p\n",
+		       tubp->lnopen, tubp->fsopen, &tubp->waitq);
 
-	len += sprintf(buf+len,
-"    dstat=%.2x      mode=%-2d     stat=%-2d     flags=%-4x\n",
-	tubp->dstat, tubp->mode, tubp->stat, tubp->flags);
+	len += sprintf(buf+len, "    dstat=%.2x      mode=%-2d     "
+		       "stat=%-2d     flags=%-4x\n", tubp->dstat,
+		       tubp->mode, tubp->stat, tubp->flags);
 
 #ifdef RBH_FIXTHIS
 	len += sprintf(buf+len,
-"    oucount=%-4d  ourd=%-5d  ouwr=%-5d  nextlogx=%-5d\n",
-	tubp->tty_oucount, tubp->tty_ourd, tubp->tty_ouwr,
-	tubp->tty_nextlogx);
+		       "    oucount=%-4d  ourd=%-5d  ouwr=%-5d"
+		       "  nextlogx=%-5d\n", tubp->tty_oucount,
+		       tubp->tty_ourd, tubp->tty_ouwr, tubp->tty_nextlogx);
 #endif
 
-	len += sprintf(buf+len,
-"    tty=%.8x\n",
-	(int)tubp->tty);
+	len += sprintf(buf+len, "    tty=%p\n",tubp->tty);
 
-	if (tty) len += sprintf(buf+len,
-"    write_wait=%.8x read_wait=%.8x\n",
-	(int)&tty->write_wait, (int)&tty->read_wait);
-
-	if (tty && ((mp = tty->termios))) len += sprintf(buf+len,
-"    iflag=%.8x oflag=%.8x cflag=%.8x lflag=%.8x\n",
-	mp->c_iflag, mp->c_oflag, mp->c_cflag, mp->c_lflag);
+	if (tty)
+		len += sprintf(buf+len,
+				"    write_wait=%p read_wait=%p\n",
+				&tty->write_wait, &tty->read_wait);
+
+	if (tty && ((mp = tty->termios)))
+		len += sprintf(buf+len,"    iflag=%.8x oflag=%.8x "
+			       "cflag=%.8x lflag=%.8x\n", mp->c_iflag,
+			       mp->c_oflag, mp->c_cflag, mp->c_lflag);
 
 
 	return len;
diff -urN linux/drivers/s390/char/tubttybld.c linux-2.4.7/drivers/s390/char/tubttybld.c
--- linux/drivers/s390/char/tubttybld.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubttybld.c	Mon Dec 17 13:41:49 2001
@@ -34,6 +34,8 @@
 	TUB_BUFADR(GEOM_INPUT, cpp);
 	*(*cpp)++ = '\0';
 	tubp->tty_oucol = tubp->tty_nextlogx = 0;
+	*(*cpp)++ = TO_SBA;
+	TUB_BUFADR(tubp->tty_nextlogx, cpp);
 }
 
 static void
@@ -376,12 +378,16 @@
 		printk(KERN_WARNING "tty3270_build unknown command %d\n", tubp->cmd);
 		return 0;
 	case TBC_OPEN:
+tbc_open:
+		tubp->flags &= ~TUB_INPUT_HACK;
 		chancmd = TC_EWRITEA;
 		tty3270_clear_input_area(tubp, &cp);
 		tty3270_set_status_area(tubp, &cp);
 		tty3270_clear_log_area(tubp, &cp);
 		break;
 	case TBC_UPDLOG:
+		if (tubp->flags & TUB_INPUT_HACK)
+			goto tbc_open;
 		chancmd = TC_WRITE;
 		writecc = TW_NONE;
 		tty3270_update_log_area(tubp, &cp);
diff -urN linux/drivers/s390/char/tubttyscl.c linux-2.4.7/drivers/s390/char/tubttyscl.c
--- linux/drivers/s390/char/tubttyscl.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubttyscl.c	Mon Dec 17 13:41:19 2001
@@ -48,7 +48,7 @@
 tty3270_scl_timeout(unsigned long data)
 {
 	tub_t *tubp = (void *)data;
-	int flags;
+	long flags;
 
 	TUBLOCK(tubp->irq, flags);
 	tubp->stat = TBS_RUNNING;
@@ -72,9 +72,9 @@
 int
 tty3270_scl_init(tub_t *tubp)
 {
-	extern int tubscrollparm;
+	extern int tubscrolltime;
 
-	tubp->tty_scrolltime = tubscrollparm;
+	tubp->tty_scrolltime = tubscrolltime;
 	if (tubp->tty_scrolltime < 0)
 		tubp->tty_scrolltime = DEFAULT_SCROLLTIME;
 	return 0;
diff -urN linux/drivers/s390/char/tubttysiz.c linux-2.4.7/drivers/s390/char/tubttysiz.c
--- linux/drivers/s390/char/tubttysiz.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/char/tubttysiz.c	Mon Dec 17 13:41:19 2001
@@ -12,7 +12,7 @@
 #include "tubio.h"
 static int tty3270_size_io(tub_t *tubp);
 static void tty3270_size_int(tub_t *tubp, devstat_t *dsp);
-static int tty3270_size_wait(tub_t *tubp, int *flags, int stat);
+static int tty3270_size_wait(tub_t *tubp, long *flags, int stat);
 
 /*
  * Structure representing Usable Area Query Reply Base
@@ -71,7 +71,7 @@
  * Try to determine screen size using Read Partition (Query)
  */
 int
-tty3270_size(tub_t *tubp, int *flags)
+tty3270_size(tub_t *tubp, long *flags)
 {
 	char wbuf[7] = { 0x00, 0x07, 0x01, 0xff, 0x03, 0x00, 0x81 };
 	int     rc = 0;
@@ -285,7 +285,7 @@
  * Return 0 unless signal pending, in which case -ERESTARTSYS.
  */
 static int
-tty3270_size_wait(tub_t *tubp, int *flags, int stat)
+tty3270_size_wait(tub_t *tubp, long *flags, int stat)
 {
 	DECLARE_WAITQUEUE(wait, current);
 
diff -urN linux/drivers/s390/idals.c linux-2.4.7/drivers/s390/idals.c
--- linux/drivers/s390/idals.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/idals.c	Mon Dec 17 13:42:42 2001
@@ -11,44 +11,33 @@
 
 #include <linux/module.h>
 #include <linux/config.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 
 #include <asm/irq.h>
 #include <asm/idals.h>
 
 #ifdef CONFIG_ARCH_S390X
-#define IDA_SIZE_LOG 12 /* 11 for 2k , 12 for 4k */
-#define IDA_BLOCK_SIZE (1L<<IDA_SIZE_LOG)
-void 
-set_normalized_cda ( ccw1_t * cp, unsigned long address )
+
+unsigned long __create_idal (unsigned long address, int count)
 {
 	int nridaws;
-	idaw_t *idal;
-        int count = cp->count;
+	unsigned long *idal, *tmp;
 
-	if (cp->flags & CCW_FLAG_IDA)
-		BUG();
-	if (((address + count) >> 31) == 0) { 
-		cp -> cda = address;
-		return;
-	}
         nridaws = ((address & (IDA_BLOCK_SIZE-1)) + count + 
 		   (IDA_BLOCK_SIZE-1)) >> IDA_SIZE_LOG;
 	idal = idal_alloc(nridaws);
-	if ( idal == NULL ) {
-		/* probably we should have a fallback here */
-		panic ("Cannot allocate memory for IDAL\n");
+	if (idal != NULL) {
+		tmp = idal;
+		*tmp++ = address;
+		address &= -IDA_BLOCK_SIZE;
+		while (--nridaws > 0) {
+			address += IDA_BLOCK_SIZE;
+			*tmp++ = address;
+		}
 	}
-	cp->flags |= CCW_FLAG_IDA;
-	cp->cda = (__u32)(unsigned long)(idaw_t *)idal;
-        do {
-		*idal++ = address;
-		address = (address & -(IDA_BLOCK_SIZE)) + (IDA_BLOCK_SIZE);
-		nridaws --;
-        } while ( nridaws > 0 );
-	return;
+	return (unsigned long) idal;
 }
 
-EXPORT_SYMBOL (set_normalized_cda);
+EXPORT_SYMBOL (__create_idal);
 
 #endif
diff -urN linux/drivers/s390/misc/chandev.c linux-2.4.7/drivers/s390/misc/chandev.c
--- linux/drivers/s390/misc/chandev.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/misc/chandev.c	Mon Dec 17 13:42:47 2001
@@ -24,6 +24,14 @@
 #include <asm/s390dyn.h>
 #include <asm/queue.h>
 #include <linux/kmod.h>
+#ifndef MIN
+#define MIN(a,b) ((a<b)?a:b)
+#endif
+#ifndef MAX
+#define MAX(a,b) ((a>b)?a:b)
+#endif
+
+
 
 typedef struct chandev_model_info chandev_model_info;
 struct chandev_model_info
@@ -35,7 +43,9 @@
 	s32 dev_type;     /* device type -1 = don't care */
 	s16 dev_model;    /* device model -1 = don't care */
 	u8  max_port_no;
-	int      auto_msck_recovery;
+	int auto_msck_recovery;
+	u8  default_checksum_received_ip_pkts;
+	u8  default_use_hw_stats; /* where available e.g. lcs */
 	devreg_t drinfo;
 };
 
@@ -44,12 +54,7 @@
 {
 	struct chandev *next;
 	chandev_model_info *model_info;
-	u16 cu_type;      /* control unit type */
-	u8  cu_model;     /* control unit model */
-	u16 dev_type;     /* device type */
-	u8  dev_model;    /* device model */
-	u16 devno;
-	unsigned int irq;
+	chandev_subchannel_info sch;
 	int owned;
 };
 
@@ -66,28 +71,32 @@
 {
 	struct chandev_force *next;
 	chandev_type chan_type;
-	s32     devif_num; /* -1 don't care e.g. tr0 implies 0 */
-        u16     read_devno;
-	u16     write_devno;
+	s32     devif_num; /* -1 don't care, -2 we are forcing a range e.g. tr0 implies 0 */
+        u16     read_lo_devno;
+	u16     write_hi_devno;
+	u16     data_devno; /* only used by gigabit ethernet */
+	s32     memory_usage_in_k;
         s16     port_protocol_no; /* where available e.g. lcs,-1 don't care */
 	u8      checksum_received_ip_pkts;
 	u8      use_hw_stats; /* where available e.g. lcs */
+	/* claw specific stuff */
+	chandev_claw_info  claw;
 };
 
 typedef struct chandev_probelist chandev_probelist;
 struct chandev_probelist
 {
-	struct chandev_probelist *next;
-	chandev_probefunc       probefunc;
-	chandev_shutdownfunc    shutdownfunc;
-	chandev_reoperfunc      reoperfunc;
-	chandev_type            chan_type;
-	int                     devices_found;
+	struct chandev_probelist            *next;
+	chandev_probefunc                   probefunc;
+	chandev_shutdownfunc                shutdownfunc;
+	chandev_msck_notification_func      msck_notfunc;
+	chandev_type                        chan_type;
+	int                                 devices_found;
 };
 
 
 
-#define default_msck_bits ((1<<(not_oper-1))|(1<<(no_path-1))|(1<<(revalidate-1))|(1<<(gone-1)))
+#define default_msck_bits ((1<<(chandev_status_not_oper-1))|(1<<(chandev_status_no_path-1))|(1<<(chandev_status_revalidate-1))|(1<<(chandev_status_gone-1)))
 
 
 static char *msck_status_strs[]=
@@ -113,14 +122,13 @@
 typedef struct chandev_irqinfo chandev_irqinfo;
 struct chandev_irqinfo
 {
-	chandev_irqinfo      *next;
-	chandev_msck_status  msck_status;
-	u16                  devno;
-	unsigned int         irq;
-	void                 (*handler)(int, void *, struct pt_regs *);
-	unsigned long        irqflags;
-	void                 *dev_id;
-	char                 devname[0];
+	chandev_irqinfo         *next;
+	chandev_subchannel_info sch;
+	chandev_msck_status     msck_status;
+	void                    (*handler)(int, void *, struct pt_regs *);
+	unsigned long           irqflags;
+	void                    *dev_id;
+	char                    devname[0];
 };
 
 
@@ -131,34 +139,33 @@
 {
 	chandev_parms      *next;
 	chandev_type       chan_type;
+	u16                lo_devno;
+	u16                hi_devno;
 	char               parmstr[0];
 };
 
+static chandev_type chandev_persistent=0; 
+
 chandev_parms *chandev_parms_head=NULL;
 
 
 typedef struct chandev_activelist chandev_activelist;
 struct chandev_activelist
 {
-	struct chandev_activelist *next;
-	chandev_irqinfo         *read_irqinfo;
-	chandev_irqinfo         *write_irqinfo;
-	u16                     cu_type;      /* control unit type */
-	u8                      cu_model;     /* control unit model */
-	u16                     dev_type;     /* device type */
-	u8                      dev_model;    /* device model */
-	chandev_probefunc       probefunc;
-	chandev_shutdownfunc    shutdownfunc;
-	chandev_reoperfunc      reoperfunc;
-	chandev_unregfunc       unreg_dev;
-	chandev_type            chan_type;
-	u8                      port_no;
-	chandev_category        category;
-	int                     saved_busy_flag;
-	
-
-	void                    *dev_ptr;
-	char                    devname[0];
+	struct chandev_activelist        *next;
+	chandev_irqinfo                  *read_irqinfo;
+	chandev_irqinfo                  *write_irqinfo;
+	chandev_irqinfo                  *data_irqinfo;
+	chandev_probefunc                probefunc;
+	chandev_shutdownfunc             shutdownfunc;
+	chandev_msck_notification_func   msck_notfunc;
+	chandev_unregfunc                unreg_dev;
+	chandev_type                     chan_type;
+	u8                               port_no;
+	chandev_category                 category;
+	s32                              memory_usage_in_k;
+	void                             *dev_ptr;
+	char                             devname[0];
 };
 
 
@@ -172,10 +179,11 @@
 static chandev_probelist *chandev_probelist_head=NULL;
 static chandev_activelist *chandev_activelist_head=NULL;
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-static int use_devno_names=FALSE;
+int chandev_use_devno_names=FALSE;
 #endif
-static int chandev_conf_read=FALSE;
-static int chandev_initialised=FALSE;
+static int chandev_cautious_auto_detect=TRUE;
+static atomic_t chandev_conf_read=ATOMIC_INIT(FALSE);
+static atomic_t chandev_initialised=ATOMIC_INIT(FALSE);
 
 
 static unsigned long chandev_last_machine_check;
@@ -186,22 +194,38 @@
 static atomic_t chandev_new_msck;
 static unsigned long chandev_last_startmsck_list_update;
 
-typedef struct chandev_startmsck_list chandev_startmsck_list;
-struct chandev_startmsck_list
+
+typedef enum
+{
+	chandev_start,
+	chandev_first_tag=chandev_start,
+	chandev_msck,
+	chandev_num_notify_tags
+} chandev_userland_notify_tag;
+
+static char *userland_notify_strs[]=
+{
+	"start",
+	"machine_check"
+};
+
+typedef struct chandev_userland_notify_list chandev_userland_notify_list;
+struct chandev_userland_notify_list
 {
-	chandev_startmsck_list    *next;
-	chandev_msck_status       pre_recovery_action_status;
-	chandev_msck_status       post_recovery_action_status;
+	chandev_userland_notify_list    *next;
+	chandev_userland_notify_tag      tag;
+	chandev_msck_status              prev_status;
+	chandev_msck_status              curr_status;
 	char                      devname[0];
 };
 
 
-static chandev_startmsck_list *startlist_head=NULL;
-static chandev_startmsck_list *mscklist_head=NULL;
+static chandev_userland_notify_list *chandev_userland_notify_head=NULL;
 
 
 
 
+static void chandev_read_conf_if_necessary(void);
 static void chandev_read_conf(void);
 
 #if LINUX_VERSION_CODE >=KERNEL_VERSION(2,3,0)
@@ -233,7 +257,56 @@
 static long                 chandev_lock_owner;
 static int                  chandev_lock_cnt; 
 static spinlock_t           chandev_spinlock;
-void                        *chandev_firstlock_addr,*chandev_lastlock_addr; 
+#define CHANDEV_LOCK_DEBUG 0
+#if CHANDEV_LOCK_DEBUG && !defined(CONFIG_ARCH_S390X)
+#define CHANDEV_BACKTRACE_LOOPCNT 10
+void                        *chandev_first_lock_addr[CHANDEV_BACKTRACE_LOOPCNT],
+	                    *chandev_last_lock_addr[CHANDEV_BACKTRACE_LOOPCNT],
+	                    *chandev_last_unlock_addr[CHANDEV_BACKTRACE_LOOPCNT];
+#define CHANDEV_BACKTRACE(variable) \
+memset((variable),0,sizeof(void *)*CHANDEV_BACKTRACE_LOOPCNT); \
+(variable)[0]=__builtin_return_address(0); \
+if(((long)variable[0])&0x80000000)         \
+{                                          \
+(variable)[1]=__builtin_return_address(1); \
+if(((long)variable[1])&0x80000000)         \
+{                                          \
+(variable)[2]=__builtin_return_address(2); \
+if(((long)variable[2])&0x80000000)         \
+{                                          \
+(variable)[3]=__builtin_return_address(3); \
+if(((long)variable[3])&0x80000000)         \
+{                                          \
+(variable)[4]=__builtin_return_address(4); \
+if(((long)variable[4])&0x80000000)         \
+{                                          \
+(variable)[5]=__builtin_return_address(5); \
+if(((long)variable[5])&0x80000000)         \
+{                                          \
+(variable)[6]=__builtin_return_address(6); \
+if(((long)variable[6])&0x80000000)         \
+{                                          \
+(variable)[7]=__builtin_return_address(7); \
+if(((long)variable[7])&0x80000000)         \
+{                                          \
+(variable)[8]=__builtin_return_address(8); \
+if(((long)variable[8])&0x80000000)         \
+{                                          \
+(variable)[9]=__builtin_return_address(9); \
+} \
+} \
+} \
+} \
+} \
+} \
+} \
+} \
+}
+#else
+#define CHANDEV_BACKTRACE(variable)
+#endif
+
+
 
 typedef struct chandev_not_oper_struct chandev_not_oper_struct;
 
@@ -250,7 +323,6 @@
  */
 static qheader chandev_not_oper_head={NULL,NULL};
 static spinlock_t           chandev_not_oper_spinlock;
-static char           exec_script[]="/bin/chandev";
 
 #define chandev_interrupt_check() \
 if(in_interrupt())                \
@@ -260,22 +332,30 @@
 #define for_each(variable,head) \
 for((variable)=(head);(variable)!=NULL;(variable)=(variable)->next)
 
+#define for_each_allow_delete(variable,nextmember,head) \
+for((variable)=(head),(nextmember)=((head) ? (head)->next:NULL); \
+(variable)!=NULL; (variable)=(nextmember),(nextmember)=((nextmember) ? (nextmember->next) : NULL))
+
+#define for_each_allow_delete2(variable,nextmember,head) \
+for((variable)=(head);(variable)!=NULL;(variable)=(nextmember))
+
 
 static void chandev_lock(void)
 {
-	chandev_interrupt_check();
 	eieio();
+	chandev_interrupt_check();
 	if(chandev_lock_owner!=(long)current)
 	{
-		spin_lock(&chandev_spinlock);
+		while(!spin_trylock(&chandev_spinlock))
+			schedule();
 		chandev_lock_cnt=1;
 		chandev_lock_owner=(long)current;
-		chandev_firstlock_addr=__builtin_return_address(0);
+		CHANDEV_BACKTRACE(chandev_first_lock_addr)
 	}
 	else
 	{
 		chandev_lock_cnt++;
-		chandev_lastlock_addr=__builtin_return_address(0);
+		CHANDEV_BACKTRACE(chandev_last_lock_addr)
 	}
 	if(chandev_lock_cnt<0||chandev_lock_cnt>100)
 	{
@@ -301,6 +381,7 @@
 		      (long)current,
 		      chandev_lock_owner,
 		      chandev_lock_cnt);
+	CHANDEV_BACKTRACE(chandev_last_unlock_addr)
 	if(--chandev_lock_cnt==0)
 	{
 		chandev_lock_owner=CHANDEV_INVALID_LOCK_OWNER;
@@ -315,13 +396,6 @@
 }
 
 
-void chandev_relock(int saved_lock_cnt)
-{
-	
-	chandev_lock();
-	chandev_lock_cnt=saved_lock_cnt;
-}
-
 
 void *chandev_alloc(size_t size)
 {
@@ -369,6 +443,7 @@
 
 void chandev_free_listmember(list **listhead,list *member)
 {
+	chandev_lock();
 	if(member)
 	{
 		if(chandev_remove_from_list(listhead,member))
@@ -377,18 +452,21 @@
 			printk(KERN_CRIT"chandev_free_listmember detected nonexistant"
 			       "listmember listhead=%p member %p\n",listhead,member);
 	}
+	chandev_unlock();
 }
 
 void chandev_free_queuemember(qheader *qhead,queue *member)
 {
+	chandev_lock();
 	if(member)
 	{
 		if(chandev_remove_from_queue(qhead,member))
 			kfree(member);
 		else
-			printk(KERN_CRIT"chandev_free_listmember detected nonexistant"
-			       "listmember qhead=%p member %p\n",qhead,member);
+			printk(KERN_CRIT"chandev_free_queuemember detected nonexistant"
+			       "queuemember qhead=%p member %p\n",qhead,member);
 	}
+	chandev_unlock();
 }
 
 
@@ -397,27 +475,45 @@
 {
 	list *head;
 
+	chandev_lock();
 	while((head=remove_listhead(listhead)))
 		kfree(head);
+	chandev_unlock();
 }
 
 void chandev_free_all_queue(qheader *qhead)
 {
+	chandev_lock();
 	while(qhead->head)
 		chandev_free_queuemember(qhead,qhead->head);
+	chandev_unlock();
 }
 
+static void chandev_wait_for_root_fs(void)
+{
+	wait_queue_head_t      wait;
 
+	init_waitqueue_head(&wait);
+	/* We need to wait till there is a root filesystem */
+	while(init_task.fs->root==NULL)
+	{
+		sleep_on_timeout(&wait,HZ);
+	}
+}
 
+/* We are now hotplug compliant i.e. */
+/* we typically get called in /sbin/hotplug chandev our parameters */
 static int chandev_exec_start_script(void *unused)
 {
 	
 	char **argv,*tempname;
 	int retval=-ENOMEM;
-	int loopcnt,argc;
+	int argc,loopcnt;
 	size_t allocsize;
-	chandev_startmsck_list *member;
+	chandev_userland_notify_list *member;
 	wait_queue_head_t      wait;
+	int                    have_tag[chandev_num_notify_tags]={FALSE,};
+	chandev_userland_notify_tag tagidx;
 	static char * envp[] = { "HOME=/", "TERM=linux", "PATH=/sbin:/usr/sbin:/bin:/usr/bin", NULL };
 	
 	init_waitqueue_head(&wait);
@@ -427,17 +523,33 @@
 	{
 		sleep_on_timeout(&wait,HZ);
 	}
+	if(!chandev_userland_notify_head)
+		return(0);
 	chandev_lock();
-	argc=1;
-	if(startlist_head)
-		argc++;
-	for_each(member,startlist_head)
-		argc++;
-	if(mscklist_head)
-		argc+=3;
-	for_each(member,mscklist_head)
-		argc++;
+	argc=2;
+	for(tagidx=chandev_first_tag;tagidx<chandev_num_notify_tags;tagidx++)
+	{
+		for_each(member,chandev_userland_notify_head)
+		{
+			if(member->tag==tagidx)
+			{
+				switch(tagidx)
+				{
+				case chandev_start:
+					argc++;
+					break;
+				case chandev_msck:
+					argc+=3;
+					break;
+				default:
+				}
+				if(have_tag[tagidx]==FALSE)
+					argc++;
+				have_tag[tagidx]=TRUE;
 
+			}
+		}
+	}
 	allocsize=(argc+1)*sizeof(char *);
         /* Warning possible stack overflow */
 	/* We can't kmalloc the parameters here as execve will */
@@ -446,58 +558,48 @@
 	if(argv)
 	{
 		memset(argv,0,allocsize);
-		argc=0;
-		argv[argc++]=exec_script;
-		if(startlist_head)
-			argv[argc++]="start";
-		for_each(member,startlist_head)
-		{
-			tempname=alloca(strlen(member->devname)+1);
-			if(tempname)
-			{
-				strcpy(tempname,member->devname);
-				argv[argc++]=tempname;
-			}
-			else
-				goto Fail;
-		}
-		if(mscklist_head)
-			argv[argc++]="machine_check";
-		for_each(member,mscklist_head)
+		argv[0]=hotplug_path;
+		argv[1]="chandev";
+		argc=2;
+		for(tagidx=chandev_first_tag;tagidx<chandev_num_notify_tags;tagidx++)
 		{
-			tempname=alloca(strlen(member->devname)+1);
-			if(tempname)
+			if(have_tag[tagidx])
 			{
-				strcpy(tempname,member->devname);
-				argv[argc++]=tempname;
+				argv[argc++]=userland_notify_strs[tagidx];
+				for_each(member,chandev_userland_notify_head)
+				{
+					if(member->tag==tagidx)
+					{
+						tempname=alloca(strlen(member->devname)+1);
+						if(tempname)
+						{
+							strcpy(tempname,member->devname);
+							argv[argc++]=tempname;
+						}
+						else
+							goto Fail;
+						if(member->tag==chandev_msck)
+						{
+							argv[argc++]=msck_status_strs[member->prev_status];
+							argv[argc++]=msck_status_strs[member->curr_status];
+						}
+					}
+				}
 			}
-			else
-				goto Fail;
-			argv[loopcnt++]=msck_status_strs[member->pre_recovery_action_status];
-			argv[loopcnt++]=msck_status_strs[member->post_recovery_action_status];
 		}
-		chandev_free_all_list((list **)&startlist_head);
-		chandev_free_all_list((list **)&mscklist_head);
+		chandev_free_all_list((list **)&chandev_userland_notify_head);
 		chandev_unlock();
-
-		/* We need to wait till there is a root filesystem */
-		while(init_task.fs->root==NULL)
-		{
-			sleep_on_timeout(&wait,HZ);
-		}
+		chandev_wait_for_root_fs();
 		/* We are basically execve'ing here there normally is no */
 		/* return */
-		retval=exec_usermodehelper(exec_script, argv, envp);
+		retval=exec_usermodehelper(hotplug_path, argv, envp);
 		goto Fail2;
 	}
  Fail:
 	
 	chandev_unlock();
  Fail2:
-	/* We don't really need to report /bin/chandev not existing */
-	if(retval!=-ENOENT)
-	   printk("chandev_exec_start_script failed retval=%d\n",retval);
-	return(0);
+	return(retval);
 }
 
 
@@ -513,27 +615,25 @@
 }
 
 
-static int chandev_add_to_startmsck_list(chandev_startmsck_list **listhead,char *devname,
-chandev_msck_status pre_recovery_action_status,chandev_msck_status post_recovery_action_status)
+static int chandev_add_to_userland_notify_list(chandev_userland_notify_tag tag,
+char *devname, chandev_msck_status prev_status,chandev_msck_status curr_status)
 {
-	chandev_startmsck_list *member;
+	chandev_userland_notify_list *member,*nextmember;
 	int pid;
 	
 	chandev_lock();
 	/* remove operations still outstanding for this device */
-	for_each(member,startlist_head)
-		if(strcmp(member->devname,devname)==0)
-			chandev_remove_from_list((list **)&startlist_head,(list *)member);
-	for_each(member,mscklist_head)
+	for_each_allow_delete(member,nextmember,chandev_userland_notify_head)
 		if(strcmp(member->devname,devname)==0)
-			chandev_remove_from_list((list **)&mscklist_head,(list *)member);
+			chandev_free_listmember((list **)&chandev_userland_notify_head,(list *)member);
 	
 
-	if((member=chandev_allocstr(devname,offsetof(chandev_startmsck_list,devname))))
+	if((member=chandev_allocstr(devname,offsetof(chandev_userland_notify_list,devname))))
 	{
-		member->pre_recovery_action_status=pre_recovery_action_status;
-		member->post_recovery_action_status=post_recovery_action_status;
-		add_to_list((list **)listhead,(list *)member);
+		member->tag=tag;
+		member->prev_status=prev_status;
+		member->curr_status=curr_status;
+		add_to_list((list **)&chandev_userland_notify_head,(list *)member);
 		chandev_last_startmsck_list_update=jiffies;
 		chandev_unlock();
 		pid = kernel_thread(chandev_exec_start_script,NULL,SIGCHLD);
@@ -596,7 +696,7 @@
 {
 	chandev_irqinfo *curr_irqinfo;
 	for_each(curr_irqinfo,chandev_irqinfo_head)
-		if(irq==curr_irqinfo->irq)
+		if(irq==curr_irqinfo->sch.irq)
 			return(curr_irqinfo);
 	return(NULL);
 }
@@ -606,7 +706,7 @@
 	chandev *curr_chandev;
 
 	for_each(curr_chandev,(chandev *)chandev_head.head)
-		if(curr_chandev->irq==irq)
+		if(curr_chandev->sch.irq==irq)
 		{
 			return(curr_chandev);
 		}
@@ -619,8 +719,9 @@
 
 	for_each(curr_device,chandev_activelist_head)
 	{
-			if(curr_device->read_irqinfo->irq==irq||
-			   curr_device->write_irqinfo->irq==irq)
+			if(curr_device->read_irqinfo->sch.irq==irq||
+			   curr_device->write_irqinfo->sch.irq==irq||
+			   (curr_device->data_irqinfo&&curr_device->data_irqinfo->sch.irq==irq))
 				return(curr_device);
 	}
 	return(NULL);
@@ -630,16 +731,50 @@
 void chandev_remove_irqinfo_by_irq(unsigned int irq)
 {
 	chandev_irqinfo *remove_irqinfo;
+	chandev_activelist *curr_device;
 
 	chandev_lock();
 	/* remove any orphan irqinfo left lying around. */
         if((remove_irqinfo=chandev_get_irqinfo_by_irq(irq)))
-		chandev_remove_from_list((list **)&chandev_irqinfo_head,
+	{
+		for_each(curr_device,chandev_activelist_head)
+		{
+			if(curr_device->read_irqinfo==remove_irqinfo)
+			{
+				curr_device->read_irqinfo=NULL;
+				break;
+			}
+			if(curr_device->write_irqinfo==remove_irqinfo)
+			{
+				curr_device->write_irqinfo=NULL;
+				break;
+			}
+			if(curr_device->data_irqinfo&&curr_device->data_irqinfo==remove_irqinfo)
+			{
+				curr_device->data_irqinfo=NULL;
+				break;
+			}
+		}
+		chandev_free_listmember((list **)&chandev_irqinfo_head,
 					 (list *)remove_irqinfo);
+	}
 	chandev_unlock();
 	
 }
 
+int chandev_add_schib_info(int irq,chandev_subchannel_info *sch)
+{
+	schib_t *new_schib;
+	
+	if((new_schib=s390_get_schib(irq)))
+	{
+		sch->pim=new_schib->pmcw.pim;
+		memcpy(&sch->chpid,&new_schib->pmcw.chpid,sizeof(sch->chpid));
+		return(0);
+	}
+	return(-ENODEV);
+}
+
 int chandev_request_irq(unsigned int   irq,
                       void           (*handler)(int, void *, struct pt_regs *),
                       unsigned long  irqflags,
@@ -674,10 +809,16 @@
 			kfree(new_irqinfo);
 		else
 		{
-			new_irqinfo->irq=irq;
+			new_irqinfo->msck_status=chandev_status_good;
+			new_irqinfo->sch.devno=devinfo.devno;
+			new_irqinfo->sch.irq=irq;
+			new_irqinfo->sch.cu_type=devinfo.sid_data.cu_type; /* control unit type */
+			new_irqinfo->sch.cu_model=devinfo.sid_data.cu_model; /* control unit model */
+			new_irqinfo->sch.dev_type=devinfo.sid_data.dev_type; /* device type */
+			new_irqinfo->sch.dev_model=devinfo.sid_data.dev_model; /* device model */
+			chandev_add_schib_info(irq,&new_irqinfo->sch);
 			new_irqinfo->handler=handler;
 			new_irqinfo->dev_id=dev_id;
-			new_irqinfo->devno=devinfo.devno;
 			chandev_add_to_list((list **)&chandev_irqinfo_head,new_irqinfo);
 		}
 	}
@@ -689,14 +830,33 @@
 	return(retval);
 }
 
+/* This should be safe to call even multiple times. */
 void chandev_free_irq(unsigned int irq, void *dev_id)
 {
+	s390_dev_info_t devinfo;
+	int err;
+	
 	/* remove any orphan irqinfo left lying around. */
 	chandev_remove_irqinfo_by_irq(irq);
-	free_irq(irq,dev_id);
+	if((err=get_dev_info_by_irq(irq,&devinfo)))
+	{
+		printk("chandev_free_irq get_dev_info_by_irq reported err=%X on irq %d\n"
+		       "should not happen\n",err,irq);
+		return;
+	 }
+	if(devinfo.status&DEVSTAT_DEVICE_OWNED)
+	   free_irq(irq,dev_id);
+}
+
+/* This should be safe even if chandev_free_irq is already called by the device */
+void chandev_free_irq_by_irqinfo(chandev_irqinfo *irqinfo)
+{
+	if(irqinfo)
+		chandev_free_irq(irqinfo->sch.irq,irqinfo->dev_id);
 }
 
 
+
 void chandev_sprint_type_model(char *buff,s32 type,s16 model)
 {
 	if(type==-1)
@@ -716,37 +876,66 @@
 	chandev_sprint_type_model(&buff[strlen(buff)],dev_type,dev_model);
 }
 
-void chandev_remove_parms(chandev_type chan_type,int exact_match)
+void chandev_remove_parms(chandev_type chan_type,int exact_match,int lo_devno)
 {
-	chandev_parms      *curr_parms;
+	chandev_parms      *curr_parms,*next_parms;
 
 	chandev_lock();
-	for_each(curr_parms,chandev_parms_head)
+	for_each_allow_delete(curr_parms,next_parms,chandev_parms_head)
 	{
-		if((chan_type&(curr_parms->chan_type)&&!exact_match)||
-		    (chan_type==(curr_parms->chan_type)&&exact_match))
-		    chandev_free_listmember((list **)&chandev_parms_head,(list *)curr_parms);
+		if(((chan_type&(curr_parms->chan_type)&&!exact_match)||
+		   (chan_type==(curr_parms->chan_type)&&exact_match))&&
+		   (lo_devno==-1||lo_devno==curr_parms->lo_devno))
+			chandev_free_listmember((list **)&chandev_parms_head,(list *)curr_parms);
 	}
 	chandev_unlock();
 }
 
-void chandev_add_parms(chandev_type chan_type,char *parmstr)
+
+void chandev_add_parms(chandev_type chan_type,u16 lo_devno,u16 hi_devno,char *parmstr)
 {
-	chandev_parms      *new_parms;
-	
-	if((new_parms=chandev_allocstr(parmstr,offsetof(chandev_parms,parmstr))))
+	chandev_parms      *parms;
+
+	if(lo_devno>hi_devno)
+	{
+		printk("chandev_add_parms detected bad device range lo_devno=0x%04x  hi_devno=0x%04x\n,",
+		       (int)lo_devno,(int)hi_devno);
+		return;
+	}
+	chandev_lock();
+	for_each(parms,chandev_parms_head)
+	{
+		if(chan_type&(parms->chan_type))
+		{
+			u16 lomax=MAX(parms->lo_devno,lo_devno),
+				himin=MIN(parms->hi_devno,lo_devno);
+			if(lomax<=himin)
+			{
+				chandev_unlock();
+				printk("chandev_add_parms detected overlapping "
+				       "parameter definitions for chan_type=0x%02x"
+				       " lo_devno=0x%04x  hi_devno=0x%04x\n,"
+				       " do a del_parms.",chan_type,(int)lo_devno,(int)hi_devno);
+				return;
+			}
+		}
+	}
+	chandev_unlock();
+	if((parms=chandev_allocstr(parmstr,offsetof(chandev_parms,parmstr))))
 	{
-		chandev_remove_parms(chan_type,TRUE);
-		new_parms->chan_type=chan_type;
-		chandev_add_to_list((list **)&chandev_parms_head,(void *)new_parms);
+		parms->chan_type=chan_type;
+		parms->lo_devno=lo_devno;
+		parms->hi_devno=hi_devno;
+		chandev_add_to_list((list **)&chandev_parms_head,(void *)parms);
 	}
 	else
-		printk("chandev_add_parmstr memory request failed\n");
+		printk("chandev_add_parms memory request failed\n");
 }
 
 
 void chandev_add_model(chandev_type chan_type,s32 cu_type,s16 cu_model,
-		       s32 dev_type,s16 dev_model,u8 max_port_no,int auto_msck_recovery)
+		       s32 dev_type,s16 dev_model,u8 max_port_no,int auto_msck_recovery,
+		       u8 default_checksum_received_ip_pkts,u8 default_use_hw_stats)
 {
 	chandev_model_info *newmodel;
 	int                err;
@@ -762,7 +951,8 @@
 		newmodel->dev_model=dev_model;
 		newmodel->max_port_no=max_port_no;
 		newmodel->auto_msck_recovery=auto_msck_recovery;
-		
+		newmodel->default_checksum_received_ip_pkts=default_checksum_received_ip_pkts;
+		newmodel->default_use_hw_stats=default_use_hw_stats; /* where available e.g. lcs */
 		if(cu_type==-1&&dev_type==-1)
 		{
 			chandev_sprint_devinfo(buff,newmodel->cu_type,newmodel->cu_model,
@@ -771,17 +961,15 @@
 			kfree(newmodel);
 			return;
 		}
-		/* We ignore errors as they are likely to
-		   occur owing to incompatibilities with
-		   Ingos layer 
-		*/
 		drinfo->flag=DEVREG_TYPE_DEVCHARS;
-		if(dev_model==-1)
-			drinfo->flag|=(dev_type==-1 ? DEVREG_NO_DEV_INFO:DEVREG_MATCH_DEV_TYPE);
-		if(cu_model==-1)
-			drinfo->flag|=(cu_type==-1 ? DEVREG_NO_CU_INFO:DEVREG_MATCH_CU_TYPE);
-		else if(dev_model!=-1&&cu_type!=-1)
-			drinfo->flag|=DEVREG_EXACT_MATCH;
+		if(cu_type!=-1)
+			drinfo->flag|=DEVREG_MATCH_CU_TYPE;
+		if(cu_model!=-1)
+			drinfo->flag|=DEVREG_MATCH_CU_MODEL;
+		if(dev_type!=-1)
+			drinfo->flag|=DEVREG_MATCH_DEV_TYPE;
+		if(dev_model!=-1)
+			drinfo->flag|=DEVREG_MATCH_DEV_MODEL;
 		drinfo->ci.hc.ctype=cu_type;
 		drinfo->ci.hc.cmode=cu_model;
 		drinfo->ci.hc.dtype=dev_type;
@@ -813,10 +1001,10 @@
 
 void chandev_remove_model(chandev_model_info *model)
 {
-	chandev *curr_chandev;
+	chandev *curr_chandev,*next_chandev;
 
 	chandev_lock();
-	for_each(curr_chandev,(chandev *)chandev_head.head)
+	for_each_allow_delete(curr_chandev,next_chandev,(chandev *)chandev_head.head)
 		if(curr_chandev->model_info==model)
 			chandev_remove(curr_chandev);
 	if(model->drinfo.oper_func)
@@ -835,10 +1023,10 @@
 
 void chandev_del_model(s32 cu_type,s16 cu_model,s32 dev_type,s16 dev_model)
 {
-	chandev_model_info *curr_model;
+	chandev_model_info *curr_model,*next_model;
 	
 	chandev_lock();
-	for_each(curr_model,chandev_models_head)
+	for_each_allow_delete(curr_model,next_model,chandev_models_head)
 		if((curr_model->cu_type==cu_type||cu_type==-1)&&
 		   (curr_model->cu_model==cu_model||cu_model==-1)&&
 		   (curr_model->dev_type==dev_type||dev_type==-1)&&
@@ -849,31 +1037,34 @@
 
 static void chandev_init_default_models(void)
 {
-	/* P390/Planter 3172 emulation assume maximum 16 to be safe. */
-	chandev_add_model(lcs,0x3088,0x1,-1,-1,15,default_msck_bits);	
+	/* Usually P390/Planter 3172 emulation assume maximum 16 to be safe. */
+	chandev_add_model(chandev_type_lcs,0x3088,0x1,-1,-1,15,default_msck_bits,FALSE,FALSE);	
 
 	/* 3172/2216 Paralell the 2216 allows 16 ports per card the */
 	/* the original 3172 only allows 4 we will assume the max of 16 */
-	chandev_add_model(lcs|ctc,0x3088,0x8,-1,-1,15,default_msck_bits);
+	chandev_add_model(chandev_type_lcs|chandev_type_ctc,0x3088,0x8,-1,-1,15,default_msck_bits,FALSE,FALSE);
 
 	/* 3172/2216 Escon serial the 2216 allows 16 ports per card the */
 	/* the original 3172 only allows 4 we will assume the max of 16 */
-	chandev_add_model(lcs|escon,0x3088,0x1F,-1,-1,15,default_msck_bits);
+	chandev_add_model(chandev_type_lcs|chandev_type_escon,0x3088,0x1F,-1,-1,15,default_msck_bits,FALSE,FALSE);
 
 	/* Only 2 ports allowed on OSA2 cards model 0x60 */
-	chandev_add_model(lcs,0x3088,0x60,-1,-1,1,default_msck_bits);
-	/* qeth has relative adapter concept so we give it 16 */
-	chandev_add_model(qeth,0x1731,0x1,0x1732,0x1,15,default_msck_bits);
+	chandev_add_model(chandev_type_lcs,0x3088,0x60,-1,-1,1,default_msck_bits,FALSE,FALSE);
+	/* qeth gigabit ethernet */
+	chandev_add_model(chandev_type_qeth,0x1731,0x1,0x1732,0x1,0,default_msck_bits,FALSE,FALSE);
+	chandev_add_model(chandev_type_qeth,0x1731,0x5,0x1732,0x5,0,default_msck_bits,FALSE,FALSE);
 	/* Osa-D we currently aren't too emotionally involved with this */
-	chandev_add_model(osad,0x3088,0x62,-1,-1,0,default_msck_bits);
+	chandev_add_model(chandev_type_osad,0x3088,0x62,-1,-1,0,default_msck_bits,FALSE,FALSE);
+	/* claw */
+	chandev_add_model(chandev_type_claw,0x3088,0x61,-1,-1,0,default_msck_bits,FALSE,FALSE);
 }
 
 
 void chandev_del_noauto(u16 devno)
 {
-	chandev_noauto_range *curr_noauto;
+	chandev_noauto_range *curr_noauto,*next_noauto;
 	chandev_lock();
-	for_each(curr_noauto,chandev_noauto_head)
+	for_each_allow_delete(curr_noauto,next_noauto,chandev_noauto_head)
 		if(curr_noauto->lo_devno<=devno&&curr_noauto->hi_devno>=devno)
 			chandev_free_listmember((list **)&chandev_noauto_head,(list *)curr_noauto); 
 	chandev_unlock();
@@ -881,9 +1072,9 @@
 
 void chandev_del_msck(u16 devno)
 {
-	chandev_msck_range *curr_msck_range;
+	chandev_msck_range *curr_msck_range,*next_msck_range;
 	chandev_lock();
-	for_each(curr_msck_range,chandev_msck_range_head)
+	for_each_allow_delete(curr_msck_range,next_msck_range,chandev_msck_range_head)
 		if(curr_msck_range->lo_devno<=devno&&curr_msck_range->hi_devno>=devno)
 			chandev_free_listmember((list **)&chandev_msck_range_head,(list *)curr_msck_range); 
 	chandev_unlock();
@@ -897,12 +1088,13 @@
 	if((new_chandev=chandev_alloc(sizeof(chandev))))
 	{
 		new_chandev->model_info=newmodelinfo;
-		new_chandev->cu_type=newdevinfo->sid_data.cu_type; /* control unit type */
-		new_chandev->cu_model=newdevinfo->sid_data.cu_model; /* control unit model */
-		new_chandev->dev_type=newdevinfo->sid_data.dev_type; /* device type */
-		new_chandev->dev_model=newdevinfo->sid_data.dev_model; /* device model */
-		new_chandev->devno=newdevinfo->devno;
-		new_chandev->irq=newdevinfo->irq;
+		new_chandev->sch.devno=newdevinfo->devno;
+		new_chandev->sch.irq=newdevinfo->irq;
+		new_chandev->sch.cu_type=newdevinfo->sid_data.cu_type; /* control unit type */
+		new_chandev->sch.cu_model=newdevinfo->sid_data.cu_model; /* control unit model */
+		new_chandev->sch.dev_type=newdevinfo->sid_data.dev_type; /* device type */
+		new_chandev->sch.dev_model=newdevinfo->sid_data.dev_model; /* device model */
+		chandev_add_schib_info(newdevinfo->irq,&new_chandev->sch);
 		new_chandev->owned=(newdevinfo->status&DEVSTAT_DEVICE_OWNED ? TRUE:FALSE);
 		chandev_queuemember(&chandev_head,new_chandev);
 	}
@@ -910,16 +1102,29 @@
 
 void chandev_unregister_probe(chandev_probefunc probefunc)
 {
-	chandev_probelist *curr_probe;
+	chandev_probelist *curr_probe,*next_probe;
 
 	chandev_lock();
-	for_each(curr_probe,chandev_probelist_head)
+	for_each_allow_delete(curr_probe,next_probe,chandev_probelist_head)
 		if(curr_probe->probefunc==probefunc)
 			chandev_free_listmember((list **)&chandev_probelist_head,
 						(list *)curr_probe);
 	chandev_unlock();
 }
 
+void chandev_unregister_probe_by_chan_type(chandev_type chan_type)
+{
+	chandev_probelist *curr_probe,*next_probe;
+
+	chandev_lock();
+	for_each_allow_delete(curr_probe,next_probe,chandev_probelist_head)
+		if(curr_probe->chan_type==chan_type)
+			chandev_free_listmember((list **)&chandev_probelist_head,
+						(list *)curr_probe);
+	chandev_unlock();
+}
+
+
 
 void chandev_reset(void)
 {
@@ -928,36 +1133,63 @@
 	chandev_free_all_list((list **)&chandev_noauto_head);
 	chandev_free_all_list((list **)&chandev_msck_range_head);
 	chandev_free_all_list((list **)&chandev_force_head);
-	chandev_remove_parms(-1,FALSE);
+	chandev_remove_parms(-1,FALSE,-1);
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-	use_devno_names=FALSE;
+	chandev_use_devno_names=FALSE;
 #endif
-	chandev_conf_read=FALSE;
+	chandev_persistent=0;
 	chandev_unlock();
 }
 
 
-chandev_model_info *chandev_is_chandev(int irq,s390_dev_info_t *devinfo)
+int chandev_is_chandev(int irq,s390_dev_info_t *devinfo,chandev_force **forceinfo,chandev_model_info **ret_model)
 {
+	chandev_force *curr_force;
 	chandev_model_info *curr_model=NULL;
 	int err;
+	int retval=FALSE;
+
+	if(forceinfo)
+		*forceinfo=NULL;
+	if(ret_model)
+		*ret_model=NULL;
 	if((err=get_dev_info_by_irq(irq,devinfo)))
 	{
 		printk("chandev_is_chandev get_dev_info_by_irq reported err=%X on irq %d\n"
 		       "should not happen\n",err,irq);
-			return(NULL);
+			return FALSE;
 	}
 	chandev_lock();
+	
 	for_each(curr_model,chandev_models_head)
 	{
 		if(((curr_model->cu_type==devinfo->sid_data.cu_type)||(curr_model->cu_type==-1))&&
 		   ((curr_model->cu_model==devinfo->sid_data.cu_model)||(curr_model->cu_model==-1))&&
 		   ((curr_model->dev_type==devinfo->sid_data.dev_type)||(curr_model->dev_type==-1))&&
 		   ((curr_model->dev_model==devinfo->sid_data.dev_model)||(curr_model->dev_model==-1)))
+		{
+			retval=TRUE;
+			if(ret_model)
+				*ret_model=curr_model;
+			break;
+		}
+	}
+	for_each(curr_force,chandev_force_head)
+	{
+		if(((curr_force->read_lo_devno==devinfo->devno)&&
+		   (curr_force->write_hi_devno==devinfo->devno)&&
+		    (curr_force->devif_num!=-2))||
+		   ((curr_force->read_lo_devno>=devinfo->devno)&&
+		    (curr_force->write_hi_devno<=devinfo->devno)&&
+		    (curr_force->devif_num==-2)))
+		{
+			if(forceinfo)
+				*forceinfo=curr_force;
 			break;
+		}
 	}
 	chandev_unlock();
-	return(curr_model);
+	return(retval);
 }
 
 void chandev_collect_devices(void)
@@ -982,39 +1214,70 @@
 			break;
 		}
 		chandev_lock();
-		if((curr_model=chandev_is_chandev(curr_irq,&curr_devinfo)))
+		if(chandev_is_chandev(curr_irq,&curr_devinfo,NULL,&curr_model))
 			chandev_add(&curr_devinfo,curr_model);
 		chandev_unlock();
 	}
 }
 
-void chandev_add_force(chandev_type chan_type,s32 devif_num,u16 read_devno,
-u16 write_devno,s16 port_protocol_no,u8 checksum_received_ip_pkts,u8 use_hw_stats)
-
+int chandev_add_force(chandev_type chan_type,s32 devif_num,u16 read_lo_devno,
+u16 write_hi_devno,u16 data_devno,s32 memory_usage_in_k,s16 port_protocol_no,u8 checksum_received_ip_pkts,
+u8 use_hw_stats,char *host_name,char *adapter_name,char *api_type)
 {
 	chandev_force *new_chandev_force;
-
+	
+	if(devif_num==-2&&read_lo_devno>write_hi_devno)
+	{
+		printk("chandev_add_force detected bad device range lo_devno=0x%04x  hi_devno=0x%04x\n,",
+		       (int)read_lo_devno,(int)write_hi_devno);
+		return(-1);
+	}
+	if(memory_usage_in_k<0)
+	{
+		printk("chandev_add_force memory_usage_in_k is bad\n");
+		return(-1);
+	}
+	if(chan_type==chandev_type_claw)
+	{
+		int host_name_len=strlen(host_name),
+			adapter_name_len=strlen(adapter_name),
+			api_type_len=strlen(api_type);
+		if(host_name_len>=CLAW_NAMELEN||host_name_len==0||
+		   adapter_name_len>=CLAW_NAMELEN||adapter_name_len==0||
+		   api_type_len>=CLAW_NAMELEN||api_type_len==0)
+			return(-1);
+	}
 	if((new_chandev_force=chandev_alloc(sizeof(chandev_force))))
 	{
 		new_chandev_force->chan_type=chan_type;
 		new_chandev_force->devif_num=devif_num;
-		new_chandev_force->read_devno=read_devno;
-		new_chandev_force->write_devno=write_devno;
+		new_chandev_force->read_lo_devno=read_lo_devno;
+		new_chandev_force->write_hi_devno=write_hi_devno;
+		new_chandev_force->data_devno=data_devno;
+		new_chandev_force->memory_usage_in_k=memory_usage_in_k;
 		new_chandev_force->port_protocol_no=port_protocol_no;
 		new_chandev_force->checksum_received_ip_pkts=checksum_received_ip_pkts;
 		new_chandev_force->use_hw_stats=use_hw_stats;
+		
+		if(chan_type==chandev_type_claw)
+		{
+			strcpy(new_chandev_force->claw.host_name,host_name);
+			strcpy(new_chandev_force->claw.adapter_name,adapter_name);
+			strcpy(new_chandev_force->claw.api_type,api_type);
+		}
 		chandev_add_to_list((list **)&chandev_force_head,new_chandev_force);
 	}
+	return(0);
 }
 
-void chandev_del_force(u16 read_devno)
+void chandev_del_force(int read_lo_devno)
 {
-	chandev_force *curr_force;
+	chandev_force *curr_force,*next_force;
 	
 	chandev_lock();
-	for_each(curr_force,chandev_force_head)
+	for_each_allow_delete(curr_force,next_force,chandev_force_head)
 	{
-		if(curr_force->read_devno==read_devno)
+		if(curr_force->read_lo_devno==read_lo_devno||read_lo_devno==-1)
 			chandev_free_listmember((list **)&chandev_force_head,
 						(list *)curr_force);
 	}
@@ -1024,26 +1287,35 @@
 
 void chandev_shutdown(chandev_activelist *curr_device)
 {
-	int saved_lock_cnt;
+	int err=0;
 	chandev_lock();
 
-	if(curr_device->category==network_device)
+
+	/* unregister_netdev calls the dev->close so we shouldn't do this */
+	/* this otherwise we crash */
+	if(curr_device->unreg_dev)
 	{
-		/* unregister_netdev calls the dev->close so we shouldn't do this */
-		/* this otherwise we crash */
-		if(curr_device->unreg_dev)
-		{
-			saved_lock_cnt=chandev_full_unlock();
-			curr_device->unreg_dev(curr_device->dev_ptr);
-			chandev_relock(saved_lock_cnt);
-		}
+		curr_device->unreg_dev(curr_device->dev_ptr);
+		curr_device->unreg_dev=NULL;
+	}
+	if(curr_device->shutdownfunc)
+	{
+		err=curr_device->shutdownfunc(curr_device->dev_ptr);
 	}
-	saved_lock_cnt=chandev_full_unlock();
-	curr_device->shutdownfunc(curr_device->dev_ptr);
-	chandev_relock(saved_lock_cnt);
-	kfree(curr_device->dev_ptr);
-	chandev_free_listmember((list **)&chandev_activelist_head,
+	if(err)
+		printk("chandev_shutdown unable to fully shutdown & unload %s err=%d\n"
+		       "probably some upper layer still requires the device to exist\n",
+		       curr_device->devname,err);
+	else
+	{
+		
+		chandev_free_irq_by_irqinfo(curr_device->read_irqinfo);
+		chandev_free_irq_by_irqinfo(curr_device->write_irqinfo);
+		if(curr_device->data_irqinfo)
+			chandev_free_irq_by_irqinfo(curr_device->data_irqinfo);
+		chandev_free_listmember((list **)&chandev_activelist_head,
 				(list *)curr_device);
+	}
 	chandev_unlock();
 }
 
@@ -1071,8 +1343,9 @@
 	chandev_activelist *curr_device;
 
 	for_each(curr_device,chandev_activelist_head)
-		if(curr_device->read_irqinfo->devno==devno||
-		   curr_device->write_irqinfo->devno==devno)
+		if(curr_device->read_irqinfo->sch.devno==devno||
+		   curr_device->write_irqinfo->sch.devno==devno||
+		   (curr_device->data_irqinfo&&curr_device->data_irqinfo->sch.devno==devno))
 		{
 			return(curr_device);
 		}
@@ -1105,7 +1378,7 @@
 			str++;
 			continue;
 		}
-		if(isspace(*str)||((*str)=='-'))
+		if(isspace(*str))
 		{
 			*str=',';
 			goto pack_dn;
@@ -1159,7 +1432,7 @@
 
 int chandev_initdevice(chandev_probeinfo *probeinfo,void *dev_ptr,u8 port_no,char *devname,chandev_category category,chandev_unregfunc unreg_dev)
 {
-	chandev_activelist *newdevice;
+	chandev_activelist *newdevice,*curr_device;
 
 	chandev_interrupt_check();
 	if(probeinfo->newdevice!=NULL)
@@ -1167,70 +1440,117 @@
 		printk("probeinfo->newdevice!=NULL in chandev_initdevice for %s",devname);
 		return(-EPERM);
 	}
-	
 
+
+	chandev_lock();
+	for_each(curr_device,chandev_activelist_head)
+	{
+		if(strcmp(curr_device->devname,devname)==0)
+		{
+			printk("chandev_initdevice detected duplicate devicename %s\n",devname);
+			chandev_unlock();
+			return(-EPERM);
+		}
+	}
 	if((newdevice=chandev_allocstr(devname,offsetof(chandev_activelist,devname))))
 	{
-		probeinfo->newdevice=newdevice;
-		chandev_lock();
-		newdevice->read_irqinfo=chandev_get_irqinfo_by_irq(probeinfo->read_irq);
-		newdevice->write_irqinfo=chandev_get_irqinfo_by_irq(probeinfo->write_irq);
+		newdevice->read_irqinfo=chandev_get_irqinfo_by_irq(probeinfo->read.irq);
+		newdevice->write_irqinfo=chandev_get_irqinfo_by_irq(probeinfo->write.irq);
+		if(probeinfo->data_exists)
+			newdevice->data_irqinfo=chandev_get_irqinfo_by_irq(probeinfo->data.irq);
 		chandev_unlock();
-		if(newdevice->read_irqinfo==NULL||newdevice->write_irqinfo==NULL)
+		if(newdevice->read_irqinfo==NULL||newdevice->write_irqinfo==NULL||
+		   (probeinfo->data_exists&&newdevice->data_irqinfo==NULL))
 		{
 			printk("chandev_initdevice, it appears that chandev_request_irq was not "
-			       "called for devname=%s read_irq=%d write_irq=%d\n",devname,probeinfo->read_irq,probeinfo->write_irq);
+			       "called for devname=%s read_irq=%d write_irq=%d data_irq=%d\n",
+			       devname,probeinfo->read.irq,probeinfo->write.irq,probeinfo->data.irq);
 			kfree(newdevice);
 			return(-EPERM);
 		}
-		newdevice->cu_type=probeinfo->cu_type;
-		newdevice->cu_model=probeinfo->cu_model;
-		newdevice->dev_type=probeinfo->dev_type;
-		newdevice->dev_model=probeinfo->dev_model;
 		newdevice->chan_type=probeinfo->chan_type;		
 		newdevice->dev_ptr=dev_ptr;
 		newdevice->port_no=port_no;
+		newdevice->memory_usage_in_k=probeinfo->memory_usage_in_k;
 		newdevice->category=category;
 		newdevice->unreg_dev=unreg_dev;
+		probeinfo->newdevice=newdevice;
 		return(0);
 	}
+	chandev_unlock();
 	return(-ENOMEM);
 }
 
+
+char *chandev_build_device_name(chandev_probeinfo *probeinfo,char *destnamebuff,char *basename,int buildfullname)
+{
+	if (chandev_use_devno_names&&(!probeinfo->device_forced||probeinfo->devif_num==-1)) 
+		sprintf(destnamebuff,"%s%04x",basename,(int)probeinfo->read.devno);
+	else
+	{
+		if(probeinfo->devif_num==-1)
+		{
+			if(buildfullname)
+			{
+				int idx,len=strlen(basename);
+				
+				chandev_activelist *curr_device;
+				for(idx=0;idx<0xffff;idx++)
+				{
+					for_each(curr_device,chandev_activelist_head)
+					{
+						if(strncmp(curr_device->devname,basename,len)==0)
+						{
+							char numbuff[10];
+							sprintf(numbuff,"%d",idx);
+							if(strcmp(&curr_device->devname[len],numbuff)==0)
+								goto next_idx;
+						}
+					}
+					sprintf(destnamebuff,"%s%d",basename,idx);
+					return(destnamebuff);
+				next_idx:
+				}
+				printk("chandev_build_device_name was usable to build a unique name for %s\n",basename);
+				return(NULL);
+			}
+			else
+				sprintf(destnamebuff,"%s%%d",basename);
+		}
+		else
+		{
+			sprintf(destnamebuff,"%s%d",basename,(int)probeinfo->devif_num);
+		}
+	}
+	return(destnamebuff);
+}
+
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-struct net_device *chandev_initnetdevice(chandev_probeinfo *probeinfo,u8 port_no,
-struct net_device *dev, int sizeof_priv, char *basename, 
-struct net_device *(*init_netdevfunc)(struct net_device *dev, int sizeof_priv),
-void (*unreg_netdevfunc)(struct net_device *dev))
+struct net_device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct net_device *dev, int sizeof_priv,
+struct net_device *(*init_netdevfunc)(struct net_device *dev, int sizeof_priv))
 #else
-struct device *chandev_initnetdevice(chandev_probeinfo *probeinfo,u8 port_no,
-struct device *dev, int sizeof_priv, char *basename,
-struct device *(*init_netdevfunc)(struct device *dev, int sizeof_priv),
-void (*unreg_netdevfunc)(struct device *dev))
+struct device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct device *dev, int sizeof_priv,
+struct device *(*init_netdevfunc)(struct device *dev, int sizeof_priv))
 #endif
 {
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
 	struct net_device *retdevice=NULL;
-	int new_device = 0;
+	int new_device = FALSE;
 #else
 	struct device *retdevice=NULL;
 #endif
+	
 
+	chandev_interrupt_check();
 	if (!init_netdevfunc) 
 	{
-		printk("init_netdevfunc=NULL in chandev_initnetdevice, it should not be valid.\n");
-		return NULL;
-	}
-	if (!unreg_netdevfunc) 
-	{
-		printk("unreg_netdevfunc=NULL in chandev_initnetdevice, it should not be valid.\n");
+		printk("init_netdevfunc=NULL in chandev_init_netdev, it should not be valid.\n");
 		return NULL;
 	}
-
-	chandev_interrupt_check();
-
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-        /* Allocate a device if one is not provided. */
+	/* Allocate a device if one is not provided. */
         if (dev == NULL) 
 	{
 		/* ensure 32-byte alignment of the private area */
@@ -1247,90 +1567,162 @@
 
 		if (sizeof_priv)
 			dev->priv = (void *) (((long)(dev + 1) + 31) & ~31);
-
-		if (probeinfo->devif_num != -1) 
-			sprintf(dev->name,"%s%d",basename,(int)probeinfo->devif_num);
-		else if (use_devno_names) 
-			sprintf(dev->name,"%s0x%04x",basename,(int)probeinfo->read_devno);
-
-		new_device = 1;
+		new_device=TRUE;
 	}
+	chandev_build_device_name(probeinfo,dev->name,basename,FALSE);
 #endif
-
 	retdevice=init_netdevfunc(dev,sizeof_priv);
-
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
 	/* Register device if necessary */
+	/* we need to do this as init_netdev doesn't call register_netdevice */
+	/* for already allocated devices */
 	if (retdevice && new_device)
 		register_netdev(retdevice);
 #endif
-
-	if (retdevice) 
-	{
-		if (chandev_initdevice(probeinfo,retdevice,port_no,retdevice->name,
-				      network_device,(chandev_unregfunc)unreg_netdevfunc)) 
-		{
-			unreg_netdevfunc(retdevice);
-			retdevice = NULL;
-		}
-	}
-
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
 	/* We allocated it, so we should free it on error */
 	if (!retdevice && new_device) 
 		kfree(dev);
 #endif
-
 	return retdevice;
 }
 
 
 
 
-int chandev_doprobe(chandev_force *force,chandev *read_chandev,
-chandev *write_chandev)
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
+struct net_device *chandev_initnetdevice(chandev_probeinfo *probeinfo,u8 port_no,
+struct net_device *dev, int sizeof_priv, char *basename, 
+struct net_device *(*init_netdevfunc)(struct net_device *dev, int sizeof_priv),
+void (*unreg_netdevfunc)(struct net_device *dev))
+#else
+struct device *chandev_initnetdevice(chandev_probeinfo *probeinfo,u8 port_no,
+struct device *dev, int sizeof_priv, char *basename,
+struct device *(*init_netdevfunc)(struct device *dev, int sizeof_priv),
+void (*unreg_netdevfunc)(struct device *dev))
+#endif
 {
-	chandev_probelist *probe;
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
+	struct net_device *retdevice=NULL;
+	int new_device=(dev==NULL);
+#else
+	struct device *retdevice=NULL;
+#endif
+
+	if (!unreg_netdevfunc) 
+	{
+		printk("unreg_netdevfunc=NULL in chandev_initnetdevice, it should not be valid.\n");
+		return NULL;
+	}
+	chandev_interrupt_check();
+	retdevice=chandev_init_netdev(probeinfo,basename,dev,sizeof_priv,init_netdevfunc);
+	if (retdevice) 
+	{
+		if (chandev_initdevice(probeinfo,retdevice,port_no,retdevice->name,
+				      chandev_category_network_device,(chandev_unregfunc)unreg_netdevfunc)) 
+		{
+			unreg_netdevfunc(retdevice);
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
+			/* We allocated it, so we should free it on error */
+			if(new_device)
+				kfree(dev);
+#endif
+
+			retdevice = NULL;
+		}
+	}
+	return retdevice;
+}
+
+
+int chandev_compare_chpid_info(chandev_subchannel_info *chan1,chandev_subchannel_info *chan2)
+{
+	return (chan1->pim!=chan2->pim || *chan1->chpid!=*chan2->chpid);
+}
+
+int chandev_compare_cu_dev_info(chandev_subchannel_info *chan1,chandev_subchannel_info *chan2)
+{
+	return ((chan1->cu_type != chan2->cu_type)||
+		(chan1->cu_model != chan2->cu_model)||
+		(chan1->dev_type != chan2->dev_type)||
+		(chan1->dev_model != chan2->dev_model));
+}
+
+int chandev_compare_subchannel_info(chandev_subchannel_info *chan1,chandev_subchannel_info *chan2)
+{
+	return((chan1->devno == chan2->devno) &&
+	       (chan1->cu_type == chan2->cu_type) &&
+	       (chan1->cu_model == chan2->cu_model) &&
+	       (chan1->dev_type == chan2->dev_type) &&
+	       (chan1->dev_model == chan2->dev_model) &&
+	       (chan1->pim == chan2->pim) &&
+	       (*chan1->chpid == *chan2->chpid));
+}
+
+
+int chandev_doprobe(chandev_force *force,chandev *read,
+chandev *write,chandev *data)
+{
+	chandev_probelist *probe;
 	chandev_model_info *model_info;
 	chandev_probeinfo probeinfo;
 	int               rc=-1,hint=-1;
 	chandev_activelist *newdevice;
 	chandev_probefunc  probefunc;
-	int                saved_lock_cnt;
 	chandev_parms      *curr_parms;
+	chandev_model_info dummy_model_info;
 
 	memset(&probeinfo,0,sizeof(probeinfo));
-	model_info=read_chandev->model_info;
-	if(read_chandev->model_info!=write_chandev->model_info||
-	   (force&&((force->chan_type&model_info->chan_type)==0))||
-	   (!force&&((read_chandev->cu_type!=write_chandev->cu_type)||
-		    (read_chandev->cu_model!=write_chandev->cu_model)||
-		    (read_chandev->dev_type!=write_chandev->dev_type)||
-		   (read_chandev->dev_model!=write_chandev->dev_model))))
-		return(-1); /* inconsistent */
+	memset(&dummy_model_info,0,sizeof(dummy_model_info));
+	probeinfo.device_forced=(force!=NULL);
+	probeinfo.chpid_info_inconsistent=chandev_compare_chpid_info(&read->sch,&write->sch)||
+		 (data&&chandev_compare_chpid_info(&read->sch,&data->sch));
+	probeinfo.cu_dev_info_inconsistent=chandev_compare_cu_dev_info(&read->sch,&write->sch)||
+		 (data&&chandev_compare_cu_dev_info(&read->sch,&data->sch));
+	if(read->model_info)
+		model_info=read->model_info;
+	else
+	{
+		dummy_model_info.chan_type=chandev_type_none;
+		dummy_model_info.max_port_no=16;
+		model_info=&dummy_model_info;
+	}
 	for_each(probe,chandev_probelist_head)
 	{
-		probeinfo.chan_type=(probe->chan_type&model_info->chan_type);
-		if(probeinfo.chan_type)
+		if(force)
+			probeinfo.chan_type = ( probe->chan_type & force->chan_type );
+		else
+		{
+			if(chandev_cautious_auto_detect)
+				probeinfo.chan_type = ( probe->chan_type == model_info->chan_type ? 
+						       probe->chan_type : chandev_type_none );
+			else
+				probeinfo.chan_type = ( probe->chan_type & model_info->chan_type );
+		}
+		if(probeinfo.chan_type && (force || ( !probeinfo.cu_dev_info_inconsistent &&
+		  ((probe->chan_type&(chandev_type_ctc|chandev_type_escon)) ||
+		   !probeinfo.chpid_info_inconsistent))))
 		{
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-			if(use_devno_names)
-				probeinfo.devif_num=read_chandev->devno;
+			if(chandev_use_devno_names)
+				probeinfo.devif_num=read->sch.devno;
 			else
 #endif
 				probeinfo.devif_num=-1;
-			probeinfo.read_irq=read_chandev->irq;
-			probeinfo.write_irq=write_chandev->irq;
-			probeinfo.read_devno=read_chandev->devno;
-			probeinfo.write_devno=write_chandev->devno;
-			probeinfo.max_port_no=model_info->max_port_no;
-			probeinfo.cu_type=read_chandev->cu_type;
-			probeinfo.cu_model=read_chandev->cu_model;
-			probeinfo.dev_type=read_chandev->dev_type;
-			probeinfo.dev_model=read_chandev->dev_model;
+			probeinfo.read=read->sch;
+			probeinfo.write=write->sch;
+			if(data)
+			{
+				probeinfo.data=data->sch;
+				probeinfo.data_exists=TRUE;
+			}
+			probeinfo.max_port_no=(force&&(force->port_protocol_no!=-1) ? 
+			      force->port_protocol_no : model_info->max_port_no);
 			for_each(curr_parms,chandev_parms_head)
 			{
-				if(probe->chan_type==curr_parms->chan_type)
+				if(probe->chan_type==curr_parms->chan_type&&
+				   read->sch.devno>=curr_parms->lo_devno&&
+					read->sch.devno<=curr_parms->hi_devno)
 				{
 					probeinfo.parmstr=curr_parms->parmstr;
 					break;
@@ -1338,25 +1730,26 @@
 			}
 			if(force)
 			{
+				if(force->chan_type==chandev_type_claw)
+					memcpy(&probeinfo.claw,&force->claw,sizeof(chandev_claw_info));
 				probeinfo.port_protocol_no=force->port_protocol_no;
-				if(force->devif_num!=-1)
+				if(force->devif_num==-1&&force->devif_num==-2)
+					probeinfo.devif_num=-1;
+				else
 					probeinfo.devif_num=force->devif_num;
+				probeinfo.memory_usage_in_k=force->memory_usage_in_k;
 				probeinfo.checksum_received_ip_pkts=force->checksum_received_ip_pkts;
 				probeinfo.use_hw_stats=force->use_hw_stats;
-				
 			}
 			else
 			{
-				probeinfo.port_protocol_no=-1;
-				probeinfo.checksum_received_ip_pkts=FALSE;
-				probeinfo.use_hw_stats=FALSE;
-				if(probe->chan_type&lcs)
-				{
-					if((probeinfo.read_devno&1)||
-					   ((probeinfo.read_devno|1)!=
-					    (probeinfo.write_devno)))
-						return(-1);
-					hint=(read_chandev->devno&0xFF)>>1;
+				probeinfo.port_protocol_no=0;
+				probeinfo.checksum_received_ip_pkts=model_info->default_checksum_received_ip_pkts;
+				probeinfo.use_hw_stats=model_info->default_use_hw_stats;
+				probeinfo.memory_usage_in_k=0;
+				if(probe->chan_type&chandev_type_lcs)
+				{
+					hint=(read->sch.devno&0xFF)>>1;
 					if(hint>model_info->max_port_no)
 					{
 				/* The card is possibly emulated e.g P/390 */
@@ -1368,12 +1761,7 @@
 			}
 			probeinfo.hint_port_no=hint;
 			probefunc=probe->probefunc;
-			saved_lock_cnt=chandev_full_unlock();
-			/* We have to leave the lock go here */
-			/* as probefunctions can call schedule & */
-                        /* reenter to do a kernel thread & we may deadlock */
 			rc=probefunc(&probeinfo);
-			chandev_relock(saved_lock_cnt);
 			if(rc==0)
 			{
 				newdevice=probeinfo.newdevice;
@@ -1381,47 +1769,174 @@
 				{
 					newdevice->probefunc=probe->probefunc;
 					newdevice->shutdownfunc=probe->shutdownfunc;
-					newdevice->reoperfunc=probe->reoperfunc;
+					newdevice->msck_notfunc=probe->msck_notfunc;
 					probe->devices_found++;
 					chandev_add_to_list((list **)&chandev_activelist_head,
 							    newdevice);
-					chandev_add_to_startmsck_list(&startlist_head,
-								      newdevice->devname,good,good);
-					
+					chandev_add_to_userland_notify_list(chandev_start,
+								      newdevice->devname,chandev_status_good,chandev_status_good);
 				}
 				else
 				{
-					printk("chandev_initdevice either failed or wasn't called for device read_irq=0x%04x\n",probeinfo.read_irq);
+					printk("chandev_initdevice either failed or wasn't called for device read_irq=0x%04x\n",probeinfo.read.irq);
 				}
 				break;
+				
 			}
 		}
 	}
+	chandev_remove(read);
+	chandev_remove(write);
+	if(data)
+		chandev_remove(data);
 	return(rc);
 }
 
 
 int chandev_request_irq_from_irqinfo(chandev_irqinfo *irqinfo,chandev *this_chandev)
 {
-	int retval=s390_request_irq_special(irqinfo->irq,
+	int retval=s390_request_irq_special(irqinfo->sch.irq,
 				   irqinfo->handler,
 				   chandev_not_oper_handler,
 				   irqinfo->irqflags,
 				   irqinfo->devname,
 				   irqinfo->dev_id);
 	if(retval==0)
+	{
+		irqinfo->msck_status=chandev_status_good;
 		this_chandev->owned=TRUE;
+	}
 	return(retval);
 }
 
 void chandev_irqallocerr(chandev_irqinfo *irqinfo,int err)
 {
-	printk("chandev_probe failed to realloc irq=%d for %s err=%d\n",irqinfo->irq,irqinfo->devname,err);
+	printk("chandev_probe failed to realloc irq=%d for %s err=%d\n",irqinfo->sch.irq,irqinfo->devname,err);
+}
+
+
+void chandev_call_notification_func(chandev_activelist *curr_device,chandev_irqinfo *curr_irqinfo,
+chandev_msck_status prevstatus)
+{
+	if(curr_irqinfo->msck_status!=prevstatus)
+	{
+		chandev_msck_status new_msck_status=curr_irqinfo->msck_status;
+		if(curr_irqinfo->msck_status==chandev_status_good)
+		{
+			if(curr_device->read_irqinfo->msck_status==chandev_status_good&&
+			   curr_device->write_irqinfo->msck_status==chandev_status_good)
+			{
+				if(curr_device->data_irqinfo)
+				{
+					if(curr_device->data_irqinfo->msck_status==chandev_status_good)
+						new_msck_status=chandev_status_all_chans_good;
+				}
+				else
+					new_msck_status=chandev_status_all_chans_good;
+			}
+		}
+		if(curr_device->msck_notfunc)
+		{
+			curr_device->msck_notfunc(curr_device->dev_ptr,
+					      curr_irqinfo->sch.irq,
+					      prevstatus,new_msck_status);
+		}
+		if(new_msck_status!=chandev_status_good)
+		{
+			/* No point in sending a machine check if only one channel is good */
+			chandev_add_to_userland_notify_list(chandev_msck,curr_device->devname,
+						      prevstatus,curr_irqinfo->msck_status);
+		}
+	}
+}
+
+int chandev_find_eligible_channels(chandev *first_chandev_to_check,
+			       chandev **read,chandev **write,chandev **data,chandev **next,
+				   chandev_type chan_type)
+{
+	chandev *curr_chandev;
+	int eligible_found=FALSE,changed;
+	
+	*next=first_chandev_to_check->next;
+	*read=*write=*data=NULL;
+	for_each(curr_chandev,first_chandev_to_check)
+		if((curr_chandev->sch.devno&1)==0&&curr_chandev->model_info->chan_type!=chandev_type_claw)
+		{
+			*read=curr_chandev;
+			if(chan_type==chandev_type_none)
+				chan_type=(*read)->model_info->chan_type;
+			break;
+		}
+	if(*read)
+	{
+		for_each(curr_chandev,(chandev *)chandev_head.head)
+			if((((*read)->sch.devno|1)==curr_chandev->sch.devno)&&
+			   (chandev_compare_cu_dev_info(&(*read)->sch,&curr_chandev->sch)==0)&&
+			   ((chan_type&(chandev_type_ctc|chandev_type_escon))||
+			    chandev_compare_chpid_info(&(*read)->sch,&curr_chandev->sch)==0))
+			{
+				*write=curr_chandev;
+				break;
+			}
+	}
+	if((chan_type&chandev_type_qeth))
+	{
+		if(*write)
+		{
+			for_each(curr_chandev,(chandev *)chandev_head.head)
+				if((curr_chandev!=*read&&curr_chandev!=*write)&&
+				   (chandev_compare_cu_dev_info(&(*read)->sch,&curr_chandev->sch)==0)&&
+				   (chandev_compare_chpid_info(&(*read)->sch,&curr_chandev->sch)==0))
+				{
+					*data=curr_chandev;
+					break;
+				}
+			if(*data)
+				eligible_found=TRUE;
+		}
+		
+	}
+	else
+		if(*write)
+			eligible_found=TRUE;
+	if(eligible_found)
+	{
+		do
+		{
+			changed=FALSE;
+			if(*next&&
+			   ((*read&&(*read==*next))||
+			   (*write&&(*write==*next))||
+			   (*data&&(*data==*next))))
+			{
+				*next=(*next)->next;
+				changed=TRUE;
+			}
+		}while(changed==TRUE);
+	}
+	return(eligible_found);
+}
+
+chandev *chandev_get_free_chandev_by_devno(int devno)
+{
+	chandev *curr_chandev;
+	if(devno==-1)
+		return(NULL);
+	for_each(curr_chandev,(chandev *)chandev_head.head)
+		if(curr_chandev->sch.devno==devno)
+		{
+			if(chandev_active(devno))
+				return(NULL);
+			else
+				return(curr_chandev);
+		}
+	return(NULL);
+
 }
 
 void chandev_probe(void)
 {
-	chandev *read_chandev,*write_chandev,*curr_chandev;
+	chandev *read_chandev,*write_chandev,*data_chandev,*curr_chandev,*next_chandev;
 	chandev_force *curr_force;
 	chandev_noauto_range *curr_noauto;
 	chandev_activelist *curr_device;
@@ -1434,16 +1949,17 @@
 
 
 	chandev_interrupt_check();
+	chandev_read_conf_if_necessary();
 	chandev_collect_devices();
 	chandev_lock();
 	for_each(curr_irqinfo,chandev_irqinfo_head)
 	{
-		if((curr_device=chandev_get_activelist_by_irq(curr_irqinfo->irq)))
+		if((curr_device=chandev_get_activelist_by_irq(curr_irqinfo->sch.irq)))
 		{
 			prevstatus=curr_irqinfo->msck_status;
-			if(curr_irqinfo->msck_status!=good)
+			if(curr_irqinfo->msck_status!=chandev_status_good)
 			{
-				curr_chandev=chandev_get_by_irq(curr_irqinfo->irq);
+				curr_chandev=chandev_get_by_irq(curr_irqinfo->sch.irq);
 				if(curr_chandev)
 				{
 					auto_msck_recovery=curr_chandev->model_info->
@@ -1454,9 +1970,9 @@
 				for_each(curr_msck_range,chandev_msck_range_head)
 				{
 					if(curr_msck_range->lo_devno<=
-					   curr_irqinfo->devno&&
+					   curr_irqinfo->sch.devno&&
 					   curr_msck_range->hi_devno>=
-					   curr_irqinfo->devno)
+					   curr_irqinfo->sch.devno)
 					{
 						auto_msck_recovery=
 							curr_msck_range->
@@ -1466,28 +1982,32 @@
 				}
 				if((1<<(curr_irqinfo->msck_status-1))&auto_msck_recovery)
 				{
-					if(curr_irqinfo->msck_status==revalidate)
+					if(curr_irqinfo->msck_status==chandev_status_revalidate)
 					{
-						if((get_dev_info_by_irq(curr_irqinfo->irq,&curr_devinfo)==0))
+						if((get_dev_info_by_irq(curr_irqinfo->sch.irq,&curr_devinfo)==0))
 						{
-							curr_irqinfo->devno=curr_devinfo.devno;
-							curr_irqinfo->msck_status=good;
-							goto remove;
+							curr_irqinfo->sch.devno=curr_devinfo.devno;
+							curr_irqinfo->msck_status=chandev_status_good;
 						}
 					}
 					else
 					{
-						if((curr_chandev=chandev_get_by_irq(curr_irqinfo->irq)))
+						if(curr_chandev)
 						{
 							/* Has the device reappeared */
-							if(curr_chandev->cu_type==curr_device->cu_type&&
-							   curr_chandev->cu_model==curr_device->cu_model&&
-							   curr_chandev->dev_type==curr_device->dev_type&&
-							   curr_chandev->dev_model==curr_device->dev_model&&
-							   curr_chandev->devno==curr_irqinfo->devno)
+							if(chandev_compare_subchannel_info(
+								&curr_chandev->sch,
+								&curr_device->read_irqinfo->sch)||
+							   chandev_compare_subchannel_info(
+								&curr_chandev->sch,
+								&curr_device->write_irqinfo->sch)||
+							   (curr_device->data_irqinfo&&
+							    chandev_compare_subchannel_info(
+								    &curr_chandev->sch,
+								    &curr_device->data_irqinfo->sch)))
 							{
 								if((err=chandev_request_irq_from_irqinfo(curr_irqinfo,curr_chandev))==0)
-									curr_irqinfo->msck_status=good;
+									curr_irqinfo->msck_status=chandev_status_good;
 								else
 									chandev_irqallocerr(curr_irqinfo,err);
 							}
@@ -1496,86 +2016,89 @@
 					}
 				}
 			}
-			if(curr_irqinfo->msck_status==good&&prevstatus!=good)
-			{
-				if(curr_device->reoperfunc)
-				{
-					int saved_lock_cnt=chandev_full_unlock();
-					curr_device->reoperfunc(curr_device->dev_ptr,
-								(curr_device->read_irqinfo==curr_irqinfo),
-								prevstatus);
-					chandev_relock(saved_lock_cnt);
-				}
-				if(curr_device->category==network_device&&
-				   curr_device->write_irqinfo==curr_irqinfo)
-				{
-					net_device *dev=(net_device *)curr_device->dev_ptr;
-					if(dev->flags&IFF_UP)
-						netif_start_queue(dev);
-				}
-				chandev_add_to_startmsck_list(&mscklist_head,curr_device->devname,
-							      prevstatus,curr_irqinfo->msck_status);
-			}
+			chandev_call_notification_func(curr_device,curr_irqinfo,prevstatus);
 		}
 		/* This is required because the device can go & come back */
                 /* even before we realize it is gone owing to the waits in our kernel threads */
 		/* & the device will be marked as not owned but its status will be good */
                 /* & an attempt to accidently reprobe it may be done. */ 
 		remove:
-		chandev_remove(chandev_get_by_irq(curr_irqinfo->irq));
+		chandev_remove(chandev_get_by_irq(curr_irqinfo->sch.irq));
 		
 	}
 	/* extra sanity */
-	for_each(curr_chandev,(chandev *)chandev_head.head)
+	for_each_allow_delete(curr_chandev,next_chandev,(chandev *)chandev_head.head)
 		if(curr_chandev->owned)
 			chandev_remove(curr_chandev);
 	for_each(curr_force,chandev_force_head)
 	{
-		for_each(read_chandev,(chandev *)chandev_head.head)
-			if(read_chandev->devno==curr_force->read_devno&&
-				!chandev_active(curr_force->read_devno))
-			{
-				for_each(write_chandev,(chandev *)chandev_head.head)
-					if(write_chandev->devno==
-					   curr_force->write_devno&&
-					   !chandev_active(curr_force->write_devno))
+		if(curr_force->devif_num==-2)
+		{
+			for_each_allow_delete2(curr_chandev,next_chandev,(chandev *)chandev_head.head)
+			{
+				if(chandev_find_eligible_channels(curr_chandev,&read_chandev,
+								  &write_chandev,&data_chandev,
+								  &next_chandev,
+								  curr_force->chan_type));
+				{
+					if((curr_force->read_lo_devno>=read_chandev->sch.devno)&&
+					   (curr_force->write_hi_devno<=read_chandev->sch.devno)&&
+					   (curr_force->read_lo_devno>=write_chandev->sch.devno)&&
+					   (curr_force->write_hi_devno<=write_chandev->sch.devno)&&
+					   (!data_chandev||(data_chandev&&
+					   (curr_force->read_lo_devno>=data_chandev->sch.devno)&&
+					   (curr_force->write_hi_devno<=data_chandev->sch.devno))))
+						chandev_doprobe(curr_force,read_chandev,write_chandev,
+								data_chandev);
+				}
+			}
+		}
+		else
+		{
+			read_chandev=chandev_get_free_chandev_by_devno(curr_force->read_lo_devno);
+			if(read_chandev)
+			{
+				write_chandev=chandev_get_free_chandev_by_devno(curr_force->write_hi_devno);
+				if(write_chandev)
+				{
+					if(curr_force->chan_type==chandev_type_qeth)
 					{
-						if(chandev_doprobe(curr_force,
-								read_chandev,
-								write_chandev)==0)
-						{
-							chandev_remove(read_chandev);
-							chandev_remove(write_chandev);
-							goto chandev_probe_skip;
-						}
+
+						data_chandev=chandev_get_free_chandev_by_devno(curr_force->data_devno);
+						if(data_chandev==NULL)
+							printk("chandev_probe unable to force gigabit_ethernet driver invalid device  no 0x%04x given\n",curr_force->data_devno);
 					}
+					else
+						data_chandev=NULL;
+					chandev_doprobe(curr_force,read_chandev,write_chandev,
+							data_chandev);
+				}
 			}
-	chandev_probe_skip:
+		}
 	}
-	for_each(curr_chandev,(chandev *)chandev_head.head)
+	for_each_allow_delete(curr_chandev,next_chandev,(chandev *)chandev_head.head)
 	{
 		for_each(curr_noauto,chandev_noauto_head)
 		{
-			if(curr_chandev->devno>=curr_noauto->lo_devno&&
-			   curr_chandev->devno<=curr_noauto->hi_devno)
+			if(curr_chandev->sch.devno>=curr_noauto->lo_devno&&
+			   curr_chandev->sch.devno<=curr_noauto->hi_devno)
 			{
 				chandev_remove(curr_chandev);
 				break;
 			}
 		}
 	}
-	for_each(curr_chandev,(chandev *)chandev_head.head)
+	for_each_allow_delete2(curr_chandev,next_chandev,(chandev *)chandev_head.head)
 	{
-		if(curr_chandev->next&&curr_chandev->model_info==
-		   curr_chandev->next->model_info)
-		{
-			
-			chandev_doprobe(NULL,curr_chandev,curr_chandev->next);
-			curr_chandev=curr_chandev->next;
-		}
+		if(chandev_find_eligible_channels(curr_chandev,&read_chandev,
+						  &write_chandev,&data_chandev,
+						  &next_chandev,
+						  chandev_type_none))
+			chandev_doprobe(NULL,read_chandev,write_chandev,
+					data_chandev);
 	}
-	chandev_unlock();
 	chandev_remove_all();
+	chandev_unlock();
 }
 
 static void chandev_not_oper_func(int irq,int status)
@@ -1585,49 +2108,40 @@
 	
 	chandev_lock();
 	for_each(curr_irqinfo,chandev_irqinfo_head)
-		if(curr_irqinfo->irq==irq)
+		if(curr_irqinfo->sch.irq==irq)
 		{
+			chandev_msck_status prevstatus=curr_irqinfo->msck_status;
 			switch(status)
 			{
 				/* Currently defined but not used in kernel */
 				/* Despite being in specs */
 			case DEVSTAT_NOT_OPER:
-				curr_irqinfo->msck_status=not_oper;
+				curr_irqinfo->msck_status=chandev_status_not_oper;
 				break;
 #ifdef DEVSTAT_NO_PATH
 				/* Kernel hasn't this defined currently. */
 				/* Despite being in specs */
 			case DEVSTAT_NO_PATH:
-				curr_irqinfo->msck_status=no_path;
+				curr_irqinfo->msck_status=chandev_status_no_path;
 				break;
 #endif
 			case DEVSTAT_REVALIDATE:
-				curr_irqinfo->msck_status=revalidate;
+				curr_irqinfo->msck_status=chandev_status_revalidate;
 				break;
 			case DEVSTAT_DEVICE_GONE:
-				curr_irqinfo->msck_status=gone;
-				break;
-			}
-			for_each(curr_device,chandev_activelist_head)
-			{
-				if(curr_device->write_irqinfo==curr_irqinfo)
-				{
-					if(curr_device->category==network_device)
-					{
-						net_device *dev=(net_device *)curr_device->dev_ptr;
-						if(dev->flags&IFF_UP)
-							netif_stop_queue(dev);
-					}
-				}
+				curr_irqinfo->msck_status=chandev_status_gone;
 				break;
-			}
-			break;
+                        }
+                        if((curr_device=chandev_get_activelist_by_irq(irq)))
+					chandev_call_notification_func(curr_device,curr_irqinfo,prevstatus);
+ 			else
+				printk("chandev_not_oper_func received channel check for unowned irq %d",irq);
 		}
 	chandev_unlock();
 }
 
 
-static void chandev_msck_task(void *unused)
+static int chandev_msck_thread(void *unused)
 {
 	int loopcnt,not_oper_probe_required=FALSE;
 	wait_queue_head_t    wait;
@@ -1663,9 +2177,17 @@
 	}
 	if(not_oper_probe_required)
 		chandev_probe();
+	return(0);
 }
 
-
+static void chandev_msck_task(void *unused)
+{
+	if(kernel_thread(chandev_msck_thread,NULL,SIGCHLD)<0)
+	{
+		atomic_set(&chandev_msck_thread_lock,1);
+		printk("error making chandev_msck_thread kernel thread\n");
+	}
+}
 
 
 
@@ -1686,6 +2208,8 @@
 	"use_devno_names",
 	"dont_use_devno_names",
 #endif
+	"cautious_auto_detect",
+	"non_cautious_auto_detect",
 	"add_model",
 	"del_model",
 	"auto_msck",
@@ -1696,8 +2220,10 @@
 	"shutdown",
 	"reprobe",
 	"unregister_probe",
+	"unregister_probe_by_chan_type",
 	"read_conf",
 	"dont_read_conf",
+	"persist"
 };
 
 typedef enum
@@ -1719,6 +2245,8 @@
 	use_devno_names_stridx,
 	dont_use_devno_names_stridx,
 #endif
+	cautious_auto_detect_stridx,
+	non_cautious_auto_detect_stridx,
 	add_model_stridx,
 	del_model_stridx,
 	auto_msck_stridx,
@@ -1729,8 +2257,10 @@
 	shutdown_stridx,
 	reprobe_stridx,
 	unregister_probe_stridx,
+	unregister_probe_by_chan_type_stridx,
 	read_conf_stridx,
 	dont_read_conf_stridx,
+	persist_stridx,
 	last_stridx,
 } chandev_str_enum;
 
@@ -1799,16 +2329,18 @@
     return 1;
 }
 
+
 static char *chandev_get_options(char *str, int nints, chandev_int *ints)
 {
 	int res,i=1;
 
-    while (i<nints) {
-        res = chandev_get_option(&str, ints+i);
-        if (res==0) break;
-        i++;
-        if (res==1) break;
-    }
+	while (i<nints) 
+	{
+		res = chandev_get_option(&str, ints+i);
+		if (res==0) break;
+		i++;
+		if (res==1) break;
+	}
 	ints[0] = i-1;
 	return(str);
 }
@@ -1816,8 +2348,45 @@
 #define chandev_get_option get_option
 #define chandev_get_options get_options
 #endif
+/*
+ * Read an string from an option string; if available accept a subsequent
+ * comma as well & set this comma to a null character when returning the string.
+ *
+ * Return values:
+ * 0 : no string found
+ * 1 : string found, no subsequent comma
+ * 2 : string found including a subsequent comma
+ */
+static int chandev_get_string(char **instr,char **outstr)
+{
+	char *cur = *instr;
+
+	if (!cur ||*cur==0)
+	{
+		*outstr=NULL;
+		return 0;
+	}
+	*outstr=*instr;
+	for(;;)
+	{
+		if(*(++cur)==',')
+		{
+			*cur=0;
+			*instr=cur+1;
+			return 2;
+		}
+		else if(*cur==0)
+		{
+			*instr=cur+1;
+			return 1;
+		}
+	}
+}
+
 
-static int chandev_setup(char *instr,char *errstr,int lineno)
+
+
+static int chandev_setup(int in_read_conf,char *instr,char *errstr,int lineno)
 {
 	chandev_strval   val=isnull;
 	chandev_str_enum stridx;
@@ -1826,15 +2395,15 @@
 	char             *str,*currstr,*interpretstr=NULL;
 	int              cnt,strcnt;
 	int              retval=0;
-#define CHANDEV_MAX_EXTRA_INTS 8
+#define CHANDEV_MAX_EXTRA_INTS 12
 	chandev_int ints[CHANDEV_MAX_EXTRA_INTS+1];
-	memset(ints,0,sizeof(ints));
 	currstr=alloca(strlen(instr)+1);
 	strcpy(currstr,instr);
 	strcnt=chandev_pack_args(currstr);
 	for(cnt=1;cnt<=strcnt;cnt++)
 	{
 		interpretstr=currstr;
+		memset(ints,0,sizeof(ints));
 		for(stridx=first_stridx;stridx<last_stridx;stridx++)
 		{
 			str=currstr;
@@ -1844,29 +2413,35 @@
 		currstr=str;
 		if(val)
 		{
-			if(val&iscomma)
+			val=(((chandev_strval)stridx)*stridx_mult)+(val&~isstr);
+			switch(val)
 			{
-				if(stridx==add_parms_stridx&&(val==(isstr|iscomma)))
+			case (add_parms_stridx*stridx_mult)|iscomma:
+				currstr=chandev_get_options(currstr,4,ints);
+				if(*currstr&&ints[0]>=1)
 				{
-					str=currstr;
-					if(chandev_get_option(&str,&ints[0])==2)
+					if(ints[0]==1)
 					{
-						chandev_add_parms(ints[0],str);
-						currstr=str+strlen(str)+1;
-						continue;
+						ints[2]=0;
+						ints[3]=0xffff;
 					}
-					else
-						goto BadArgs;
+					else if(ints[0]==2)
+						ints[3]=ints[2];
+					chandev_add_parms(ints[1],ints[2],ints[3],currstr);
+					goto NextOption;
 				}
 				else
-					currstr=chandev_get_options(str,CHANDEV_MAX_EXTRA_INTS,ints)+1;
-			}
-			else
-			{
-				ints[0]=0;
-				currstr++;
+					goto BadArgs;
+				break;
+			case (claw_stridx*stridx_mult)|isnum|iscomma:
+			case (claw_stridx*stridx_mult)|iscomma:
+				currstr=chandev_get_options(str,6,ints);
+				break;
+			default:
+				if(val&iscomma)
+					currstr=chandev_get_options(str,CHANDEV_MAX_EXTRA_INTS,ints);
+				break;
 			}
-			val=(((chandev_strval)stridx)*stridx_mult)+(val&~isstr);
 			switch(val)
 			{
 			case noauto_stridx*stridx_mult:
@@ -1924,59 +2499,105 @@
 				else
 					goto BadArgs;
 				break;
+			case (qeth_stridx*stridx_mult)|isnum|iscomma:
+				if(ints[0]<3||ints[0]>7)
+					goto BadArgs;
+				chandev_add_force(chandev_type_qeth,endlong,ints[1],ints[2],
+						  ints[3],ints[4],ints[5],ints[6],ints[7],
+						  NULL,NULL,NULL);
+				break;
 			case (ctc_stridx*stridx_mult)|isnum|iscomma:
 			case (escon_stridx*stridx_mult)|isnum|iscomma:
 			case (lcs_stridx*stridx_mult)|isnum|iscomma:
 			case (osad_stridx*stridx_mult)|isnum|iscomma:
-			case (qeth_stridx*stridx_mult)|isnum|iscomma:
-			case (claw_stridx*stridx_mult)|isnum|iscomma:
-				switch(val)
+			case (ctc_stridx*stridx_mult)|iscomma:
+			case (escon_stridx*stridx_mult)|iscomma:
+			case (lcs_stridx*stridx_mult)|iscomma:
+			case (osad_stridx*stridx_mult)|iscomma:
+				switch(val&~(isnum|iscomma))
 				{
-				case (ctc_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=ctc;
-					break;
-				case (escon_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=escon;
+				case (ctc_stridx*stridx_mult):
+					chan_type=chandev_type_ctc;
 					break;
-				case (lcs_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=lcs;
+				case (escon_stridx*stridx_mult):
+					chan_type=chandev_type_escon;
 					break;
-				case (osad_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=osad;
+				case (lcs_stridx*stridx_mult):
+					chan_type=chandev_type_lcs;
 					break;
-				case (qeth_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=qeth;
+				case (osad_stridx*stridx_mult):
+					chan_type=chandev_type_osad;
 					break;
-				case (claw_stridx*stridx_mult)|isnum|iscomma:
-					chan_type=claw;
+				case (qeth_stridx*stridx_mult):
+					chan_type=chandev_type_qeth;
 					break;
 				default:
 					goto BadArgs;
 				}
+				if((val&isnum)==0)
+					endlong=-2;
+				if(ints[0]<2||ints[0]>6)
+					goto BadArgs;
 				chandev_add_force(chan_type,endlong,ints[1],ints[2],
-						  ints[3],ints[4],ints[5]);
+						  0,ints[3],ints[4],ints[5],ints[6],
+						  NULL,NULL,NULL);
+				break;
+			case (claw_stridx*stridx_mult)|isnum|iscomma:
+			case (claw_stridx*stridx_mult)|iscomma:
+				if(ints[0]>=2&&ints[0]<=5)
+				{
+					char    *host_name,*adapter_name,*api_type;
+					char    *clawstr=alloca(strlen(currstr)+1);
+					
+					strcpy(clawstr,currstr);
+					if(!(chandev_get_string(&clawstr,&host_name)==2&&
+					     chandev_get_string(&clawstr,&adapter_name)==2&&
+					     chandev_get_string(&clawstr,&api_type)==1&&
+					     chandev_add_force(chandev_type_claw,
+							       endlong,ints[1],ints[2],0,
+							       ints[3],0,ints[4],ints[5],
+							       host_name,adapter_name,api_type)==0))
+						goto BadArgs;
+						
+				}
+				else
+					goto BadArgs;
 				break;
 			case (del_parms_stridx*stridx_mult):
 				ints[1]=-1;
 			case (del_parms_stridx*stridx_mult)|iscomma:
-				if(ints[0]==1)
+				if(ints[0]==0)
+					ints[1]=-1;
+				if(ints[0]<=1)
 					ints[2]=FALSE;
-				if(ints[0]>2)
+				if(ints[0]<=2)
+					ints[3]=-1;
+				if(ints[0]>3)
 					goto BadArgs;
-				chandev_remove_parms(ints[1],ints[2]);
+				chandev_remove_parms(ints[1],ints[2],ints[3]);
 				break;
 			case (del_force_stridx*stridx_mult)|iscomma:
 				if(ints[0]!=1)
 					goto BadArgs;
 				chandev_del_force(ints[1]);
 				break;
+			case (del_force_stridx*stridx_mult):
+				chandev_del_force(-1);
+				break;
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
 			case (use_devno_names_stridx*stridx_mult):
-				use_devno_names=1;
+				chandev_use_devno_names=TRUE;
 				break;
 			case (dont_use_devno_names_stridx*stridx_mult):
-				use_devno_names=0;
+				chandev_use_devno_names=FALSE;
+				break;
 #endif
+			case (cautious_auto_detect_stridx*stridx_mult):
+				chandev_cautious_auto_detect=TRUE;
+				break;
+			case (non_cautious_auto_detect_stridx*stridx_mult):
+				chandev_cautious_auto_detect=FALSE;
+				break;
 			case (add_model_stridx*stridx_mult)|iscomma:
 				if(ints[0]<3)
 					goto BadArgs;
@@ -1988,9 +2609,13 @@
 					ints[6]=-1;
 				if(ints[0]<=6)
 					ints[7]=default_msck_bits;
+				if(ints[0]<=7)
+					ints[8]=FALSE;
+				if(ints[0]<=8)
+					ints[9]=FALSE;
 				ints[0]=7;
 				chandev_add_model(ints[1],ints[2],ints[3],
-						  ints[4],ints[5],ints[6],ints[7]);
+						  ints[4],ints[5],ints[6],ints[7],ints[8],ints[9]);
 				break;
 			case (del_model_stridx*stridx_mult)|iscomma:
 				if(ints[0]<2||ints[0]>4)
@@ -2042,41 +2667,59 @@
 					goto BadArgs;
 				chandev_unregister_probe((chandev_probefunc)ints[1]);
 				break;
+			case (unregister_probe_by_chan_type_stridx*stridx_mult)|iscomma:
+				if(ints[0]!=1)
+					goto BadArgs;
+				chandev_unregister_probe_by_chan_type((chandev_type)ints[1]);
+				break;
 			case read_conf_stridx*stridx_mult:
+				if(in_read_conf)
+				{
+					printk("attempt to recursively call read_conf\n");
+					goto BadArgs;
+				}
 				chandev_read_conf();
 				break;
 			case dont_read_conf_stridx*stridx_mult:
-				chandev_conf_read=TRUE;
+				atomic_set(&chandev_conf_read,TRUE);
+				break;
+			case (persist_stridx*stridx_mult)|iscomma:
+				if(ints[0]==1)
+					chandev_persistent=ints[1];
+				else
+					goto BadArgs;
 				break;
 			default:
 				goto BadArgs;
-			}		
+			}
 		}
 		else
 			goto BadArgs;
+	NextOption:
+		if(cnt<strcnt)
+		{
+			/* eat up stuff till next string */
+			while(*(currstr++));
+		}
 	}
 	retval=1;
  BadArgs:
 	if(!retval)
 	{
-		printk("chandev_setup bad argument %s",instr);
+		printk("chandev_setup %s %s",(val==0 ? "unknown verb":"bad argument"),instr);
 		if(errstr)
 		{
 			printk("%s %d interpreted as %s",errstr,lineno,interpretstr);
 			if(strcnt>1)
-				printk(" before semicolon no %d",cnt);
+			{
+				if(cnt==strcnt)
+					printk(" after the last semicolon\n");
+				else
+					printk(" before semicolon no %d",cnt);
+			}
 		}
 		printk(".\n Type man chandev for more info.\n\n");
 	}
-	eieio();
-	if(chandev_lock_owner==(long)current)
-	{
-		printk("chandev_setup bug chandev_lock_cnt=%d lock_owner=%lx\n"
-                       "firstlock_retaddr=%p last_lock_returnaddr=%p\n",
-		       chandev_lock_cnt,chandev_lock_owner,chandev_firstlock_addr,
-		       chandev_lastlock_addr);
-		chandev_full_unlock();
-        }
 	return(retval);
 }
 #define CHANDEV_KEYWORD "chandev="
@@ -2089,7 +2732,7 @@
 	copystr=alloca(len+1);
 	strncpy(copystr,str,len);
 	copystr[len]=0;
-	if(chandev_setup(copystr,"at "CHANDEV_KEYWORD" bootparam no",paramno)==0)
+	if(chandev_setup(FALSE,copystr,"at "CHANDEV_KEYWORD" bootparam no",paramno)==0)
 		return(0);
 	return(len);
 
@@ -2118,7 +2761,7 @@
 	}
 }
 
-int chandev_do_setup(char *buff,int size)
+int chandev_do_setup(int in_read_conf,char *buff,int size)
 {
 	int curr,comment=FALSE,newline=FALSE,oldnewline=TRUE;
 	char *startline=NULL,*endbuff=&buff[size];
@@ -2147,7 +2790,7 @@
 			startline=buff;
 		if(startline&&(buff>startline)&&(oldnewline==FALSE)&&(newline==TRUE))
 		{
-			if((chandev_setup(startline," on line no",lineno))==0)
+			if((chandev_setup(in_read_conf,startline," on line no",lineno))==0)
 				return(-EINVAL);
 			startline=NULL;
 		}
@@ -2166,9 +2809,15 @@
 	char        *buff;
 	int         curr,left,len,fd;
 
+	/* if called from chandev_register_and_probe & 
+	   the driver is compiled into the kernel the
+	   parameters will need to be passed in from
+	   the kernel boot parameter line as the root
+	   fs is not mounted yet, we can't wait here.
+	*/
 	if(in_interrupt()||current->fs->root==NULL)
 		return;
-	chandev_conf_read=TRUE;
+	atomic_set(&chandev_conf_read,TRUE);
 	set_fs(KERNEL_DS);
 	if(stat(CHANDEV_FILE,&statbuf)==0)
 	{
@@ -2189,7 +2838,7 @@
 				close(fd);
 			}
 			set_fs(USER_DS);
-			chandev_do_setup(buff,statbuf.st_size);
+			chandev_do_setup(TRUE,buff,statbuf.st_size);
 			vfree(buff);
 		}
 	}
@@ -2198,7 +2847,9 @@
 
 static void chandev_read_conf_if_necessary(void)
 {
-	if(!chandev_conf_read)
+	if(in_interrupt()||current->fs->root==NULL)
+		return;
+	if(!atomic_compare_and_swap(FALSE,TRUE,&chandev_conf_read))
 		chandev_read_conf();
 }
 
@@ -2218,7 +2869,7 @@
 	chandev_msck_status idx;
 	int first_time=TRUE;
 	buff[0]=0;
-	for(idx=first_msck;idx<last_msck;idx++)
+	for(idx=chandev_status_first_msck;idx<chandev_status_last_msck;idx++)
 	{
 		if((1<<(idx-1))&auto_msck_recovery)
 		{
@@ -2243,34 +2894,39 @@
 	chandev_msck_range *curr_msck_range;
 	s390_dev_info_t   curr_devinfo;
 	int pass,chandevs_detected,curr_irq,loopcnt;
-	chandev_irqinfo *read_irqinfo,*write_irqinfo;
-	char buff[40],buff2[80];    
+	chandev_irqinfo *read_irqinfo,*write_irqinfo,*data_irqinfo;
+	char buff[3][80];    
 
 	chandev_lock();
-	chandev_read_conf_if_necessary();
 	chandev_printf(chan_exit,"\n%s\n"
 		       "*'s for cu/dev type/models indicate don't cares\n",chandev_keydescript);
+	chandev_printf(chan_exit,"\ncautious_auto_detect: %s\n",chandev_cautious_auto_detect ? "on":"off");
+	chandev_printf(chan_exit,"\npersist = 0x%02x\n",chandev_persistent);
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-	chandev_printf(chan_exit,"\nuse_devno_names: %s\n\n",use_devno_names ? "on":"off");
+	chandev_printf(chan_exit,"\nuse_devno_names: %s\n\n",chandev_use_devno_names ? "on":"off");
 #endif
+	
 	if(chandev_models_head)
 	{
 		chandev_printf(chan_exit,"Channels enabled for detection\n");      
-		chandev_printf(chan_exit,"  chan     cu      cu     dev   dev    max     auto recovery\n");
-		chandev_printf(chan_exit,"  type    type    model  type  model  port_no.      type    \n");
-		chandev_printf(chan_exit,"============================================================\n");
+		chandev_printf(chan_exit,"  chan     cu      cu     dev   dev    max     checksum  use hw  auto recovery\n");
+		chandev_printf(chan_exit,"  type    type    model  type  model  port_no. received   stats      type\n");
+		chandev_printf(chan_exit,"==============================================================================\n");
 		for_each(curr_model,chandev_models_head)
 		{
 			
 			
-			chandev_sprint_devinfo(buff,curr_model->cu_type,
+			chandev_sprint_devinfo(buff[0],curr_model->cu_type,
 					       curr_model->cu_model,
 					       curr_model->dev_type,
 					       curr_model->dev_model);
-			sprintf_msck(buff2,curr_model->auto_msck_recovery);
-			chandev_printf(chan_exit,"  0x%02x  %s%3d %s\n",
-				       curr_model->chan_type,buff,
-				       (int)curr_model->max_port_no,buff2);         
+			sprintf_msck(buff[1],curr_model->auto_msck_recovery);
+			chandev_printf(chan_exit,"  0x%02x  %s%3d %s     %s     %s\n",
+				       curr_model->chan_type,buff[0],
+				       (int)curr_model->max_port_no,
+				       curr_model->default_checksum_received_ip_pkts ? "yes":"no ",
+				       curr_model->default_use_hw_stats ? "yes":"no ",
+				       buff[1]);         
 		}
 	}
         
@@ -2294,65 +2950,78 @@
 		chandev_printf(chan_exit,"===========================================\n");
 		for_each(curr_msck_range,chandev_msck_range_head)
 		{
-			sprintf_msck(buff2,curr_msck_range->auto_msck_recovery);
+			sprintf_msck(buff[0],curr_msck_range->auto_msck_recovery);
 			chandev_printf(chan_exit,"  0x%04x     0x%04x %s\n",
 				       curr_msck_range->lo_devno,
-				       curr_msck_range->hi_devno,buff2)
+				       curr_msck_range->hi_devno,buff[0])
 		}
 	}
 	if(chandev_force_head)
 	{
 		chandev_printf(chan_exit,"\nForced devices\n");
-		chandev_printf(chan_exit,"  chan defif read   write     port         ip    hw\n");
-		chandev_printf(chan_exit,"  type  num  devno  devno  protocol no.  chksum stats\n");
-		chandev_printf(chan_exit,"======================================================\n");
+		chandev_printf(chan_exit,"  chan defif read   write  data   memory      port         ip    hw   host       adapter   api\n");
+		chandev_printf(chan_exit,"  type  num  devno  devno  devno  usage(k) protocol no.  chksum stats name        name     name\n");
+		chandev_printf(chan_exit,"===============================================================================================\n");
 		for_each(curr_force,chandev_force_head)
 		{
-			chandev_printf(chan_exit,"  0x%02x  %3d  0x%04x 0x%04x       %3d       %1d    %1d\n",
-				       curr_force->chan_type,curr_force->devif_num,
-				       curr_force->read_devno,curr_force->write_devno,
-				       curr_force->port_protocol_no,curr_force->checksum_received_ip_pkts,
-				       curr_force->use_hw_stats);
+			if(curr_force->memory_usage_in_k==0)
+				strcpy(buff[0],"default");
+			else
+				sprintf(buff[0],"%6d",curr_force->memory_usage_in_k);
+			chandev_printf(chan_exit,"  0x%02x  %3d  0x%04x 0x%04x 0x%04x %7s       %3d       %1d    %1d%s",
+				       (int)curr_force->chan_type,(int)curr_force->devif_num,
+				       (int)curr_force->read_lo_devno,(int)curr_force->write_hi_devno,
+				       (int)curr_force->data_devno,buff[0],
+				       (int)curr_force->port_protocol_no,(int)curr_force->checksum_received_ip_pkts,
+				       (int)curr_force->use_hw_stats,curr_force->chan_type==chandev_type_claw ? "":"\n");
+			if(curr_force->chan_type==chandev_type_claw)
+			{
+				chandev_printf(chan_exit," %9s %9s %9s\n",
+					       curr_force->claw.host_name,
+					       curr_force->claw.adapter_name,
+					       curr_force->claw.api_type);
+			}
+
 		}
 	}
 	if(chandev_probelist_head)
 	{
 #if CONFIG_ARCH_S390X
 		chandev_printf(chan_exit,"\nRegistered probe functions\n"
-			       		 "probefunc            shutdownfunc         reoperfunc         chan  devices\n"
-                                         "                                                             type   found\n"
-			                 "==========================================================================\n");
+			       		 "probefunc            shutdownfunc        msck_notfunc        chan  devices devices\n"
+                                         "                                                             type   found  active\n"
+			                 "==================================================================================\n");
 #else
 		chandev_printf(chan_exit,"\nRegistered probe functions\n"
-			                 "probefunc   shutdownfunc  reoperfunc chan  devices\n"
-                                         "                                     type   found\n"
-			                 "==================================================\n");
+			                 "probefunc   shutdownfunc   msck_notfunc   chan  devices devices\n"
+                                         "                                          type   found  active\n"
+			                 "===============================================================\n");
 #endif
 		for_each(curr_probe,chandev_probelist_head)
 		{
-			chandev_printf(chan_exit,"0x%p   0x%p   0x%p   0x%02x      %d\n",
+			int devices_active=0;
+			for_each(curr_device,chandev_activelist_head)
+			{
+				if(curr_device->probefunc==curr_probe->probefunc)
+					devices_active++;
+			}
+			chandev_printf(chan_exit,"0x%p   0x%p   0x%p       0x%02x     %d      %d\n",
 				       curr_probe->probefunc,
 				       curr_probe->shutdownfunc,
-				       curr_probe->reoperfunc,
+				       curr_probe->msck_notfunc,
 				       curr_probe->chan_type,
-				       curr_probe->devices_found);
+				       curr_probe->devices_found,
+				       devices_active);
 		}
 	}
 	if(chandev_activelist_head)
 	{
-#if CONFIG_ARCH_S390X
+		unsigned long long total_memory_usage_in_k=0;
 		chandev_printf(chan_exit,
 			       "\nInitialised Devices\n"
-			       " read   write  read   write chan port  dev             dev        read msck   write msck\n"
-			       " irq    irq    devno  devno type no.   ptr             name        status      status   \n"
-			       "========================================================================================\n");
-#else
-		chandev_printf(chan_exit,
-			       "\nInitialised Devices\n"
-			       " read   write  read   write chan port  dev     dev        read msck   write msck\n"
-			       " irq    irq    devno  devno type no.   ptr     name        status      status   \n"
-			       "================================================================================\n");
-#endif
+			       " read   write  data  read   write  data  chan port  dev     dev         memory   read msck    write msck    data msck\n"
+			       " irq     irq    irq  devno  devno  devno type no.   ptr     name        usage(k)  status       status        status\n"
+			       "=====================================================================================================================\n");
 		/* We print this list backwards for cosmetic reasons */
 		for(curr_device=chandev_activelist_head;
 		    curr_device->next!=NULL;curr_device=curr_device->next);
@@ -2360,19 +3029,44 @@
 		{
 			read_irqinfo=curr_device->read_irqinfo;
 			write_irqinfo=curr_device->write_irqinfo;
+			data_irqinfo=curr_device->data_irqinfo;
+			if(data_irqinfo)
+			{
+				sprintf(buff[0],"0x%04x",data_irqinfo->sch.irq);
+				sprintf(buff[1],"0x%04x",(int)data_irqinfo->sch.devno);
+			}
+			else
+			{
+				strcpy(buff[0],"  n/a ");
+				strcpy(buff[1],"  n/a ");
+			}
+			if(curr_device->memory_usage_in_k<0)
+			{
+				sprintf(buff[2],"%d",(int)-curr_device->memory_usage_in_k);
+				total_memory_usage_in_k-=curr_device->memory_usage_in_k;
+			}
+			else
+				strcpy(buff[2],"  n/a ");
 			chandev_printf(chan_exit,
-				       "0x%04x 0x%04x 0x%04x 0x%04x 0x%02x %2d 0x%p %-10s   %-12s %-12s\n",
-				       curr_device->read_irqinfo->irq,curr_device->write_irqinfo->irq,
-				       (int)read_irqinfo->devno,
-				       (int)write_irqinfo->devno,
+				       "0x%04x 0x%04x %s 0x%04x 0x%04x %s 0x%02x %2d 0x%p %-10s  %6s   %-12s %-12s %-12s\n",
+				       read_irqinfo->sch.irq,
+				       write_irqinfo->sch.irq,
+				       buff[0],
+				       (int)read_irqinfo->sch.devno,
+				       (int)write_irqinfo->sch.devno,
+				       buff[1],
 				       curr_device->chan_type,(int)curr_device->port_no,
 				       curr_device->dev_ptr,curr_device->devname,
+				       buff[2],
 				       msck_status_strs[read_irqinfo->msck_status],
-				       msck_status_strs[write_irqinfo->msck_status]);
+				       msck_status_strs[write_irqinfo->msck_status],
+				       data_irqinfo ? msck_status_strs[data_irqinfo->msck_status] :
+				       "not applicable");
 			get_prev((list *)chandev_activelist_head,
 				 (list *)curr_device,
 				 (list **)&curr_device);
 		}
+		chandev_printf(chan_exit,"\nTotal device memory usage %Luk.\n",total_memory_usage_in_k);
 	}
 	chandevs_detected=FALSE;
 	for(pass=FALSE;pass<=TRUE;pass++)
@@ -2380,9 +3074,9 @@
 		if(pass&&chandevs_detected)
 		{
 			chandev_printf(chan_exit,"\nchannels detected\n");
-			chandev_printf(chan_exit,"              chan    cu    cu   dev    dev   in   chandev\n");
-			chandev_printf(chan_exit,"  irq  devno  type   type  model type  model  use    reg.\n");
-			chandev_printf(chan_exit,"==========================================================\n");
+			chandev_printf(chan_exit,"              chan    cu    cu   dev    dev                          in chandev\n");
+			chandev_printf(chan_exit,"  irq  devno  type   type  model type  model pim      chpids         use  reg.\n");
+			chandev_printf(chan_exit,"===============================================================================\n");
 		}
 		for(curr_irq=get_irq_first(),loopcnt=0;curr_irq>=0; curr_irq=get_irq_next(curr_irq),loopcnt++)
 		{
@@ -2391,20 +3085,26 @@
 				printk(KERN_ERR"chandev_read_proc detected infinite loop bug in get_irq_next\n");
 				goto chan_error;
 			}
-			if((curr_model=chandev_is_chandev(curr_irq,&curr_devinfo)))
+			if(chandev_is_chandev(curr_irq,&curr_devinfo,&curr_force,&curr_model))
 			{
+				schib_t *curr_schib;
+				curr_schib=s390_get_schib(curr_irq);
 				chandevs_detected=TRUE;
 				if(pass)
 				{
-					chandev_printf(chan_exit,"0x%04x 0x%04x 0x%02x  0x%04x 0x%02x  0x%04x 0x%02x  %-5s %-5s\n",
+					chandev_printf(chan_exit,"0x%04x 0x%04x 0x%02x  0x%04x 0x%02x  0x%04x 0x%02x 0x%02x 0x%016Lx  %-5s %-5s\n",
 						       curr_irq,curr_devinfo.devno,
-						       curr_model->chan_type,
+						       ( curr_force ? curr_force->chan_type : 
+						       ( curr_model ? curr_model->chan_type : 
+							 chandev_type_none )),
 						       (int)curr_devinfo.sid_data.cu_type,
 						       (int)curr_devinfo.sid_data.cu_model,
 						       (int)curr_devinfo.sid_data.dev_type,
 						       (int)curr_devinfo.sid_data.dev_model,
-						       (curr_devinfo.status&DEVSTAT_DEVICE_OWNED) ? "yes":"no",
-						       (chandev_get_irqinfo_by_irq(curr_irq) ? "yes":"no"));
+						       (int)(curr_schib ? curr_schib->pmcw.pim : 0),
+						       *(long long *)(curr_schib ? &curr_schib->pmcw.chpid[0] : 0),
+						       (curr_devinfo.status&DEVSTAT_DEVICE_OWNED) ? "yes":"no ",
+						       (chandev_get_irqinfo_by_irq(curr_irq) ? "yes":"no "));
 						       
 						       
 				}
@@ -2418,14 +3118,14 @@
 		chandev_parms      *curr_parms;
 
 		chandev_printf(chan_exit,"\n driver specific parameters\n");
-		chandev_printf(chan_exit,"chan    driver\n");
-		chandev_printf(chan_exit,"type  parameters\n");
+		chandev_printf(chan_exit,"chan    lo    hi      driver\n");
+		chandev_printf(chan_exit,"type  devno  devno  parameters\n");
 		chandev_printf(chan_exit,"=============================================================================\n");
 		for_each(curr_parms,chandev_parms_head)
 		{
-			chandev_printf(chan_exit,"0x%02x    %s\n",
-				       curr_parms->chan_type,
-				       curr_parms->parmstr);
+			chandev_printf(chan_exit,"0x%02x 0x%04x 0x%04x  %s\n",
+				       curr_parms->chan_type,(int)curr_parms->lo_devno,
+				       (int)curr_parms->hi_devno,curr_parms->parmstr);
 		}
 	}
  chan_error:
@@ -2448,14 +3148,13 @@
 	int         rc;
 	char        *buff;
 	
-	chandev_read_conf_if_necessary();
 	buff=vmalloc(count+1);
 	if(buff)
 	{
 		rc = copy_from_user(buff,buffer,count);
 		if (rc)
 			goto chandev_write_exit;
-		chandev_do_setup(buff,count);
+		chandev_do_setup(FALSE,buff,count);
 		rc=count;
 	chandev_write_exit:
 		vfree(buff);
@@ -2485,29 +3184,26 @@
 #endif
 int __init chandev_init(void)
 {
-	if(!chandev_initialised)
-	{
-		chandev_parse_args();
-		chandev_init_default_models();
+	atomic_set(&chandev_initialised,TRUE);
+	chandev_parse_args();
+	chandev_init_default_models();
 #if CONFIG_PROC_FS
-		chandev_create_proc();
+	chandev_create_proc();
 #endif
-		chandev_msck_task_tq.routine=
+	chandev_msck_task_tq.routine=
 		chandev_msck_task;
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
-		INIT_LIST_HEAD(&chandev_msck_task_tq.list);
-		chandev_msck_task_tq.sync=0;
+	INIT_LIST_HEAD(&chandev_msck_task_tq.list);
+	chandev_msck_task_tq.sync=0;
 #endif
-		chandev_msck_task_tq.data=NULL;
-		chandev_last_startmsck_list_update=chandev_last_machine_check=jiffies-HZ;
-		atomic_set(&chandev_msck_thread_lock,1);
-		chandev_lock_owner=CHANDEV_INVALID_LOCK_OWNER;
-		chandev_lock_cnt=0;
-		spin_lock_init(&chandev_spinlock);
-		spin_lock_init(&chandev_not_oper_spinlock);
-		chandev_initialised=TRUE;
-		atomic_set(&chandev_new_msck,FALSE);
-	}
+	chandev_msck_task_tq.data=NULL;
+	chandev_last_startmsck_list_update=chandev_last_machine_check=jiffies-HZ;
+	atomic_set(&chandev_msck_thread_lock,1);
+	chandev_lock_owner=CHANDEV_INVALID_LOCK_OWNER;
+	chandev_lock_cnt=0;
+	spin_lock_init(&chandev_spinlock);
+	spin_lock_init(&chandev_not_oper_spinlock);
+	atomic_set(&chandev_new_msck,FALSE);
 	return(0);
 }
 #if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
@@ -2516,34 +3212,45 @@
 
 int chandev_register_and_probe(chandev_probefunc probefunc,
 			       chandev_shutdownfunc shutdownfunc,
-			       chandev_reoperfunc reoperfunc,
+			       chandev_msck_notification_func msck_notfunc,
 			       chandev_type chan_type)
 {
-	chandev_probelist *new_probe;
+	chandev_probelist *new_probe,*curr_probe;
 	/* Avoid chicked & egg situations where we may be called before we */
 	/* are initialised. */
 
 	chandev_interrupt_check();
-	if(!chandev_initialised)
+	if(!atomic_compare_and_swap(FALSE,TRUE,&chandev_initialised))
 		chandev_init();
-	chandev_read_conf_if_necessary();
+	chandev_lock();
+	for_each(curr_probe,chandev_probelist_head)
+	{
+		if(curr_probe->probefunc==probefunc)
+		{
+			chandev_unlock();
+			printk("chandev_register_and_probe detected duplicate probefunc %p"
+			       " for chan_type  0x%02x \n",probefunc,chan_type);
+			return (-EPERM);
+		}
+	}
+	chandev_unlock();
 	if((new_probe=chandev_alloc(sizeof(chandev_probelist))))
 	{
 		new_probe->probefunc=probefunc;
 		new_probe->shutdownfunc=shutdownfunc;
-		new_probe->reoperfunc=reoperfunc;
+		new_probe->msck_notfunc=msck_notfunc;
 		new_probe->chan_type=chan_type;
 		new_probe->devices_found=0;
 		chandev_add_to_list((list **)&chandev_probelist_head,new_probe);
 		chandev_probe();
 	}
-	return(new_probe ? new_probe->devices_found:0);
+	return(new_probe ? new_probe->devices_found:-ENOMEM);
 }
 
 void chandev_unregister(chandev_probefunc probefunc,int call_shutdown)
 {
-	chandev_probelist *curr_probe=NULL;
-	chandev_activelist *curr_device;
+	chandev_probelist *curr_probe;
+	chandev_activelist *curr_device,*next_device;
 	
 	chandev_interrupt_check();
 	chandev_lock();
@@ -2551,27 +3258,33 @@
 	{
 		if(curr_probe->probefunc==probefunc)
 		{
-			for_each(curr_device,chandev_activelist_head)
-				if(curr_device->probefunc==probefunc)
-				{
-					if(call_shutdown)
-					{
-						chandev_shutdown(curr_device);
-					}
-				}
+			for_each_allow_delete(curr_device,next_device,chandev_activelist_head)
+				if(curr_device->probefunc==probefunc&&call_shutdown)
+					chandev_shutdown(curr_device);
 			chandev_free_listmember((list **)&chandev_probelist_head,
 						(list *)curr_probe);
+			break;
 		}
 	}
 	chandev_unlock();
 }
 
+
+int chandev_persist(chandev_type chan_type)
+{
+	return((chandev_persistent&chan_type) ? TRUE:FALSE);
+}
+
 EXPORT_SYMBOL(chandev_register_and_probe);
 EXPORT_SYMBOL(chandev_request_irq);
-EXPORT_SYMBOL(chandev_free_irq);
 EXPORT_SYMBOL(chandev_unregister);
 EXPORT_SYMBOL(chandev_initdevice);
+EXPORT_SYMBOL(chandev_build_device_name);
 EXPORT_SYMBOL(chandev_initnetdevice);
-
-
+EXPORT_SYMBOL(chandev_init_netdev);
+EXPORT_SYMBOL(chandev_use_devno_names);
+EXPORT_SYMBOL(chandev_free_irq);
+EXPORT_SYMBOL(chandev_add_model);
+EXPORT_SYMBOL(chandev_del_model);
+EXPORT_SYMBOL(chandev_persist);
 
diff -urN linux/drivers/s390/net/Makefile linux-2.4.7/drivers/s390/net/Makefile
--- linux/drivers/s390/net/Makefile	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/net/Makefile	Mon Dec 17 13:41:19 2001
@@ -5,11 +5,11 @@
 O_TARGET := s390-net.o
 
 list-multi := ctc.o
-export-objs := iucv.o
+export-objs := iucv.o fsm.o
 
-ctc-objs := ctcmain.o ctctty.o fsm.o
+ctc-objs := ctcmain.o ctctty.o
 
-obj-y += iucv.o
+obj-y += iucv.o fsm.o
 obj-$(CONFIG_CTC) += ctc.o
 obj-$(CONFIG_IUCV) += netiucv.o
 
diff -urN linux/drivers/s390/net/ctcmain.c linux-2.4.7/drivers/s390/net/ctcmain.c
--- linux/drivers/s390/net/ctcmain.c	Wed Apr 18 17:40:07 2001
+++ linux-2.4.7/drivers/s390/net/ctcmain.c	Mon Dec 17 13:43:29 2001
@@ -1,5 +1,5 @@
 /*
- * $Id: ctcmain.c,v 1.17 2001/01/23 14:23:51 felfert Exp $
+ * $Id: ctcmain.c,v 1.54 2001/11/23 13:21:56 felfert Exp $
  *
  * CTC / ESCON network driver
  *
@@ -35,70 +35,15 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Log: ctcmain.c,v $
- * Revision 1.17  2001/01/23 14:23:51  felfert
- * Added ctc based tty.
+ * RELEASE-TAG: CTC/ESCON network driver $Revision: 1.54 $
  *
- * Revision 1.16  2001/01/18 16:10:53  felfert
- * Added fixes by acme@conectiva.com.br.
- *
- * Revision 1.15  2001/01/12 15:40:11  felfert
- * Fixed ITPM# PL030052IME (Unitchecks when using real escon).
- *
- * Revision 1.14  2001/01/11 17:43:52  felfert
- * Fixed ITPM# PL030051IME (Initialization of escon).
- *
- * Revision 1.13  2001/01/11 16:40:26  smolinsk
- * resolved name space conflict with LVM and renamed
- *  dev_info_t to s390_dev_info_t
- * worked around a bug in OSA microcode by stepping back to 2k IDALS in idals.c
- *
- * Revision 1.12  2000/12/27 09:40:45  tonn
- * upgrade to test12
- *
- * Revision 1.11  2000/12/15 19:34:54  bird
- * struct ctc_priv_t: set type of tbusy to "unsigned long"
- *
- * Revision 1.10  2000/12/14 16:49:50  bird
- * ch_action_txretry(): added missing clear_normalized_cda()
- *
- * Revision 1.9  2000/12/14 13:56:53  felfert
- * Eliminated a compiler warning when building in old kernel.
- *
- * Revision 1.8  2000/12/14 13:11:59  felfert
- * static ccws now separately allocated.
- * remove locally allocated ccw for setup.
- *
- * Revision 1.7  2000/12/14 03:32:15  bird
- * Fixes for >2GB memory.   Switch on checksumming.
- *
- * Revision 1.6  2000/12/07 20:08:30  felfert
- * Modified RX channel initialization to be compatible with VM TCP
- *
- * Revision 1.5  2000/12/07 18:15:05  felfert
- * Added workaround against VM TCP bug.
- * Fixed an error message.
- *
- * Revision 1.4  2000/12/06 16:55:57  felfert
- * Removed check for double call of ctc_setup().
- * ctc_setup can now handle mutiple calls.
- *
- * Revision 1.3  2000/12/06 16:48:44  felfert
- * New initialization.
- * Removed old cvs log from 2.2 kernel.
- *
- * Revision 1.2  2000/12/06 14:13:46  felfert
- * New unified configuration.
- *
- * Revision 1.1  2000/11/30 11:21:08  bird
- * Support for new ctc driver
  */
 
 #include <linux/version.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/errno.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
@@ -119,14 +64,29 @@
 #include <asm/io.h>
 #include <asm/bitops.h>
 #include <asm/uaccess.h>
+#ifdef CONFIG_CHANDEV
+#define CTC_CHANDEV
+#endif
 
-#define CTC_USE_IDALS 1
-#if CTC_USE_IDALS
+#ifdef CTC_CHANDEV
+#include <asm/chandev.h>
+#define REQUEST_IRQ chandev_request_irq
+#define FREE_IRQ chandev_free_irq
+#else
+#define REQUEST_IRQ request_irq
+#define FREE_IRQ free_irq
+#endif
+
+#if LINUX_VERSION_CODE >= 0x020213
 #  include <asm/idals.h>
 #else
-#  define set_normalized_cda(ccw, addr) ((ccw)->cda = (addr))
+#  define set_normalized_cda(ccw, addr) ((ccw)->cda = (addr),0)
 #  define clear_normalized_cda(ccw)
 #endif
+#if LINUX_VERSION_CODE < 0x020400
+#  define s390_dev_info_t dev_info_t
+#  define dev_kfree_skb_irq(a) dev_kfree_skb(a)
+#endif
 
 #include <asm/irq.h>
 
@@ -136,12 +96,17 @@
 #ifdef MODULE
 MODULE_AUTHOR("(C) 2000 IBM Corp. by Fritz Elfert (felfert@millenux.com)");
 MODULE_DESCRIPTION("Linux for S/390 CTC/Escon Driver");
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,12))
+MODULE_LICENSE("GPL");
+#endif
+#ifndef CTC_CHANDEV
 MODULE_PARM(ctc, "s");
 MODULE_PARM_DESC(ctc,
 "One or more definitions in the same format like the kernel param for ctc.\n"
 "E.g.: ctc0:0x700:0x701:0:ctc1:0x702:0x703:0\n");
 
 char *ctc = NULL;
+#endif
 #else
 /**
  * Number of devices in monolithic (not module) driver version.
@@ -162,7 +127,8 @@
 #define CTC_PROTO_S390          0
 #define CTC_PROTO_LINUX         1
 #define CTC_PROTO_LINUX_TTY     2
-#define CTC_PROTO_MAX           2
+#define CTC_PROTO_OS390         3
+#define CTC_PROTO_MAX           3
 
 #define CTC_BUFSIZE_LIMIT       65535
 #define CTC_BUFSIZE_DEFAULT     32768
@@ -206,13 +172,16 @@
 
 typedef enum channel_types channel_type_t;
 
+#ifndef CTC_CHANDEV
 static int ctc_no_auto = 0;
+#endif
 
 /**
  * If running on 64 bit, this must be changed. XXX Why? (bird)
  */
 typedef unsigned long intparm_t;
 
+#ifndef CTC_CHANDEV
 /**
  * Definition of a per device parameter block
  */
@@ -226,6 +195,7 @@
 } param;
 
 static param *params = NULL;
+#endif
 
 typedef struct {
 	unsigned long maxmulti;
@@ -246,7 +216,6 @@
 	 * Pointer to next channel in list.
 	 */
 	struct channel_t    *next;
-
 	__u16               devno;
 	int                 irq;
 
@@ -278,19 +247,14 @@
 	struct tq_struct    tq;
 
 	/**
-	 * RX/TX buffer for init sequence.
-	 */
-	__u16               dummy_buf;
-
-	/**
-	 * RX buffer size
+	 * RX/TX buffer size
 	 */
 	int                 max_bufsize;
 
 	/**
-	 * Receive buffer.
+	 * Transmit/Receive buffer.
 	 */
-	struct sk_buff      *rx_skb;
+	struct sk_buff      *trans_skb;
 
 	/**
 	 * Universal I/O queue.
@@ -313,16 +277,6 @@
 	spinlock_t          collect_lock;
 
 	/**
-	 * Pointer to dynamic allocated CCWs for TX
-	 */
-	ccw1_t              *dccw;
-
-	/**
-	 * Number of dynamic allocated CCWs needed for clearing IDALs.
-	 */
-	int                 dccw_count;
-
-	/**
 	 * Timer for detecting unresposive
 	 * I/O operations.
 	 */
@@ -345,11 +299,14 @@
 	net_device          *netdev;
 
 	ctc_profile         prof;
+
+	unsigned char       *trans_skb_data;
 } channel;
 
-#define CHANNEL_FLAGS_READ   0
-#define CHANNEL_FLAGS_WRITE  1
-#define CHANNEL_FLAGS_INUSE  2
+#define CHANNEL_FLAGS_READ            0
+#define CHANNEL_FLAGS_WRITE           1
+#define CHANNEL_FLAGS_INUSE           2
+#define CHANNEL_FLAGS_BUFSIZE_CHANGED 4
 #define CHANNEL_FLAGS_RWMASK 1
 #define CHANNEL_DIRECTION(f) (f & CHANNEL_FLAGS_RWMASK)
 
@@ -358,6 +315,10 @@
  */
 static channel *channels = NULL;
 
+#ifdef CTC_CHANDEV
+static int activated;
+#endif
+
 typedef struct ctc_priv_t {
 	struct net_device_stats stats;
 #if LINUX_VERSION_CODE >= 0x02032D
@@ -375,6 +336,7 @@
 	struct proc_dir_entry   *proc_dentry;
 	struct proc_dir_entry   *proc_stat_entry;
 	struct proc_dir_entry   *proc_ctrl_entry;
+	int                     proc_registered;
 } ctc_priv;
 
 /**
@@ -425,7 +387,7 @@
  */
 static void print_banner(void) {
 	static int printed = 0;
-	char vbuf[] = "$Revision: 1.17 $";
+	char vbuf[] = "$Revision: 1.54 $";
 	char *version = vbuf;
 
 	if (printed)
@@ -436,10 +398,21 @@
 			*p = '\0';
 	} else
 		version = " ??? ";
-	printk(KERN_INFO "CTC driver Version%s initialized\n", version);
+	printk(KERN_INFO
+	       "CTC driver Version%swith"
+#ifndef CTC_CHANDEV
+	       "out"
+#endif
+	       " CHANDEV support"
+#ifdef DEBUG
+	       " (DEBUG-VERSION, " __DATE__ __TIME__ ")"
+#endif
+	       " initialized\n", version);
 	printed = 1;
 }
 
+
+#ifndef CTC_CHANDEV
 /**
  * Return type of a detected device.
  */
@@ -502,6 +475,8 @@
 	}
 	return type;
 }
+#endif
+
 
 /**
  * States of the interface statemachine.
@@ -593,6 +568,12 @@
 	CH_EVENT_SC_UNKNOWN,
 
 	/**
+	 * Events, representing machine checks
+	 */
+	CH_EVENT_MC_FAIL,
+	CH_EVENT_MC_GOOD,
+
+	/**
 	 * Event, representing normal IRQ
 	 */
 	CH_EVENT_IRQ,
@@ -637,6 +618,9 @@
 
 	"SubChannel check Unknown",
 
+	"Machine check failure",
+	"Machine check operational",
+
 	"IRQ normal",
 	"IRQ final",
 
@@ -673,6 +657,7 @@
 	CH_STATE_TXERR,
 	CH_STATE_TERM,
 	CH_STATE_DTERM,
+	CH_STATE_NOTOP,
 
 	/**
 	 * MUST be always the last element!!
@@ -696,9 +681,11 @@
 	"TX error",
 	"Terminating",
 	"Restarting",
+	"Not operational",
 };
 
 
+#ifdef DEBUG
 /**
  * Dump header and first 16 bytes of an sk_buff for debugging purposes.
  *
@@ -729,114 +716,121 @@
 		bl = 16;
 	printk(KERN_DEBUG "data: ");
 	for (i = 0; i < bl; i++)
-		printk("%02x ", *p++);
+		printk("%02x%s", *p++, (i % 16) ? " " : "\n<7>");
 	printk("\n");
 }
+#endif
 
 /**
- * Bottom half routine.
+ * Unpack a just received skb and hand it over to
+ * upper layers.
  *
- * @param ch The channel to work on.
+ * @param ch The channel where this skb has been received.
+ * @param pskb The received skb.
  */
-static void ctc_bh(channel *ch)
+static __inline__ void ctc_unpack_skb(channel *ch, struct sk_buff *pskb)
 {
 	net_device     *dev = ch->netdev;
 	ctc_priv       *privptr = (ctc_priv *)dev->priv;
-	struct sk_buff *skb;
 
-	while ((skb = skb_dequeue(&ch->io_queue))) {
-		__u16 len = *((__u16*)skb->data);
+	__u16 len = *((__u16*)pskb->data);
+	skb_put(pskb, 2 + LL_HEADER_LENGTH);
+	skb_pull(pskb, 2);
+	pskb->dev = dev;
+	pskb->ip_summed = CHECKSUM_UNNECESSARY;
+	while (len > 0) {
+		struct sk_buff *skb;
+		ll_header *header = (ll_header *)pskb->data;
 
-		skb_put(skb, 2 + LL_HEADER_LENGTH);
-		skb_pull(skb, 2);
-		skb->dev = dev;
-		skb->ip_summed = CHECKSUM_NONE;
-		while (len > 0) {
-			ll_header *header = (ll_header *)skb->data;
-			skb_pull(skb, LL_HEADER_LENGTH);
-			if ((ch->protocol == CTC_PROTO_S390) &&
-			    (header->type != ETH_P_IP)) {
-				/**
-				 * Check packet type only if we stick strictly
-				 * to S/390's protocol of OS390. This only
-				 * supports IP. Otherwise allow any packet
-				 * type.
-				 */
-				printk(KERN_WARNING
-				       "%s Illegal packet type 0x%04x "
-				       "received, dropping\n",
-				       dev->name, header->type);
-				ctc_dump_skb(skb, -6);
-				privptr->stats.rx_dropped++;
-				privptr->stats.rx_frame_errors++;
-				dev_kfree_skb(skb);
-				goto again;
-			}
-			skb->protocol = ntohs(header->type);
-			header->length -= LL_HEADER_LENGTH;
-			if ((header->length > dev->mtu) ||
-			    (header->length == 0)) {
-				printk(KERN_WARNING
-				       "%s Illegal packet size %d "
-				       "received (MTU=%d), "
-				       "dropping\n", dev->name, header->length,
-				       dev->mtu);
-				ctc_dump_skb(skb, -6);
-				privptr->stats.rx_dropped++;
-				privptr->stats.rx_length_errors++;
-				dev_kfree_skb(skb);
-				goto again;
-			}
-			skb_put(skb, header->length);
-			skb->mac.raw = skb->data;
+		skb_pull(pskb, LL_HEADER_LENGTH);
+		if ((ch->protocol == CTC_PROTO_S390) &&
+		    (header->type != ETH_P_IP)) {
 			/**
-			 * Set truesize here to make the kernel's
-			 * socket layer happy. If this is not done,
-			 * the RX-routines of the socket code are dropping
-			 * most of the received packets, because they "think"
-			 * there isn't enough buffer space for the incoming
-			 * data.
+			 * Check packet type only if we stick strictly
+			 * to S/390's protocol of OS390. This only
+			 * supports IP. Otherwise allow any packet
+			 * type.
 			 */
-			skb->truesize = skb->len;
-			len -= (LL_HEADER_LENGTH + header->length);
-			if (len > 0) {
-				/**
-				 * Clone the skb only if there are still
-				 * sub-packets.
-				 */
-				struct sk_buff *skb2 =
-					skb_clone(skb, GFP_ATOMIC);
-				if (!skb2) {
-					printk(KERN_WARNING "%s Out of memory"
-					       " in ctc_bh\n",
-					       dev->name);
-					privptr->stats.rx_dropped++;
-					dev_kfree_skb(skb);
-					goto again;
-				}
-				if (ch->protocol == CTC_PROTO_LINUX_TTY)
-					ctc_tty_netif_rx(skb2);
-				else
-					netif_rx(skb2);
-				privptr->stats.rx_packets++;
-				privptr->stats.rx_bytes += skb2->len;
-				/**
-				 * Advance pointers to next sub-packet.
-				 */
-				skb_pull(skb, header->length);
-				skb_put(skb, LL_HEADER_LENGTH);
-			} else {
-				if (ch->protocol == CTC_PROTO_LINUX_TTY)
-					ctc_tty_netif_rx(skb);
-				else
-					netif_rx(skb);
-				privptr->stats.rx_packets++;
-				privptr->stats.rx_bytes += skb->len;
-			}
+			printk(KERN_WARNING
+			       "%s Illegal packet type 0x%04x "
+			       "received, dropping\n",
+			       dev->name, header->type);
+#ifdef DEBUG
+			ctc_dump_skb(pskb, -6);
+#endif
+			privptr->stats.rx_dropped++;
+			privptr->stats.rx_frame_errors++;
+			return;
+		}
+		pskb->protocol = ntohs(header->type);
+		header->length -= LL_HEADER_LENGTH;
+		if ((header->length == 0) ||
+		    (header->length > skb_tailroom(pskb)) ||
+		    (header->length > len)) {
+			printk(KERN_WARNING
+			       "%s Illegal packet size %d "
+			       "received (MTU=%d blocklen=%d), "
+			       "dropping\n", dev->name, header->length,
+			       dev->mtu, len);
+#ifdef DEBUG
+			ctc_dump_skb(pskb, -6);
+#endif
+			privptr->stats.rx_dropped++;
+			privptr->stats.rx_length_errors++;
+			return;
+		}
+		if (header->length > skb_tailroom(pskb)) {
+			printk(KERN_WARNING
+			       "%s Illegal packet size %d "
+			       "(beyond the end of received data), "
+			       "dropping\n", dev->name, header->length);
+#ifdef DEBUG
+			ctc_dump_skb(pskb, -6);
+#endif
+			privptr->stats.rx_dropped++;
+			privptr->stats.rx_length_errors++;
+			return;
+		}
+		skb_put(pskb, header->length);
+		pskb->mac.raw = pskb->data;
+		len -= (LL_HEADER_LENGTH + header->length);
+		skb = dev_alloc_skb(pskb->len);
+		if (!skb) {
+			printk(KERN_WARNING
+			       "%s Out of memory in ctc_unpack_skb\n",
+			       dev->name);
+			privptr->stats.rx_dropped++;
+			return;
+		}
+		memcpy(skb_put(skb, pskb->len), pskb->data, pskb->len);
+		skb->mac.raw = skb->data;
+		skb->dev = pskb->dev;
+		skb->protocol = pskb->protocol;
+		pskb->ip_summed = CHECKSUM_UNNECESSARY;
+		if (ch->protocol == CTC_PROTO_LINUX_TTY)
+			ctc_tty_netif_rx(skb);
+		else
+			netif_rx(skb);
+		privptr->stats.rx_packets++;
+		privptr->stats.rx_bytes += skb->len;
+		if (len > 0) {
+			skb_pull(pskb, header->length);
+			skb_put(pskb, LL_HEADER_LENGTH);
 		}
-	again:
 	}
-	return;
+}
+
+/**
+ * Bottom half routine.
+ *
+ * @param ch The channel to work on.
+ */
+static void ctc_bh(channel *ch)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&ch->io_queue)))
+		ctc_unpack_skb(ch, skb);
 }
 
 /**
@@ -883,9 +877,10 @@
 static void inline ccw_unit_check (channel *ch, unsigned char sense) {
 	if (sense & SNS0_INTERVENTION_REQ) {
 		if (sense & 0x01)  {
-			printk(KERN_DEBUG
-			       "ch-%04x: Interface disc. or Sel. reset "
-			       "(remote)\n", ch->devno);
+			if (ch->protocol != CTC_PROTO_LINUX_TTY)
+				printk(KERN_DEBUG
+				       "ch-%04x: Interface disc. or Sel. reset "
+				       "(remote)\n", ch->devno);
 			fsm_event(ch->fsm, CH_EVENT_UC_RCRESET, ch);
 		} else {
 			printk(KERN_DEBUG "ch-%04x: System reset (remote)\n",
@@ -917,7 +912,8 @@
 			fsm_event(ch->fsm, CH_EVENT_UC_TXPARITY, ch);
 		}
 	} else if (sense & SNS0_CMD_REJECT) {
-			printk(KERN_WARNING "ch-%04x: Command reject\n", ch->devno);
+			printk(KERN_WARNING "ch-%04x: Command reject\n",
+			       ch->devno);
 	} else if (sense == 0) {
 		printk(KERN_DEBUG "ch-%04x: Unit check ZERO\n", ch->devno);
 		fsm_event(ch->fsm, CH_EVENT_UC_ZERO, ch);
@@ -935,8 +931,46 @@
 
 	while ((skb = skb_dequeue(q))) {
 		atomic_dec(&skb->users);
-		dev_kfree_skb(skb);
+		dev_kfree_skb_irq(skb);
+	}
+}
+
+static __inline__ int ctc_checkalloc_buffer(channel *ch, int warn) {
+	if ((ch->trans_skb == NULL) ||
+	    (ch->flags & CHANNEL_FLAGS_BUFSIZE_CHANGED)) {
+		if (ch->trans_skb != NULL)
+			dev_kfree_skb(ch->trans_skb);
+		clear_normalized_cda(&ch->ccw[1]);
+		ch->trans_skb = __dev_alloc_skb(ch->max_bufsize,
+						GFP_ATOMIC|GFP_DMA);
+		if (ch->trans_skb == NULL) {
+			if (warn)
+				printk(KERN_WARNING
+				       "ch-%04x: Couldn't alloc %s trans_skb\n",
+				       ch->devno,
+				       (CHANNEL_DIRECTION(ch->flags) == READ) ?
+				       "RX" : "TX");
+			return -ENOMEM;
+		}
+		ch->ccw[1].count = ch->max_bufsize;
+		if (set_normalized_cda(&ch->ccw[1],
+				       virt_to_phys(ch->trans_skb->data))) {
+			dev_kfree_skb(ch->trans_skb);
+			ch->trans_skb = NULL;
+			if (warn)
+				printk(KERN_WARNING
+				       "ch-%04x: set_normalized_cda for %s "
+				       "trans_skb failed, dropping packets\n",
+				       ch->devno,
+				       (CHANNEL_DIRECTION(ch->flags) == READ) ?
+				       "RX" : "TX");
+			return -ENOMEM;
+		}
+		ch->ccw[1].count = 0;
+		ch->trans_skb_data = ch->trans_skb->data;
+		ch->flags &= ~CHANNEL_FLAGS_BUFSIZE_CHANGED;
 	}
+	return 0;
 }
 
 /**
@@ -988,79 +1022,52 @@
 			first = 0;
 		}
 		atomic_dec(&skb->users);
-		dev_kfree_skb(skb);
+		dev_kfree_skb_irq(skb);
 	}
 	spin_lock(&ch->collect_lock);
-	if (ch->dccw) {
-		for (i = 0; i < ch->dccw_count; i++)
-			clear_normalized_cda(&ch->dccw[i]);
-		kfree(ch->dccw);
-		ch->dccw = NULL;
-	}
+	clear_normalized_cda(&ch->ccw[4]);
 	if (ch->collect_len > 0) {
 		int rc;
 
-		ch->dccw_count = skb_queue_len(&ch->collect_queue) + 1;
-		if (ch->prof.maxmulti < (ch->collect_len + 2))
-			ch->prof.maxmulti = ch->collect_len + 2;
-		if (ch->prof.maxcqueue < ch->dccw_count)
-			ch->prof.maxcqueue = ch->dccw_count;
-
-		ch->dccw = kmalloc(ch->dccw_count *
-				   sizeof(ccw1_t), GFP_ATOMIC|GFP_DMA);
-		if (!ch->dccw) {
+		if (ctc_checkalloc_buffer(ch, 1)) {
 			spin_unlock(&ch->collect_lock);
-			printk(KERN_WARNING
-			       "%s: Unable to alloc dynamic ccws\n",
-			       dev->name);
 			return;
 		}
-
-		ch->dccw[0].cmd_code = CCW_CMD_PREPARE;
-		ch->dccw[0].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
-		ch->dccw[0].count    = 0;
-		ch->dccw[0].cda	     = 0;
-		i = 1;
+		ch->trans_skb->tail = ch->trans_skb->data = ch->trans_skb_data;
+		ch->trans_skb->len = 0;
+		if (ch->prof.maxmulti < (ch->collect_len + 2))
+			ch->prof.maxmulti = ch->collect_len + 2;
+		if (ch->prof.maxcqueue < skb_queue_len(&ch->collect_queue))
+			ch->prof.maxcqueue = skb_queue_len(&ch->collect_queue);
+		*((__u16 *)skb_put(ch->trans_skb, 2)) = ch->collect_len + 2;
+		i = 0;
 		while ((skb = skb_dequeue(&ch->collect_queue))) {
-			ch->prof.txlen += (skb->len - LL_HEADER_LENGTH);
-			if (i == 1)
-				*((__u16 *)skb_push(skb, 2)) =
-					ch->collect_len + 2;
-			ch->dccw[i].cmd_code = CCW_CMD_WRITE;
-			ch->dccw[i].flags    = CCW_FLAG_SLI |
-				((skb_queue_len(&ch->collect_queue))
-				 ? CCW_FLAG_DC : 0);
-			ch->dccw[i].count    = skb->len;
-			set_normalized_cda(&ch->dccw[i],
-					   virt_to_phys(skb->data));
-			skb_queue_tail(&ch->io_queue, skb);
+			memcpy(skb_put(ch->trans_skb, skb->len), skb->data,
+			       skb->len);
+			privptr->stats.tx_packets++;
+			privptr->stats.tx_bytes += skb->len - LL_HEADER_LENGTH;
+			atomic_dec(&skb->users);
+			dev_kfree_skb_irq(skb);
 			i++;
 		}
 		ch->collect_len = 0;
+		spin_unlock(&ch->collect_lock);
+		ch->ccw[1].count = ch->trans_skb->len;
 		fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC, CH_EVENT_TIMER, ch);
 		ch->prof.send_stamp = xtime;
-		rc = do_IO(ch->irq, ch->dccw, (intparm_t)ch, 0xff, 0);
+		rc = do_IO(ch->irq, &ch->ccw[0], (intparm_t)ch, 0xff, 0);
 		ch->prof.doios_multi++;
 		if (rc != 0) {
+			privptr->stats.tx_dropped += i;
+			privptr->stats.tx_errors += i;
 			fsm_deltimer(&ch->timer);
-			i = 0;
-			while ((skb = skb_dequeue(&ch->io_queue))) {
-				privptr->stats.tx_dropped++;
-				privptr->stats.tx_errors++;
-				atomic_dec(&skb->users);
-				dev_kfree_skb(skb);
-				i++;
-			}
-			kfree(ch->dccw);
-			ch->dccw = NULL;
-			if (i != ch->dccw_count)
-				printk(KERN_WARNING "ctc: i != nccws !!!\n");
 			ccw_check_return_code(ch, rc);
 		}
-	} else
+	} else {
+		spin_unlock(&ch->collect_lock);
 		fsm_newstate(fi, CH_STATE_TXIDLE);
+	}
 	ctc_clear_busy(dev);
-	spin_unlock(&ch->collect_lock);
 }
 
 /**
@@ -1096,10 +1103,9 @@
 	net_device     *dev = ch->netdev;
 	ctc_priv       *privptr = dev->priv;
 	int            len = ch->max_bufsize - ch->devstat->rescnt;
-	struct sk_buff *skb = ch->rx_skb;
+	struct sk_buff *skb = ch->trans_skb;
 	__u16          block_len = *((__u16*)skb->data);
-	char           *saved_data = skb->data;
-	int            queued = 0;
+	int            check_len;
 	int            rc;
 
 	fsm_deltimer(&ch->timer);
@@ -1117,17 +1123,26 @@
 		privptr->stats.rx_length_errors++;
 		goto again;
 	}
+
 	/**
 	 * VM TCP seems to have a bug sending 2 trailing bytes of garbage.
 	 */
-	if ((len < block_len) ||
-	    ((len > block_len) && (ch->protocol != CTC_PROTO_S390)) ||
-	    ((len > (block_len + 2)) && (ch->protocol == CTC_PROTO_S390))) {
-		printk(KERN_WARNING
-		       "%s: got block length %d != rx length %d\n", dev->name,
-		       block_len, len);
-		*((__u16*)skb->data) = len;
+	switch (ch->protocol) {
+		case CTC_PROTO_S390:
+		case CTC_PROTO_OS390:
+			check_len = block_len + 2;
+			break;
+		default:
+			check_len = block_len;
+			break;
+	}
+	if ((len < block_len) || (len > check_len)) {
+		printk(KERN_WARNING "%s: got block length %d != rx length %d\n",
+		       dev->name, block_len, len);
+#ifdef DEBUG
 		ctc_dump_skb(skb, 0);
+#endif
+		*((__u16*)skb->data) = len;
 		privptr->stats.rx_dropped++;
 		privptr->stats.rx_length_errors++;
 		goto again;
@@ -1135,31 +1150,21 @@
 	block_len -= 2;
 	if (block_len > 0) {
 		*((__u16*)skb->data) = block_len;
-		skb_queue_tail(&ch->io_queue, skb);
-		queued++;
+		ctc_unpack_skb(ch, skb);
 	}
  again:
-	if (queued) {
-		queue_task(&ch->tq, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-		ch->rx_skb = dev_alloc_skb(ch->max_bufsize);
-		if (ch->rx_skb == NULL) {
-			printk(KERN_WARNING "%s: Couldn't alloc rx_skb in "
-			       "ch_action_rx\n", dev->name);
-			/* TODO: retry after bottom half */
-			return;
-		}
-	} else {
-		skb->data = skb->tail = saved_data;
-		skb->len = 0;
-	}
+	skb->data = skb->tail = ch->trans_skb_data;
+	skb->len = 0;
+	if (ctc_checkalloc_buffer(ch, 1))
+		return;
 	ch->ccw[1].count = ch->max_bufsize;
-	set_normalized_cda(&ch->ccw[1], virt_to_phys(ch->rx_skb->data));
 	rc = do_IO(ch->irq, &ch->ccw[0], (intparm_t)ch, 0xff, 0);
 	if (rc != 0)
 		ccw_check_return_code(ch, rc);
 }
 
+static void ch_action_rxidle(fsm_instance *fi, int event, void *arg);
+
 /**
  * Initialize connection by sending a __u16 of value 0.
  *
@@ -1176,6 +1181,25 @@
 		printk(KERN_DEBUG "ch-%04x: remote side issued READ?, "
 		       "init ...\n", ch->devno);
 	fsm_deltimer(&ch->timer);
+	if (ctc_checkalloc_buffer(ch, 1))
+		return;
+	if ((fsm_getstate(fi) == CH_STATE_SETUPWAIT) &&
+	    (ch->protocol == CTC_PROTO_OS390)) {
+		/* OS/390 resp. z/OS */
+		if (CHANNEL_DIRECTION(ch->flags) == READ) {
+			*((__u16 *)ch->trans_skb->data) = CTC_INITIAL_BLOCKLEN;
+			fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC,
+				     CH_EVENT_TIMER, ch);
+			ch_action_rxidle(fi, event, arg);
+		} else {
+			net_device *dev = ch->netdev;
+			fsm_newstate(fi, CH_STATE_TXIDLE);
+			fsm_event(((ctc_priv *)dev->priv)->fsm,
+				  DEV_EVENT_TXUP, dev);
+		}
+		return;
+	}
+
 	/**
 	 * Dont setup a timer for receiving the initial RX frame
 	 * if in compatibility mode, since VM TCP delays the initial
@@ -1185,9 +1209,9 @@
 	    (ch->protocol != CTC_PROTO_S390))
 		fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC, CH_EVENT_TIMER, ch);
 
-	ch->dummy_buf    = CTC_INITIAL_BLOCKLEN;
+	*((__u16 *)ch->trans_skb->data) = CTC_INITIAL_BLOCKLEN;
 	ch->ccw[1].count = 2; /* Transfer only length */
-	set_normalized_cda(&ch->ccw[1], virt_to_phys(&ch->dummy_buf));
+
 	fsm_newstate(fi, (CHANNEL_DIRECTION(ch->flags) == READ)
 		     ? CH_STATE_RXINIT : CH_STATE_TXINIT);
 	rc = do_IO(ch->irq, &ch->ccw[0], (intparm_t)ch, 0xff, 0);
@@ -1223,19 +1247,18 @@
 {
 	channel    *ch = (channel *)arg;
 	net_device *dev = ch->netdev;
+	__u16      buflen;
 	int        rc;
 
 	fsm_deltimer(&ch->timer);
-	if (ch->dummy_buf >= CTC_INITIAL_BLOCKLEN) {
-		ch->rx_skb = dev_alloc_skb(ch->max_bufsize);
-		if (ch->rx_skb == NULL) {
-			printk(KERN_WARNING "%s: Couldn't alloc rx_skb in "
-			       "ch_action_rxidle\n", dev->name);
+	buflen = *((__u16 *)ch->trans_skb->data);
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s: Initial RX count %d\n", dev->name, buflen);
+#endif
+	if (buflen >= CTC_INITIAL_BLOCKLEN) {
+		if (ctc_checkalloc_buffer(ch, 1))
 			return;
-		}
 		ch->ccw[1].count = ch->max_bufsize;
-		set_normalized_cda(&ch->ccw[1],
-				   virt_to_phys(ch->rx_skb->data));
 		fsm_newstate(fi, CH_STATE_RXIDLE);
 		rc = do_IO(ch->irq, &ch->ccw[0], (intparm_t)ch, 0xff, 0);
 		if (rc != 0) {
@@ -1246,7 +1269,7 @@
 				  DEV_EVENT_RXUP, dev);
 	} else {
 		printk(KERN_DEBUG "%s: Initial RX count %d not %d\n",
-		       dev->name, ch->dummy_buf, CTC_INITIAL_BLOCKLEN);
+		       dev->name, buflen, CTC_INITIAL_BLOCKLEN);
 		ch_action_firstio(fi, event, arg);
 	}
 }
@@ -1269,7 +1292,7 @@
 	fsm_newstate(fi, CH_STATE_SETUPWAIT);
 	if (event == CH_EVENT_TIMER)
 		s390irq_spin_lock_irqsave(ch->irq, saveflags);
-	rc = do_IO(ch->irq, &ch->ccw[3], (intparm_t)ch, 0xff, 0);
+	rc = do_IO(ch->irq, &ch->ccw[6], (intparm_t)ch, 0xff, 0);
 	if (event == CH_EVENT_TIMER)
 		s390irq_spin_unlock_irqrestore(ch->irq, saveflags);
 	if (rc != 0) {
@@ -1303,38 +1326,55 @@
 		       ch->irq);
 		return;
 	}
-
- dev = ch->netdev;
+	dev = ch->netdev;
 
 #ifdef DEBUG
 	printk(KERN_DEBUG "%s: %s channel start\n", dev->name,
 	       (CHANNEL_DIRECTION(ch->flags) == READ) ? "RX" : "TX");
 #endif
 
-	INIT_LIST_HEAD(&ch->tq.list);
-	ch->tq.sync    = 0;
-	ch->tq.routine = (void *)(void *)ctc_bh;
-	ch->tq.data    = ch;
-
-	ch->ccw[0].cmd_code = CCW_CMD_PREPARE;
-	ch->ccw[0].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
-	ch->ccw[0].count    = 0;
-	ch->ccw[0].cda	    = 0;
+	if (ch->trans_skb != NULL) {
+		clear_normalized_cda(&ch->ccw[1]);
+		dev_kfree_skb(ch->trans_skb);
+		ch->trans_skb = NULL;
+	}
 	if (CHANNEL_DIRECTION(ch->flags) == READ) {
 		ch->ccw[1].cmd_code = CCW_CMD_READ;
 		ch->ccw[1].flags    = CCW_FLAG_SLI;
 		ch->ccw[1].count    = 0;
-		ch->ccw[1].cda	    = 0;
 	} else {
 		ch->ccw[1].cmd_code = CCW_CMD_WRITE;
 		ch->ccw[1].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
 		ch->ccw[1].count    = 0;
-		ch->ccw[1].cda	    = 0;
 	}
+	if (ctc_checkalloc_buffer(ch, 0))
+		printk(KERN_NOTICE
+		       "%s: Could not allocate %s trans_skb, delaying "
+		       "allocation until first transfer\n",
+		       dev->name, 
+		       (CHANNEL_DIRECTION(ch->flags) == READ) ? "RX" : "TX");
+
+#if LINUX_VERSION_CODE >= 0x020400
+	INIT_LIST_HEAD(&ch->tq.list);
+#else
+	ch->tq.next = NULL;
+#endif
+	ch->tq.sync    = 0;
+	ch->tq.routine = (void *)(void *)ctc_bh;
+	ch->tq.data    = ch;
+
+	ch->ccw[0].cmd_code = CCW_CMD_PREPARE;
+	ch->ccw[0].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
+	ch->ccw[0].count    = 0;
+	ch->ccw[0].cda	    = 0;
 	ch->ccw[2].cmd_code = CCW_CMD_NOOP;	 /* jointed CE + DE */
 	ch->ccw[2].flags    = CCW_FLAG_SLI;
 	ch->ccw[2].count    = 0;
 	ch->ccw[2].cda	    = 0;
+	memcpy(&ch->ccw[3], &ch->ccw[0], sizeof(ccw1_t) * 3);
+	ch->ccw[4].cda	    = 0;
+	ch->ccw[4].flags    &= ~CCW_FLAG_IDA;
+
 	fsm_newstate(fi, CH_STATE_STARTWAIT);
 	fsm_addtimer(&ch->timer, 1000, CH_EVENT_TIMER, ch);
 	s390irq_spin_lock_irqsave(ch->irq, saveflags);
@@ -1392,26 +1432,62 @@
 	channel *ch = (channel *)arg;
 	net_device *dev = ch->netdev;
 
-	if (ch->dccw) {
-		printk(KERN_WARNING "ch_action_stopped: dccw !NULL\n");
-		return;
-	}
 	fsm_deltimer(&ch->timer);
 	fsm_newstate(fi, CH_STATE_STOPPED);
+	if (ch->trans_skb != NULL) {
+		clear_normalized_cda(&ch->ccw[1]);
+		dev_kfree_skb(ch->trans_skb);
+		ch->trans_skb = NULL;
+	}
+	if (CHANNEL_DIRECTION(ch->flags) == READ) {
+		skb_queue_purge(&ch->io_queue);
+		fsm_event(((ctc_priv *)dev->priv)->fsm, DEV_EVENT_RXDOWN, dev);
+	} else {
+		ctc_purge_skb_queue(&ch->io_queue);
+		spin_lock(&ch->collect_lock);
+		ctc_purge_skb_queue(&ch->collect_queue);
+		ch->collect_len = 0;
+		spin_unlock(&ch->collect_lock);
+		fsm_event(((ctc_priv *)dev->priv)->fsm, DEV_EVENT_TXDOWN, dev);
+	}
+}
+
+/**
+ * A stop command from device statemachine arrived and we are in
+ * not operational mode. Set state to stopped.
+ *
+ * @param fi    An instance of a channel statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from channel * upon call.
+ */
+static void ch_action_stop(fsm_instance *fi, int event, void *arg)
+{
+	fsm_newstate(fi, CH_STATE_STOPPED);
+}
+
+/**
+ * A machine check for no path, not operational status or gone device has
+ * happened.
+ * Cleanup queue and notify interface statemachine.
+ *
+ * @param fi    An instance of a channel statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from channel * upon call.
+ */
+static void ch_action_fail(fsm_instance *fi, int event, void *arg)
+{
+	channel *ch = (channel *)arg;
+	net_device *dev = ch->netdev;
+
+	fsm_deltimer(&ch->timer);
+	fsm_newstate(fi, CH_STATE_NOTOP);
 	if (CHANNEL_DIRECTION(ch->flags) == READ) {
 		skb_queue_purge(&ch->io_queue);
-		if (ch->rx_skb != NULL) {
-			dev_kfree_skb(ch->rx_skb);
-			ch->rx_skb = NULL;
-		}
 		fsm_event(((ctc_priv *)dev->priv)->fsm, DEV_EVENT_RXDOWN, dev);
 	} else {
 		ctc_purge_skb_queue(&ch->io_queue);
 		spin_lock(&ch->collect_lock);
 		ctc_purge_skb_queue(&ch->collect_queue);
-		if (ch->dccw)
-			kfree(ch->dccw);
-		ch->dccw = NULL;
 		ch->collect_len = 0;
 		spin_unlock(&ch->collect_lock);
 		fsm_event(((ctc_priv *)dev->priv)->fsm, DEV_EVENT_TXDOWN, dev);
@@ -1478,9 +1554,9 @@
 	channel *ch = (channel *)arg;
 	net_device *dev = ch->netdev;
 
+	fsm_deltimer(&ch->timer);
 	printk(KERN_DEBUG "%s: %s channel restart\n", dev->name,
 	       (CHANNEL_DIRECTION(ch->flags) == READ) ? "RX" : "TX");
-
 	fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC, CH_EVENT_TIMER, ch);
 	oldstate = fsm_getstate(fi);
 	fsm_newstate(fi, CH_STATE_STARTWAIT);
@@ -1629,20 +1705,21 @@
 		if ((skb = skb_peek(&ch->io_queue))) {
 			int rc = 0;
 
+			clear_normalized_cda(&ch->ccw[4]);
+			ch->ccw[4].count = skb->len;
+			if (set_normalized_cda(&ch->ccw[4],
+					       virt_to_phys(skb->data))) {
+				printk(KERN_DEBUG "%s: IDAL alloc failed, "
+				       "restarting channel\n", dev->name);
+				fsm_event(((ctc_priv *)dev->priv)->fsm,
+					  DEV_EVENT_TXDOWN, dev);
+				ch_action_restart(fi, event, arg);
+				return;
+			}
 			fsm_addtimer(&ch->timer, 1000, CH_EVENT_TIMER, ch);
 			if (event == CH_EVENT_TIMER)
 				s390irq_spin_lock_irqsave(ch->irq, saveflags);
-			if (ch->dccw)
-				rc = do_IO(ch->irq, ch->dccw, (intparm_t)ch,
-					   0xff, 0);
-			else {
-				clear_normalized_cda(&ch->ccw[1]);
-				ch->ccw[1].count = skb->len;
-				set_normalized_cda(&ch->ccw[1],
-						   virt_to_phys(skb->data));
-				rc = do_IO(ch->irq, &ch->ccw[0],
-					   (intparm_t)ch, 0xff, 0);
-			}
+			rc = do_IO(ch->irq, &ch->ccw[3], (intparm_t)ch, 0xff, 0);
 			if (event == CH_EVENT_TIMER)
 				s390irq_spin_unlock_irqrestore(ch->irq,
 							       saveflags);
@@ -1687,6 +1764,13 @@
 	{ CH_STATE_STOPPED,    CH_EVENT_STOP,       fsm_action_nop       },
 	{ CH_STATE_STOPPED,    CH_EVENT_START,      ch_action_start      },
 	{ CH_STATE_STOPPED,    CH_EVENT_FINSTAT,    fsm_action_nop       },
+	{ CH_STATE_STOPPED,    CH_EVENT_MC_FAIL,    fsm_action_nop       },
+
+	{ CH_STATE_NOTOP,      CH_EVENT_STOP,       ch_action_stop       },
+	{ CH_STATE_NOTOP,      CH_EVENT_START,      fsm_action_nop       },
+	{ CH_STATE_NOTOP,      CH_EVENT_FINSTAT,    fsm_action_nop       },
+	{ CH_STATE_NOTOP,      CH_EVENT_MC_FAIL,    fsm_action_nop       },
+	{ CH_STATE_NOTOP,      CH_EVENT_MC_GOOD,    ch_action_start      },
 
 	{ CH_STATE_STARTWAIT,  CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_STARTWAIT,  CH_EVENT_START,      fsm_action_nop       },
@@ -1694,10 +1778,12 @@
 	{ CH_STATE_STARTWAIT,  CH_EVENT_TIMER,      ch_action_setuperr   },
 	{ CH_STATE_STARTWAIT,  CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_STARTWAIT,  CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_STARTWAIT,  CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_STARTRETRY, CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_STARTRETRY, CH_EVENT_TIMER,      ch_action_setmode    },
 	{ CH_STATE_STARTRETRY, CH_EVENT_FINSTAT,    fsm_action_nop       },
+	{ CH_STATE_STARTRETRY, CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_SETUPWAIT,  CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_SETUPWAIT,  CH_EVENT_START,      fsm_action_nop       },
@@ -1707,6 +1793,7 @@
 	{ CH_STATE_SETUPWAIT,  CH_EVENT_TIMER,      ch_action_setmode    },
 	{ CH_STATE_SETUPWAIT,  CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_SETUPWAIT,  CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_SETUPWAIT,  CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_RXINIT,     CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_RXINIT,     CH_EVENT_START,      fsm_action_nop       },
@@ -1718,6 +1805,7 @@
 	{ CH_STATE_RXINIT,     CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_RXINIT,     CH_EVENT_IO_EIO,     ch_action_iofatal    },
 	{ CH_STATE_RXINIT,     CH_EVENT_UC_ZERO,    ch_action_firstio    },
+	{ CH_STATE_RXINIT,     CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_RXIDLE,     CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_RXIDLE,     CH_EVENT_START,      fsm_action_nop       },
@@ -1726,6 +1814,8 @@
 //	{ CH_STATE_RXIDLE,     CH_EVENT_UC_RSRESET, ch_action_rxretry    },
 	{ CH_STATE_RXIDLE,     CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_RXIDLE,     CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_RXIDLE,     CH_EVENT_MC_FAIL,    ch_action_fail       },
+	{ CH_STATE_RXIDLE,     CH_EVENT_UC_ZERO,    ch_action_rx         },
 
 	{ CH_STATE_TXINIT,     CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_TXINIT,     CH_EVENT_START,      fsm_action_nop       },
@@ -1735,6 +1825,7 @@
 	{ CH_STATE_TXINIT,     CH_EVENT_TIMER,      ch_action_txiniterr  },
 	{ CH_STATE_TXINIT,     CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_TXINIT,     CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_TXINIT,     CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_TXIDLE,     CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_TXIDLE,     CH_EVENT_START,      fsm_action_nop       },
@@ -1743,18 +1834,21 @@
 	{ CH_STATE_TXIDLE,     CH_EVENT_UC_RSRESET, fsm_action_nop       },
 	{ CH_STATE_TXIDLE,     CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_TXIDLE,     CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_TXIDLE,     CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_TERM,       CH_EVENT_STOP,       fsm_action_nop       },
 	{ CH_STATE_TERM,       CH_EVENT_START,      ch_action_restart    },
 	{ CH_STATE_TERM,       CH_EVENT_FINSTAT,    ch_action_stopped    },
 	{ CH_STATE_TERM,       CH_EVENT_UC_RCRESET, fsm_action_nop       },
 	{ CH_STATE_TERM,       CH_EVENT_UC_RSRESET, fsm_action_nop       },
+	{ CH_STATE_TERM,       CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_DTERM,      CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_DTERM,      CH_EVENT_START,      ch_action_restart    },
 	{ CH_STATE_DTERM,      CH_EVENT_FINSTAT,    ch_action_setmode    },
 	{ CH_STATE_DTERM,      CH_EVENT_UC_RCRESET, fsm_action_nop       },
 	{ CH_STATE_DTERM,      CH_EVENT_UC_RSRESET, fsm_action_nop       },
+	{ CH_STATE_DTERM,      CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_TX,         CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_TX,         CH_EVENT_START,      fsm_action_nop       },
@@ -1764,9 +1858,12 @@
 	{ CH_STATE_TX,         CH_EVENT_TIMER,      ch_action_txretry    },
 	{ CH_STATE_TX,         CH_EVENT_IO_ENODEV,  ch_action_iofatal    },
 	{ CH_STATE_TX,         CH_EVENT_IO_EIO,     ch_action_iofatal    },
+	{ CH_STATE_TX,         CH_EVENT_MC_FAIL,    ch_action_fail       },
 
 	{ CH_STATE_RXERR,      CH_EVENT_STOP,       ch_action_haltio     },
 	{ CH_STATE_TXERR,      CH_EVENT_STOP,       ch_action_haltio     },
+	{ CH_STATE_TXERR,      CH_EVENT_MC_FAIL,    ch_action_fail       },
+	{ CH_STATE_RXERR,      CH_EVENT_MC_FAIL,    ch_action_fail       },
 };
 
 static const int CH_FSM_LEN = sizeof(ch_fsm) / sizeof(fsm_node);
@@ -1796,7 +1893,7 @@
 		return -1;
 	}
 	memset(ch, 0, sizeof(channel));
-	if ((ch->ccw = (ccw1_t *)kmalloc(sizeof(ccw1_t) * 5,
+	if ((ch->ccw = (ccw1_t *)kmalloc(sizeof(ccw1_t) * 8,
 					 GFP_KERNEL|GFP_DMA)) == NULL) {
 		kfree(ch);
 		printk(KERN_WARNING "ctc: Out of memory in add_channel\n");
@@ -1808,24 +1905,29 @@
 	 *
 	 * ccw[0..2] (Channel program for generic I/O):
 	 *           0: prepare
-	 *           1: read or write (depending on direction)
+	 *           1: read or write (depending on direction) with fixed
+	 *              buffer (idal allocated once when buffer is allocated)
 	 *           2: nop
-	 * ccw[3..4] (Channel program for initial channel setup):
+	 * ccw[3..5] (Channel program for direct write of packets)
+	 *           3: prepare
+	 *           4: write (idal allocated on every write).
+	 *           5: nop
+	 * ccw[6..7] (Channel program for initial channel setup):
 	 *           3: set extended mode
 	 *           4: nop
 	 *
-	 * ch->ccw[0..2] are initialized in ch_action_start because
+	 * ch->ccw[0..5] are initialized in ch_action_start because
 	 * the channel's direction is yet unknown here.
 	 */
-	ch->ccw[3].cmd_code = CCW_CMD_SET_EXTENDED;
-	ch->ccw[3].flags    = CCW_FLAG_SLI;
-	ch->ccw[3].count    = 0;
-	ch->ccw[3].cda      = 0;
+	ch->ccw[6].cmd_code = CCW_CMD_SET_EXTENDED;
+	ch->ccw[6].flags    = CCW_FLAG_SLI;
+	ch->ccw[6].count    = 0;
+	ch->ccw[6].cda      = 0;
 	
-	ch->ccw[4].cmd_code = CCW_CMD_NOOP;
-	ch->ccw[4].flags    = CCW_FLAG_SLI;
-	ch->ccw[4].count    = 0;
-	ch->ccw[4].cda      = 0;
+	ch->ccw[7].cmd_code = CCW_CMD_NOOP;
+	ch->ccw[7].flags    = CCW_FLAG_SLI;
+	ch->ccw[7].count    = 0;
+	ch->ccw[7].cda      = 0;
 
 	ch->irq = irq;
 	ch->devno = devno;
@@ -1835,7 +1937,8 @@
 			ch_event_names, NR_CH_STATES, NR_CH_EVENTS,
 			ch_fsm, CH_FSM_LEN, GFP_KERNEL);
 	if (ch->fsm == NULL) {
-		printk(KERN_WARNING "ctc: Could not create FSM in add_channel\n");
+		printk(KERN_WARNING
+		       "ctc: Could not create FSM in add_channel\n");
 		kfree(ch);
 		return -1;
 	}
@@ -1852,8 +1955,8 @@
 		c = &(*c)->next;
 	if ((*c)->devno == devno) {
 		printk(KERN_DEBUG
-		       "ctc: add_channel: device %04x already in list\n",
-		       (*c)->devno);
+		       "ctc: add_channel: device %04x already in list, "
+		       "using old entry\n", (*c)->devno);
 		kfree(ch->devstat);
 		kfree_fsm(ch->fsm);
 		kfree(ch);
@@ -1867,14 +1970,14 @@
 	return 0;
 }
 
+#ifndef CTC_CHANDEV
 /**
  * scan for all channels and create an entry in the channels list
  * for every supported channel.
- *
- * @param print_result Flag: If !0, print a final result.
  */
-static void channel_scan(int print_result)
+static void channel_scan(void)
 {
+	static int      print_result = 1;
 	int	        irq;
 	int             nr_escon = 0;
 	int             nr_ctca  = 0;
@@ -1912,7 +2015,9 @@
 		else
 			printk(KERN_INFO "ctc: No channel devices found.\n");
 	}
+	print_result = 0;
 }
+#endif
 
 /**
  * Release a specific channel in the channel list.
@@ -1925,6 +2030,40 @@
 	fsm_newstate(ch->fsm, CH_STATE_IDLE);
 }
 
+/**
+ * Remove a specific channel in the channel list.
+ *
+ * @param ch Pointer to channel struct to be released.
+ */
+static void channel_remove(channel *ch)
+{
+	channel **c = &channels;
+
+	if (ch == NULL)
+		return;
+
+#ifndef CTC_CHANDEV
+	if (ch->flags & CHANNEL_FLAGS_INUSE)
+		FREE_IRQ(ch->irq, ch->devstat);
+#endif
+	channel_free(ch);
+	while (*c) {
+		if (*c == ch) {
+			*c = ch->next;
+			fsm_deltimer(&ch->timer);
+			kfree_fsm(ch->fsm);
+			clear_normalized_cda(&ch->ccw[4]);
+			if (ch->trans_skb != NULL) {
+				clear_normalized_cda(&ch->ccw[1]);
+				dev_kfree_skb(ch->trans_skb);
+			}
+			kfree(ch->ccw);
+			return;
+		}
+		c = &((*c)->next);
+	}
+}
+
 
 /**
  * Get a specific channel from the channel list.
@@ -1977,7 +2116,7 @@
 	return ch;
 }
 
-
+#ifndef CTC_CHANDEV
 /**
  * Get the next free channel from the channel list
  *
@@ -2001,6 +2140,7 @@
 	}
 	return ch;
 }
+#endif
 
 /**
  * Return the channel type by name.
@@ -2065,7 +2205,6 @@
 		}
 	}
 
-	clear_normalized_cda(&ch->ccw[1]);
 	dev = (net_device *)(ch->netdev);
 	if (dev == NULL) {
 		printk(KERN_CRIT
@@ -2173,6 +2312,7 @@
 static void dev_action_chup(fsm_instance *fi, int event, void *arg)
 {
 	net_device *dev = (net_device *)arg;
+	ctc_priv   *privptr = dev->priv;
 
 	switch (fsm_getstate(fi)) {
 		case DEV_STATE_STARTWAIT_RXTX:
@@ -2187,6 +2327,8 @@
 				printk(KERN_INFO
 				       "%s: connected with remote side\n",
 				       dev->name);
+				if (privptr->protocol == CTC_PROTO_LINUX_TTY)
+					ctc_tty_setcarrier(dev, 1);
 				ctc_clear_busy(dev);
 			}
 			break;
@@ -2196,6 +2338,8 @@
 				printk(KERN_INFO
 				       "%s: connected with remote side\n",
 				       dev->name);
+				if (privptr->protocol == CTC_PROTO_LINUX_TTY)
+					ctc_tty_setcarrier(dev, 1);
 				ctc_clear_busy(dev);
 			}
 			break;
@@ -2220,8 +2364,13 @@
  */
 static void dev_action_chdown(fsm_instance *fi, int event, void *arg)
 {
+	net_device *dev = (net_device *)arg;
+	ctc_priv   *privptr = dev->priv;
+
 	switch (fsm_getstate(fi)) {
 		case DEV_STATE_RUNNING:
+			if (privptr->protocol == CTC_PROTO_LINUX_TTY)
+				ctc_tty_setcarrier(dev, 0);
 			if (event == DEV_EVENT_TXDOWN)
 				fsm_newstate(fi, DEV_STATE_STARTWAIT_TX);
 			else
@@ -2313,8 +2462,6 @@
 	if (fsm_getstate(ch->fsm) != CH_STATE_TXIDLE) {
 		int l = skb->len + LL_HEADER_LENGTH;
 
-		if (ch->type == channel_type_escon)
-			return -EBUSY;
 		spin_lock_irqsave(&ch->collect_lock, saveflags);
 		if (ch->collect_len + l > ch->max_bufsize - 2)
 			rc = -EBUSY;
@@ -2331,6 +2478,9 @@
 		spin_unlock_irqrestore(&ch->collect_lock, saveflags);
 	} else {
 		__u16 block_len;
+		int ccw_idx;
+		struct sk_buff *nskb;
+		unsigned long hi;
 
 		/**
 		 * Protect skb against beeing free'd by upper
@@ -2345,26 +2495,85 @@
 		       LL_HEADER_LENGTH);
 		block_len = skb->len + 2;
 		*((__u16 *)skb_push(skb, 2)) = block_len;
-		skb_queue_tail(&ch->io_queue, skb);
+
+		/**
+		 * IDAL support in CTC is broken, so we have to
+		 * care about skb's above 2G ourselves.
+		 */
+		hi = ((unsigned long)skb->tail + LL_HEADER_LENGTH) >> 31;
+		if (hi) {
+			nskb = alloc_skb(skb->len, GFP_ATOMIC | GFP_DMA);
+			if (!nskb) {
+				atomic_dec(&skb->users);
+				skb_pull(skb, LL_HEADER_LENGTH + 2);
+				return -ENOMEM;
+			} else {
+				memcpy(skb_put(nskb, skb->len),
+				       skb->data, skb->len);
+				atomic_inc(&nskb->users);
+				atomic_dec(&skb->users);
+				dev_kfree_skb_irq(skb);
+				skb = nskb;
+			}
+		}
+
+		ch->ccw[4].count = block_len;
+		if (set_normalized_cda(&ch->ccw[4], virt_to_phys(skb->data))) {
+			/**
+			 * idal allocation failed, try via copying to
+			 * trans_skb. trans_skb usually has a pre-allocated
+			 * idal.
+			 */
+			if (ctc_checkalloc_buffer(ch, 1)) {
+				/**
+				 * Remove our header. It gets added
+				 * again on retransmit.
+				 */
+				atomic_dec(&skb->users);
+				skb_pull(skb, LL_HEADER_LENGTH + 2);
+				return -EBUSY;
+			}
+
+			ch->trans_skb->tail = ch->trans_skb->data;
+			ch->trans_skb->len = 0;
+			ch->ccw[1].count = skb->len;
+			memcpy(skb_put(ch->trans_skb, skb->len), skb->data,
+			       skb->len);
+			atomic_dec(&skb->users);
+			dev_kfree_skb_irq(skb);
+			ccw_idx = 0;
+		} else {
+			skb_queue_tail(&ch->io_queue, skb);
+			ccw_idx = 3;
+		}
 		ch->retry = 0;
 		fsm_newstate(ch->fsm, CH_STATE_TX);
-		fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC, CH_EVENT_TIMER, ch);
-		ch->ccw[1].count = block_len;
-		set_normalized_cda(&ch->ccw[1], virt_to_phys(skb->data));
+		fsm_addtimer(&ch->timer, CTC_TIMEOUT_5SEC,
+			     CH_EVENT_TIMER, ch);
 		s390irq_spin_lock_irqsave(ch->irq, saveflags);
 		ch->prof.send_stamp = xtime;
-		rc = do_IO(ch->irq, &ch->ccw[0], (intparm_t)ch, 0xff, 0);
+		rc = do_IO(ch->irq, &ch->ccw[ccw_idx], (intparm_t)ch, 0xff, 0);
 		s390irq_spin_unlock_irqrestore(ch->irq, saveflags);
-		ch->prof.doios_single++;
+		if (ccw_idx == 3)
+			ch->prof.doios_single++;
 		if (rc != 0) {
 			fsm_deltimer(&ch->timer);
 			ccw_check_return_code(ch, rc);
-			skb_dequeue_tail(&ch->io_queue);
+			if (ccw_idx == 3)
+				skb_dequeue_tail(&ch->io_queue);
 			/**
 			 * Remove our header. It gets added
 			 * again on retransmit.
 			 */
 			skb_pull(skb, LL_HEADER_LENGTH + 2);
+		} else {
+			if (ccw_idx == 0) {
+				net_device *dev = ch->netdev;
+				ctc_priv   *privptr = dev->priv;
+				privptr->stats.tx_packets++;
+				privptr->stats.tx_bytes +=
+					skb->len - LL_HEADER_LENGTH;
+			}
 		}
 	}
 
@@ -2429,8 +2638,9 @@
 		return 0;
 	}
 	if (skb_headroom(skb) < (LL_HEADER_LENGTH + 2)) {
-		printk(KERN_WARNING "%s: Got sk_buff with head room < %ld bytes\n",
-				dev->name, LL_HEADER_LENGTH + 2);
+		printk(KERN_WARNING
+		       "%s: Got sk_buff with head room < %ld bytes\n",
+		       dev->name, LL_HEADER_LENGTH + 2);
 		dev_kfree_skb(skb);
 		privptr->stats.tx_dropped++;
 		return 0;
@@ -2443,6 +2653,8 @@
 	 */
 	if (fsm_getstate(privptr->fsm) != DEV_STATE_RUNNING) {
 		fsm_event(privptr->fsm, DEV_EVENT_START, dev);
+		if (privptr->protocol == CTC_PROTO_LINUX_TTY)
+			return -EBUSY;
 		dst_link_failure(skb);
 		dev_kfree_skb(skb);
 		privptr->stats.tx_dropped++;
@@ -2577,12 +2789,23 @@
 		return -EFAULT;
 	tmp[count+1] = '\0';
 	bs1 = simple_strtoul(tmp, &e, 0);
+
 	if ((bs1 > CTC_BUFSIZE_LIMIT) ||
-	    (bs1 < (dev->mtu - LL_HEADER_LENGTH - 2)) ||
 	    (e && (!isspace(*e))))
 		return -EINVAL;
+	if ((dev->flags & IFF_RUNNING) &&
+	    (bs1 < (dev->mtu + LL_HEADER_LENGTH + 2)))
+		return -EINVAL;
+	if (bs1 < (576 + LL_HEADER_LENGTH + 2))
+		return -EINVAL;
+
+
 	privptr->channel[READ]->max_bufsize =
 		privptr->channel[WRITE]->max_bufsize = bs1;
+	if (!(dev->flags & IFF_RUNNING))
+		dev->mtu = bs1 - LL_HEADER_LENGTH - 2;
+	privptr->channel[READ]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;
+	privptr->channel[WRITE]->flags |= CHANNEL_FLAGS_BUFSIZE_CHANGED;
 
 	return count;
 }
@@ -2685,7 +2908,7 @@
 			     fsm_getstate_str(privptr->channel[WRITE]->fsm));
 		p += sprintf(p, "Max. TX buffer used: %ld\n",
 			     privptr->channel[WRITE]->prof.maxmulti);
-		p += sprintf(p, "Max. chained CCWs: %ld\n",
+		p += sprintf(p, "Max. chained SKBs: %ld\n",
 			     privptr->channel[WRITE]->prof.maxcqueue);
 		p += sprintf(p, "TX single write ops: %ld\n",
 			     privptr->channel[WRITE]->prof.doios_single);
@@ -2853,15 +3076,18 @@
 	proc_register(privptr->proc_dentry, privptr->proc_stat_entry);
 	proc_register(privptr->proc_dentry, privptr->proc_ctrl_entry);
 #endif
+	privptr->proc_registered = 1;
 }
 
-#ifdef MODULE
+
 /**
  * Destroy a device specific subdirectory.
  *
  * @param privptr Pointer to device private data.
  */
 static void ctc_proc_destroy_sub(ctc_priv *privptr) {
+	if (!privptr->proc_registered)
+		return;
 #if LINUX_VERSION_CODE > 0x020362
 	remove_proc_entry("statistics", privptr->proc_dentry);
 	remove_proc_entry("buffersize", privptr->proc_dentry);
@@ -2874,9 +3100,12 @@
 	proc_unregister(&ctc_dir,
 			privptr->proc_dentry->low_ino);
 #endif
+	privptr->proc_registered = 0;
 }
-#endif MODULE
+
 
+
+#ifndef CTC_CHANDEV
 /**
  * Setup related routines
  *****************************************************************************/
@@ -2991,7 +3220,8 @@
 #else
 static param parms_array[MAX_STATIC_DEVICES];
 static param *next_param = parms_array;
-#define alloc_param() ((next_param<parms_array+MAX_STATIC_DEVICES)?next_param++:NULL)
+#define alloc_param() \
+        ((next_param<parms_array+MAX_STATIC_DEVICES)?next_param++:NULL)
 #endif MODULE
 
 /**
@@ -3159,7 +3389,313 @@
 #if LINUX_VERSION_CODE >= 0x020300
 __setup("ctc=", ctc_setup);
 #endif
+#endif /* !CTC_CHANDEV */
 
+
+static void
+ctc_netdev_unregister(net_device *dev)
+{
+	ctc_priv *privptr;
+
+	if (!dev)
+		return;
+	privptr = (ctc_priv *)dev->priv;
+	if (privptr->protocol != CTC_PROTO_LINUX_TTY)
+		unregister_netdev(dev);
+	else
+		ctc_tty_unregister_netdev(dev);
+}
+
+static int
+ctc_netdev_register(net_device *dev)
+{
+	ctc_priv *privptr = (ctc_priv *)dev->priv;
+	if (privptr->protocol != CTC_PROTO_LINUX_TTY)
+		return register_netdev(dev);
+	else
+		return ctc_tty_register_netdev(dev);
+}
+
+static void
+ctc_free_netdevice(net_device *dev, int free_dev)
+{
+	ctc_priv *privptr;
+	if (!dev)
+		return;
+	privptr = dev->priv;
+	if (privptr) {
+		if (privptr->fsm)
+			kfree_fsm(privptr->fsm);
+		ctc_proc_destroy_sub(privptr);
+		kfree(privptr);
+	}
+#ifdef MODULE
+	if (free_dev)
+		kfree(dev);
+#endif
+}
+
+#ifdef CTC_CHANDEV
+static int
+ctc_shutdown(net_device *dev)
+{
+	ctc_priv *privptr;
+
+	if (!dev)
+		return 0;
+	privptr = (ctc_priv *)dev->priv;
+	channel_remove(privptr->channel[READ]);
+	channel_remove(privptr->channel[WRITE]);
+	ctc_free_netdevice(dev, 0);
+	return 0;
+}
+#endif
+
+/**
+ * Initialize everything of the net device except the name and the
+ * channel structs.
+ */
+static net_device *
+ctc_init_netdevice(net_device *dev, int alloc_device)
+{
+	ctc_priv *privptr;
+	int      priv_size;
+	if (alloc_device) {
+		dev = kmalloc(sizeof(net_device)
+#if LINUX_VERSION_CODE < 0x020300
+			      + 11 /* name + zero */
+#endif
+			      , GFP_KERNEL);
+		if (!dev)
+			return NULL;
+		memset(dev, 0, sizeof(net_device));
+	}
+	priv_size = sizeof(ctc_priv) + sizeof(ctc_template) +
+		sizeof(stat_entry) + sizeof(ctrl_entry);
+	dev->priv = kmalloc(priv_size, GFP_KERNEL);
+	if (dev->priv == NULL) {
+		if (alloc_device)
+			kfree(dev);
+		return NULL;
+	}
+        memset(dev->priv, 0, priv_size);
+        privptr = (ctc_priv *)dev->priv;
+        privptr->proc_dentry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(ctc_priv));
+        privptr->proc_stat_entry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(ctc_priv) +
+		 sizeof(ctc_template));
+        privptr->proc_ctrl_entry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(ctc_priv) +
+		 sizeof(ctc_template) + sizeof(stat_entry));
+	memcpy(privptr->proc_dentry, &ctc_template, sizeof(ctc_template));
+	memcpy(privptr->proc_stat_entry, &stat_entry, sizeof(stat_entry));
+	memcpy(privptr->proc_ctrl_entry, &ctrl_entry, sizeof(ctrl_entry));
+	privptr->fsm = init_fsm("ctcdev", dev_state_names,
+			dev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,
+			dev_fsm, DEV_FSM_LEN, GFP_KERNEL);
+	if (privptr->fsm == NULL) {
+		kfree(privptr);
+		if (alloc_device)
+			kfree(dev);
+		return NULL;
+	}
+	fsm_newstate(privptr->fsm, DEV_STATE_STOPPED);
+	dev->mtu	         = CTC_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2;
+	dev->hard_start_xmit     = ctc_tx;
+	dev->open	         = ctc_open;
+	dev->stop	         = ctc_close;
+	dev->get_stats	         = ctc_stats;
+	dev->change_mtu          = ctc_change_mtu;
+	dev->hard_header_len     = LL_HEADER_LENGTH + 2;
+	dev->addr_len            = 0;
+	dev->type                = ARPHRD_SLIP;
+	dev->tx_queue_len        = 100;
+	SET_DEVICE_START(dev, 1);
+	dev_init_buffers(dev);
+	dev->flags	         = IFF_POINTOPOINT | IFF_NOARP;
+	return dev;
+}
+
+#ifdef CTC_CHANDEV
+static void
+ctc_chandev_msck_notify(void *dev, int msck_irq,
+			chandev_msck_status prevstatus,
+			chandev_msck_status newstatus)
+{
+	net_device *device = (net_device *)dev;
+	ctc_priv *privptr;
+	int direction;
+
+	if (!dev)
+		return;
+
+	privptr = device->priv;
+	if (prevstatus == chandev_status_revalidate)
+		for (direction = READ; direction <= WRITE; direction++) {
+			channel *ch = privptr->channel[direction];
+			if(ch->irq == msck_irq) {
+				s390_dev_info_t devinfo;
+
+				if (get_dev_info_by_irq(ch->irq, &devinfo))
+					ch->devno = devinfo.devno;
+				else
+					printk(KERN_WARNING
+					       "ctc_chandev_msck_notify: "
+					       "get_dev_info_by_irq failed for "
+					       "irq %d\n", ch->irq);
+			}
+		}
+	switch (newstatus) {
+		case chandev_status_not_oper:
+		case chandev_status_no_path:
+		case chandev_status_gone:
+			for (direction = READ; direction <= WRITE; direction++) {
+				channel *ch = privptr->channel[direction];
+				fsm_event(ch->fsm, CH_EVENT_MC_FAIL, ch);
+			}
+			printk(KERN_WARNING
+			       "ctc: %s channel deactivated\n", device->name);
+			break;
+		case chandev_status_all_chans_good:
+			for (direction = READ; direction <= WRITE; direction++) {
+				channel *ch = privptr->channel[direction];
+				fsm_event(ch->fsm, CH_EVENT_MC_GOOD, ch);
+			}
+			printk(KERN_WARNING
+			       "ctc: %s channel activated\n", device->name);
+			break;
+		default:
+			break;
+	}
+}
+
+/**
+ *
+ * Setup an interface.
+ *
+ * Like ctc_setup(), ctc_probe() can be called from two different locations:
+ *  - If built as module, it is called from within init_module().
+ *  - If built in monolithic kernel, it is called from within generic network
+ *    layer during initialization for every corresponding device, declared in
+ *    drivers/net/Space.c
+ *
+ * @param dev Pointer to net_device to be initialized.
+ *
+ * @returns 0 on success, !0 on failure.
+ */
+static int ctc_chandev_probe(chandev_probeinfo *info)
+{
+	int               devno[2];
+	__u16             proto;
+	int               rc;
+	int               direction;
+	channel_type_t    type;
+	ctc_priv          *privptr;
+	net_device        *dev;
+
+	ctc_proc_create_main();
+
+
+	switch (info->chan_type) {
+		case chandev_type_ctc:
+			type = channel_type_ctca;
+			break;
+		case chandev_type_escon:
+			type = channel_type_escon;
+			break;
+		default:
+			printk(KERN_WARNING "ctc_chandev_probe called with "
+			       "unsupported channel type %d\n", info->chan_type);
+			return -ENODEV;
+	}
+	devno[READ]  = info->read.devno;
+	devno[WRITE] = info->write.devno;
+	proto        = info->port_protocol_no;
+
+	if (add_channel(info->read.irq, info->read.devno, type))
+		return -ENOMEM;
+	if (add_channel(info->write.irq, info->write.devno, type))
+		return -ENOMEM;
+
+	dev = ctc_init_netdevice(NULL, 1);
+
+	
+	if (!dev) {
+		printk(KERN_WARNING "ctc_init_netdevice failed\n");
+		return -ENODEV;
+	}
+	
+	if (proto == CTC_PROTO_LINUX_TTY)
+		chandev_build_device_name(info, dev->name, "ctctty", 1);
+	else
+		chandev_build_device_name(info, dev->name, "ctc", 1);
+
+	privptr = (ctc_priv *)dev->priv;
+	privptr->protocol = proto;
+	for (direction = READ; direction <= WRITE; direction++) {
+		privptr->channel[direction] =
+			channel_get(type, devno[direction], direction);
+		if (privptr->channel[direction] == NULL) {
+			if (direction == WRITE) {
+				FREE_IRQ(privptr->channel[READ]->irq,
+					 privptr->channel[READ]->devstat);
+				channel_free(privptr->channel[READ]);
+			}
+			ctc_free_netdevice(dev, 1);
+			return -ENODEV;
+		}
+		privptr->channel[direction]->netdev = dev;
+		privptr->channel[direction]->protocol = proto;
+		privptr->channel[direction]->max_bufsize = CTC_BUFSIZE_DEFAULT;
+		rc = REQUEST_IRQ(privptr->channel[direction]->irq,
+				 (void *)ctc_irq_handler, SA_INTERRUPT,
+				 dev->name,
+				 privptr->channel[direction]->devstat);
+		if (rc) {
+			printk(KERN_WARNING
+			       "%s: requested irq %d is busy rc=%02x\n",
+			       dev->name, privptr->channel[direction]->irq,
+			       rc);
+			if (direction == WRITE) {
+				FREE_IRQ(privptr->channel[READ]->irq,
+					 privptr->channel[READ]->devstat);
+				channel_free(privptr->channel[READ]);
+			}
+			channel_free(privptr->channel[direction]);
+			ctc_free_netdevice(dev, 1);
+			return -EBUSY;
+		}
+	}
+	if (ctc_netdev_register(dev) != 0) {
+		ctc_free_netdevice(dev, 1);
+		return -ENODEV;
+	}
+
+	/**
+	 * register subdir in /proc/net/ctc
+	 */
+	ctc_proc_create_sub(dev);
+	strncpy(privptr->fsm->name, dev->name, sizeof(privptr->fsm->name));
+	activated++;
+
+	print_banner();
+
+	printk(KERN_INFO
+	       "%s: read: ch %04x (irq %04x), "
+	       "write: ch %04x (irq %04x) proto: %d\n",
+	       dev->name, privptr->channel[READ]->devno,
+	       privptr->channel[READ]->irq, privptr->channel[WRITE]->devno,
+	       privptr->channel[WRITE]->irq, proto);
+
+	chandev_initdevice(info, dev, 0, dev->name,
+			   (proto == CTC_PROTO_LINUX_TTY)
+			   ? chandev_category_serial_device :
+			   chandev_category_network_device,
+			   (chandev_unregfunc)ctc_netdev_unregister);
+	return 0;
+}
+#else /* ! CHANDEV */
 /**
  *
  * Setup an interface.
@@ -3191,7 +3727,7 @@
 	 * ctc_probe gets control.
 	 */
 	if (channels == NULL)
-		channel_scan(1);
+		channel_scan();
 
 	type = extract_channel_media(dev->name);
 	if (type == channel_type_unknown)
@@ -3212,47 +3748,13 @@
 		}
 	}
 
-	dev->priv = kmalloc(sizeof(ctc_priv)
-			    + sizeof(ctc_template)
-			    + sizeof(stat_entry)
-			    + sizeof(ctrl_entry)
-			    , GFP_KERNEL);
-	if (dev->priv == NULL)
-		return -ENOMEM;
-	memset(dev->priv, 0, sizeof(ctc_priv));
+#ifndef MODULE
+	if (ctc_init_netdevice(dev, 0) == NULL)
+		return -ENODEV;
+#endif
 	privptr = (ctc_priv *)dev->priv;
 	privptr->protocol = proto;
-        privptr->proc_dentry = (struct proc_dir_entry *)
-		(((char *)privptr) + sizeof(ctc_priv));
-        privptr->proc_stat_entry = (struct proc_dir_entry *)
-		(((char *)privptr) + sizeof(ctc_priv) +
-		 sizeof(ctc_template));
-        privptr->proc_ctrl_entry = (struct proc_dir_entry *)
-		(((char *)privptr) + sizeof(ctc_priv) +
-		 sizeof(ctc_template) + sizeof(stat_entry));
-	memcpy(privptr->proc_dentry, &ctc_template, sizeof(ctc_template));
-	memcpy(privptr->proc_stat_entry, &stat_entry, sizeof(stat_entry));
-	memcpy(privptr->proc_ctrl_entry, &ctrl_entry, sizeof(ctrl_entry));
-	privptr->fsm = init_fsm(dev->name, dev_state_names,
-			dev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,
-			dev_fsm, DEV_FSM_LEN, GFP_KERNEL);
-	fsm_newstate(privptr->fsm, DEV_STATE_STOPPED);
-	if (privptr->fsm == NULL) {
-		kfree(privptr);
-		return -ENOMEM;
-	}
-	dev->mtu	         = CTC_BUFSIZE_DEFAULT - LL_HEADER_LENGTH - 2; 
-	dev->hard_start_xmit     = ctc_tx;
-	dev->open	         = ctc_open;
-	dev->stop	         = ctc_close;
-	dev->get_stats	         = ctc_stats;
-	dev->change_mtu          = ctc_change_mtu;
-	dev->hard_header_len     = LL_HEADER_LENGTH + 2;
-	dev->addr_len            = 0;
-	dev->type                = ARPHRD_SLIP;
-	dev->tx_queue_len        = 100;
-	SET_DEVICE_START(dev, 1);
-	dev->flags	         = IFF_POINTOPOINT | IFF_NOARP;
+
 	for (direction = READ; direction <= WRITE; direction++) {
 		if ((ctc_no_auto == 0) || (devno[direction] == -1))
 			privptr->channel[direction] =
@@ -3262,19 +3764,17 @@
 				channel_get(type, devno[direction], direction);
 		if (privptr->channel[direction] == NULL) {
 			if (direction == WRITE) {
-				free_irq(privptr->channel[READ]->irq,
+				FREE_IRQ(privptr->channel[READ]->irq,
 					 privptr->channel[READ]->devstat);
 				channel_free(privptr->channel[READ]);
 			}
-			kfree_fsm(privptr->fsm);
-			kfree(dev->priv);
-			dev->priv = NULL;
+			ctc_free_netdevice(dev, 1);
 			return -ENODEV;
 		}
 		privptr->channel[direction]->netdev = dev;
 		privptr->channel[direction]->protocol = proto;
 		privptr->channel[direction]->max_bufsize = CTC_BUFSIZE_DEFAULT;
-		rc = request_irq(privptr->channel[direction]->irq,
+		rc = REQUEST_IRQ(privptr->channel[direction]->irq,
 				 (void *)ctc_irq_handler, SA_INTERRUPT,
 				 dev->name,
 				 privptr->channel[direction]->devstat);
@@ -3284,14 +3784,12 @@
 			       dev->name, privptr->channel[direction]->irq,
 			       rc);
 			if (direction == WRITE) {
-				free_irq(privptr->channel[READ]->irq,
+				FREE_IRQ(privptr->channel[READ]->irq,
 					 privptr->channel[READ]->devstat);
 				channel_free(privptr->channel[READ]);
 			}
 			channel_free(privptr->channel[direction]);
-			kfree_fsm(privptr->fsm);
-			kfree(dev->priv);
-			dev->priv = NULL;
+			ctc_free_netdevice(dev, 1);
 			return -EBUSY;
 		}
 	}
@@ -3304,13 +3802,15 @@
 	print_banner();
 
 	printk(KERN_INFO
-	       "%s: read: ch %04x (irq %04x), write: ch %04x (irq %04x) proto: %d\n",
+	       "%s: read: ch %04x (irq %04x), "
+	       "write: ch %04x (irq %04x) proto: %d\n",
 	       dev->name, privptr->channel[READ]->devno,
 	       privptr->channel[READ]->irq, privptr->channel[WRITE]->devno,
 	       privptr->channel[WRITE]->irq, proto);
 
 	return 0;
 }
+#endif
 
 /**
  * Module related routines
@@ -3324,46 +3824,35 @@
  * for that.
  */
 void cleanup_module(void) {
-	channel *c = channels;
 
-	ctc_tty_cleanup();
+	ctc_tty_cleanup(0);
 	/* we are called if all interfaces are down only, so no need
 	 * to bother around with locking stuff
 	 */
-	channels = NULL;
-	while (c) {
-		channel *oldc = c;
-		if (c->netdev && c->netdev->priv) {
-			net_device *nd = c->netdev;
-			ctc_priv *privptr = (ctc_priv *)nd->priv;
-
-			fsm_deltimer(&privptr->channel[READ]->timer);
-			fsm_deltimer(&privptr->channel[WRITE]->timer);
-			free_irq(privptr->channel[READ]->irq,
-				 privptr->channel[READ]->devstat);
-			free_irq(privptr->channel[WRITE]->irq,
-				 privptr->channel[WRITE]->devstat);
-			kfree_fsm(privptr->channel[READ]->fsm);
-			kfree_fsm(privptr->channel[WRITE]->fsm);
-			if (privptr->protocol != CTC_PROTO_LINUX_TTY)
-				unregister_netdev(nd);
-			else
-				ctc_tty_unregister_netdev(nd);
-			kfree_fsm(privptr->fsm);
-			privptr->channel[READ]->netdev = NULL;
-			privptr->channel[WRITE]->netdev = NULL;
-			ctc_proc_destroy_sub(privptr);
-			kfree(privptr);
-			kfree(nd);
-			if (c->netdev != NULL)
-				printk(KERN_EMERG
-				       "ctc: PANIC: channel list corrupted\n");
-		}
-		c = c->next;
-		kfree(oldc->ccw);
-		kfree(oldc);
+#ifndef CTC_CHANDEV
+	while (channels) {
+		if ((channels->flags & CHANNEL_FLAGS_INUSE) &&
+		    (channels->netdev != NULL)) {
+			net_device *dev = channels->netdev;
+			ctc_priv *privptr = dev->priv;
+
+			if (privptr) {
+				privptr->channel[READ]->netdev = NULL;
+				privptr->channel[WRITE]->netdev = NULL;
+			}
+			channels->netdev = NULL;
+			ctc_netdev_unregister(dev);
+			ctc_free_netdevice(dev, 1);
+		}
+		channel_remove(channels);
 	}
+	channels = NULL;
+#endif
+	ctc_tty_cleanup(1);
 	ctc_proc_destroy_main();
+#ifdef CTC_CHANDEV
+	chandev_unregister(ctc_chandev_probe, 1);
+#endif
 	printk(KERN_INFO "CTC driver unloaded\n");
 }
 
@@ -3377,41 +3866,48 @@
  * @return 0 on success, !0 on error.
  */
 int ctc_init(void) {
+#ifndef CTC_CHANDEV
 	int   cnt[2];
 	int   itype;
 	int   activated;
-	int   ret = 0;
 	param *par;
+#endif
+	int   ret = 0;
+	int   probed = 0;
 
 	print_banner();
 
-#ifdef DEBUG
+#if defined(DEBUG) && !defined(CTC_CHANDEV)
 	printk(KERN_DEBUG
-	       "ctc: init_module(): got string '%s'\n", setup);
+	       "ctc: init_module(): got string '%s'\n", ctc);
 #endif
 
+#ifndef CTC_CHANDEV
 #ifdef MODULE
 	ctc_setup(ctc);
 #endif
-	activated = 0;
 	par = params;
+#endif
+
+	activated = 0;
 	ctc_tty_init();
+#ifdef CTC_CHANDEV
+	chandev_register_and_probe(ctc_chandev_probe,
+				   (chandev_shutdownfunc)ctc_shutdown,
+				   ctc_chandev_msck_notify,
+				   chandev_type_ctc|chandev_type_escon);
+#else /* CTC_CHANDEV */
 	for (itype = 0; itype < 2; itype++) {
 		net_device *dev = NULL;
 		char       *bname = (itype) ? "escon" : "ctc";
 
 		cnt[itype] = 0;
 		do {
-			dev = kmalloc(sizeof(net_device)
-#if LINUX_VERSION_CODE < 0x020300
-				      + 11 /* name + zero */
-#endif
-				      , GFP_KERNEL);
+			dev = ctc_init_netdevice(NULL, 1);
 			if (!dev) {
 				ret = -ENOMEM;
 				break;
 			}
-			memset(dev, 0, sizeof(net_device));
 #if LINUX_VERSION_CODE < 0x020300
 			dev->name = (unsigned char *)dev + sizeof(net_device);
 #endif
@@ -3425,7 +3921,9 @@
 					if (isdigit(*p))
 						break;
 				if (p && *p) {
-					int it = (strncmp(dev->name, "escon", 5)) ? 1 : 0;
+					int it =
+						(strncmp(dev->name, "escon", 5))
+						? 1 : 0;
 					n = simple_strtoul(p, NULL, 0);
 					if (n >= cnt[it])
 						cnt[it] = n + 1;
@@ -3433,7 +3931,7 @@
 			} else {
 				if (ctc_no_auto) {
 					itype = 3;
-					kfree(dev);
+					ctc_free_netdevice(dev, 1);
 					dev = NULL;
 					break;
 				}
@@ -3444,6 +3942,7 @@
 			printk(KERN_DEBUG "ctc: %s(): probing for device %s\n",
 						 __FUNCTION__, dev->name);
 #endif			
+			probed = 1;
 			if (ctc_probe(dev) == 0) {
 				ctc_priv *privptr = (ctc_priv *)dev->priv;
 #ifdef DEBUG
@@ -3454,67 +3953,56 @@
 				       "ctc: %s(): registering device %s\n",
 				       __FUNCTION__, dev->name);
 #endif
-				if (privptr->protocol != CTC_PROTO_LINUX_TTY) {
-					if (register_netdev(dev) != 0) {
-						printk(KERN_WARNING
-						       "ctc: Couldn't register netdev %s\n",
-						       dev->name);
-						free_irq(privptr->channel[READ]->irq,
-							 privptr->channel[READ]->devstat);
-						free_irq(privptr->channel[WRITE]->irq,
-							 privptr->channel[WRITE]->devstat);
-						channel_free(privptr->channel[READ]);
-						channel_free(privptr->channel[WRITE]);
-						kfree(dev->priv);
-						kfree(dev);
-					} else {
-#ifdef DEBUG
-						printk(KERN_DEBUG
-						       "ctc: %s(): register succeed\n",
-						       __FUNCTION__);
-#endif			
-						activated++;
-					}
+				if (ctc_netdev_register(dev) != 0) {
+					printk(KERN_WARNING
+					       "ctc: Couldn't register %s\n",
+					       dev->name);
+					FREE_IRQ(
+						privptr->channel[READ]->irq,
+						privptr->channel[READ]->devstat);
+					FREE_IRQ(
+						privptr->channel[WRITE]->irq,
+						privptr->channel[WRITE]->devstat);
+					channel_free(privptr->channel[READ]);
+					channel_free(privptr->channel[WRITE]);
+					ctc_free_netdevice(dev, 1);
+					dev = NULL;
 				} else {
-					if (ctc_tty_register_netdev(dev) != 0) {
-						printk(KERN_WARNING
-						       "ctc: Couldn't register ttydev %s\n",
-						       dev->name);
-						free_irq(privptr->channel[READ]->irq,
-							 privptr->channel[READ]->devstat);
-						free_irq(privptr->channel[WRITE]->irq,
-							 privptr->channel[WRITE]->devstat);
-						channel_free(privptr->channel[READ]);
-						channel_free(privptr->channel[WRITE]);
-						kfree(dev->priv);
-						kfree(dev);
-					} else {
-#ifdef DEBUG
-						printk(KERN_DEBUG
-						       "ctc: %s(): register succeed\n",
-						       __FUNCTION__);
+#ifdef DEBUG
+					printk(KERN_DEBUG
+					       "ctc: %s(): register succeed\n",
+					       __FUNCTION__);
 #endif			
-						activated++;
-					}
+					activated++;
 				}
-				
 			} else {
 #ifdef DEBUG
 				printk(KERN_DEBUG
 				       "ctc: %s(): probing failed\n",
 				       __FUNCTION__);
 #endif			
-				kfree(dev);
 				dev = NULL;
 			}
 		} while (dev && (ret == 0));
 	}
+#endif /* CHANDEV */
+#if !defined(CTC_CHANDEV) && defined(MODULE)
 	if (!activated) {
 		printk(KERN_WARNING "ctc: No devices registered\n");
 		ret = -ENODEV;
 	}
-	if (ret)
-		ctc_tty_cleanup();
+#endif
+	if (ret) {
+		ctc_tty_cleanup(0);
+		ctc_tty_cleanup(1);
+#if defined(CTC_CHANDEV) && defined(MODULE)
+		chandev_unregister(ctc_chandev_probe, 0);
+#endif
+#ifdef MODULE
+		if (probed)
+			ctc_proc_destroy_main();
+#endif
+	}
 	return ret;
 }
 
diff -urN linux/drivers/s390/net/ctctty.c linux-2.4.7/drivers/s390/net/ctctty.c
--- linux/drivers/s390/net/ctctty.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/net/ctctty.c	Mon Dec 17 13:41:19 2001
@@ -1,5 +1,5 @@
 /*
- * $Id: ctctty.c,v 1.1 2001/01/23 14:23:51 felfert Exp $
+ * $Id: ctctty.c,v 1.8 2001/05/16 16:28:31 felfert Exp $
  *
  * CTC / ESCON network driver, tty interface.
  *
@@ -33,7 +33,23 @@
 #  include <linux/devfs_fs_kernel.h>
 #endif
 #include "ctctty.h"
-#include <net/dst.h>
+
+#if LINUX_VERSION_CODE < 0x020212
+typedef struct wait_queue wait_queue_t;
+typedef struct wait_queue *wait_queue_head_t;
+#define DECLARE_WAITQUEUE(wait, current) \
+	struct wait_queue wait = { current, NULL }
+#define init_waitqueue_head(x) *(x)=NULL
+#define __set_current_state(state_value) \
+	do { current->state = state_value; } while (0)
+#ifdef __SMP__
+#define set_current_state(state_value) \
+	do { __set_current_state(state_value); mb(); } while (0)
+#else
+#define set_current_state(state_value) __set_current_state(state_value)
+#endif
+#define init_MUTEX(x) *(x)=MUTEX
+#endif
 
 #define CTC_TTY_MAJOR       43
 #define CTC_TTY_MAX_DEVICES 64
@@ -45,6 +61,8 @@
 #define CTC_ASYNC_CTS_FLOW       0x04000000 /* Do CTS flow control          */
 #define CTC_ASYNC_CHECK_CD       0x02000000 /* i.e., CLOCAL                 */
 #define CTC_ASYNC_HUP_NOTIFY         0x0001 /* Notify tty on hangups/closes */
+#define CTC_ASYNC_NETDEV_OPEN        0x0002 /* Underlying netdev is open    */
+#define CTC_ASYNC_TX_LINESTAT        0x0004 /* Must send line status        */
 #define CTC_ASYNC_SPLIT_TERMIOS      0x0008 /* Sep. termios for dialin/out  */
 #define CTC_TTY_XMIT_SIZE              1024 /* Default bufsize for write    */
 #define CTC_SERIAL_XMIT_MAX            4000 /* Maximum bufsize for write    */
@@ -54,14 +72,13 @@
 typedef struct {
   int			magic;
   int			flags;		 /* defined in tty.h               */
-  int			x_char;		 /* xon/xoff character             */
   int			mcr;		 /* Modem control register         */
   int                   msr;             /* Modem status register          */
   int                   lsr;             /* Line status register           */
   int			line;
   int			count;		 /* # of fd on device              */
   int			blocked_open;	 /* # of blocked opens             */
-	net_device            *netdev;
+  net_device            *netdev;
   struct sk_buff_head   tx_queue;        /* transmit queue                 */
   struct sk_buff_head   rx_queue;        /* receive queue                  */
   struct tty_struct 	*tty;            /* Pointer to corresponding tty   */
@@ -69,7 +86,8 @@
   wait_queue_head_t	open_wait;
   wait_queue_head_t	close_wait;
   struct semaphore      write_sem;
-	struct tq_struct tq;
+  struct tq_struct      tq;
+  struct timer_list     stoptimer;
 } ctc_tty_info;
 
 /* Description of one CTC-tty */
@@ -88,7 +106,7 @@
 #define MODEM_PARANOIA_CHECK
 #define MODEM_DO_RESTART
 
-#define CTC_TTY_NAME "ttyZ"
+#define CTC_TTY_NAME "ctctty"
 
 #ifdef CONFIG_DEVFS_FS
 static char *ctc_ttyname = "ctc/" CTC_TTY_NAME "%d";
@@ -96,7 +114,12 @@
 static char *ctc_ttyname = CTC_TTY_NAME;
 #endif
 
-char *ctc_tty_revision = "$Revision: 1.1 $";
+char *ctc_tty_revision = "$Revision: 1.8 $";
+
+static __u32 ctc_tty_magic = CTC_ASYNC_MAGIC;
+static int ctc_tty_shuttingdown = 0;
+
+static spinlock_t ctc_tty_lock;
 
 /* ctc_tty_try_read() is called from within ctc_tty_rcv_skb()
  * to stuff incoming data directly into a tty's flip-buffer. If the
@@ -120,11 +143,11 @@
 			len = skb->len;
 			if (c >= len) {
 				memcpy(tty->flip.char_buf_ptr, skb->data, len);
+				memset(tty->flip.flag_buf_ptr, 0, len);
 				tty->flip.count += len;
 				tty->flip.char_buf_ptr += len;
-				memset(tty->flip.flag_buf_ptr, 0, len);
 				tty->flip.flag_buf_ptr += len;
-				queue_task(&tty->flip.tqueue, &tq_timer);
+				tty_flip_buffer_push(tty);
 				kfree_skb(skb);
 				return 1;
 			}
@@ -140,7 +163,7 @@
 static int
 ctc_tty_readmodem(ctc_tty_info *info)
 {
-	int ret = 0;
+	int ret = 1;
 	struct tty_struct *tty;
 
 	if ((tty = info->tty)) {
@@ -152,16 +175,19 @@
 				int len = skb->len;
 				if (len > c)
 					len = c;
-				memcpy(tty->flip.char_buf_ptr, skb_pull(skb, len), len);
-				tty->flip.count += len;
+				memcpy(tty->flip.char_buf_ptr, skb->data, len);
+				skb_pull(skb, len);
 				memset(tty->flip.flag_buf_ptr, 0, len);
+				tty->flip.count += len;
+				tty->flip.char_buf_ptr += len;
 				tty->flip.flag_buf_ptr += len;
-				queue_task(&tty->flip.tqueue, &tq_timer);
-				if (skb->len) {
+				tty_flip_buffer_push(tty);
+				if (skb->len > 0)
 					skb_queue_head(&info->rx_queue, skb);
-					ret = 1;
-				} else
+				else {
 					kfree_skb(skb);
+					ret = skb_queue_len(&info->rx_queue);
+				}
 			}
 		}
 	}
@@ -169,6 +195,25 @@
 }
 
 void
+ctc_tty_setcarrier(net_device *netdev, int on)
+{
+	int i;
+
+	if ((!driver) || ctc_tty_shuttingdown)
+		return;
+	for (i = 0; i < CTC_TTY_MAX_DEVICES; i++)
+		if (driver->info[i].netdev == netdev) {
+			ctc_tty_info *info = &driver->info[i];
+			if (on)
+				info->msr |= UART_MSR_DCD;
+			else
+				info->msr &= ~UART_MSR_DCD;
+			if ((info->flags & CTC_ASYNC_CHECK_CD) && (!on))
+				tty_hangup(info->tty);
+		}
+}
+
+void
 ctc_tty_netif_rx(struct sk_buff *skb)
 {
 	int i;
@@ -176,7 +221,7 @@
 
 	if (!skb)
 		return;
-	if (!skb->dev) {
+	if ((!skb->dev) || (!driver) || ctc_tty_shuttingdown) {
 		dev_kfree_skb(skb);
 		return;
 	}
@@ -189,7 +234,35 @@
 		dev_kfree_skb(skb);
 		return;
 	}
-	skb_pull(skb, sizeof(int));
+	if (skb->len < 6) {
+		dev_kfree_skb(skb);
+		return;
+	}
+	if (memcmp(skb->data, &ctc_tty_magic, sizeof(__u32))) {
+		dev_kfree_skb(skb);
+		return;
+	}
+	skb_pull(skb, sizeof(__u32));
+
+	i = *((int *)skb->data);
+	skb_pull(skb, sizeof(info->mcr));
+	if (i & UART_MCR_RTS) {
+		info->msr |= UART_MSR_CTS;
+		if (info->flags & CTC_ASYNC_CTS_FLOW)
+			info->tty->hw_stopped = 0;
+	} else {
+		info->msr &= ~UART_MSR_CTS;
+		if (info->flags & CTC_ASYNC_CTS_FLOW)
+			info->tty->hw_stopped = 1;
+	}
+	if (i & UART_MCR_DTR)
+		info->msr |= UART_MSR_DSR;
+	else
+		info->msr &= ~UART_MSR_DSR;
+	if (skb->len <= 0) {
+		kfree_skb(skb);
+		return;
+	}
 	/* Try to deliver directly via tty-flip-buf if queue is empty */
 	if (skb_queue_empty(&info->rx_queue))
 		if (ctc_tty_try_read(info, skb))
@@ -203,46 +276,70 @@
 	mark_bh(IMMEDIATE_BH);
 }
 
-static void
-ctc_tty_dstfail(struct sk_buff *skb) {
-	if (!skb)
-		return;
-	dev_kfree_skb(skb);
-	return;
-}
-
-static struct dst_entry dst_e;
-static struct dst_ops   dst_o;
-
 static int
 ctc_tty_tint(ctc_tty_info * info)
 {
 	struct sk_buff *skb = skb_dequeue(&info->tx_queue);
+	int stopped = (info->tty->hw_stopped || info->tty->stopped);
+	int wake = 1;
 	int rc;
-	int l;
-	char c;
 
-	if (!skb)
-		return 0;
 	if (!info->netdev) {
-		kfree(skb);
+		if (skb)
+			kfree(skb);
 		return 0;
 	}
-	skb->dst = &dst_e;
-	l = skb->len;
-	c = *(skb->data);
-	rc = info->netdev->hard_start_xmit(skb, info->netdev);
-printk(KERN_DEBUG "xmit: l=%d rc=%d '%02x'\n", l, rc, c);
-	if (rc) {
+	if (info->flags & CTC_ASYNC_TX_LINESTAT) {
+		int skb_res = info->netdev->hard_header_len +
+			sizeof(info->mcr) + sizeof(__u32);
+		/* If we must update line status,
+		 * create an empty dummy skb and insert it.
+		 */
+		if (skb)
+			skb_queue_head(&info->tx_queue, skb);
+
+		skb = dev_alloc_skb(skb_res);
+		if (!skb) {
+			printk(KERN_WARNING
+			       "ctc_tty: Out of memory in %s%d tint\n",
+			       CTC_TTY_NAME, info->line);
+			return 1;
+		}
+		skb_reserve(skb, skb_res);
+		stopped = 0;
+		wake = 0;
+	}
+	if (!skb)
+		return 0;
+	if (stopped) {
 		skb_queue_head(&info->tx_queue, skb);
 		return 1;
+	}
+#if 0
+	if (skb->len > 0)
+		printk(KERN_DEBUG "tint: %d %02x\n", skb->len, *(skb->data));
+	else
+		printk(KERN_DEBUG "tint: %d STAT\n", skb->len);
+#endif
+	memcpy(skb_push(skb, sizeof(info->mcr)), &info->mcr, sizeof(info->mcr));
+	memcpy(skb_push(skb, sizeof(__u32)), &ctc_tty_magic, sizeof(__u32));
+	rc = info->netdev->hard_start_xmit(skb, info->netdev);
+	if (rc) {
+		skb_pull(skb, sizeof(info->mcr) + sizeof(__u32));
+		if (skb->len > 0)
+			skb_queue_head(&info->tx_queue, skb);
+		else
+			kfree_skb(skb);
 	} else {
 		struct tty_struct *tty = info->tty;
-		info->lsr |= UART_LSR_TEMT;
-		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-		    tty->ldisc.write_wakeup)
-			(tty->ldisc.write_wakeup)(tty);
-		wake_up_interruptible(&tty->write_wait);
+
+		info->flags &= ~CTC_ASYNC_TX_LINESTAT;
+		if (tty) {
+			if (wake && (tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+			    tty->ldisc.write_wakeup)
+				(tty->ldisc.write_wakeup)(tty);
+			wake_up_interruptible(&tty->write_wait);
+		}
 	}
 	return (skb_queue_empty(&info->tx_queue) ? 0 : 1);
 }
@@ -274,6 +371,40 @@
 }
 
 static void
+ctc_tty_inject(ctc_tty_info *info, char c)
+{
+	int skb_res;
+	struct sk_buff *skb;
+	
+	if (ctc_tty_shuttingdown)
+		return;
+	skb_res = info->netdev->hard_header_len + sizeof(info->mcr) +
+		sizeof(__u32) + 1;
+	skb = dev_alloc_skb(skb_res);
+	if (!skb) {
+		printk(KERN_WARNING
+		       "ctc_tty: Out of memory in %s%d tx_inject\n",
+		       CTC_TTY_NAME, info->line);
+		return;
+	}
+	skb_reserve(skb, skb_res);
+	*(skb_put(skb, 1)) = c;
+	skb_queue_head(&info->tx_queue, skb);
+	queue_task(&info->tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static void
+ctc_tty_transmit_status(ctc_tty_info *info)
+{
+	if (ctc_tty_shuttingdown)
+		return;
+	info->flags |= CTC_ASYNC_TX_LINESTAT;
+	queue_task(&info->tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+}
+
+static void
 ctc_tty_change_speed(ctc_tty_info * info)
 {
 	unsigned int cflag;
@@ -294,8 +425,12 @@
 	}
 	if (quot) {
 		info->mcr |= UART_MCR_DTR;
+		info->mcr |= UART_MCR_RTS;
+		ctc_tty_transmit_status(info);
 	} else {
 		info->mcr &= ~UART_MCR_DTR;
+		info->mcr &= ~UART_MCR_RTS;
+		ctc_tty_transmit_status(info);
 		return;
 	}
 
@@ -331,11 +466,24 @@
 	ctc_tty_change_speed(info);
 
 	info->flags |= CTC_ASYNC_INITIALIZED;
-	info->msr |= (UART_MSR_DSR | UART_MSR_CTS);
-	info->netdev->open(info->netdev);
+	if (!(info->flags & CTC_ASYNC_NETDEV_OPEN))
+		info->netdev->open(info->netdev);
+	info->flags |= CTC_ASYNC_NETDEV_OPEN;
 	return 0;
 }
 
+static void
+ctc_tty_stopdev(unsigned long data)
+{
+	ctc_tty_info *info = (ctc_tty_info *)data;
+
+	if ((!info) || (!info->netdev) ||
+	    (info->flags & CTC_ASYNC_INITIALIZED))
+		return;
+	info->netdev->stop(info->netdev);
+	info->flags &= ~CTC_ASYNC_NETDEV_OPEN;
+}
+
 /*
  * This routine will shutdown a serial port; interrupts are disabled, and
  * DTR is dropped if the hangup on close termio flag is on.
@@ -349,12 +497,11 @@
 	printk(KERN_DEBUG "Shutting down %s%d ....\n", CTC_TTY_NAME, info->line);
 #endif
 	info->msr &= ~UART_MSR_RI;
-	if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
+	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
 		info->mcr &= ~(UART_MCR_DTR | UART_MCR_RTS);
-	}
 	if (info->tty)
 		set_bit(TTY_IO_ERROR, &info->tty->flags);
-	info->netdev->stop(info->netdev);
+	mod_timer(&info->stoptimer, jiffies + (10 * HZ));
 	skb_queue_purge(&info->tx_queue);
 	skb_queue_purge(&info->rx_queue);
 	info->flags &= ~CTC_ASYNC_INITIALIZED;
@@ -376,6 +523,8 @@
 	int total = 0;
 	ctc_tty_info *info = (ctc_tty_info *) tty->driver_data;
 
+	if (ctc_tty_shuttingdown)
+		return 0;
 	if (ctc_tty_paranoia_check(info, tty->device, "ctc_tty_write"))
 		return 0;
 	if (!tty)
@@ -392,7 +541,8 @@
 		if (c <= 0)
 			break;
 		
-		skb_res = info->netdev->hard_header_len + sizeof(int);
+		skb_res = info->netdev->hard_header_len + sizeof(info->mcr) +
+			+ sizeof(__u32);
 		skb = dev_alloc_skb(skb_res + c);
 		if (!skb) {
 			printk(KERN_WARNING
@@ -411,6 +561,7 @@
 		count -= c;
 	}
 	if (skb_queue_len(&info->tx_queue)) {
+		info->lsr &= ~UART_LSR_TEMT;
 		queue_task(&info->tq, &tq_immediate);
 		mark_bh(IMMEDIATE_BH);
 	}
@@ -457,6 +608,7 @@
 		return;
 	}
 	skb_queue_purge(&info->tx_queue);
+	info->lsr |= UART_LSR_TEMT;
 	restore_flags(flags);
 	wake_up_interruptible(&tty->write_wait);
 	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
@@ -469,12 +621,14 @@
 {
 	ctc_tty_info *info = (ctc_tty_info *) tty->driver_data;
 
+	if (ctc_tty_shuttingdown)
+		return;
 	if (ctc_tty_paranoia_check(info, tty->device, "ctc_tty_flush_chars"))
 		return;
-	if (skb_queue_len(&info->tx_queue)) {
-		queue_task(&info->tq, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
-	}
+	if (tty->stopped || tty->hw_stopped || (!skb_queue_len(&info->tx_queue)))
+		return;
+	queue_task(&info->tq, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
 }
 
 /*
@@ -492,9 +646,10 @@
 
 	if (ctc_tty_paranoia_check(info, tty->device, "ctc_tty_throttle"))
 		return;
-	if (I_IXOFF(tty))
-		info->x_char = STOP_CHAR(tty);
 	info->mcr &= ~UART_MCR_RTS;
+	if (I_IXOFF(tty))
+		ctc_tty_inject(info, STOP_CHAR(tty));
+	ctc_tty_transmit_status(info);
 }
 
 static void
@@ -504,13 +659,10 @@
 
 	if (ctc_tty_paranoia_check(info, tty->device, "ctc_tty_unthrottle"))
 		return;
-	if (I_IXOFF(tty)) {
-		if (info->x_char)
-			info->x_char = 0;
-		else
-			info->x_char = START_CHAR(tty);
-	}
 	info->mcr |= UART_MCR_RTS;
+	if (I_IXOFF(tty))
+		ctc_tty_inject(info, START_CHAR(tty));
+	ctc_tty_transmit_status(info);
 }
 
 /*
@@ -573,6 +725,7 @@
 ctc_tty_set_ctc_tty_info(ctc_tty_info * info, uint cmd, uint * value)
 {
 	uint arg;
+	int old_mcr = info->mcr & (UART_MCR_RTS | UART_MCR_DTR);
 
 	get_user(arg, (uint *) value);
 	switch (cmd) {
@@ -581,24 +734,20 @@
 			printk(KERN_DEBUG "%s%d ioctl TIOCMBIS\n", CTC_TTY_NAME,
 			       info->line);
 #endif
-			if (arg & TIOCM_RTS) {
+			if (arg & TIOCM_RTS)
 				info->mcr |= UART_MCR_RTS;
-			}
-			if (arg & TIOCM_DTR) {
+			if (arg & TIOCM_DTR)
 				info->mcr |= UART_MCR_DTR;
-			}
 			break;
 		case TIOCMBIC:
 #ifdef CTC_DEBUG_MODEM_IOCTL
 			printk(KERN_DEBUG "%s%d ioctl TIOCMBIC\n", CTC_TTY_NAME,
 			       info->line);
 #endif
-			if (arg & TIOCM_RTS) {
+			if (arg & TIOCM_RTS)
 				info->mcr &= ~UART_MCR_RTS;
-			}
-			if (arg & TIOCM_DTR) {
+			if (arg & TIOCM_DTR)
 				info->mcr &= ~UART_MCR_DTR;
-			}
 			break;
 		case TIOCMSET:
 #ifdef CTC_DEBUG_MODEM_IOCTL
@@ -612,6 +761,8 @@
 		default:
 			return -EINVAL;
 	}
+	if ((info->mcr  & (UART_MCR_RTS | UART_MCR_DTR)) != old_mcr)
+		ctc_tty_transmit_status(info);
 	return 0;
 }
 
@@ -709,18 +860,30 @@
 ctc_tty_set_termios(struct tty_struct *tty, struct termios *old_termios)
 {
 	ctc_tty_info *info = (ctc_tty_info *) tty->driver_data;
+	unsigned int cflag = tty->termios->c_cflag;
 
-	if (!old_termios)
-		ctc_tty_change_speed(info);
-	else {
-		if (tty->termios->c_cflag == old_termios->c_cflag)
-			return;
-		ctc_tty_change_speed(info);
-		if ((old_termios->c_cflag & CRTSCTS) &&
-		    !(tty->termios->c_cflag & CRTSCTS)) {
-			tty->hw_stopped = 0;
-		}
+	ctc_tty_change_speed(info);
+
+	/* Handle transition to B0 */
+	if ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD)) {
+		info->mcr &= ~(UART_MCR_DTR|UART_MCR_RTS);
+		ctc_tty_transmit_status(info);
+	}
+
+	/* Handle transition from B0 to other */
+	if (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {
+		info->mcr |= UART_MCR_DTR;
+		if (!(tty->termios->c_cflag & CRTSCTS) ||
+                    !test_bit(TTY_THROTTLED, &tty->flags)) {
+                        info->mcr |= UART_MCR_RTS;
+                }
+		ctc_tty_transmit_status(info);
 	}
+
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) &&
+            !(tty->termios->c_cflag & CRTSCTS))
+                tty->hw_stopped = 0;
 }
 
 /*
@@ -836,6 +999,7 @@
 ctc_tty_open(struct tty_struct *tty, struct file *filp)
 {
 	ctc_tty_info *info;
+	unsigned long saveflags;
 	int retval,
 	 line;
 
@@ -851,9 +1015,11 @@
 	printk(KERN_DEBUG "ctc_tty_open %s%d, count = %d\n", tty->driver.name,
 	       info->line, info->count);
 #endif
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
 	info->count++;
 	tty->driver_data = info;
 	info->tty = tty;
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 	/*
 	 * Start up serial port
 	 */
@@ -885,6 +1051,7 @@
 ctc_tty_close(struct tty_struct *tty, struct file *filp)
 {
 	ctc_tty_info *info = (ctc_tty_info *) tty->driver_data;
+	unsigned long saveflags;
 	ulong flags;
 	ulong timeout;
 
@@ -958,7 +1125,9 @@
 		tty->driver.flush_buffer(tty);
 	if (tty->ldisc.flush_buffer)
 		tty->ldisc.flush_buffer(tty);
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
 	info->tty = 0;
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 	tty->closing = 0;
 	if (info->blocked_open) {
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -980,13 +1149,16 @@
 ctc_tty_hangup(struct tty_struct *tty)
 {
 	ctc_tty_info *info = (ctc_tty_info *)tty->driver_data;
+	unsigned long saveflags;
 
 	if (ctc_tty_paranoia_check(info, tty->device, "ctc_tty_hangup"))
 		return;
 	ctc_tty_shutdown(info);
 	info->count = 0;
 	info->flags &= ~CTC_ASYNC_NORMAL_ACTIVE;
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
 	info->tty = 0;
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 	wake_up_interruptible(&info->open_wait);
 }
 
@@ -998,14 +1170,21 @@
 static void
 ctc_tty_task(ctc_tty_info *info)
 {
+	unsigned long saveflags;
 	int again;
 
-	again = ctc_tty_tint(info);
-	again |= ctc_tty_readmodem(info);
-	if (again) {
-		queue_task(&info->tq, &tq_immediate);
-		mark_bh(IMMEDIATE_BH);
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
+	if ((!ctc_tty_shuttingdown) && info) {
+		again = ctc_tty_tint(info);
+		if (!again)
+			info->lsr |= UART_LSR_TEMT;
+		again |= ctc_tty_readmodem(info);
+		if (again) {
+			queue_task(&info->tq, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+		}
 	}
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 }
 
 int
@@ -1015,8 +1194,6 @@
 	ctc_tty_info *info;
 	struct tty_driver *device;
 
-	dst_e.ops = &dst_o;
-	dst_o.link_failure = ctc_tty_dstfail;
 	driver = kmalloc(sizeof(ctc_tty_driver), GFP_KERNEL);
 	if (driver == NULL) {
 		printk(KERN_WARNING "Out of memory in ctc_tty_modem_init\n");
@@ -1064,14 +1241,17 @@
 	for (i = 0; i < CTC_TTY_MAX_DEVICES; i++) {
 		info = &driver->info[i];
 		init_MUTEX(&info->write_sem);
+#if LINUX_VERSION_CODE >= 0x020400
 		INIT_LIST_HEAD(&info->tq.list);
+#else
+		info->tq.next    = NULL;
+#endif
 		info->tq.sync    = 0;
 		info->tq.routine = (void *)(void *)ctc_tty_task;
 		info->tq.data    = info;
 		info->magic = CTC_ASYNC_MAGIC;
 		info->line = i;
 		info->tty = 0;
-		info->x_char = 0;
 		info->count = 0;
 		info->blocked_open = 0;
 		info->normal_termios = device->init_termios;
@@ -1079,6 +1259,10 @@
 		init_waitqueue_head(&info->close_wait);
 		skb_queue_head_init(&info->tx_queue);
 		skb_queue_head_init(&info->rx_queue);
+		init_timer(&info->stoptimer);
+		info->stoptimer.function = ctc_tty_stopdev;
+		info->stoptimer.data = (unsigned long)info;
+		info->mcr = UART_MCR_RTS;
 	}
 	return 0;
 }
@@ -1118,8 +1302,10 @@
 void
 ctc_tty_unregister_netdev(net_device *dev) {
 	int i;
+	unsigned long saveflags;
 	ctc_tty_info *info = NULL;
 
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
 	for (i = 0; i < CTC_TTY_MAX_DEVICES; i++)
 		if (driver->info[i].netdev == dev) {
 			info = &driver->info[i];
@@ -1130,10 +1316,24 @@
 		skb_queue_purge(&info->tx_queue);
 		skb_queue_purge(&info->rx_queue);
 	}
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 }
 
 void
-ctc_tty_cleanup(void) {
-	tty_unregister_driver(&driver->ctc_tty_device);
-	kfree(driver);
+ctc_tty_cleanup(int final) {
+	unsigned long saveflags;
+	
+	spin_lock_irqsave(&ctc_tty_lock, saveflags);
+	ctc_tty_shuttingdown = 1;
+	if (final) {
+		kfree(driver);
+		driver = NULL;
+	} else {
+		int i;
+
+		for (i = 0; i < CTC_TTY_MAX_DEVICES; i++)
+			driver->info[i].tq.routine = NULL;
+		tty_unregister_driver(&driver->ctc_tty_device);
+	}
+	spin_unlock_irqrestore(&ctc_tty_lock, saveflags);
 }
diff -urN linux/drivers/s390/net/ctctty.h linux-2.4.7/drivers/s390/net/ctctty.h
--- linux/drivers/s390/net/ctctty.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/net/ctctty.h	Mon Dec 17 13:41:19 2001
@@ -1,5 +1,5 @@
 /*
- * $Id: ctctty.h,v 1.2 2001/01/30 22:09:28 uweigand Exp $
+ * $Id: ctctty.h,v 1.4 2001/03/22 12:46:01 felfert Exp $
  *
  * CTC / ESCON network driver, tty interface.
  *
@@ -34,10 +34,11 @@
 typedef struct net_device  net_device;
 #endif
 
-extern int  ctc_tty_register_netdev(net_device *dev);
-extern void ctc_tty_unregister_netdev(net_device *dev);
-extern void ctc_tty_netif_rx(struct sk_buff *skb);
+extern int  ctc_tty_register_netdev(net_device *);
+extern void ctc_tty_unregister_netdev(net_device *);
+extern void ctc_tty_netif_rx(struct sk_buff *);
 extern int  ctc_tty_init(void);
-extern void ctc_tty_cleanup(void);
+extern void ctc_tty_cleanup(int);
+extern void ctc_tty_setcarrier(net_device *, int);
 
 #endif
diff -urN linux/drivers/s390/net/fsm.c linux-2.4.7/drivers/s390/net/fsm.c
--- linux/drivers/s390/net/fsm.c	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/net/fsm.c	Mon Dec 17 13:41:19 2001
@@ -1,23 +1,14 @@
 /**
- * $Id: fsm.c,v 1.1 2000/11/30 11:21:08 bird Exp $
+ * $Id: fsm.c,v 1.3 2001/06/18 16:49:19 felfert Exp $
  *
  * A generic FSM based on fsm used in isdn4linux
  *
- * $Log: fsm.c,v $
- * Revision 1.1  2000/11/30 11:21:08  bird
- * Support for new ctc driver
- *
- * Revision 1.2  2000/11/10 17:25:11  felfert
- * Changes for kernel 2.4
- *
- * Revision 1.1  2000/11/03 16:58:45  felfert
- * Initial import
- *
- *
  */
 
 #include "fsm.h"
 #include <linux/version.h>
+#include <linux/config.h>
+#include <linux/module.h>
 
 fsm_instance *
 init_fsm(char *name, const char **state_names, const char **event_names, int nr_states,
@@ -228,3 +219,16 @@
 	this->tl.expires = jiffies + (millisec * HZ) / 1000;
 	add_timer(&this->tl);
 }
+
+EXPORT_SYMBOL(init_fsm);
+EXPORT_SYMBOL(kfree_fsm);
+EXPORT_SYMBOL(fsm_settimer);
+EXPORT_SYMBOL(fsm_deltimer);
+EXPORT_SYMBOL(fsm_addtimer);
+EXPORT_SYMBOL(fsm_modtimer);
+EXPORT_SYMBOL(fsm_getstate_str);
+
+#if FSM_DEBUG_HISTORY
+EXPORT_SYMBOL(fsm_print_history);
+EXPORT_SYMBOL(fsm_record_history);
+#endif
diff -urN linux/drivers/s390/net/fsm.h linux-2.4.7/drivers/s390/net/fsm.h
--- linux/drivers/s390/net/fsm.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/net/fsm.h	Mon Dec 17 13:42:42 2001
@@ -1,13 +1,4 @@
-/* $Id: fsm.h,v 1.1 2000/11/30 11:21:08 bird Exp $
- *
- * $Log: fsm.h,v $
- * Revision 1.1  2000/11/30 11:21:08  bird
- * Support for new ctc driver
- *
- * Revision 1.1  2000/11/03 16:58:45  felfert
- * Initial import
- *
- *
+/* $Id: fsm.h,v 1.4 2001/09/24 10:38:02 mschwide Exp $
  */
 #ifndef _FSM_H_
 #define _FSM_H_
@@ -16,7 +7,7 @@
 #include <linux/types.h>
 #include <linux/timer.h>
 #include <linux/time.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/string.h>
 #include <asm/atomic.h>
@@ -115,10 +106,11 @@
  * @param tmpl_len    Length of the describing array.
  * @param order       Parameter for allocation of the FSM data structs.
  */
-fsm_instance * init_fsm(char *name, const char **state_names,
-			const char **event_names,
-			int nr_states, int nr_events, const fsm_node *tmpl,
-			int tmpl_len, int order);
+extern fsm_instance *
+init_fsm(char *name, const char **state_names,
+	 const char **event_names,
+	 int nr_states, int nr_events, const fsm_node *tmpl,
+	 int tmpl_len, int order);
 
 /**
  * Releases an FSM
diff -urN linux/drivers/s390/net/iucv.c linux-2.4.7/drivers/s390/net/iucv.c
--- linux/drivers/s390/net/iucv.c	Thu Apr 12 15:16:35 2001
+++ linux-2.4.7/drivers/s390/net/iucv.c	Mon Dec 17 13:42:42 2001
@@ -1,2029 +1,2274 @@
 /*
- *  drivers/s390/net/iucv.c
- *    Support for VM IUCV functions for use by other part of the
- *    kernel or loadable modules.
- *
- *  S390 version
- *    Copyright (C) 2000 IBM Corporation
- *    Author(s): Xenia Tkatschow (xenia@us.ibm.com)
- *               Alan Altmark (Alan_Altmark@us.ibm.com)
+ * $Id$
+ *
+ * IUCV network driver
+ *
+ * Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
+ * Author(s):
+ *    Original source:
+ *      Alan Altmark (Alan_Altmark@us.ibm.com)  Sept. 2000
+ *      Xenia Tkatschow (xenia@us.ibm.com)
+ *    2Gb awareness and general cleanup:
+ *      Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)
+ *
+ * Documentation used:
+ *    The original source
+ *    CP Programming Service, IBM document # SC24-5760
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * RELEASE-TAG: IUCV lowlevel driver $Revision$
+ *
  */
-
+
 #include <linux/module.h>
+#include <linux/config.h>
+
 #include <linux/version.h>
 #include <linux/spinlock.h>
 #include <linux/kernel.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/init.h>
 #include <linux/tqueue.h>
 #include <linux/interrupt.h>
+#include <linux/list.h>
 #include <asm/atomic.h>
 #include "iucv.h"
 #include <asm/io.h>
+#include <asm/irq.h>
 #include <asm/s390_ext.h>
 #include <asm/ebcdic.h>
 
-#undef KERN_DEBUG
-#define KERN_DEBUG KERN_EMERG
-//#define DEBUG3
-//#define DEBUG         /* Turns Printk's on                         */
-//#define DEBUG2        /* This prints the parameter list before and */
-		      /* after the b2f0 call to cp                 */
-#undef NULL
-#define NULL 0
-#define ADDED_STOR 64		/* ADDITIONAL STORAGE FOR PATHID @'S */
-ulong declare_flag = 0;
-static uchar iucv_external_int_buffer[40];
-struct tq_struct short_task;	/* automatically initialized to zero */
-static iucv_interrupt_ops_t my_ops;
-spinlock_t lock = SPIN_LOCK_UNLOCKED;
-
-static void do_int (iucv_ConnectionPending *);
-
-/***************INTERRUPT HANDLING DEFINITIONS***************/
-typedef struct _iucv_packet {
-	struct _iucv_packet *next;
-	uchar data[40];
-} iucv_packet;
-struct tq_struct short_task;
-static spinlock_t iucv_packets_lock = SPIN_LOCK_UNLOCKED;
-iucv_packet *iucv_packets_head, *iucv_packets_tail;
-
-static atomic_t bh_scheduled = ATOMIC_INIT (0);
-void bottom_half_interrupt (void);
-
-/************FUNCTION ID'S****************************/
-#define accept          10
-#define connect         11
-#define declare_buffer  12
-#define purge           9
-#define query           0
-#define quiesc          13
-#define receive         5
-#define reject          8
-#define reply           6
-#define resume          14
-#define retrieve_buffer 2
-#define send            4
-#define setmask         16
-#define sever           15
-
-/*****************************************************************/
-/*  Structure: handler                                           */
-/*  members: next - is a pointer to next handler on chain        */
-/*           prev - is a pointer to prev handler on chain        */
-/*           vmid - 8 char array of machine identification       */
-/*           user_data - 16 char array for user identification   */
-/*           mask - 24 char array used to compare the 2 previous */
-/*           interrupt_table - functions for interrupts          */
-/*           start - pointer to start of block of pointers to    */
-/*                   handler_table_entries                       */
-/*           end - pointer to end of block of pointers to        */
-/*                 handler_table_entries                         */
-/*           size - ulong, size of block                         */
-/*           pgm_data - ulong, program data                      */
-/* NOTE: Keep vmid and user_data together in this order          */
-/*****************************************************************/
+#undef DEBUG
+
+#ifndef min
+#define min(a,b) (((a)<(b))?(a):(b))
+#endif
+
+/* FLAGS:
+ * All flags are defined in the field IPFLAGS1 of each function
+ * and can be found in CP Programming Services.
+ * IPSRCCLS - Indicates you have specified a source class
+ * IPFGMCL  - Indicates you have specified a target class
+ * IPFGPID  - Indicates you have specified a pathid
+ * IPFGMID  - Indicates you have specified a message ID
+ * IPANSLST - Indicates that you are using an address list for
+ *            reply data
+ * IPBUFLST - Indicates that you are using an address list for
+ *            message data
+ */
+
+#define IPSRCCLS 	0x01
+#define IPFGMCL         0x01
+#define IPFGPID         0x02
+#define IPFGMID         0x04
+#define IPANSLST        0x08
+#define IPBUFLST        0x40
+
+/* General IUCV interrupt structure */
 typedef struct {
-	ulong *next;
-	ulong *prev;
-	uchar vmid[8];
-	uchar user_data[16];
-	uchar mask[24];
+	__u16 ippathid;
+	__u8  res1;
+	__u8  iptype;
+	__u32 res2;
+	__u8  ipvmid[8];
+	__u8  res3[24];
+} iucv_GeneralInterrupt;
+
+static iucv_GeneralInterrupt *iucv_external_int_buffer;
+
+/* Spin Lock declaration */
+
+static spinlock_t iucv_lock = SPIN_LOCK_UNLOCKED;
+
+/***************INTERRUPT HANDLING ***************/
+
+typedef struct {
+	struct list_head queue;
+	iucv_GeneralInterrupt data;
+} iucv_irqdata;
+
+struct list_head  iucv_irq_queue;
+static spinlock_t iucv_irq_queue_lock = SPIN_LOCK_UNLOCKED;
+
+struct tq_struct  iucv_tq;
+
+static atomic_t   iucv_bh_scheduled = ATOMIC_INIT (0);
+
+/*
+ *Internal function prototypes
+ */
+static void iucv_bh_handler(void);
+static void iucv_irq_handler(struct pt_regs *, __u16);
+
+/************ FUNCTION ID'S ****************************/
+
+#define ACCEPT          10
+#define CONNECT         11
+#define DECLARE_BUFFER  12
+#define PURGE           9
+#define QUERY           0
+#define QUIESCE         13
+#define RECEIVE         5
+#define REJECT          8
+#define REPLY           6
+#define RESUME          14
+#define RETRIEVE_BUFFER 2
+#define SEND            4
+#define SETMASK         16
+#define SEVER           15
+
+/**
+ * Structure: handler
+ * members: list - list management.
+ *          structure: id
+ *             userid - 8 char array of machine identification
+ *             user_data - 16 char array for user identification
+ *             mask - 24 char array used to compare the 2 previous
+ *          interrupt_table - vector of interrupt functions.
+ *          pgm_data -  ulong, application data that is passed
+ *                      to the interrupt handlers
+*/
+typedef struct handler_t {
+	struct list_head list;
+	struct {
+		__u8 userid[8];
+		__u8 user_data[16];
+		__u8 mask[24];
+	}                    id;
 	iucv_interrupt_ops_t *interrupt_table;
-	ulong *start;
-	ulong *end;
-	ulong size;
-	ulong pgm_data;
+	void                 *pgm_data;
 } handler;
 
-/*******************************************************************/
-/* Structure: handler_table_entry                                  */
-/* members: addrs - pointer to a handler                           */
-/*          pathid - ushort containing path identification         */
-/*          pgm_data - ulong, program data                         */
-/*******************************************************************/
-typedef struct {
-	handler *addrs;
-	ushort pathid;
-	ulong pgm_data;
-} handler_table_entry;
-
-/* main_table: array of pointers to handler_tables         */
-static handler_table_entry *main_table[128];
-/* handler_anchor: points to first handler on chain        */
-static handler *handler_anchor;
-
-/****************FIVE  STRUCTURES************************************/
-/* Data struct 1: iparml_control                                    */
-/*                Used for iucv_accept                              */
-/*                         iucv_connect                             */
-/*                         iucv_quiesce                             */
-/*                         iucv_resume                              */
-/*                         iucv_sever                               */
-/*                         iucv_retrieve_buffer                     */
-/* Data struct 2: iparml_dpl  (data in parameter list)              */
-/*                Used for iucv_send_prmmsg                         */
-/*                         iucv_send2way_prmmsg                     */
-/*                         iucv_send2way_prmmsg_array               */
-/*                         iucv_reply_prmmsg                        */
-/* Data struct 3: iparml_db    (data in a buffer)                   */
-/*                Used for iucv_receive                             */
-/*                         iucv_receive_array                       */
-/*                         iucv_receive_simple                      */
-/*                         iucv_reject                              */
-/*                         iucv_reply                               */
-/*                         iucv_reply_array                         */
-/*                         iucv_send                                */
-/*                         iucv_send_simple                         */
-/*                         iucv_send_array                          */
-/*                         iucv_send2way                            */
-/*                         iucv_send2way_array                      */
-/*                         iucv_declare_buffer                      */
-/* Data struct 4: iparml_purge                                      */
-/*                Used for iucv_purge                               */
-/*                         iucv_query                               */
-/* Data struct 5: iparml_set_mask                                   */
-/*                Used for iucv_set_mask                            */
-/********************************************************************/
+/**
+ * iucv_handler_table: List of registered handlers.
+ */
+static struct list_head iucv_handler_table;
+
+/**
+ * iucv_pathid_table: an array of *handler pointing into
+ *                    iucv_handler_table for fast indexing by pathid;
+ */
+static handler **iucv_pathid_table;
+
+static unsigned long max_connections;
+
+/**
+ * declare_flag: is 0 when iucv_declare_buffer has not been called
+ */
+static int declare_flag;
+
+/****************FIVE 40-BYTE PARAMETER STRUCTURES******************/
+/* Data struct 1: iparml_control
+ * Used for iucv_accept
+ *          iucv_connect
+ *          iucv_quiesce
+ *          iucv_resume
+ *          iucv_sever
+ *          iucv_retrieve_buffer
+ * Data struct 2: iparml_dpl     (data in parameter list)
+ * Used for iucv_send_prmmsg
+ *          iucv_send2way_prmmsg
+ *          iucv_send2way_prmmsg_array
+ *          iucv_reply_prmmsg
+ * Data struct 3: iparml_db       (data in a buffer)
+ * Used for iucv_receive
+ *          iucv_receive_array
+ *          iucv_reject
+ *          iucv_reply
+ *          iucv_reply_array
+ *          iucv_send
+ *          iucv_send_array
+ *          iucv_send2way
+ *          iucv_send2way_array
+ *          iucv_declare_buffer
+ * Data struct 4: iparml_purge
+ * Used for iucv_purge
+ *          iucv_query
+ * Data struct 5: iparml_set_mask
+ * Used for iucv_set_mask
+ */
+
 typedef struct {
-	ushort ippathid;
-	uchar ipflags1;
-	uchar iprcode;
-	ushort ipmsglim;
-	ushort res1;
-	uchar ipvmid[8];
-	uchar ipuser[16];
-	uchar iptarget[8];
+	__u16 ippathid;
+	__u8  ipflags1;
+	__u8  iprcode;
+	__u16 ipmsglim;
+	__u16 res1;
+	__u8  ipvmid[8];
+	__u8  ipuser[16];
+	__u8  iptarget[8];
 } iparml_control;
 
-/******************/
 typedef struct {
-	ushort ippathid;
-	uchar ipflags1;
-	uchar iprcode;
-	ulong ipmsgid;
-	ulong iptrgcls;
-	uchar iprmmsg[8];
-	ulong ipsrccls;
-	ulong ipmsgtag;
-	ulong ipbfadr2;
-	ulong ipbfln2f;
-	ulong res;
+	__u16 ippathid;
+	__u8  ipflags1;
+	__u8  iprcode;
+	__u32 ipmsgid;
+	__u32 iptrgcls;
+	__u8  iprmmsg[8];
+	__u32 ipsrccls;
+	__u32 ipmsgtag;
+	__u32 ipbfadr2;
+	__u32 ipbfln2f;
+	__u32 res;
 } iparml_dpl;
 
-/*******************/
 typedef struct {
-	ushort ippathid;
-	uchar ipflags1;
-	uchar iprcode;
-	ulong ipmsgid;
-	ulong iptrgcls;
-	ulong ipbfadr1;
-	ulong ipbfln1f;
-	ulong ipsrccls;
-	ulong ipmsgtag;
-	ulong ipbfadr2;
-	ulong ipbfln2f;
-	ulong res;
+	__u16 ippathid;
+	__u8  ipflags1;
+	__u8  iprcode;
+	__u32 ipmsgid;
+	__u32 iptrgcls;
+	__u32 ipbfadr1;
+	__u32 ipbfln1f;
+	__u32 ipsrccls;
+	__u32 ipmsgtag;
+	__u32 ipbfadr2;
+	__u32 ipbfln2f;
+	__u32 res;
 } iparml_db;
 
-/********************/
 typedef struct {
-	ushort ippathid;
-	uchar ipflags1;
-	uchar iprcode;
-	ulong ipmsgid;
-	uchar ipaudit[4];
-	uchar res1[4];
-	ulong res2;
-	ulong ipsrccls;
-	ulong ipmsgtag;
-	ulong res3[3];
+	__u16 ippathid;
+	__u8  ipflags1;
+	__u8  iprcode;
+	__u32 ipmsgid;
+	__u8  ipaudit[3];
+	__u8  res1[5];
+	__u32 res2;
+	__u32 ipsrccls;
+	__u32 ipmsgtag;
+	__u32 res3[3];
 } iparml_purge;
 
-/*******************/
 typedef struct {
-	uchar ipmask;
-	uchar res1[2];
-	uchar iprcode;
-	ulong res2[9];
+	__u8  ipmask;
+	__u8  res1[2];
+	__u8  iprcode;
+	__u32 res2[9];
 } iparml_set_mask;
 
-/*********************INTERNAL FUNCTIONS*****************************/
-/********************************************************************/
-/* Name: b2f0                                                       */
-/* Purpose: this function calls cp to execute iucv commands.        */
-/* Input: code - int, identifier of iucv call to cp.                */
-/*        parm - void *, pointer to 40 byte iparml area passed to cp */
-/* Output: iprcode- return code from iucv call to cp                */
-/********************************************************************/
-/* Assembler code performing iucv call                             */
-/*******************************************************************/
-inline ulong
-b2f0 (int code, void *parm)
+typedef struct {
+	union {
+		iparml_control  p_ctrl;
+		iparml_dpl      p_dpl;
+		iparml_db       p_db;
+		iparml_purge    p_purge;
+		iparml_set_mask p_set_mask;
+	} param;
+	atomic_t in_use;
+}  __attribute__ ((aligned(8))) iucv_param;
+#define PARAM_POOL_SIZE (PAGE_SIZE / sizeof(iucv_param))
+
+static iucv_param * iucv_param_pool;
+
+/*
+ * Debugging stuff
+ *******************************************************************************/
+
+#ifdef DEBUG
+
+static void
+iucv_dumpit(void *buf, int len)
 {
-	uchar *iprcode;		/* used to extract iprcode */
-#ifdef DEBUG2
 	int i;
-	uchar *prt_parm;
-	prt_parm = (uchar *) (parm);
-	printk (KERN_DEBUG "parameter list before b2f0 call\n");
-	for (i = 0; i < 40; i++)
-		printk (KERN_DEBUG "%02x ", prt_parm[i]);
-	printk (KERN_DEBUG "\n");
-#endif
-	asm volatile ("LRA   1,0(%1)\n\t"
-		      "LR    0,%0\n\t"
-		      ".long 0xb2f01000"
-		      : : "d" (code), "a" (parm) : "0", "1");
-#ifdef DEBUG2
-	printk (KERN_DEBUG "parameter list after b2f0 call\n");
-	for (i = 0; i < 40; i++)
-		printk (KERN_DEBUG "%02x ", prt_parm[i]);
-	printk (KERN_DEBUG "\n");
+	__u8 *p = (__u8 *)buf;
+
+	printk(KERN_DEBUG "  ");
+	for (i = 0; i < len; i++) {
+		if (!(i % 16) && i != 0)
+			printk ("\n  ");
+		else if (!(i % 4) && i != 0)
+			printk (" ");
+		printk ("%02X", *p++);
+	}
+	if (len % 16)
+		printk ("\n");
+	return;
+}
+#define iucv_debug(fmt, args...) \
+printk(KERN_DEBUG __FUNCTION__ ": " fmt "\n" , ## args);
+
+#else
+
+#define iucv_debug(fmt, args...)
+#define iucv_dumpit(buf, len)
+
 #endif
-	iprcode = (uchar *) (parm + 3);
-	return (ulong) (*iprcode);
+
+/*
+ * Internal functions
+ *******************************************************************************/
+
+/**
+ * iucv_init - Initialization
+ *
+ * Allocates and initializes various data structures.
+ */
+static int
+iucv_init(void)
+{
+	if (iucv_external_int_buffer)
+		return 0;
+
+	/* Note: GFP_DMA used used to get memory below 2G */
+	iucv_external_int_buffer = kmalloc(sizeof(iucv_GeneralInterrupt),
+					   GFP_KERNEL|GFP_DMA);
+	if (!iucv_external_int_buffer) {
+		printk(KERN_WARNING
+		       "%s: Could not allocate external interrupt buffer\n",
+		       __FUNCTION__);
+		return -ENOMEM;
+	}
+	memset(iucv_external_int_buffer, 0, sizeof(iucv_GeneralInterrupt));
+
+	/* Initialize parameter pool */
+	iucv_param_pool = kmalloc(sizeof(iucv_param) * PARAM_POOL_SIZE,
+				  GFP_KERNEL|GFP_DMA);
+	if (!iucv_param_pool) {
+		printk(KERN_WARNING "%s: Could not allocate param pool\n",
+		       __FUNCTION__);
+		kfree(iucv_external_int_buffer);
+		iucv_external_int_buffer = NULL;
+		return -ENOMEM;
+	}
+	memset(iucv_param_pool, 0, sizeof(iucv_param) * PARAM_POOL_SIZE);
+
+	/* Initialize task queue */
+	INIT_LIST_HEAD(&iucv_tq.list);
+	iucv_tq.sync = 0;
+	iucv_tq.routine = (void *)iucv_bh_handler;
+
+	/* Initialize irq queue */
+	INIT_LIST_HEAD(&iucv_irq_queue);
+
+	/* Initialize handler table */
+	INIT_LIST_HEAD(&iucv_handler_table);
+
+	return 0;
+}
+
+/**
+ * grab_param: - Get a parameter buffer from the pre-allocated pool.
+ *
+ * This function searches for an unused element in the the pre-allocated pool
+ * of parameter buffers. If one is found, it marks it "in use" and returns
+ * a pointer to it. The calling function is responsible for releasing it
+ * when it has finished its usage.
+ *
+ * Returns: A pointer to iucv_param.
+ */
+static __inline__ iucv_param *
+grab_param(void)
+{
+	iucv_param *ret;
+	static int i = 0;
+
+	while (atomic_compare_and_swap(0, 1, &iucv_param_pool[i].in_use)) {
+		i++;
+		if (i >= PARAM_POOL_SIZE)
+			i = 0;
+	}
+	ret = &iucv_param_pool[i];
+	memset(&ret->param, 0, sizeof(ret->param));
+	return ret;
+}
+
+/**
+ * release_param - Release a parameter buffer.
+ * @p: A pointer to a struct iucv_param, previously obtained by calling
+ *     grab_param().
+ *
+ * This function marks the specified parameter buffer "unused".
+ */
+static __inline__ void
+release_param(void *p)
+{
+	atomic_set(&((iucv_param *)p)->in_use, 0);
+}
+
+/**
+ * iucv_add_handler: - Add a new handler
+ * @new_handler: handle that is being entered into chain.
+ *
+ * Places new handle on iucv_handler_table, if identical handler is not
+ * found.
+ *
+ * Returns: 0 on success, !0 on failure (handler already in chain).
+ */
+static int
+iucv_add_handler (handler *new)
+{
+	ulong flags;
+
+	iucv_debug("entering");
+	iucv_dumpit(new, sizeof(handler));
+
+	spin_lock_irqsave (&iucv_lock, flags);
+	if (!list_empty(&iucv_handler_table)) {
+		struct list_head *lh;
+
+		/**
+		 * Search list for handler with identical id. If one
+		 * is found, the new handler is _not_ added.
+		 */
+		list_for_each(lh, &iucv_handler_table) {
+			handler *h = list_entry(lh, handler, list);
+			if (memcmp(&new->id, &h->id, sizeof(h->id)) == 0) {
+				iucv_debug("ret 1");
+				spin_unlock_irqrestore (&iucv_lock, flags);
+				return 1;
+			}
+		}
+	}
+	/**
+	 * If we get here, no handler was found.
+	 */
+	INIT_LIST_HEAD(&new->list);
+	list_add(&new->list, &iucv_handler_table);
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	iucv_debug("exiting");
+	return 0;
+}
+
+/**
+ * iucv_remove_handler:
+ * @users_handler: handler to be removed
+ *
+ * Remove handler when application unregisters.
+ */
+static void
+iucv_remove_handler(handler *handler)
+{
+	unsigned long flags;
+
+	if ((!iucv_pathid_table) || (!handler))
+		return;
+
+	iucv_debug("entering");
+
+	spin_lock_irqsave (&iucv_lock, flags);
+	list_del(&handler->list);
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	iucv_debug("exiting");
+	return;
+}
+
+/**
+ * b2f0:
+ * @code: identifier of IUCV call to CP.
+ * @parm: pointer to 40 byte iparml area passed to CP
+ *
+ * Calls CP to execute IUCV commands.
+ *
+ * Returns: return code from CP's IUCV call
+ */
+static __inline__ ulong
+b2f0(__u32 code, void *parm)
+{
+	iucv_debug("iparml before b2f0 call:");
+	iucv_dumpit(parm, sizeof(iucv_param.param));
+
+	asm volatile (
+		"LRA   1,0(%1)\n\t"
+		"LR    0,%0\n\t"
+		".long 0xb2f01000"
+		:
+		: "d" (code), "a" (parm)
+		: "0", "1"
+		);
+
+	iucv_debug("iparml after b2f0 call:");
+	iucv_dumpit(parm, sizeof(iucv_param.param));
+
+	return (unsigned long)*((__u8 *)(parm + 3));
+}
+
+/*
+ * Name: iucv_add_pathid
+ * Purpose: Adds a path id to the system.
+ * Input: pathid -  pathid that is going to be entered into system
+ *        handle -  address of handler that the pathid will be associated
+ *		   with.
+ *        pgm_data - token passed in by application.
+ * Output: 0: successful addition of pathid
+ *	   - EINVAL - pathid entry is being used by another application
+ *	   - ENOMEM - storage allocation for a new pathid table failed
+*/
+static int
+iucv_add_pathid(__u16 pathid, handler *handler)
+{
+	ulong flags;
+
+	iucv_debug("entering");
+
+	iucv_debug("handler is pointing to %p", handler);
+
+	if (pathid > (max_connections - 1))
+		return -EINVAL;
+
+	spin_lock_irqsave (&iucv_lock, flags);
+	if (iucv_pathid_table[pathid]) {
+		spin_unlock_irqrestore (&iucv_lock, flags);
+		iucv_debug("pathid entry is %p", iucv_pathid_table[pathid]);
+		printk(KERN_WARNING
+		       "%s: Pathid being used, error.\n", __FUNCTION__);
+		return -EINVAL;
+	}
+	iucv_pathid_table[pathid] = handler;
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	iucv_debug("exiting");
+	return 0;
+}				/* end of add_pathid function */
+
+static void
+iucv_remove_pathid(__u16 pathid)
+{
+	ulong flags;
+
+	if (pathid > (max_connections - 1))
+		return;
+
+	spin_lock_irqsave (&iucv_lock, flags);
+	iucv_pathid_table[pathid] = NULL;
+	spin_unlock_irqrestore (&iucv_lock, flags);
 }
 
-/**************************************************************/
-/* Name: iucv_retrieve_buffer                                 */
-/* Purpose: terminates all use of iucv                        */
-/* Input: void                                                */
-/* Output: Return code from CP                                */
-/**************************************************************/
+/*
+ * Name: iucv_declare_buffer
+ * Purpose: Specifies the guests real address of an external
+ *          interrupt.
+ * Input: void
+ * Output: iprcode - return code from b2f0 call
+*/
 int
-iucv_retrieve_buffer (void)
+iucv_declare_buffer (void)
 {
-	iparml_control parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_retrieve_buffer\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	b2f0_result = b2f0 (retrieve_buffer, &parm);
-	if (b2f0_result == NULL)
-		declare_flag = 0;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_retrieve_buffer\n");
-#endif
+	iparml_db *parm = (iparml_db *)grab_param();
+
+	parm->ipbfadr1 = virt_to_phys(iucv_external_int_buffer);
+	b2f0_result = b2f0(DECLARE_BUFFER, parm);
+	release_param(parm);
+	iucv_debug("Address of EIB = %p", iucv_external_int_buffer);
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_declare_buffer                                  */
-/* Purpose: specifies the guests real address of an external  */
-/*          interrupt.                                        */
-/* Input: bfr - pointer to  buffer                            */
-/* Output: iprcode - return code from b2f0 call               */
-/* Note : See output options for b2f0 call                    */
-/**************************************************************/
+/**
+ * iucv_retrieve_buffer:
+ *
+ * Terminates all use of IUCV.
+ * Returns: return code from CP
+ */
 int
-iucv_declare_buffer (uchar * bfr)
+iucv_retrieve_buffer (void)
 {
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "Entering iucv_declare_buffer\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipbfadr1 = virt_to_phys (bfr);
-	b2f0_result = b2f0 (declare_buffer, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "Address of EIB = %p\n", bfr);
-	printk (KERN_DEBUG "Exiting iucv_declare_buffer\n");
-#endif
+	ulong b2f0_result = 0;
+	iparml_control *parm = (iparml_control *)grab_param();
+
+	iucv_debug("entering");
+
+	b2f0_result = b2f0(RETRIEVE_BUFFER, parm);
+	release_param(parm);
+	if (b2f0_result == 0) {
+		kfree(iucv_pathid_table);
+		iucv_pathid_table = NULL;
+		declare_flag = 0;
+	}
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: add_pathid                                           */
-/* Purpose: adds a path id to the system                      */
-/* Input: pathid - ushort, pathid to enter system             */
-/*        handle - iucv_handle_t, address of handler to add to */
-/*        pgm_data - ulong, pathid identifier.                */
-/* Output: 0: successful addition of pathid                   */
-/**************************************************************/
-int
-add_pathid (ushort pathid, iucv_handle_t handle, ulong pgm_data)
-{
-	ulong index1, index2;	/* index1 into main_table */
-	ulong add_flag = 0;
-	ulong old_size = 0, new_size = 0;
-	uchar *to, *from;	/* pointer for copying the table */
-	handler_table_entry *P = 0;	/*P is a pointer to H_T_E */
-	handler *Q = 0;		/*Q is a pointer to handler */
-	ulong *X = 0;		/*Points to array of pointers */
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering add_pathid\n");
-#endif
-	Q = (handler *) handle;	/* Q points to a handler    */
-	/*
-	 * main_table has 128 entries.
-	 * 128*512 = 65536 maximum number of pathid's allowed
-	 */
-	index1 = ((ulong) pathid) / 512;
-	index2 = ((ulong) pathid) % 512;
-#ifdef DEBUG
-	printk (KERN_DEBUG "index1 = %d\n ", (int) index1);
-	printk (KERN_DEBUG "index2 = %d\n ", (int) index2);
-	printk (KERN_DEBUG "Q is pointing to %p ", Q);
-#endif
-	spin_lock (&lock);
-	/*
-	 * If NULL then handler table does not exist and need to get storage
-	 *  and have main_table[index1] point to it
-	 * If allocating storage failed, return
-	 */
-	if (main_table[index1] == NULL) {
-		main_table[index1] = (handler_table_entry *) kmalloc
-		    (512 * sizeof (handler_table_entry), GFP_KERNEL);
-		if (main_table[index1] == NULL) {
-			spin_unlock (&lock);
-			return -ENOBUFS;
+/**
+ * iucv_register_program:
+ * @pgmname:  user identification
+ * @userid:   machine identification
+ * @pgmmask:  Indicates which bits in the pgmname and userid combined will be
+ *            used to determine who is given control.
+ * @ops:      Address of interrupt handler table.
+ * @pgm_data: Application data to be passed to interrupt handlers.
+ *
+ * Registers an application with IUCV.
+ * Returns:
+ *           The address of handler, or NULL on failure.
+ * NOTE on pgmmask:
+ *   If pgmname, userid and pgmmask are provided, pgmmask is entered into the
+ *   handler as is.
+ *   If pgmmask is NULL, the internal mask is set to all 0xff's
+ *   When userid is NULL, the first 8 bytes of the internal mask are forced
+ *   to 0x00.
+ *   If pgmmask and userid are NULL, the first 8 bytes of the internal mask
+ *   are forced to 0x00 and the last 16 bytes to 0xff.
+ */
+
+iucv_handle_t
+iucv_register_program (__u8 pgmname[16],
+		       __u8 userid[8],
+		       __u8 pgmmask[24],
+		       iucv_interrupt_ops_t * ops, void *pgm_data)
+{
+	ulong rc = 0;		/* return code from function calls */
+	handler *new_handler;
+
+	iucv_debug("entering");
+
+	if (ops == NULL) {
+		/* interrupt table is not defined */
+		printk(KERN_WARNING "%s: Interrupt table is not defined, "
+		       "exiting\n", __FUNCTION__);
+		return NULL;
+	}
+	if (!pgmname) {
+		printk(KERN_WARNING "%s: pgmname not provided\n", __FUNCTION__);
+		return NULL;
+	}
+
+	/* Allocate handler entry */
+	new_handler = (handler *)kmalloc(sizeof(handler), GFP_KERNEL);
+	if (new_handler == NULL) {
+		printk(KERN_WARNING "%s: storage allocation for new handler "
+		       "failed.\n", __FUNCTION__);
+		return NULL;
+	}
+
+	if (!iucv_pathid_table) {
+		if (iucv_init()) {
+			kfree(new_handler);
+			return NULL;
 		}
-		memset (main_table[index1], 0,
-			512 * sizeof (handler_table_entry));
-#ifdef DEBUG
-		printk (KERN_DEBUG "address of table H_T is %p \n",
-			main_table[index1]);
-#endif
+
+		max_connections = iucv_query_maxconn();
+		iucv_pathid_table = kmalloc(max_connections * sizeof(handler *),
+				       GFP_KERNEL);
+		if (iucv_pathid_table == NULL) {
+			printk(KERN_WARNING "%s: iucv_pathid_table storage "
+			       "allocation failed\n", __FUNCTION__);
+			return NULL;
+		}
+		memset (iucv_pathid_table, 0, max_connections * sizeof(handler *));
 	}
-	/*
-	 * P points to a handler table entry (H_T_E) in which all entries in
-	 * that structure should be NULL. If they're not NULL, then there
-	 * is a bad pointer and it will return(-2) immediately, otherwise
-	 * data will be entered into H_T_E.
-	 */
-	P = main_table[index1];
-	if ((P + index2)->addrs) {
-#ifdef DEBUG
-		printk (KERN_DEBUG "main_table[index1] = %p \n",
-			main_table[index1]);
-		printk (KERN_DEBUG "P+index2 = %p \n", P + index2);
-		printk (KERN_DEBUG "(P+index2)->addrs is %p \n",
-			(P + index2)->addrs);
-#endif
-		spin_unlock (&lock);
-		printk (KERN_DEBUG "bad pointer1\n");
-		return (-2);
+	memset(new_handler, 0, sizeof (handler));
+	memcpy(new_handler->id.user_data, pgmname,
+		sizeof (new_handler->id.user_data));
+	if (userid) {
+		memcpy (new_handler->id.userid, userid,
+			sizeof (new_handler->id.userid));
+		ASCEBC (new_handler->id.userid,
+			sizeof (new_handler->id.userid));
+		EBC_TOUPPER (new_handler->id.userid,
+			     sizeof (new_handler->id.userid));
+		
+		if (pgmmask) {
+			memcpy (new_handler->id.mask, pgmmask,
+				sizeof (new_handler->id.mask));
+		} else {
+			memset (new_handler->id.mask, 0xFF,
+				sizeof (new_handler->id.mask));
+		}
+	} else {
+		if (pgmmask) {
+			memcpy (new_handler->id.mask, pgmmask,
+				sizeof (new_handler->id.mask));
+		} else {
+			memset (new_handler->id.mask, 0xFF,
+				sizeof (new_handler->id.mask));
+		}
+		memset (new_handler->id.mask, 0x00,
+			sizeof (new_handler->id.userid));
 	}
-	(P + index2)->addrs = handle;
-	/*
-	 * checking if address of handle is valid, if it's not valid,
-	 * unlock the lock and return(-2) immediately.
-	 */
-	if ((P + index2)->addrs == NULL) {
-		spin_unlock (&lock);
-		printk (KERN_DEBUG "bad pointer2\n");
-		return (-2);
-	}
-	(P + index2)->pathid = pathid;
-	if (pgm_data)
-		(P + index2)->pgm_data = pgm_data;
-	else
-		(P + index2)->pgm_data = Q->pgm_data;
+	/* fill in the rest of handler */
+	new_handler->pgm_data = pgm_data;
+	new_handler->interrupt_table = ops;
+
 	/*
-	 * Step thru the table of addresses of pathid's to find the first
-	 * available entry (NULL). If an entry is found, add the pathid,
-	 * unlock and exit. If an available entry is not found, allocate a
-	 * new, larger table, copy over the old table and deallocate the
-	 * old table and add the pathid.
+	 * Check if someone else is registered with same pgmname, userid
+	 * and mask. If someone is already registered with same pgmname,
+	 * userid and mask, registration will fail and NULL will be returned
+	 * to the application.
+	 * If identical handler not found, then handler is added to list.
 	 */
-#ifdef DEBUG
-	printk (KERN_DEBUG "address of handle is %p\n", handle);
-	printk (KERN_DEBUG "&(Q->start) is %p\n", &(Q->start));
-	printk (KERN_DEBUG "&(Q->end) is %p\n", &(Q->end));
-	printk (KERN_DEBUG "start of pathid table is %p\n", (Q->start));
-	printk (KERN_DEBUG "end of pathid table is %p\n", (Q->end));
-	for (X = (Q->start); X < (Q->end); X++)
-		printk (KERN_DEBUG "X = %p ", X);
-	printk (KERN_DEBUG "\n");
-#endif
-	for (X = (Q->start); X < (Q->end); X++) {
-		if (*X == NULL) {
-#ifdef DEBUG
-			printk (KERN_DEBUG "adding pathid, %p = P+index2\n",
-				(P + index2));
-#endif
-			*X = (ulong) (P + index2);
-			add_flag = 1;
-		}
-		if (add_flag == 1)
-			break;
+	rc = iucv_add_handler(new_handler);
+	if (rc) {
+		printk(KERN_WARNING "%s: Someone already registered with same "
+		       "pgmname, userid, pgmmask\n", __FUNCTION__);
+		kfree (new_handler);
+		return NULL;
 	}
-	if (add_flag == 0) {	/* element not added to list */
-		X = Q->start;
-		old_size = Q->size;
-		new_size = old_size + ADDED_STOR;	/* size of new table */
-		from = (uchar *) (Q->start);	/* address of old table */
-		(*Q).start = kmalloc (new_size * sizeof (ulong), GFP_KERNEL);
-		if ((Q->start) == NULL) {
-			spin_unlock (&lock);
-			return -ENOBUFS;
+
+	if (declare_flag == 0) {
+		rc = iucv_declare_buffer();
+		if (rc) {
+			iucv_remove_handler(new_handler);
+			kfree(new_handler);
+			printk(KERN_WARNING "%s: iucv_declare_buffer "
+			       "returned %ld\n", __FUNCTION__, rc);
+			return NULL;
 		}
-		memset ((*Q).start, 0, new_size * sizeof (ulong));
-		to = (uchar *) (Q->start);	/* address of new table */
-		/* copy old table to new  */
-		memcpy (to, from, old_size * (sizeof (ulong)));
-#ifdef DEBUG
-		printk (KERN_DEBUG "Getting a new pathid table\n");
-		printk (KERN_DEBUG "to is %p \n", to);
-		printk (KERN_DEBUG "from is %p \n", from);
-#endif
-		Q->size = new_size;	/* storing new size of table */
-		Q->end = (Q->start) + (Q->size);
-		X = Q->start + old_size;	/* next blank in table */
-		*X = (ulong) (P + index2);	/* adding element to new table */
-#ifdef DEBUG
-		printk (KERN_DEBUG "Q->size is %u \n", (int) (Q->size));
-		printk (KERN_DEBUG "Q->end is %p \n", Q->end);
-		printk (KERN_DEBUG "Q->start is %p \n", Q->start);
-		printk (KERN_DEBUG "X is %p \n", X);
-		printk (KERN_DEBUG "*X is %u \n", (int) (*X));
-#endif
-		kfree (from);	/* free old table */
+		/* request the 0x4000 external interrupt */
+		rc = register_external_interrupt (0x4000, iucv_irq_handler);
+		if (rc) {
+			iucv_remove_handler(new_handler);
+			iucv_retrieve_buffer();
+			kfree (new_handler);
+			printk(KERN_WARNING "%s: "
+			       "register_external_interrupt returned %ld\n",
+			       __FUNCTION__, rc);
+			return NULL;
+
+		}
+		declare_flag = 1;
 	}
-	spin_unlock (&lock);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting add_pathid\n");
-#endif
-	return (0);
-}				/* end of add_pathid function */
+	iucv_debug("exiting");
+	return new_handler;
+}				/* end of register function */
+
+/**
+ * iucv_unregister_program:
+ * @handle: address of handler
+ *
+ * Unregister application with IUCV.
+ * Returns:
+ *   Always 0
+ */
 
-/***********************EXTERNAL FUNCTIONS***************************/
-/**************************************************************/
-/* Name: iucv_query                                           */
-/* Purpose: determines how large an external interrupt buffer */
-/*          IUCV requires to store information                */
-/* Input : bufsize - ulong: size of interrupt buffer          */
-/*         - filled in by function and returned to caller     */
-/*         conmax  - ulong: maximum number of connections that */
-/*           can be outstanding for this VM                   */
-/*         - filled in by function and returned to caller     */
-/* Output: void                                               */
-/**************************************************************/
-void
-iucv_query (ulong * bufsize, ulong * conmax)
+int
+iucv_unregister_program (iucv_handle_t handle)
 {
-	iparml_purge parm;	/* DOESN'T MATTER WHICH IPARML IS USED    */
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_purge\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	/*
-	 * Assembler instruction calling b2f0  and storing R0 and R1
+	handler *h = (handler *)handle;
+	int i;
+	ulong flags;
+
+	iucv_debug("entering");
+	iucv_debug("address of handler is %p", h);
+
+	/**
+	 * First, walk thru iucv_pathid_table and sever any pathid which is
+	 * still pointing to the handler to be removed.
 	 */
-	asm volatile ("LRA   1,0(%3)\n\t"
-		      "LR    0,%2\n\t"
-		      ".long 0xb2f01000\n\t"
-		      "ST    0,%0\n\t"
-		      "ST    1,%1\n\t":"=m" (*bufsize),
-		      "=m" (*conmax):"d" (query), "a" (&parm):"0", "1");
-	return;
+	spin_lock_irqsave (&iucv_lock, flags);
+	for (i = 0; i < max_connections; i++)
+		if (iucv_pathid_table[i] == h) {
+			spin_unlock_irqrestore (&iucv_lock, flags);
+			iucv_sever(i, h->id.user_data);
+			spin_lock_irqsave(&iucv_lock, flags);
+		}
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	iucv_remove_handler(h);
+	kfree(h);
+
+	iucv_debug("exiting");
+	return 0;
 }
 
-/**************************************************************/
-/* Name: iucv_purge                                           */
-/* Purpose: cancels a message you have sent                   */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, mid of message                      */
-/*        srccls - ulong, sourse message class                */
-/*        audit  - uchar[4], info about ansync. error condit. */
-/*                 filled in by function and passed back      */
-/* Output: void                                               */
-/* NOTE: pathid is required, flag is always turned on         */
-/**************************************************************/
+/**
+ * iucv_accept:
+ * @pathid:             Path identification number
+ * @msglim_reqstd:      The number of outstanding messages requested.
+ * @user_data:          Data specified by the iucv_connect function.
+ * @flags1:             Contains options for this path.
+ *     - IPPRTY (0x20)   Specifies if you want to send priority message.
+ *     - IPRMDATA (0x80) Specifies whether your program can handle a message
+ *                       in the parameter list.
+ *     - IPQUSCE (0x40)  Specifies whether you want to quiesce the path being
+ *		         established.
+ * @handle:             Address of handler.
+ * @pgm_data:           Application data passed to interrupt handlers.
+ * @flags1_out:         Pointer to an int. If not NULL, on return the options for
+ *                      the path are stored at the given location:
+ *     - IPPRTY (0x20)  Indicates you may send a priority message.
+ * @msglim:             Pointer to an __u16. If not NULL, on return the maximum
+ *                      number of outstanding messages is stored at the given
+ *                      location.
+ *
+ * This function is issued after the user receives a Connection Pending external
+ * interrupt and now wishes to complete the IUCV communication path.
+ * Returns:
+ *   return code from CP
+ */
 int
-iucv_purge (ulong msgid, ushort pathid, ulong srccls, uchar audit[4])
+iucv_accept(__u16 pathid, __u16 msglim_reqstd,
+	     __u8 user_data[16], int flags1,
+	     iucv_handle_t handle, void *pgm_data,
+	     int *flags1_out, __u16 * msglim)
 {
-	iparml_purge parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_purge\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipmsgid = msgid;
-	parm.ippathid = pathid;
-	parm.ipsrccls = srccls;
-	parm.ipflags1 |= specify_pathid;	/* pathid id flag */
-	if (parm.ipmsgid)
-		parm.ipflags1 |= specify_msgid;
-	if (parm.ipsrccls)
-		parm.ipflags1 |= source_class;
-	b2f0_result = b2f0 (purge, &parm);
-	if (b2f0_result != NULL)
-		return b2f0_result;
-	memcpy (audit, parm.ipaudit, 4);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_purge\n");
-#endif
+	ulong b2f0_result = 0;
+	ulong flags;
+	struct list_head *lh;
+	handler *h = NULL;
+	iparml_control *parm;
+
+	iucv_debug("entering");
+	iucv_debug("pathid = %d", pathid);
+
+	/* Checking if handle is valid  */
+	spin_lock_irqsave (&iucv_lock, flags);
+	list_for_each(lh, &iucv_handler_table) {
+		if ((handler *)handle == list_entry(lh, handler, list)) {
+			h = (handler *)handle;
+			break;
+		}
+	}
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	if (!h) {
+		printk(KERN_WARNING "%s: NULL handle passed by application "
+		       "or handler not found in iucv_handler_table\n",
+		       __FUNCTION__);
+		return -EINVAL;
+	}
+
+	parm = (iparml_control *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->ipmsglim = msglim_reqstd;
+	if (user_data)
+		memcpy(parm->ipuser, user_data, sizeof(parm->ipuser));
+
+	parm->ipflags1 = (__u8)flags1;
+	b2f0_result = b2f0(ACCEPT, parm);
+
+	if (b2f0_result == 0) {
+		if (pgm_data)
+			h->pgm_data = pgm_data;
+		if (flags1_out)
+			*flags1_out = (parm->ipflags1 & IPPRTY) ? IPPRTY : 0;
+	}
+	release_param(parm);
+
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_quiesce                                         */
-/* Purpose: temporarily suspends incoming messages            */
-/* Input: pathid - ushort, pathid                             */
-/*        user_data - uchar[16], user id                      */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: see b2f0 output list                                 */
-/**************************************************************/
+/**
+ * iucv_connect:
+ * @pathid:        Path identification number
+ * @msglim_reqstd: Number of outstanding messages requested
+ * @user_data:     16-byte user data
+ * @userid:        8-byte of user identification
+ * @system_name:   8-byte identifying the system name
+ * @flags1:        Specifies options for this path:
+ *     - IPPRTY (0x20)   Specifies if you want to send priority message.
+ *     - IPRMDATA (0x80) Specifies whether your program can handle a message
+ *                       in  the parameter list.
+ *     - IPQUSCE (0x40)  Specifies whether you want to quiesce the path being
+ *                       established.
+ *     - IPLOCAL (0x01)  Allows an application to force the partner to be on the
+ *                       local system. If local is specified then target class
+ *                       cannot be specified.
+ * @flags1_out:    Pointer to an int. If not NULL, on return the options for
+ *                 the path are stored at the given location:
+ *     - IPPRTY (0x20)   Indicates you may send a priority message.
+ * @msglim:        Pointer to an __u16. If not NULL, on return the maximum
+ *                 number of outstanding messages is stored at the given
+ *                 location.
+ * @handle:        Address of handler.
+ * @pgm_data:      Application data to be passed to interrupt handlers.
+ *
+ * This function establishes an IUCV path. Although the connect may complete
+ * successfully, you are not able to use the path until you receive an IUCV
+ * Connection Complete external interrupt.
+ * Returns: return code from CP, or one of the following
+ *     - ENOMEM
+ *     - return code from iucv_declare_buffer
+ *     - EINVAL - invalid handle passed by application
+ *     - EINVAL - pathid address is NULL
+ *     - ENOMEM - pathid table storage allocation failed
+ *     - return code from internal function add_pathid
+ */
 int
-iucv_quiesce (ushort pathid, uchar user_data[16])
-{
-	iparml_control parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_quiesce\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	memcpy (parm.ipuser, user_data, 16);
-	parm.ippathid = pathid;
-	b2f0_result = b2f0 (quiesc, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_quiesce\n");
-#endif
+iucv_connect (__u16 *pathid, __u16 msglim_reqstd,
+	      __u8 user_data[16], __u8 userid[8],
+	      __u8 system_name[8], int flags1,
+	      int *flags1_out, __u16 * msglim,
+	      iucv_handle_t handle, void *pgm_data)
+{
+	iparml_control *parm;
+	struct list_head *lh;
+	ulong b2f0_result = 0;
+	ulong flags;
+	int add_pathid_result = 0;
+	handler *h = NULL;
+	__u8 no_memory[16] = "NO MEMORY";
+
+	iucv_debug("entering");
+
+	/* Checking if handle is valid  */
+	spin_lock_irqsave (&iucv_lock, flags);
+	list_for_each(lh, &iucv_handler_table) {
+		if ((handler *)handle == list_entry(lh, handler, list)) {
+			h = (handler *)handle;
+			break;
+		}
+	}
+	spin_unlock_irqrestore (&iucv_lock, flags);
+
+	if (!h) {
+		printk(KERN_WARNING "%s: NULL handle passed by application "
+		       "or handler not found in iucv_handler_table\n",
+		       __FUNCTION__);
+		return -EINVAL;
+	}
+
+	if (pathid == NULL) {
+		printk(KERN_WARNING "%s: NULL pathid pointer\n",
+		       __FUNCTION__);
+		return -EINVAL;
+	}
+
+	parm = (iparml_control *)grab_param();
+
+	parm->ipmsglim = msglim_reqstd;
+
+	if (user_data)
+		memcpy(parm->ipuser, user_data, sizeof(parm->ipuser));
+
+	if (userid) {
+		memcpy(parm->ipvmid, userid, sizeof(parm->ipvmid));
+		ASCEBC(parm->ipvmid, sizeof(parm->ipvmid));
+		EBC_TOUPPER(parm->ipvmid, sizeof(parm->ipvmid));
+	}
+
+	if (system_name) {
+		memcpy(parm->iptarget, system_name, sizeof(parm->iptarget));
+		ASCEBC(parm->iptarget, sizeof(parm->iptarget));
+		EBC_TOUPPER(parm->iptarget, sizeof(parm->iptarget));
+	}
+
+	parm->ipflags1 = (__u8)flags1;
+	b2f0_result = b2f0(CONNECT, parm);
+
+	if (b2f0_result) {
+		release_param(parm);
+		return b2f0_result;
+	}
+
+	add_pathid_result = iucv_add_pathid(parm->ippathid, h);
+	*pathid = parm->ippathid;
+
+	if (msglim)
+		*msglim = parm->ipmsglim;
+	if (flags1_out)
+		*flags1_out = (parm->ipflags1 & IPPRTY) ? IPPRTY : 0;
+
+	if (add_pathid_result) {
+		iucv_sever(parm->ippathid, no_memory);
+		printk(KERN_WARNING "%s: add_pathid failed with rc ="
+			" %d\n", __FUNCTION__, add_pathid_result);
+		return(add_pathid_result);
+	}
+
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_resume                                          */
-/* Purpose: restores communication over a quiesced path       */
-/* Input: pathid - ushort, pathid                             */
-/*        user_data - uchar[16], user id                      */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: see b2f0 output list                                 */
-/**************************************************************/
+/**
+ * iucv_purge:
+ * @pathid: Path identification number
+ * @msgid:  Message ID of message to purge.
+ * @srccls: Message class of the message to purge.
+ * @audit:  Pointer to an __u32. If not NULL, on return, information about
+ *          asynchronous errors that may have affected the normal completion
+ *          of this message ist stored at the given location.
+ *
+ * Cancels a message you have sent.
+ * Returns: return code from CP
+ */
 int
-iucv_resume (ushort pathid, uchar user_data[16])
+iucv_purge (__u16 pathid, __u32 msgid, __u32 srccls, __u32 *audit)
 {
-	iparml_control parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_resume\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	memcpy (parm.ipuser, user_data, 16);
-	parm.ippathid = pathid;
-	b2f0_result = b2f0 (resume, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_resume\n");
-#endif
+	iparml_purge *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+	iucv_debug("pathid = %d", pathid);
+
+	parm = (iparml_purge *)grab_param();
+
+	parm->ipmsgid = msgid;
+	parm->ippathid = pathid;
+	parm->ipsrccls = srccls;
+	parm->ipflags1 |= (IPSRCCLS | IPFGMID | IPFGPID);
+	b2f0_result = b2f0(PURGE, parm);
+
+	if ((b2f0_result == 0) && audit) {
+		memcpy(audit, parm->ipaudit, sizeof(parm->ipaudit));
+		/* parm->ipaudit has only 3 bytes */
+		*audit >>= 8;
+	}
+	
+	release_param(parm);
+
+	iucv_debug("b2f0_result = %ld", b2f0_result);
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_reject                                          */
-/* Purpose: rejects a message                                 */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, mid of message                      */
-/*        trgcls - ulong, target message class                */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: pathid is required field, flag always turned on      */
-/*       RESTRICTION: target class cannot be zero             */
-/* NOTE: see b2f0 output list                                 */
-/**************************************************************/
-int
-iucv_reject (ushort pathid, ulong msgid, ulong trgcls)
+/**
+ * iucv_query_generic:
+ * @want_maxconn: Flag, describing which value is to be returned.
+ *
+ * Helper function for iucv_query_maxconn() and iucv_query_bufsize().
+ *
+ * Returns: The buffersize, if want_maxconn is 0; the maximum number of
+ *           connections, if want_maxconn is 1 or an error-code < 0 on failure.
+ */
+static int
+iucv_query_generic(int want_maxconn)
 {
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_reject\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipmsgid = msgid;
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipflags1 |= specify_pathid;	/* flag for pathid */
-	if (parm.ipmsgid)
-		parm.ipflags1 |= specify_msgid;
-	if (parm.iptrgcls)
-		parm.ipflags1 |= target_class;
-	b2f0_result = b2f0 (reject, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_reject\n");
-#endif
-	return b2f0_result;
+	iparml_purge *parm = (iparml_purge *)grab_param();
+	int bufsize, maxconn;
+	int ccode;
+
+	/**
+	 * Call b2f0 and store R0 (max buffer size),
+	 * R1 (max connections) and CC.
+	 */
+	asm volatile (
+		"LRA   1,0(%4)\n\t"
+		"LR    0,%3\n\t"
+		".long 0xb2f01000\n\t"
+		"IPM   %0\n\t"
+		"SRL   %0,28\n\t"
+		"ST    0,%1\n\t"
+		"ST    1,%2\n\t"
+		: "=d" (ccode), "=m" (bufsize), "=m" (maxconn)
+		: "d" (QUERY), "a" (parm)
+		: "0", "1", "cc"
+		);
+	release_param(parm);
+
+	if (ccode)
+		return -EPERM;
+	if (want_maxconn)
+		return maxconn;
+	return bufsize;
 }
 
-/**************************************************************/
-/* Name: iucv_setmask                                         */
-/* Purpose: enables or disables certain iucv external interr. */
-/* Input: non_priority_interrupts - uchar                     */
-/*        priority_interrupts - uchar                         */
-/*        non_priority_completion_interrupts - uchar          */
-/*        priority_completion_interrupts) - uchar             */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: see b2f0 output list                                 */
-/**************************************************************/
-int
-iucv_setmask (uchar non_priority_interrupts,
-	      uchar priority_interrupts,
-	      uchar non_priority_completion_interrupts,
-	      uchar priority_completion_interrupts)
+/**
+ * iucv_query_maxconn:
+ *
+ * Determines the maximum number of connections thay may be established.
+ *
+ * Returns: Maximum number of connections that can be.
+ */
+ulong
+iucv_query_maxconn(void)
 {
-	iparml_set_mask parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_setmask\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	if (non_priority_interrupts)
-		parm.ipmask |= 0x80;
-	if (priority_interrupts)
-		parm.ipmask |= 0x40;
-	if (non_priority_completion_interrupts)
-		parm.ipmask |= 0x20;
-	if (priority_completion_interrupts)
-		parm.ipmask |= 0x10;
-	b2f0_result = b2f0 (setmask, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_setmask\n");
-#endif
-	return b2f0_result;
+	return iucv_query_generic(1);
+}
+
+/**
+ * iucv_query_bufsize:
+ *
+ * Determines the size of the external interrupt buffer.
+ *
+ * Returns: Size of external interrupt buffer.
+ */
+ulong
+iucv_query_bufsize (void)
+{
+	return iucv_query_generic(0);
 }
 
-/**************************************************************/
-/* Name: iucv_sever                                           */
-/* Purpose: terminates an iucv path to another machine        */
-/* Input: pathid - ushort, pathid                             */
-/*        user_data - uchar[16], user id                      */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: see b2f0 output list                                 */
-/**************************************************************/
+/**
+ * iucv_quiesce:
+ * @pathid:    Path identification number
+ * @user_data: 16-byte user data
+ *
+ * Temporarily suspends incoming messages on an IUCV path.
+ * You can later reactivate the path by invoking the iucv_resume function.
+ * Returns: return code from CP
+ */
 int
-iucv_sever (ushort pathid, uchar user_data[16])
+iucv_quiesce (__u16 pathid, __u8 user_data[16])
 {
-	ulong index1, index2;
-	ulong b2f0_result;
-	handler_table_entry *P = 0;
-	handler *Q = 0;
-	ulong *X;
-	iparml_control parm;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_sever\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	memcpy (parm.ipuser, user_data, 16);
-	parm.ippathid = pathid;
-	b2f0_result = b2f0 (sever, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	index1 = ((ulong) pathid) / 512;
-	index2 = ((ulong) pathid) % 512;
-	spin_lock (&lock);
-	P = main_table[index1];
-	if (((P + index2)->addrs) == NULL) {	/* called from interrupt code */
-		spin_unlock (&lock);
-		return (-2);	/* bad pointer */
-	}
-	Q = (*(P + index2)).addrs;
-#ifdef DEBUG
-	printk (KERN_DEBUG "pathid is %d\n", pathid);
-	printk (KERN_DEBUG "index1 is %d\n", (int) index1);
-	printk (KERN_DEBUG "index2 is %d\n", (int) index2);
-	printk (KERN_DEBUG "H_T_E is %p\n", P);
-	printk (KERN_DEBUG "address of handler is %p\n", Q);
-	for (X = ((*Q).start); X < ((*Q).end); X++)
-		printk (KERN_DEBUG " %x ", (int) (*X));
-	printk (KERN_DEBUG "\n above is pathid table\n");
-#endif
-/********************************************************************/
-/* Searching the pathid address table for matching address, once    */
-/* found, NULL the field. Then Null the H_T_E fields.               */
-/********************************************************************/
-	for (X = ((*Q).start); X < ((*Q).end); X++)
-		if (*X == (ulong) (P + index2)) {
-#ifdef DEBUG
-			printk (KERN_DEBUG "found a path to sever\n");
-			printk (KERN_DEBUG "severing %d \n", (int) (*X));
-#endif
-			*X = NULL;
-			(*(P + index2)).addrs = NULL;	/*clearing the fields */
-			(*(P + index2)).pathid = 0;
-			(*(P + index2)).pgm_data = 0;
-		}
-	spin_unlock (&lock);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_sever\n");
-#endif
+	iparml_control *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+	iucv_debug("pathid = %d", pathid);
+
+	parm = (iparml_control *)grab_param();
+
+	memcpy(parm->ipuser, user_data, sizeof(parm->ipuser));
+	parm->ippathid = pathid;
+
+	b2f0_result = b2f0(QUIESCE, parm);
+	release_param(parm);
+
+	iucv_debug("b2f0_result = %ld", b2f0_result);
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_receive                                         */
-/* Purpose: receives incoming message                         */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - *ulong, mid of message                     */
-/*        trgcls - *ulong, target message class               */
-/*        buffer - pointer of buffer                          */
-/*        buflen - length of buffer                           */
-/*        adds_curr_buffer - pointer to updated buffer address*/
-/*                           to write to                      */
-/*        adds_curr_length - pointer to updated length in     */
-/*                           buffer available to write to     */
-/*        reply_required - uchar *, flag                      */
-/*        priority_msg - uchar *, flag                        */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: pathid must be specified, flag being turned on       */
-/* RESTRICTIONS: target class CANNOT be zero because the code */
-/* checks for a non-NULL value to turn flag on, therefore if  */
-/* target class = zero, flag will not be turned on.           */
-/**************************************************************/
+/**
+ * iucv_receive:
+ * @pathid: Path identification number.
+ * @buffer: Address of buffer to receive. Must be below 2G.
+ * @buflen: Length of buffer to receive.
+ * @msgid:  Specifies the message ID.
+ * @trgcls: Specifies target class.
+ * @flags1_out: Receives options for path on return.
+ *    - IPNORPY (0x10)  Specifies whether a reply is required
+ *    - IPPRTY (0x20)   Specifies if you want to send priority message
+ *    - IPRMDATA (0x80) Specifies the data is contained in the parameter list
+ * @residual_buffer: Receives the address of buffer updated by the number
+ *                   of bytes you have received on return.
+ * @residual_length: On return, receives one of the following values:
+ *    - 0                          If the receive buffer is the same length as
+ *                                 the message.
+ *    - Remaining bytes in buffer  If the receive buffer is longer than the
+ *                                 message.
+ *    - Remaining bytes in message If the receive buffer is shorter than the
+ *                                 message.
+ *
+ * This function receives messages that are being sent to you over established
+ * paths.
+ * Returns: return code from CP IUCV call; If the receive buffer is shorter
+ *   than the message, always 5
+ *   -EINVAL - buffer address is pointing to NULL
+ */
 int
-iucv_receive (ushort pathid, ulong * msgid, ulong * trgcls,
+iucv_receive (__u16 pathid, __u32 msgid, __u32 trgcls,
 	      void *buffer, ulong buflen,
-	      uchar * reply_required,
-	      uchar * priority_msg,
-	      ulong * adds_curr_buffer, ulong * adds_curr_length)
+	      int *flags1_out, ulong * residual_buffer, ulong * residual_length)
 {
-	iparml_db parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_receive\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipmsgid = *msgid;
-	parm.ippathid = pathid;
-	parm.iptrgcls = *trgcls;
-	parm.ipflags1 |= specify_pathid;	/* turning pathid flag */
-	if (parm.ipmsgid)
-		parm.ipflags1 |= 0x05;
-	if (parm.iptrgcls)
-		parm.ipflags1 |= target_class;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;
-	b2f0_result = b2f0 (receive, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	if (msgid)
-		*msgid = parm.ipmsgid;
-	if (trgcls)
-		*trgcls = parm.iptrgcls;
-	if (parm.ipflags1 & prior_msg)
-		if (priority_msg)
-			*priority_msg = 0x01;	/*yes, priority msg */
-	if (!(parm.ipflags1 & 0x10))	/*& with X'10'     */
-		if (reply_required)
-			*reply_required = 0x01;	/*yes, reply required */
-	if (!(parm.ipflags1 & parm_data)) {	/*msg not in parmlist */
-		if (adds_curr_length)
-			*adds_curr_length = parm.ipbfln1f;
-		if (adds_curr_buffer)
-			*adds_curr_buffer = parm.ipbfadr1;
-	} else {
-		if ((buflen) >= 8) {
-			if (buffer)
-				memcpy ((char *) buffer,
-					(char *) parm.ipbfadr1, 8);
-			if (adds_curr_length)
-				*adds_curr_length = ((buflen) - 8);
-			if (adds_curr_buffer)
-				*adds_curr_buffer = (ulong) buffer + 8;
+	int moved = 0;	/* number of bytes moved from parmlist to buffer */
+
+	iucv_debug("entering");
+
+	if (!buffer)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ipbfadr1 = (__u32) (addr_t) buffer;
+	parm->ipbfln1f = (__u32) ((ulong) buflen);
+	parm->ipmsgid = msgid;
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipflags1 = (IPFGPID | IPFGMID | IPFGMCL);
+
+	b2f0_result = b2f0(RECEIVE, parm);
+
+	if (b2f0_result == 0 || b2f0_result == 5) {
+		if (flags1_out) {
+			iucv_debug("*flags1_out = %d", *flags1_out);
+			*flags1_out = (parm->ipflags1 & (~0x07));
+			iucv_debug("*flags1_out = %d", *flags1_out);
+		}
+
+		if (!(parm->ipflags1 & IPRMDATA)) {	/*msg not in parmlist */
+			if (residual_length)
+				*residual_length = parm->ipbfln1f;
+
+			if (residual_buffer)
+				*residual_buffer = parm->ipbfadr1;
 		} else {
-			parm.iprcode |= 0x05;
-			b2f0_result = (ulong) parm.iprcode;
+			moved = min (buflen, 8);
+
+			memcpy ((char *) buffer,
+				(char *) &parm->ipbfadr1, moved);
+
+			if (buflen < 8)
+				b2f0_result = 5;
+
+			if (residual_length)
+				*residual_length = abs (buflen - 8);
+
+			if (residual_buffer)
+				*residual_buffer = (ulong) (buffer + moved);
 		}
 	}
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_receive\n");
-#endif
+	release_param(parm);
+
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_receive_simple                                  */
-/* Purpose: receives fully-qualified message                  */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, id of message                       */
-/*        trgcls - ulong, target message class                */
-/*        buffer - pointer of buffer                          */
-/*        buflen - length of buffer                           */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
+/*
+ * Name: iucv_receive_array
+ * Purpose: This function receives messages that are being sent to you
+ *          over established paths.
+ * Input: pathid - path identification number
+ *        buffer - address of array of buffers
+ *        buflen - total length of buffers
+ *        msgid - specifies the message ID.
+ *        trgcls - specifies target class
+ * Output:
+ *        flags1_out: Options for path.
+ *          IPNORPY - 0x10 specifies whether a reply is required
+ *          IPPRTY - 0x20 specifies if you want to send priority message
+ *         IPRMDATA - 0x80 specifies the data is contained in the parameter list
+ *       residual_buffer - address points to the current list entry IUCV
+ *                         is working on.
+ *       residual_length -
+ *              Contains one of the following values, if the receive buffer is:
+ *               The same length as the message, this field is zero.
+ *               Longer than the message, this field contains the number of
+ *                bytes remaining in the buffer.
+ *               Shorter than the message, this field contains the residual
+ *                count (that is, the number of bytes remaining in the
+ *                message that does not fit into the buffer. In this case
+ *		  b2f0_result = 5.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer address is NULL
+ */
 int
-iucv_receive_simple (ushort pathid, ulong msgid, ulong trgcls,
-		     void *buffer, ulong buflen)
+iucv_receive_array (__u16 pathid,
+		    __u32 msgid, __u32 trgcls,
+		    iucv_array_t * buffer, ulong buflen,
+		    int *flags1_out,
+		    ulong * residual_buffer, ulong * residual_length)
 {
-	iparml_db parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-	pr_debug ("entering iucv_receive_simple\n");
+	int i = 0, moved = 0, need_to_move = 8, dyn_len;
 
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipmsgid = msgid;
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipflags1 = IPFGMID + IPFGPID + IPFGMCL;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;
+	iucv_debug("entering");
 
-	b2f0_result = b2f0 (receive, &parm);
-	if (b2f0_result)
-		return b2f0_result;
+	if (!buffer)
+		return -EINVAL;
 
-	if (parm.ipflags1 & IPRMDATA) {	/*msg in parmlist */
-		if ((buflen) >= 8)
-			memcpy ((char *) buffer, (char *) parm.ipbfadr1, 8);
-		else
-			b2f0_result = 5;
-	}
-	pr_debug ("exiting iucv_receive_simple\n");
-	return b2f0_result;
-}
+	parm = (iparml_db *)grab_param();
 
-/**************************************************************/
-/* Name: iucv_receive_array                                   */
-/* Purpose: receives incoming message                         */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  -* ulong, mid of message                     */
-/*        trgcls -* ulong, target message class               */
-/*        buffer - pointer of iucv_array_t                    */
-/*        buflen - ulong , length of buffer                   */
-/*        reply_required - uchar *, flag returned to caller   */
-/*        priority_msg - uchar *, flag returned to caller     */
-/*        adds_curr_buffer - pointer to updated buffer array  */
-/*                   to write to                              */
-/*        adds_curr_length - pointer to updated length in     */
-/*                   buffer available to write to             */
-/* Output: iprcode - return code from b2f0 call               */
-/* NOTE: pathid must be specified, flag being turned on       */
-/* RESTRICTIONS: target class CANNOT be zero because the code */
-/* checks for a non-NULL value to turn flag on, therefore if  */
-/* target class = if target class = zero flag will not be     */
-/* turned on, therefore if target class is specified it cannot */
-/* be zero.                                                   */
-/**************************************************************/
-int
-iucv_receive_array (ushort pathid, ulong * msgid, ulong * trgcls,
-		    iucv_array_t * buffer, ulong * buflen,
-		    uchar * reply_required,
-		    uchar * priority_msg,
-		    ulong * adds_curr_buffer, ulong * adds_curr_length)
-{
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_receive_array\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ipmsgid = *msgid;
-	parm.ippathid = pathid;
-	parm.iptrgcls = *trgcls;
-	parm.ipflags1 |= array;	/* using an address list  */
-	parm.ipflags1 |= specify_pathid;	/*turning on pathid flag */
-	if (parm.ipmsgid)
-		parm.ipflags1 |= 0x05;
-	if (parm.iptrgcls)
-		parm.ipflags1 |= target_class;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = *buflen;
-	b2f0_result = b2f0 (receive, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	if (msgid)
-		*msgid = parm.ipmsgid;
-	if (trgcls)
-		*trgcls = parm.iptrgcls;
-	if (parm.ipflags1 & prior_msg)
-		if (priority_msg)
-			*priority_msg = 0x01;	/*yes, priority msg */
-	if (!(parm.ipflags1 & 0x10))	/*& with X'10'     */
-		if (reply_required)
-			*reply_required = 0x01;	/*yes, reply required */
-	if (!(parm.ipflags1 & parm_data)) {	/*msg not in parmlist */
-		if (adds_curr_length)
-			*adds_curr_length = parm.ipbfln1f;
-		if (adds_curr_buffer)
-			*adds_curr_buffer = parm.ipbfadr1;
-	} else {
-		if ((buffer->length) >= 8) {
-			memcpy ((char *) buffer->address,
-				(char *) parm.ipbfadr1, 8);
-			if (adds_curr_buffer)
-				*adds_curr_buffer =
-				    (ulong) ((buffer->address) + 8);
-			if (adds_curr_length)
-				*adds_curr_length = ((buffer->length) - 8);
+	parm->ipbfadr1 = (__u32) ((ulong) buffer);
+	parm->ipbfln1f = (__u32) buflen;
+	parm->ipmsgid = msgid;
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipflags1 = (IPBUFLST | IPFGPID | IPFGMID | IPFGMCL);
+
+	b2f0_result = b2f0(RECEIVE, parm);
+
+	if (b2f0_result == 0 || b2f0_result == 5) {
+
+		if (flags1_out) {
+			iucv_debug("*flags1_out = %d", *flags1_out);
+			*flags1_out = (parm->ipflags1 & (~0x07));
+			iucv_debug("*flags1_out = %d", *flags1_out);
+		}
+
+		if (!(parm->ipflags1 & IPRMDATA)) {	/*msg not in parmlist */
+
+			if (residual_length)
+				*residual_length = parm->ipbfln1f;
+
+			if (residual_buffer)
+				*residual_buffer = parm->ipbfadr1;
 
 		} else {
-			parm.iprcode |= 0x05;
-			b2f0_result = (ulong) parm.iprcode;
+			/* copy msg from parmlist to users array. */
+
+			while ((moved < 8) && (moved < buflen)) {
+				dyn_len =
+				    min ((buffer + i)->length, need_to_move);
+
+				memcpy ((char *)((ulong)((buffer + i)->address)),
+					((char *) &parm->ipbfadr1) + moved,
+					dyn_len);
+
+				moved += dyn_len;
+				need_to_move -= dyn_len;
+
+				(buffer + i)->address =
+				    	(__u32)
+				((ulong)(__u8 *) ((ulong)(buffer + i)->address)
+						+ dyn_len);
+
+				(buffer + i)->length -= dyn_len;
+				i++;
+			}
+
+			if (need_to_move)	/* buflen < 8 bytes */
+				b2f0_result = 5;
+
+			if (residual_length)
+				*residual_length = abs (buflen - 8);
+
+			if (residual_buffer) {
+				if (moved == 0)
+					*residual_buffer = (ulong) buffer;
+				else
+					*residual_buffer =
+					    (ulong) (buffer + (i - 1));
+			}
+
 		}
 	}
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_receive\n");
-#endif
-	return b2f0_result;
-}
+	release_param(parm);
 
-/**************************************************************/
-/* Name: iucv_send                                            */
-/* Purpose: sends messages                                    */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message returned to caller  */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        buffer - pointer to buffer                          */
-/*        buflen - ulong, length of buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send (ushort pathid, ulong * msgid,
-	   ulong trgcls, ulong srccls,
-	   ulong msgtag, uchar priority_msg, void *buffer, ulong buflen)
-{
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;	/* length of message */
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipflags1 |= one_way_msg;	/* one way message */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (send, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send\n");
-#endif
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_send_array                                      */
-/* Purpose: sends messages in buffer array                    */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message returned to caller  */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        buffer - pointer to iucv_array_t                    */
-/*        buflen - ulong, length of buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send_array (ushort pathid, ulong * msgid,
-		 ulong trgcls, ulong srccls,
-		 ulong msgtag, uchar priority_msg,
-		 iucv_array_t * buffer, ulong buflen)
+/**
+ * iucv_reject:
+ * @pathid: Path identification number.
+ * @msgid:  Message ID of the message to reject.
+ * @trgcls: Target class of the message to reject.
+ * Returns: return code from CP
+ *
+ * Refuses a specified message. Between the time you are notified of a
+ * message and the time that you complete the message, the message may
+ * be rejected.
+ */
+int
+iucv_reject (__u16 pathid, __u32 msgid, __u32 trgcls)
 {
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send_array\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;	/* length of message */
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipflags1 |= one_way_msg;	/* one way message */
-	parm.ipflags1 |= array;	/* one way w/ array */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send_array\n");
-#endif
-	return b2f0_result;
-}
+	iparml_db *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+	iucv_debug("pathid = %d", pathid);
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->ipmsgid = msgid;
+	parm->iptrgcls = trgcls;
+	parm->ipflags1 = (IPFGMCL | IPFGMID | IPFGPID);
+
+	b2f0_result = b2f0(REJECT, parm);
+	release_param(parm);
+
+	iucv_debug("b2f0_result = %ld", b2f0_result);
+	iucv_debug("exiting");
 
-/**************************************************************/
-/* Name: iucv_send_prmmsg                                     */
-/* Purpose: sends messages in parameter list                  */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message                     */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        prmmsg - uchar[8], message being sent               */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send_prmmsg (ushort pathid, ulong * msgid,
-		  ulong trgcls, ulong srccls,
-		  ulong msgtag, uchar priority_msg, uchar prmmsg[8])
-{
-	iparml_dpl parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send_prmmsg\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipflags1 |= parm_data;	/* message in prmlist */
-	parm.ipflags1 |= one_way_msg;	/* one way message */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	memcpy (parm.iprmmsg, prmmsg, 8);
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send_prmmsg\n");
-#endif
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_send2way                                        */
-/* Purpose: sends messages in both directions                 */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message                     */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        buffer - pointer to buffer                          */
-/*        buflen - ulong, length of buffer                    */
-/*        ansbuf - pointer to buffer on reply                 */
-/*        anslen - length of ansbuf buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send2way (ushort pathid, ulong * msgid,
-	       ulong trgcls, ulong srccls,
-	       ulong msgtag, uchar priority_msg,
-	       void *buffer, ulong buflen, void *ansbuf, ulong anslen)
+/*
+ * Name: iucv_reply
+ * Purpose: This function responds to the two-way messages that you
+ *          receive. You must identify completely the message to
+ *          which you wish to reply. ie, pathid, msgid, and trgcls.
+ * Input: pathid - path identification number
+ *        msgid - specifies the message ID.
+ *        trgcls - specifies target class
+ *        flags1 - option for path
+ *                 IPPRTY- 0x20 - specifies if you want to send priority message
+ *        buffer - address of reply buffer
+ *        buflen - length of reply buffer
+ * Output: ipbfadr2 - Address of buffer updated by the number
+ *                    of bytes you have moved.
+ *         ipbfln2f - Contains on the the following values
+ *              If the answer buffer is the same length as the reply, this field
+ *               contains zero.
+ *              If the answer buffer is longer than the reply, this field contains
+ *               the number of bytes remaining in the buffer.
+ *              If the answer buffer is shorter than the reply, this field contains
+ *               a residual count (that is, the number of bytes remianing in the
+ *               reply that does not fit into the buffer. In this
+ *                case b2f0_result = 5.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer address is NULL
+ */
+int
+iucv_reply (__u16 pathid,
+	    __u32 msgid, __u32 trgcls,
+	    int flags1,
+	    void *buffer, ulong buflen, ulong * ipbfadr2, ulong * ipbfln2f)
 {
-	iparml_db parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send2way\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;	/* length of message */
-	parm.ipbfadr2 = (ulong) ansbuf;
-	parm.ipbfln2f = anslen;
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send2way\n");
-#endif
+
+	iucv_debug("entering");
+
+	if (!buffer)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ipbfadr2 = (__u32) ((ulong) buffer);
+	parm->ipbfln2f = (__u32) buflen;	/* length of message */
+	parm->ippathid = pathid;
+	parm->ipmsgid = msgid;
+	parm->iptrgcls = trgcls;
+	parm->ipflags1 = (__u8) flags1;	/* priority message */
+
+	b2f0_result = b2f0(REPLY, parm);
+
+	if ((b2f0_result == 0) || (b2f0_result == 5)) {
+		if (ipbfadr2)
+			*ipbfadr2 = parm->ipbfadr2;
+		if (ipbfln2f)
+			*ipbfln2f = parm->ipbfln2f;
+	}
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_send2way_array                                  */
-/* Purpose: sends messages in both directions in arrays       */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message                     */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        buffer - pointer to iucv_array_t                    */
-/*        buflen - ulong, length of buffer                    */
-/*        ansbuf - pointer to iucv_array_t on reply           */
-/*        anslen - length of ansbuf buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send2way_array (ushort pathid, ulong * msgid,
-		     ulong trgcls, ulong srccls,
-		     ulong msgtag, uchar priority_msg,
-		     iucv_array_t * buffer, ulong buflen,
-		     iucv_array_t * ansbuf, ulong anslen)
+/*
+ * Name: iucv_reply_array
+ * Purpose: This function responds to the two-way messages that you
+ *          receive. You must identify completely the message to
+ *          which you wish to reply. ie, pathid, msgid, and trgcls.
+ *          The array identifies a list of addresses and lengths of
+ *          discontiguous buffers that contains the reply data.
+ * Input: pathid - path identification number
+ *        msgid - specifies the message ID.
+ *        trgcls - specifies target class
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        buffer - address of array of reply buffers
+ *        buflen - total length of reply buffers
+ * Output: ipbfadr2 - Address of buffer which IUCV is currently working on.
+ *         ipbfln2f - Contains on the the following values
+ *              If the answer buffer is the same length as the reply, this field
+ *               contains zero.
+ *              If the answer buffer is longer than the reply, this field contains
+ *               the number of bytes remaining in the buffer.
+ *              If the answer buffer is shorter than the reply, this field contains
+ *               a residual count (that is, the number of bytes remianing in the
+ *               reply that does not fit into the buffer. In this
+ *               case b2f0_result = 5.
+ * Return: b2f0_result - return code from CP
+ *             (-EINVAL) - buffer address is NULL
+*/
+int
+iucv_reply_array (__u16 pathid,
+		  __u32 msgid, __u32 trgcls,
+		  int flags1,
+		  iucv_array_t * buffer,
+		  ulong buflen, ulong * ipbfadr2, ulong * ipbfln2f)
 {
-	iparml_db parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send2way_array\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr1 = (ulong) buffer;
-	parm.ipbfln1f = buflen;	/* length of message */
-	parm.ipbfadr2 = (ulong) ansbuf;
-	parm.ipbfln2f = anslen;
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipflags1 |= array;	/* send  w/ array  */
-	parm.ipflags1 |= reply_array;	/* reply w/ array  */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send2way_array\n");
-#endif
+
+	iucv_debug("entering");
+
+	if (!buffer)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ipbfadr2 = (__u32) ((ulong) buffer);
+	parm->ipbfln2f = buflen;	/* length of message */
+	parm->ippathid = pathid;
+	parm->ipmsgid = msgid;
+	parm->iptrgcls = trgcls;
+	parm->ipflags1 = (IPANSLST | flags1);
+
+	b2f0_result = b2f0(REPLY, parm);
+
+	if ((b2f0_result == 0) || (b2f0_result == 5)) {
+
+		if (ipbfadr2)
+			*ipbfadr2 = parm->ipbfadr2;
+		if (ipbfln2f)
+			*ipbfln2f = parm->ipbfln2f;
+	}
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_send2way_prmmsg                                 */
-/* Purpose: sends messages in both directions w/parameter lst */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message                     */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        prmmsg - uchar[8], message being sent in parameter  */
-/*        ansbuf - pointer to buffer                          */
-/*        anslen - length of ansbuf buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send2way_prmmsg (ushort pathid, ulong * msgid,
-		      ulong trgcls, ulong srccls,
-		      ulong msgtag, uchar priority_msg,
-		      uchar prmmsg[8], void *ansbuf, ulong anslen)
+/*
+ * Name: iucv_reply_prmmsg
+ * Purpose: This function responds to the two-way messages that you
+ *          receive. You must identify completely the message to
+ *          which you wish to reply. ie, pathid, msgid, and trgcls.
+ *          Prmmsg signifies the data is moved into the
+ *          parameter list.
+ * Input: pathid - path identification number
+ *        msgid - specifies the message ID.
+ *        trgcls - specifies target class
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        prmmsg - 8-bytes of data to be placed into the parameter
+ *                 list.
+ * Output: NA
+ * Return: b2f0_result - return code from CP
+*/
+int
+iucv_reply_prmmsg (__u16 pathid,
+		   __u32 msgid, __u32 trgcls, int flags1, __u8 prmmsg[8])
 {
-	iparml_dpl parm;
+	iparml_dpl *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send2way_prmmsg\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipbfadr2 = (ulong) ansbuf;
-	parm.ipbfln2f = anslen;
-	parm.ipflags1 |= parm_data;	/* message in prmlist */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	memcpy (parm.iprmmsg, prmmsg, 8);
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send2way_prmmsg\n");
-#endif
+
+	iucv_debug("entering");
+
+	parm = (iparml_dpl *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->ipmsgid = msgid;
+	parm->iptrgcls = trgcls;
+	memcpy(parm->iprmmsg, prmmsg, sizeof (parm->iprmmsg));
+	parm->ipflags1 = (IPRMDATA | flags1);
+
+	b2f0_result = b2f0(REPLY, parm);
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_reply                                           */
-/* Purpose: responds to the two-way messages that you receive */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, id of message                       */
-/*        trgcls - ulong, target message class                */
-/*        priority_msg - uchar, flag                          */
-/*        buf    - pointer, address of buffer                 */
-/*        buflen - length of buffer                           */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
+/**
+ * iucv_resume:
+ * @pathid:    Path identification number
+ * @user_data: 16-byte of user data
+ *
+ * This function restores communication over a quiesced path.
+ * Returns: return code from CP
+ */
 int
-iucv_reply (ushort pathid, ulong msgid, ulong trgcls,
-	    uchar priority_msg, void *buf, ulong buflen)
+iucv_resume (__u16 pathid, __u8 user_data[16])
 {
-	iparml_db parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_reply\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.ipmsgid = msgid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr2 = (ulong) buf;
-	parm.ipbfln2f = buflen;	/* length of message */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (reply, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_reply\n");
-#endif
+	iparml_control *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+	iucv_debug("pathid = %d", pathid);
+
+	parm = (iparml_control *)grab_param();
+
+	memcpy (parm->ipuser, user_data, sizeof (*user_data));
+	parm->ippathid = pathid;
+
+	b2f0_result = b2f0(RESUME, parm);
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_reply_array                                     */
-/* Purpose: responds to the two-way messages that you receive */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, id of message                       */
-/*        trgcls - ulong, target message class                */
-/*        priority_msg - uchar, flag                          */
-/*        buf    - pointer, address of array                  */
-/*        buflen - length of buffer                           */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
+/*
+ * Name: iucv_send
+ * Purpose: sends messages
+ * Input: pathid - ushort, pathid
+ *        msgid  - ulong *, id of message returned to caller
+ *        trgcls - ulong, target message class
+ *        srccls - ulong, source message class
+ *        msgtag - ulong, message tag
+ *	  flags1  - Contains options for this path.
+ *		IPPRTY - Ox20 - specifies if you want to send a priority message.
+ *        buffer - pointer to buffer
+ *        buflen - ulong, length of buffer
+ * Output: b2f0_result - return code from b2f0 call
+ *         msgid - returns message id
+ */
 int
-iucv_reply_array (ushort pathid, ulong msgid, ulong trgcls,
-		  uchar priority_msg, iucv_array_t * buffer, ulong buflen)
+iucv_send (__u16 pathid, __u32 * msgid,
+	   __u32 trgcls, __u32 srccls,
+	   __u32 msgtag, int flags1, void *buffer, ulong buflen)
 {
-	iparml_db parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_reply_array\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.ipmsgid = msgid;
-	parm.iptrgcls = trgcls;
-	parm.ipbfadr2 = (ulong) buffer;
-	parm.ipbfln2f = buflen;	/* length of message */
-	parm.ipflags1 |= reply_array;	/* reply w/ array  */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (reply, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_reply_array\n");
-#endif
+
+	iucv_debug("entering");
+
+	if (!buffer)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ipbfadr1 = (__u32) ((ulong) buffer);
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipbfln1f = (__u32) buflen;	/* length of message */
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipflags1 = (IPNORPY | flags1);	/* one way priority message */
+
+	b2f0_result = b2f0(SEND, parm);
+
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_reply_prmmsg                                    */
-/* Purpose: responds to the two-way messages in parameter list */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong, id of message                       */
-/*        trgcls - ulong, target message class                */
-/*        priority_msg - uchar, flag                          */
-/*        prmmsg - uchar[8], message in parameter list        */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
+/*
+ * Name: iucv_send_array
+ * Purpose: This function transmits data to another application.
+ *          The contents of buffer is the address of the array of
+ *          addresses and lengths of discontiguous buffers that hold
+ *          the message text. This is a one-way message and the
+ *          receiver will not reply to the message.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - specifies a tag to be associated witht the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        buffer - address of array of send buffers
+ *        buflen - total length of send buffers
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer address is NULL
+ */
+int
+iucv_send_array (__u16 pathid,
+		 __u32 * msgid,
+		 __u32 trgcls,
+		 __u32 srccls,
+		 __u32 msgtag, int flags1, iucv_array_t * buffer, ulong buflen)
+{
+	iparml_db *parm;
+	ulong b2f0_result;
+
+	iucv_debug("entering");
+
+	if (!buffer)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipbfadr1 = (__u32) ((ulong) buffer);
+	parm->ipbfln1f = (__u32) buflen;	/* length of message */
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipflags1 = (IPNORPY | IPBUFLST | flags1);
+	b2f0_result = b2f0(SEND, parm);
+
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+	return b2f0_result;
+}
+
+/*
+ * Name: iucv_send_prmmsg
+ * Purpose: This function transmits data to another application.
+ *          Prmmsg specifies that the 8-bytes of data are to be moved
+ *          into the parameter list. This is a one-way message and the
+ *          receiver will not reply to the message.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - specifies a tag to be associated with the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        prmmsg - 8-bytes of data to be placed into parameter list
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+*/
+int
+iucv_send_prmmsg (__u16 pathid,
+		  __u32 * msgid,
+		  __u32 trgcls,
+		  __u32 srccls, __u32 msgtag, int flags1, __u8 prmmsg[8])
+{
+	iparml_dpl *parm;
+	ulong b2f0_result;
+
+	iucv_debug("entering");
+
+	parm = (iparml_dpl *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipflags1 = (IPRMDATA | IPNORPY | flags1);
+	memcpy(parm->iprmmsg, prmmsg, sizeof(parm->iprmmsg));
+
+	b2f0_result = b2f0(SEND, parm);
+
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+
+	return b2f0_result;
+}
+
+/*
+ * Name: iucv_send2way
+ * Purpose: This function transmits data to another application.
+ *          Data to be transmitted is in a buffer. The receiver
+ *          of the send is expected to reply to the message and
+ *          a buffer is provided into which IUCV moves the reply
+ *          to this message.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - specifies a tag associated with the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        buffer - address of send buffer
+ *        buflen - length of send buffer
+ *        ansbuf - address of buffer to reply with
+ *        anslen - length of buffer to reply with
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer or ansbuf address is NULL
+ */
 int
-iucv_reply_prmmsg (ushort pathid, ulong msgid, ulong trgcls,
-		   uchar priority_msg, uchar prmmsg[8])
+iucv_send2way (__u16 pathid,
+	       __u32 * msgid,
+	       __u32 trgcls,
+	       __u32 srccls,
+	       __u32 msgtag,
+	       int flags1,
+	       void *buffer, ulong buflen, void *ansbuf, ulong anslen)
 {
-	iparml_dpl parm;
+	iparml_db *parm;
 	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_reply_prmmsg\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.ipmsgid = msgid;
-	parm.iptrgcls = trgcls;
-	memcpy (parm.iprmmsg, prmmsg, 8);
-	parm.ipflags1 |= parm_data;
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	b2f0_result = b2f0 (reply, &parm);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_reply_prmmsg\n");
-#endif
+
+	iucv_debug("entering");
+
+	if (!buffer || !ansbuf)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipbfadr1 = (__u32) ((ulong) buffer);
+	parm->ipbfln1f = (__u32) buflen;	/* length of message */
+	parm->ipbfadr2 = (__u32) ((ulong) ansbuf);
+	parm->ipbfln2f = (__u32) anslen;
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipflags1 = flags1;	/* priority message */
+
+	b2f0_result = b2f0(SEND, parm);
+
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_connect                                         */
-/* Purpose: establishes an IUCV path to another vm            */
-/* Input: pathid - ushort *, pathid returned to user          */
-/*        msglim - ushort, limit of outstanding messages      */
-/*        user_data - uchar[16], user data                    */
-/*        userid - uchar[8], user's id                        */
-/*        system_name - uchar[8], system identification       */
-/*        priority_requested - uchar- flag                    */
-/*        prmdata - uchar, flag prgrm can handler messages    */
-/*                  in parameter list                         */
-/*        quiesce - uchar, flag to quiesce a path being establ */
-/*        control - uchar, flag, option not used              */
-/*        local   - uchar, flag, establish connection only on */
-/*                  local system                              */
-/*        priority_permitted - uchar *, flag returned to user */
-/*        handle - address of handler                         */
-/*        pgm_data - ulong                                    */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
-int
-iucv_connect (ushort * pathid, ushort msglim, uchar user_data[16],
-	      uchar userid[8], uchar system_name[8],
-	      uchar priority_requested, uchar prmdata,
-	      uchar quiesce, uchar control,
-	      uchar local, uchar * priority_permitted,
-	      iucv_handle_t handle, ulong pgm_data)
+/*
+ * Name: iucv_send2way_array
+ * Purpose: This function transmits data to another application.
+ *          The contents of buffer is the address of the array of
+ *          addresses and lengths of discontiguous buffers that hold
+ *          the message text. The receiver of the send is expected to
+ *          reply to the message and a buffer is provided into which
+ *          IUCV moves the reply to this message.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - spcifies a tag to be associated with the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        buffer - address of array of send buffers
+ *        buflen - total length of send buffers
+ *        ansbuf - address of buffer to reply with
+ *        anslen - length of buffer to reply with
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer address is NULL
+ */
+int
+iucv_send2way_array (__u16 pathid,
+		     __u32 * msgid,
+		     __u32 trgcls,
+		     __u32 srccls,
+		     __u32 msgtag,
+		     int flags1,
+		     iucv_array_t * buffer,
+		     ulong buflen, iucv_array_t * ansbuf, ulong anslen)
+{
+	iparml_db *parm;
+	ulong b2f0_result;
+
+	iucv_debug("entering");
+
+	if (!buffer || !ansbuf)
+		return -EINVAL;
+
+	parm = (iparml_db *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipbfadr1 = (__u32) ((ulong) buffer);
+	parm->ipbfln1f = (__u32) buflen;	/* length of message */
+	parm->ipbfadr2 = (__u32) ((ulong) ansbuf);
+	parm->ipbfln2f = (__u32) anslen;
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipflags1 = (IPBUFLST | IPANSLST | flags1);
+	b2f0_result = b2f0(SEND, parm);
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+	return b2f0_result;
+}
+
+/*
+ * Name: iucv_send2way_prmmsg
+ * Purpose: This function transmits data to another application.
+ *          Prmmsg specifies that the 8-bytes of data are to be moved
+ *          into the parameter list. This is a two-way message and the
+ *          receiver of the message is expected to reply. A buffer
+ *          is provided into which IUCV moves the reply to this
+ *          message.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - specifies a tag to be associated with the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        prmmsg - 8-bytes of data to be placed in parameter list
+ *        ansbuf - address of buffer to reply with
+ *        anslen - length of buffer to reply with
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - buffer address is NULL
+*/
+int
+iucv_send2way_prmmsg (__u16 pathid,
+		      __u32 * msgid,
+		      __u32 trgcls,
+		      __u32 srccls,
+		      __u32 msgtag,
+		      ulong flags1, __u8 prmmsg[8], void *ansbuf, ulong anslen)
+{
+	iparml_dpl *parm;
+	ulong b2f0_result;
+
+	iucv_debug("entering");
+
+	if (!ansbuf)
+		return -EINVAL;
+
+	parm = (iparml_dpl *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipbfadr2 = (__u32) ((ulong) ansbuf);
+	parm->ipbfln2f = (__u32) anslen;
+	parm->ipflags1 = (IPRMDATA | flags1);	/* message in prmlist */
+	memcpy(parm->iprmmsg, prmmsg, sizeof(parm->iprmmsg));
+
+	b2f0_result = b2f0(SEND, parm);
+
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
+
+	return b2f0_result;
+}
+
+/*
+ * Name: iucv_send2way_prmmsg_array
+ * Purpose: This function transmits data to another application.
+ *          Prmmsg specifies that the 8-bytes of data are to be moved
+ *          into the parameter list. This is a two-way message and the
+ *          receiver of the message is expected to reply. A buffer
+ *          is provided into which IUCV moves the reply to this
+ *          message. The contents of ansbuf is the address of the
+ *          array of addresses and lengths of discontiguous buffers
+ *          that contain the reply.
+ * Input: pathid - path identification number
+ *        trgcls - specifies target class
+ *        srccls - specifies the source message class
+ *        msgtag - specifies a tag to be associated with the message
+ *        flags1 - option for path
+ *                 IPPRTY- specifies if you want to send priority message
+ *        prmmsg - 8-bytes of data to be placed into the parameter list
+ *        ansbuf - address of buffer to reply with
+ *        anslen - length of buffer to reply with
+ * Output: msgid - specifies the message ID.
+ * Return: b2f0_result - return code from CP
+ *         (-EINVAL) - ansbuf address is NULL
+ */
+int
+iucv_send2way_prmmsg_array (__u16 pathid,
+			    __u32 * msgid,
+			    __u32 trgcls,
+			    __u32 srccls,
+			    __u32 msgtag,
+			    int flags1,
+			    __u8 prmmsg[8],
+			    iucv_array_t * ansbuf, ulong anslen)
 {
-	iparml_control parm;
+	iparml_dpl *parm;
 	ulong b2f0_result;
-	int add_pathid_result, rc;
-	handler *R;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_connect\n");
-#endif
-	memset (&parm, 0, sizeof (parm));
-	if (declare_flag == NULL) {
-		rc = iucv_declare_buffer (iucv_external_int_buffer);
-		if (rc) {
-			printk (KERN_DEBUG "IUCV: registration failed\n");
-#ifdef DEBUG
-			printk (KERN_DEBUG "rc from declare buffer is: %i\n",
-				rc);
-#endif
-			return rc;
-		} else
-			declare_flag = 1;
-	}
-	/* Checking if handle is valid  */
-	spin_lock (&lock);
-	for (R = handler_anchor; R != NULL; R = (handler *) R->next)
-		if (R == handle)
-			break;
-	if (R == NULL) {
-		spin_unlock (&lock);
-#ifdef DEBUG
-		printk (KERN_DEBUG "iucv_connect: Invalid Handle\n");
-#endif
-		return (-2);
-	}
-	if (pathid == NULL) {
-		spin_unlock (&lock);
-#ifdef DEBUG
-		printk (KERN_DEBUG "iucv_connect: invalid pathid pointer\n");
-#endif
-		return (-3);
-	}
-	spin_unlock (&lock);
-	parm.ipmsglim = msglim;
-	memcpy (parm.ipuser, user_data, 16);
-	memcpy (parm.ipvmid, userid, 8);
-	memcpy (parm.iptarget, system_name, 8);
-	if (parm.iptarget)
-		ASCEBC (parm.iptarget, 8);
-	if (parm.ipvmid) {
-		ASCEBC (parm.ipvmid, 8);
-		EBC_TOUPPER(parm.ipvmid, 8);
-	}
-	if (priority_requested)
-		parm.ipflags1 |= prior_msg;
-	if (prmdata)
-		parm.ipflags1 |= parm_data;	/*data in parameter list */
-	if (quiesce)
-		parm.ipflags1 |= quiesce_msg;
-	if (control) {
-		/* do nothing at the time being  */
-		/*control not provided yet */
-	}
-	if (local)
-		parm.ipflags1 |= local_conn;	/*connect on local system */
-	b2f0_result = b2f0 (connect, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	add_pathid_result = add_pathid (parm.ippathid, handle, pgm_data);
-	if (add_pathid_result) {
-#ifdef DEBUG
-		printk (KERN_DEBUG "iucv_connect: add_pathid failed \n");
-#endif
-		return (add_pathid_result);
-	}
-	*pathid = parm.ippathid;
-	if (parm.ipflags1 & prior_msg)
-		if (priority_permitted)
-			*priority_permitted = 0x01;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_connect\n");
-#endif
+
+	iucv_debug("entering");
+
+	if (!ansbuf)
+		return -EINVAL;
+
+	parm = (iparml_dpl *)grab_param();
+
+	parm->ippathid = pathid;
+	parm->iptrgcls = trgcls;
+	parm->ipsrccls = srccls;
+	parm->ipmsgtag = msgtag;
+	parm->ipbfadr2 = (__u32) ((ulong) ansbuf);
+	parm->ipbfln2f = (__u32) anslen;
+	parm->ipflags1 = (IPRMDATA | IPANSLST | flags1);
+	memcpy(parm->iprmmsg, prmmsg, sizeof(parm->iprmmsg));
+	b2f0_result = b2f0(SEND, parm);
+	if ((b2f0_result == 0) && (msgid))
+		*msgid = parm->ipmsgid;
+	release_param(parm);
+
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_accept                                          */
-/* Purpose: completes the iucv communication path             */
-/* Input: pathid - ushort , pathid                            */
-/*        msglim - ushort, limit of outstanding messages      */
-/*        user_data - uchar[16], user data                    */
-/*        priority_requested - uchar- flag                    */
-/*        prmdata - uchar, flag prgrm can handler messages    */
-/*                  in parameter list                         */
-/*        quiesce - uchar, flag to quiesce a path being establ*/
-/*        control - uchar, flag, option not used              */
-/*        priority_permitted -uchar *, flag returned to caller*/
-/*        handle - address of handler                         */
-/*        pgm_data - ulong                                    */
-/* Output: iprcode - return code from b2f0 call               */
-/**************************************************************/
-int
-iucv_accept (ushort pathid, ushort msglim, uchar user_data[16],
-	     uchar priority_requested,
-	     uchar prmdata, uchar quiesce, uchar control,
-	     uchar * priority_permitted, iucv_handle_t handle, ulong pgm_data)
-{
-	ulong index1, index2;
-	handler_table_entry *P = 0;
-	iparml_control parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_accept\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.ipmsglim = msglim;
-	memcpy (parm.ipuser, user_data, 16);
-	if (priority_requested)
-		parm.ipflags1 |= prior_msg;
-	if (prmdata)
-		parm.ipflags1 |= parm_data;	/*data in parameter list */
-	if (quiesce)
-		parm.ipflags1 |= quiesce_msg;
-	if (control) {
-		/* do nothing at the time being  */
-		/*control not provided yet */
-	}
-	b2f0_result = b2f0 (accept, &parm);
-	if (b2f0_result)
-		return b2f0_result;
-	index1 = ((ulong) pathid) / 512;
-	index2 = ((ulong) pathid) % 512;
-	spin_lock (&lock);
-	if (pgm_data) {
-		P = main_table[index1];
-		(P + index2)->pgm_data = pgm_data;
-	}
-	spin_unlock (&lock);
-	if (parm.ipflags1 & prior_msg)
-		if (priority_permitted)
-			*priority_permitted = 0x01;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_accept\n");
-#endif
+/*
+ * Name: iucv_setmask
+ * Purpose: This function enables or disables the following IUCV
+ *          external interruptions: Nonpriority and priority message
+ *          interrupts, nonpriority and priority reply interrupts.
+ * Input: SetMaskFlag - options for interrupts
+ *           0x80 - Nonpriority_MessagePendingInterruptsFlag
+ *           0x40 - Priority_MessagePendingInterruptsFlag
+ *           0x20 - Nonpriority_MessageCompletionInterruptsFlag
+ *           0x10 - Priority_MessageCompletionInterruptsFlag
+ * Output: NA
+ * Return: b2f0_result - return code from CP
+*/
+int
+iucv_setmask (int SetMaskFlag)
+{
+	iparml_set_mask *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+
+	parm = (iparml_set_mask *)grab_param();
+
+	parm->ipmask = (__u8)SetMaskFlag;
+
+	b2f0_result = b2f0(SETMASK, parm);
+	release_param(parm);
+
+	iucv_debug("b2f0_result = %ld", b2f0_result);
+	iucv_debug("exiting");
+
 	return b2f0_result;
 }
 
-/**************************************************************/
-/* Name: iucv_send2way_prmmsg_array                           */
-/* Purpose: sends messages in both directions w/parameter lst */
-/* Input: pathid - ushort, pathid                             */
-/*        msgid  - ulong *, id of message returned to caller  */
-/*        trgcls - ulong, target message class                */
-/*        srccls - ulong, source message class                */
-/*        msgtag - ulong, message tag                         */
-/*        priority_msg - uchar, flag                          */
-/*        prmmsg - uchar[8], message being sent in parameter  */
-/*        ansbuf - pointer to array of buffers                */
-/*        anslen - length of ansbuf buffer                    */
-/* Output: iprcode - return code from b2f0 call               */
-/*         msgid - returns message id                         */
-/**************************************************************/
-int
-iucv_send2way_prmmsg_array (ushort pathid, ulong * msgid,
-			    ulong trgcls, ulong srccls,
-			    ulong msgtag, uchar priority_msg,
-			    uchar prmmsg[8],
-			    iucv_array_t * ansbuf, ulong anslen)
+/**
+ * iucv_sever:
+ * @pathid:    Path identification number
+ * @user_data: 16-byte of user data
+ *
+ * This function terminates an iucv path.
+ * Returns: return code from CP
+ */
+int
+iucv_sever(__u16 pathid, __u8 user_data[16])
 {
-	iparml_dpl parm;
-	ulong b2f0_result;
-#ifdef DEBUG
-	printk (KERN_DEBUG "entering iucv_send2way_prmmsg\n");
-#endif
-	memset (&(parm), 0, sizeof (parm));
-	parm.ippathid = pathid;
-	parm.iptrgcls = trgcls;
-	parm.ipsrccls = srccls;
-	parm.ipmsgtag = msgtag;
-	parm.ipbfadr2 = (ulong) ansbuf;
-	parm.ipbfln2f = anslen;
-	parm.ipflags1 |= 0x88;	/* message in prmlist */
-	if (priority_msg)
-		parm.ipflags1 |= prior_msg;	/* priority message */
-	memcpy (parm.iprmmsg, prmmsg, 8);
-	b2f0_result = b2f0 (send, &parm);
-	if (msgid)
-		*msgid = parm.ipmsgid;
-#ifdef DEBUG
-	printk (KERN_DEBUG "exiting iucv_send2way_prmmsg\n");
-#endif
+	iparml_control *parm;
+	ulong b2f0_result = 0;
+
+	iucv_debug("entering");
+	parm = (iparml_control *)grab_param();
+
+	memcpy(parm->ipuser, user_data, sizeof(parm->ipuser));
+	parm->ippathid = pathid;
+
+	b2f0_result = b2f0(SEVER, parm);
+
+	if (!b2f0_result)
+		iucv_remove_pathid(pathid);
+	release_param(parm);
+
+	iucv_debug("exiting");
 	return b2f0_result;
 }
 
-/******************************************************************/
-/* Name: top_half_handler                                         */
-/* Purpose: handle minimum amount of interrupt in fastest time    */
-/*  possible and then pass interrupt to bottom half handler.      */
-/* Input: external interrupt buffer                               */
-/* Output: void                                                   */
-/******************************************************************/
-
-inline void
-top_half_interrupt (struct pt_regs *regs, __u16 code)
-{
-	iucv_packet *pkt;
-	pkt = (iucv_packet *) kmalloc
-	    (sizeof (iucv_packet), GFP_ATOMIC);
-	if (pkt == NULL) {
-		printk (KERN_DEBUG "out of memory\n");
+/*
+ * Interrupt Handlers
+ *******************************************************************************/
+
+/**
+ * iucv_irq_handler:
+ * @regs: Current registers
+ * @code: irq code
+ *
+ * Handles external interrupts coming in from CP.
+ * Places the interrupt buffer on a queue and schedules iucv_bh_handler().
+ */
+static void
+iucv_irq_handler(struct pt_regs *regs, __u16 code)
+{
+	iucv_irqdata *irqdata;
+	int          cpu = smp_processor_id();
+
+	irq_enter(cpu, 0x4000);
+
+	irqdata = kmalloc(sizeof(iucv_irqdata), GFP_ATOMIC);
+	if (!irqdata) {
+		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
+		irq_exit(cpu, 0x4000);
 		return;
 	}
-	memcpy (pkt->data, iucv_external_int_buffer, 40);
-#ifdef DEBUG3
-printk (KERN_EMERG "TH: Got INT: %08x\n", *(int *)(pkt->data+4));
-#endif
-	/* put new packet on the list */
-	spin_lock (&iucv_packets_lock);
-	pkt->next = NULL;
-	if (iucv_packets_tail != NULL)
-		iucv_packets_tail->next = pkt;
-	else
-		iucv_packets_head = pkt;
-	iucv_packets_tail = pkt;
-	spin_unlock (&iucv_packets_lock);
-
-	if (atomic_compare_and_swap (0, 1, &bh_scheduled) == 0) {
-#ifdef DEBUG3
-printk (KERN_EMERG "TH: Queuing BH\n");
-#endif
-		INIT_LIST_HEAD(&short_task.list);
-		short_task.sync = 0;
-		short_task.routine = (void *) bottom_half_interrupt;
-		queue_task (&short_task, &tq_immediate);
-		mark_bh (IMMEDIATE_BH);
+
+	memcpy(&irqdata->data, iucv_external_int_buffer,
+	       sizeof(iucv_GeneralInterrupt));
+
+	spin_lock(&iucv_irq_queue_lock);
+	list_add_tail(&irqdata->queue, &iucv_irq_queue);
+	spin_unlock(&iucv_irq_queue_lock);
+
+	if (atomic_compare_and_swap (0, 1, &iucv_bh_scheduled) == 0) {
+		queue_task (&iucv_tq, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
 	}
+
+	irq_exit(cpu, 0x4000);
 	return;
 }
 
-/*******************************************************************/
-/* Name: bottom_half_interrupt                                     */
-/* Purpose: Handle interrupt at a more safer time                  */
-/* Input: void                                                     */
-/* Output: void                                                    */
-/*******************************************************************/
-void
-bottom_half_interrupt (void)
+/**
+ * iucv_do_int:
+ * @int_buf: Pointer to copy of external interrupt buffer
+ *
+ * The workhorse for handling interrupts queued by iucv_irq_handler().
+ * This function is called from the bottom half iucv_bh_handler().
+ */
+static void
+iucv_do_int(iucv_GeneralInterrupt * int_buf)
 {
-	iucv_packet *iucv_packet_list;
-	iucv_packet *tmp;
+	handler *h = NULL;
+	struct list_head *lh;
 	ulong flags;
+	iucv_interrupt_ops_t *interrupt = NULL;	/* interrupt addresses */
+	__u8 temp_buff1[24], temp_buff2[24];	/* masked handler id. */
+	int rc = 0, j = 0;
+	__u8 no_listener[16] = "NO LISTENER";
+
+	iucv_debug("entering, pathid %d, type %02X",
+		 int_buf->ippathid, int_buf->iptype);
+	iucv_debug("External Interrupt Buffer:");
+	iucv_dumpit(int_buf, sizeof(iucv_GeneralInterrupt));
 
-	atomic_set (&bh_scheduled, 0);
-	spin_lock_irqsave (&iucv_packets_lock, flags);
-	iucv_packet_list = iucv_packets_head;
-	iucv_packets_head = iucv_packets_tail = NULL;
-	spin_unlock_irqrestore (&iucv_packets_lock, flags);
-
-	/* now process all the request in the iucv_packet_list */
-#ifdef DEBUG3
-	printk (KERN_EMERG "BH: Process all packets\n");
-#endif
-	while (iucv_packet_list != NULL) {
-#ifdef DEBUG3
-		printk( KERN_EMERG "BH:>  %08x\n", 
-			*(int *)(iucv_packet_list->data+4));
-#endif
-		do_int ((iucv_ConnectionPending *) iucv_packet_list->data);
-#ifdef DEBUG3
-		printk( KERN_EMERG "BH:<  %08x\n",
-			*(int *)(iucv_packet_list->data+4));
-#endif
-		tmp = iucv_packet_list;
-		iucv_packet_list = iucv_packet_list->next;
-		kfree (tmp);
-	}
-#ifdef DEBUG3
-	printk (KERN_EMERG "BH: Done\n");
-#endif
-	return;
-}
-/*******************************************************************/
-/* Name: do_int                                                    */
-/* Purpose: Handle interrupt in a more safe environment            */
-/* Inuput: int_buf - pointer to copy of external interrupt buffer  */
-/* Output: void                                                    */
-/*******************************************************************/
-void
-do_int (iucv_ConnectionPending * int_buf)
-{
-	ulong index1 = 0, index2 = 0;
-	handler_table_entry *P = 0;	/* P is a pointer */
-	handler *Q = 0, *R;	/* Q and R are pointers */
-	iucv_interrupt_ops_t *interrupt = 0;	/* interrupt addresses */
-	uchar temp_buff1[24], temp_buff2[24];	/* masked handler id. */
-	int add_pathid_result = 0, j = 0;
-	uchar no_listener[16] = "NO LISTENER";
-#ifdef DEBUG
-	int i;
-	uchar *prt_parm;
-#endif
-#ifdef DEBUG3
-	printk (KERN_DEBUG "BH:-  Entered do_int "
-	                   "pathid %d, type %02X\n",
-		int_buf->ippathid, int_buf->iptype);
-#endif
-#ifdef DEBUG
-	prt_parm = (uchar *) (int_buf);
-	printk (KERN_DEBUG "External Interrupt Buffer\n");
-	for (i = 0; i < 40; i++)
-		printk (KERN_DEBUG "%02x ", prt_parm[i]);
-	printk (KERN_DEBUG "\n");
-#endif
 	ASCEBC (no_listener, 16);
+
 	if (int_buf->iptype != 01) {
-		index1 = ((ulong) (int_buf->ippathid)) / 512;
-		index2 = ((ulong) (int_buf->ippathid)) % 512;
-		spin_lock (&lock);
-
-		P = main_table[index1];
-		Q = (P + index2)->addrs;
-		interrupt = Q->interrupt_table;	/* interrupt functions */
-		spin_unlock (&lock);
-#ifdef DEBUG
-		printk (KERN_DEBUG "Handler is: \n");
-		prt_parm = (uchar *) Q;
-		for (i = 0; i < sizeof (handler); i++)
-			printk (KERN_DEBUG " %02x ", prt_parm[i]);
-		printk (KERN_DEBUG "\n");
-#endif
-	}			/* end of if statement */
-	switch (int_buf->iptype) {
-	case 0x01:		/* connection pending */
-		spin_lock (&lock);
-		for (R = handler_anchor; R != NULL; R = (handler *) R->next) {
-			memcpy (temp_buff1, &(int_buf->ipvmid), 24);
-			memcpy (temp_buff2, &(R->vmid), 24);
-			for (j = 0; j < 24; j++) {
-				temp_buff1[j] = (temp_buff1[j]) & (R->mask)[j];
-				temp_buff2[j] = (temp_buff2[j]) & (R->mask)[j];
-			}
-#ifdef DEBUG
-			for (i = 0; i < sizeof (temp_buff1); i++)
-				printk (KERN_DEBUG " %c ", temp_buff1[i]);
-			printk (KERN_DEBUG "\n");
-			for (i = 0; i < sizeof (temp_buff2); i++)
-				printk (KERN_DEBUG " %c ", temp_buff2[i]);
-			printk (KERN_DEBUG "\n");
-#endif
-			if (memcmp((void *) temp_buff1,
-				   (void *) temp_buff2, 24) == 0) {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"found a matching handler\n");
-#endif
-				break;
-			}
+		if ((int_buf->ippathid) > (max_connections - 1)) {
+			printk(KERN_WARNING "%s: Got interrupt with pathid %d"
+			       " > max_connections (%ld)\n", __FUNCTION__,
+			       int_buf->ippathid, max_connections - 1);
+		} else {
+			h = iucv_pathid_table[int_buf->ippathid];
+			interrupt = h->interrupt_table;
+
+			iucv_debug("Handler:");
+			iucv_dumpit(h, sizeof(handler));
 		}
-		spin_unlock (&lock);
-		if (R) {
-			/* ADD PATH TO PATHID TABLE */
-			add_pathid_result =
-			    add_pathid (int_buf->ippathid, R, R->pgm_data);
-			if (add_pathid_result == NULL) {
-				interrupt = R->interrupt_table;
-				if ((*interrupt).ConnectionPending) {
-					EBCASC (int_buf->ipvmid, 8);
+	}
+
+	/* end of if statement */
+	switch (int_buf->iptype) {
+		case 0x01:		/* connection pending */
+			spin_lock_irqsave(&iucv_lock, flags);
+			list_for_each(lh, &iucv_handler_table) {
+				h = list_entry(lh, handler, list);
+				memcpy(temp_buff1, &(int_buf->ipvmid), 24);
+				memcpy(temp_buff2, &(h->id.userid), 24);
+				for (j = 0; j < 24; j++) {
+					temp_buff1[j] &= (h->id.mask)[j];
+					temp_buff2[j] &= (h->id.mask)[j];
+				}
+				
+				iucv_debug("temp_buff1:");
+				iucv_dumpit(temp_buff1, sizeof(temp_buff1));
+				iucv_debug("temp_buff2");
+				iucv_dumpit(temp_buff2, sizeof(temp_buff2));
+				
+				if (memcmp (temp_buff1, temp_buff2, 24) == 0) {
 					
-					    ((*interrupt).
-					 ConnectionPending) (int_buf,
-							     R->pgm_data);
-				} else {
+					iucv_debug("found a matching handler");
+					break;
+				}
+			}
+			spin_unlock_irqrestore (&iucv_lock, flags);
+			if (h) {
+				/* ADD PATH TO PATHID TABLE */
+				rc = iucv_add_pathid(int_buf->ippathid, h);
+				if (rc) {
 					iucv_sever (int_buf->ippathid,
 						    no_listener);
+					iucv_debug("add_pathid failed, rc = %d",
+						   (int)add_pathid_result);
+				} else {
+					interrupt = h->interrupt_table;
+					if (interrupt->ConnectionPending) {
+						EBCASC (int_buf->ipvmid, 8);
+						interrupt->ConnectionPending(
+							(iucv_ConnectionPending *)int_buf,
+							h->pgm_data);
+					} else
+						iucv_sever(int_buf->ippathid,
+							   no_listener);
 				}
-			} /* end if if(add_p...... */
-			else {
-				iucv_sever (int_buf->ippathid, no_listener);
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"add_pathid failed with rc = %d\n",
-					(int) add_pathid_result);
-#endif
-			}
-		} else
-			iucv_sever (int_buf->ippathid, no_listener);
-		break;
-	case 0x02:		/*connection complete */
-		if (Q) {
-			if ((*interrupt).ConnectionComplete)
-				((*interrupt).ConnectionComplete)
-				    
-				    ((iucv_ConnectionComplete *) int_buf,
-				     (P + index2)->pgm_data);
-			else {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"ConnectionComplete not called\n");
-				printk (KERN_DEBUG "routine@ is %p\n",
-					(*interrupt).ConnectionComplete);
-#endif
+			} else
+				iucv_sever(int_buf->ippathid, no_listener);
+			break;
+			
+		case 0x02:		/*connection complete */
+			if (h) {
+				if (interrupt->ConnectionComplete)
+					interrupt->ConnectionComplete(
+						(iucv_ConnectionComplete *)int_buf,
+						h->pgm_data);
+				else
+					iucv_debug("ConnectionComplete not called");
 			}
-		}
-		break;
-	case 0x03:		/* connection severed */
-		if (Q) {
-			if ((*interrupt).ConnectionSevered)
-				((*interrupt).ConnectionSevered)
-				    
-				    ((iucv_ConnectionSevered *) int_buf,
-				     (P + index2)->pgm_data);
-			else
-				iucv_sever (int_buf->ippathid, no_listener);
-		} else
-			iucv_sever (int_buf->ippathid, no_listener);
-		break;
-	case 0x04:		/* connection quiesced */
-		if (Q) {
-			if ((*interrupt).ConnectionQuiesced)
-				((*interrupt).ConnectionQuiesced)
-				    
-				    ((iucv_ConnectionQuiesced *) int_buf,
-				     (P + index2)->pgm_data);
-			else {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"ConnectionQuiesced not called\n");
-				printk (KERN_DEBUG "routine@ is %p\n",
-					(*interrupt).ConnectionQuiesced);
-#endif
+			
+			break;
+			
+		case 0x03:		/* connection severed */
+			if (h) {
+				if (interrupt->ConnectionSevered)
+					interrupt->ConnectionSevered(
+						(iucv_ConnectionSevered *)int_buf,
+						h->pgm_data);
+				
+				else
+					iucv_sever (int_buf->ippathid, no_listener);
+			} else
+				iucv_sever(int_buf->ippathid, no_listener);
+			break;
+			
+		case 0x04:		/* connection quiesced */
+			if (h) {
+				if (interrupt->ConnectionQuiesced)
+					interrupt->ConnectionQuiesced(
+						(iucv_ConnectionQuiesced *)int_buf,
+						h->pgm_data);
+				else
+					iucv_debug("ConnectionQuiesced not called");
 			}
-		}
-		break;
-	case 0x05:		/* connection resumed */
-		if (Q) {
-			if ((*interrupt).ConnectionResumed)
-				((*interrupt).ConnectionResumed)
-				    
-				    ((iucv_ConnectionResumed *) int_buf,
-				     (P + index2)->pgm_data);
-			else {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"ConnectionResumed not called\n");
-				printk (KERN_DEBUG "routine@ is %p\n",
-					(*interrupt).ConnectionResumed);
-#endif
+			break;
+			
+		case 0x05:		/* connection resumed */
+			if (h) {
+				if (interrupt->ConnectionResumed)
+					interrupt->ConnectionResumed(
+						(iucv_ConnectionResumed *)int_buf,
+						h->pgm_data);
+				else
+					iucv_debug("ConnectionResumed not called");
 			}
-		}
-		break;
-	case 0x06:		/* priority message complete */
-	case 0x07:		/* nonpriority message complete */
-		if (Q) {
-			if ((*interrupt).MessageComplete)
-				((*interrupt).MessageComplete)
-				    
-				    ((iucv_MessageComplete *) int_buf,
-				     (P + index2)->pgm_data);
-			else {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"MessageComplete not called\n");
-				printk (KERN_DEBUG "routine@ is %p\n",
-					(*interrupt).MessageComplete);
-#endif
+			break;
+			
+		case 0x06:		/* priority message complete */
+		case 0x07:		/* nonpriority message complete */
+			if (h) {
+				if (interrupt->MessageComplete)
+					interrupt->MessageComplete(
+						(iucv_MessageComplete *)int_buf,
+						h->pgm_data);
+				else
+					iucv_debug("MessageComplete not called");
 			}
-		}
-		break;
-	case 0x08:		/* priority message pending  */
-	case 0x09:		/* nonpriority message pending  */
-		if (Q) {
-			if ((*interrupt).MessagePending)
-				((*interrupt).MessagePending)
-				    
-				    ((iucv_MessagePending *) int_buf,
-				     (P + index2)->pgm_data);
-			else {
-#ifdef DEBUG
-				printk (KERN_DEBUG
-					"MessagePending not called\n");
-				printk (KERN_DEBUG "routine@ is %p\n",
-					(*interrupt).MessagePending);
-#endif
+			break;
+			
+		case 0x08:		/* priority message pending  */
+		case 0x09:		/* nonpriority message pending  */
+			if (h) {
+				if (interrupt->MessagePending)
+					interrupt->MessagePending(
+						(iucv_MessagePending *) int_buf,
+						h->pgm_data);
+				else
+					iucv_debug("MessagePending not called");
 			}
-		}
-		break;
-	default:		/* unknown iucv type */
-		printk (KERN_DEBUG "unknown iucv interrupt \n");
-		break;
+			break;
+		default:		/* unknown iucv type */
+			printk(KERN_WARNING "%s: unknown iucv interrupt\n",
+			       __FUNCTION__);
+			break;
 	}			/* end switch */
-#ifdef DEBUG3
-	printk (KERN_DEBUG "BH:-  Exiting do_int "
-	                   "pathid %d, type %02X\n",
-		int_buf->ippathid, int_buf->iptype);
-#endif
+	
+	iucv_debug("exiting pathid %d, type %02X",
+		 int_buf->ippathid, int_buf->iptype);
+
 	return;
-}				/* end of function call */
+}
 
-/**************************************************************/
-/* Name: iucv_register_program                                */
-/* Purpose: registers a new handler                           */
-/* Input: pgmname- uchar[16], user id                         */
-/*        userid - uchar[8], machine id                       */
-/*        prmmask- mask                                       */
-/*        ops    - pointer to iucv_interrupt_ops buffer       */
-/* Output: new_handler - address of new handler               */
-/**************************************************************/
-iucv_handle_t
-iucv_register_program (uchar pgmname[16],
-		       uchar userid[8],
-		       uchar pgmmask[24],
-		       iucv_interrupt_ops_t * ops, ulong pgm_data)
+/**
+ * iucv_bh_handler:
+ *
+ * This function loops over the queue of irq buffers and runs iucv_do_int()
+ * on every queue element.
+ */
+static void
+iucv_bh_handler(void)
 {
-	int rc;
-	handler *new_handler = 0;
-#ifdef DEBUG
-	int i;
-	uchar *prt_parm;
-	printk (KERN_DEBUG "enter iucv_register_program\n");
-#endif
-	my_ops = *ops;
-	/* Allocate handler table */
-	new_handler = (handler *) kmalloc (sizeof (handler), GFP_KERNEL);
-	if (new_handler == NULL) {
-#ifdef DEBUG
-		printk (KERN_DEBUG
-			"IUCV: returned NULL address for new handle \n");
-#endif
-		return NULL;
-	}
-	/* fill in handler table */
-	memcpy (new_handler->user_data, pgmname, 16);
-	memcpy (new_handler->vmid, userid, 8);
-	memcpy (new_handler->mask, pgmmask, 24);
-	new_handler->pgm_data = pgm_data;
-	/* Convert from ASCII to EBCDIC */
-	if (new_handler->vmid) {
-		ASCEBC (new_handler->vmid, 8);
-		EBC_TOUPPER(new_handler->vmid, 8);
-	}
-	/* fill in handler table */
-	new_handler->interrupt_table = ops;
-	new_handler->size = ADDED_STOR;
-	/* Allocate storage for pathid table */
-	new_handler->start = kmalloc (ADDED_STOR * sizeof (ulong), GFP_KERNEL);
-	if (new_handler->start == NULL) {
-#ifdef DEBUG
-		printk (KERN_DEBUG
-			"IUCV: returned NULL address for pathid table,"
-			" exiting\n");
-#endif
-		kfree(new_handler);
-		return NULL;
-	}
-	memset (new_handler->start, 0, ADDED_STOR * sizeof (ulong));
-	new_handler->end = (*new_handler).start + ADDED_STOR;
-	new_handler->next = 0;
-	new_handler->prev = 0;
-	/* Place handler at beginning of chain */
-	spin_lock (&lock);
-	if (handler_anchor == NULL)
-		handler_anchor = new_handler;
-	else {
-		handler_anchor->prev = (ulong *) new_handler;
-		new_handler->next = (ulong *) handler_anchor;
-		handler_anchor = new_handler;
-#ifdef DEBUG
-		printk (KERN_DEBUG "adding a another handler to list\n");
-		printk (KERN_DEBUG "handler_anchor->prev is %p \n",
-			handler_anchor->prev);
-		printk (KERN_DEBUG "new_handler->next is %p \n",
-			new_handler->next);
-		printk (KERN_DEBUG "handler_anchor is %p \n", handler_anchor);
-#endif
-	}
-	spin_unlock (&lock);
-	if (declare_flag == NULL) {
-		rc = iucv_declare_buffer (iucv_external_int_buffer);
-		if (rc == 0) {
-			declare_flag = 1;
-			/* request the 0x4000 external interrupt */
-			rc =
-			    register_external_interrupt (0x4000,
-							 top_half_interrupt);
-		} else {
-			panic ("Registration failed");
-#ifdef DEBUG
-			printk (KERN_DEBUG "rc from declare buffer is: %i\n",
-				rc);
-#endif
-		}
+	struct list_head head;
+	struct list_head *next;
+	ulong  flags;
+
+	atomic_set(&iucv_bh_scheduled, 0);
+
+	spin_lock_irqsave(&iucv_irq_queue_lock, flags);
+	list_add(&head, &iucv_irq_queue);
+	list_del_init(&iucv_irq_queue);
+	spin_unlock_irqrestore (&iucv_irq_queue_lock, flags);
+
+	next = head.next;
+	while (next != &head) {
+		iucv_irqdata *p = list_entry(next, iucv_irqdata, queue);
+
+		next = next->next;
+		iucv_do_int(&p->data);
+		kfree(p);
 	}
-#ifdef DEBUG
-	printk (KERN_DEBUG "address of handle is %p ", new_handler);
-	printk (KERN_DEBUG "size of handle is %d ", (int) (sizeof (handler)));
-	printk (KERN_DEBUG "exit iucv_register_program\n");
-	printk (KERN_DEBUG "main_table is %p \n", main_table);
-	printk (KERN_DEBUG "handler_anchor is %p \n", handler_anchor);
-	printk (KERN_DEBUG "Handler is: \n");
-	prt_parm = (uchar *) new_handler;
-	for (i = 0; i < sizeof (handler); i++)
-		printk (KERN_DEBUG " %02x ", prt_parm[i]);
-	printk (KERN_DEBUG "\n");
-#endif
-	return new_handler;	/* send buffer address back */
-}				/* end of register function */
 
-/**************************************************************/
-/* Name: iucv_unregister                                      */
-/* Purpose: remove handler from chain and sever all paths     */
-/* Input: handle - address of handler to be severed           */
-/* Output: returns 0                                          */
-/**************************************************************/
-int
-iucv_unregister (iucv_handle_t handle)
-{
-	handler *temp_next = 0, *temp_prev = 0;
-	handler *Q = 0, *R;
-	handler_table_entry *H_T_E = 0;
-	ulong *S = 0;		/*points to the beginning of block of h_t_e's*/
-#ifdef DEBUG
-	printk (KERN_DEBUG "enter iucv_unregister\n");
-	printk (KERN_DEBUG "address of handle is %p ", handle);
-	printk (KERN_DEBUG "size of handle is %u ", (int) (sizeof (handle)));
-#endif
-	spin_lock (&lock);
-	Q = (handler *) handle;
-	/*
-	 * Checking if handle is still registered: if yes, continue
-	 *  if not registered, return.
-	 */
-	for (R = handler_anchor; R != NULL; R = (handler *) R->next)
-		if (Q == R) {
-#ifdef DEBUG
-			printk (KERN_DEBUG "found a matching handler\n");
-#endif
-			break;
-		}
-	if (!R) {
-		spin_unlock (&lock);
-		return (0);
-	}
-	S = Q->start;
-#ifdef DEBUG
-	printk (KERN_DEBUG "Q is handle? %p ", Q);
-	printk (KERN_DEBUG "Q->start is %p ", Q->start);
-	printk (KERN_DEBUG "&(Q->start) is %p ", &(Q->start));
-	printk (KERN_DEBUG "Q->end is %p ", Q->end);
-	printk (KERN_DEBUG "&(Q->end) is %p ", &(Q->end));
-#endif
-	while (S < (Q->end)) {	/* index thru table */
-		if (*S) {
-			H_T_E = (handler_table_entry *) (*S);
-#ifdef DEBUG
-			printk (KERN_DEBUG "Pointer to H_T_E is %p ", H_T_E);
-			printk (KERN_DEBUG "Address of handle in H_T_E is %p",
-				(H_T_E->addrs));
-#endif
-			if ((H_T_E->addrs) != handle) {
-				spin_unlock (&lock);
-				return (-2);	/*handler addresses don't match */
-			} else {
-				spin_unlock (&lock);
-				iucv_sever (H_T_E->pathid, Q->user_data);
-				spin_lock (&lock);
-			}
-		}
-		S++;		/* index by size of ulong */
-	}
-	kfree (Q->start);
-	temp_next = (handler *) Q->next;	/* address of next handler on list */
-	temp_prev = (handler *) Q->prev;	/* address of prev handler on list */
-	if ((temp_next != NULL) & (temp_prev != NULL)) {
-		(*temp_next).prev = (ulong *) temp_prev;
-		(*temp_prev).next = (ulong *) temp_next;
-	} else if ((temp_next != NULL) & (temp_prev == NULL)) {
-		(*temp_next).prev = NULL;
-		handler_anchor = temp_next;
-	} else if ((temp_next == NULL) & (temp_prev != NULL))
-		(*temp_prev).next = NULL;
-	else
-		handler_anchor = NULL;
-	if (handler_anchor == NULL)
-		iucv_retrieve_buffer ();
-	kfree (handle);
-	spin_unlock (&lock);
-#ifdef DEBUG
-	printk (KERN_DEBUG "exit iucv_unregister\n");
-#endif
-	return 0;
+	return;
 }
 
+/**
+ * Export all public stuff
+ */
 EXPORT_SYMBOL (iucv_accept);
 EXPORT_SYMBOL (iucv_connect);
 EXPORT_SYMBOL (iucv_purge);
-EXPORT_SYMBOL (iucv_query);
+EXPORT_SYMBOL (iucv_query_maxconn);
+EXPORT_SYMBOL (iucv_query_bufsize);
 EXPORT_SYMBOL (iucv_quiesce);
 EXPORT_SYMBOL (iucv_receive);
-EXPORT_SYMBOL (iucv_receive_simple);
 EXPORT_SYMBOL (iucv_receive_array);
 EXPORT_SYMBOL (iucv_reject);
 EXPORT_SYMBOL (iucv_reply);
@@ -2040,5 +2285,4 @@
 EXPORT_SYMBOL (iucv_setmask);
 EXPORT_SYMBOL (iucv_sever);
 EXPORT_SYMBOL (iucv_register_program);
-EXPORT_SYMBOL (iucv_unregister);
-
+EXPORT_SYMBOL (iucv_unregister_program);
diff -urN linux/drivers/s390/net/iucv.h linux-2.4.7/drivers/s390/net/iucv.h
--- linux/drivers/s390/net/iucv.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/drivers/s390/net/iucv.h	Mon Dec 17 13:41:49 2001
@@ -1,353 +1,752 @@
 /*
- *  drivers/s390/net/netiucv.h
+ *  drivers/s390/net/iucv.h
  *    IUCV base support.
  *
  *  S390 version
  *    Copyright (C) 2000 IBM Corporation
- *    Author(s): Xenia Tkatschow (xenia@us.ibm.com)
+ *    Author(s):Alan Altmark (Alan_Altmark@us.ibm.com) 
+ *		Xenia Tkatschow (xenia@us.ibm.com)
  *
  *
  * Functionality:
  * To explore any of the IUCV functions, one must first register
- * their program using iucv_register(). Once your program has
- * successfully completed a register, it can use the other functions.
+ * their program using iucv_register_program(). Once your program has
+ * successfully completed a register, it can exploit the other functions.
  * For furthur reference on all IUCV functionality, refer to the
  * CP Programming Services book, also available on the web
- * thru www.ibm.com/s390/vm.
+ * thru www.ibm.com/s390/vm/pubs, manual # SC24-5760
+ *
+ *      Definition of Return Codes                                    
+ *      -All positive return codes including zero are reflected back  
+ *       from CP except for iucv_register_program. The definition of each 
+ *       return code can be found in CP Programming Services book.    
+ *       Also available on the web thru www.ibm.com/s390/vm/pubs, manual # SC24-5760          
+ *      - Return Code of:         
+ *             (-EINVAL) Invalid value       
+ *             (-ENOMEM) storage allocation failed              
+ *	pgmask defined in iucv_register_program will be set depending on input
+ *	paramters. 
+ *	
  */
-#ifndef _IUCV_H
-#define _IUCV_H
+
+#include <linux/types.h>
 #define uchar  unsigned char
 #define ushort unsigned short
 #define ulong  unsigned long
 #define iucv_handle_t void *
-/***********************FLAGS*************************************/
-#define  source_class   0x01
-#define  target_class   0x01
-#define  local_conn     0x01
-#define  specify_pathid 0x02
-#define  specify_msgid  0x04
-#define  reply_array    0x08
-#define  one_way_msg    0x10
-#define  prior_msg      0x20
-#define  array          0x40
-#define  quiesce_msg    0x40
-#define  parm_data      0x80
-#define  IPRMDATA	 0x80
-#define  IPBUFLST	 0x40
-#define  IPPRTY	 0x20
-#define  IPNORPY	 0x10
-#define  IPANSLST	 0x08
-#define  IPFGMID	 0x04
-#define  IPFGPID	 0x02
-#define  IPFGMCL	 0x01
-
-/*---------------------------------------------------------*/
-/* Mapping of external interrupt buffers                   */
-/* Names: iucv_ConnectionPending    ->  connection pending */
-/*        iucv_ConnectionComplete   ->  connection complete */
-/*        iucv_ConnectionSevered    ->  connection severed */
-/*        iucv_ConnectionQuiesced   ->  connection quiesced */
-/*        iucv_ConnectionResumed    ->  connection resumed */
-/*        iucv_MessagePending       ->  message pending    */
-/*        iucv_MessageComplete      ->  message complete   */
-/*---------------------------------------------------------*/
+
+/* flags1:
+ * All flags are defined in the field IPFLAGS1 of each function   
+ * and can be found in CP Programming Services.                  
+ * IPLOCAL  - Indicates the connect can only be satisfied on the 
+ *            local system                                       
+ * IPPRTY   - Indicates a priority message                       
+ * IPQUSCE  - Indicates you do not want to receive messages on a 
+ *            path until an iucv_resume is issued                
+ * IPRMDATA - Indicates that the message is in the parameter list
+ */
+#define IPLOCAL   	0x01
+#define IPPRTY         	0x20
+#define IPQUSCE        	0x40
+#define IPRMDATA       	0x80
+
+/* flags1_out:
+ * All flags are defined in the output field of IPFLAGS1 for each function
+ * and can be found in CP Programming Services.
+ * IPNORPY - Specifies this is a one-way message and no reply is expected.
+ * IPPRTY   - Indicates a priority message is permitted. Defined in flags1.
+ */
+#define IPNORPY         0x10
+
+#define Nonpriority_MessagePendingInterruptsFlag         0x80
+#define Priority_MessagePendingInterruptsFlag            0x40
+#define Nonpriority_MessageCompletionInterruptsFlag      0x20
+#define Priority_MessageCompletionInterruptsFlag         0x10
+/*
+ * Mapping of external interrupt buffers should be used with the corresponding
+ * interrupt types.                  
+ * Names: iucv_ConnectionPending    ->  connection pending 
+ *        iucv_ConnectionComplete   ->  connection complete
+ *        iucv_ConnectionSevered    ->  connection severed 
+ *        iucv_ConnectionQuiesced   ->  connection quiesced 
+ *        iucv_ConnectionResumed    ->  connection resumed 
+ *        iucv_MessagePending       ->  message pending    
+ *        iucv_MessageComplete      ->  message complete   
+ */
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar ipflags1;
 	uchar iptype;
-	ushort ipmsglim;
-	ushort res1;
+	u16 ipmsglim;
+	u16 res1;
 	uchar ipvmid[8];
 	uchar ipuser[16];
-	ulong res3;
+	u32 res3;
 	uchar ippollfg;
 	uchar res4[3];
 } iucv_ConnectionPending;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar ipflags1;
 	uchar iptype;
-	ushort ipmsglim;
-	ushort res1;
+	u16 ipmsglim;
+	u16 res1;
 	uchar res2[8];
 	uchar ipuser[16];
-	ulong res3;
+	u32 res3;
 	uchar ippollfg;
 	uchar res4[3];
 } iucv_ConnectionComplete;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar res1;
 	uchar iptype;
-	ulong res2;
+	u32 res2;
 	uchar res3[8];
 	uchar ipuser[16];
-	ulong res4;
+	u32 res4;
 	uchar ippollfg;
 	uchar res5[3];
 } iucv_ConnectionSevered;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar res1;
 	uchar iptype;
-	ulong res2;
+	u32 res2;
 	uchar res3[8];
 	uchar ipuser[16];
-	ulong res4;
+	u32 res4;
 	uchar ippollfg;
 	uchar res5[3];
 } iucv_ConnectionQuiesced;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar res1;
 	uchar iptype;
-	ulong res2;
+	u32 res2;
 	uchar res3[8];
 	uchar ipuser[16];
-	ulong res4;
+	u32 res4;
 	uchar ippollfg;
 	uchar res5[3];
 } iucv_ConnectionResumed;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar ipflags1;
 	uchar iptype;
-	ulong ipmsgid;
-	ulong iptrgcls;
-	ulong iprmmsg1;
+	u32 ipmsgid;
+	u32 iptrgcls;
+	uchar iprmmsg1[4];
 	union u1 {
-		ulong ipbfln1f;
-		ulong iprmmsg2;
+		u32 ipbfln1f;
+		uchar iprmmsg2[4];
 	} ln1msg2;
-	ulong res1[3];
-	ulong ipbfln2f;
+	u32 res1[3];
+	u32 ipbfln2f;
 	uchar ippollfg;
 	uchar res2[3];
 } iucv_MessagePending;
 
 typedef struct {
-	ushort ippathid;
+	u16 ippathid;
 	uchar ipflags1;
 	uchar iptype;
-	ulong ipmsgid;
-	ulong ipaudit;
-	ulong iprmmsg1;
-	ulong iprmmsg2;
-	ulong ipsrccls;
-	ulong ipmsgtag;
-	ulong res;
-	ulong ipbfln2f;
+	u32 ipmsgid;
+	u32 ipaudit;
+	uchar iprmmsg[8];
+	u32 ipsrccls;
+	u32 ipmsgtag;
+	u32 res;
+	u32 ipbfln2f;
 	uchar ippollfg;
 	uchar res2[3];
 } iucv_MessageComplete;
 
-/************************structures*************************/
-/*---------------------------------------------------------*/
-/*iucv_interrupt_ops_t: List of functions for interrupt    */
-/* handling.                                               */
-/*---------------------------------------------------------*/
-
+/* 
+ * iucv_interrupt_ops_t: Is a vector of functions that handle 
+ * IUCV interrupts.                                          
+ * Parameter list:                                           
+ *         eib - is a pointer to a 40-byte area described    
+ *               with one of the structures above.           
+ *         pgm_data - this data is strictly for the          
+ *                    interrupt handler that is passed by    
+ *                    the application. This may be an address 
+ *                    or token.                              
+*/
 typedef struct {
 	void (*ConnectionPending) (iucv_ConnectionPending * eib,
-				   ulong pgm_data);
+				   void *pgm_data);
 	void (*ConnectionComplete) (iucv_ConnectionComplete * eib,
-				    ulong pgm_data);
+				    void *pgm_data);
 	void (*ConnectionSevered) (iucv_ConnectionSevered * eib,
-				   ulong pgm_data);
+				   void *pgm_data);
 	void (*ConnectionQuiesced) (iucv_ConnectionQuiesced * eib,
-				    ulong pgm_data);
+				    void *pgm_data);
 	void (*ConnectionResumed) (iucv_ConnectionResumed * eib,
-				   ulong pgm_data);
-	void (*MessagePending) (iucv_MessagePending * eib,
-				ulong pgm_data);
-	void (*MessageComplete) (iucv_MessageComplete * eib,
-				 ulong pgm_data);
+				   void *pgm_data);
+	void (*MessagePending) (iucv_MessagePending * eib, void *pgm_data);
+	void (*MessageComplete) (iucv_MessageComplete * eib, void *pgm_data);
 } iucv_interrupt_ops_t;
 
-/*---------------------------------------------------------*/
-/*iucv_array_t : Defines buffer array                      */
-/*---------------------------------------------------------*/
-
+/*
+ *iucv_array_t : Defines buffer array.                      
+ * Inside the array may be 31- bit addresses and 31-bit lengths. 
+*/
 typedef struct {
-	void *address;
-	int length;
+	u32 address;
+	u32 length;
 } iucv_array_t __attribute__ ((aligned (8)));
 
-/*************************-prototypes-******************************/
-
+/*   -prototypes-    */
+/*                                                                
+ * Name: iucv_register_program                                    
+ * Purpose: Registers an application with IUCV                    
+ * Input: prmname - user identification                           
+ *        userid  - machine identification
+ *        pgmmask - indicates which bits in the prmname and userid combined will be
+ *  		    used to determine who is given control
+ *        ops     - address of vector of interrupt handlers       
+ *        pgm_data- application data passed to interrupt handlers 
+ * Output: NA                                                     
+ * Return: address of handler                                     
+ *         (0) - Error occured, registration not completed.
+ * NOTE: Exact cause of failure will be recorded in syslog.                        
+*/
 iucv_handle_t iucv_register_program (uchar pgmname[16],
 				     uchar userid[8],
 				     uchar pgmmask[24],
 				     iucv_interrupt_ops_t * ops,
-				     ulong pgm_data);
-
-int iucv_unregister (iucv_handle_t handle);
-
-int iucv_purge (ulong msgid,
-		ushort pathid,
-		ulong srccls,
-		uchar audit[4]);
-
-void iucv_query (ulong * bufsize,
-		 ulong * conmax);
-
-int iucv_quiesce (ushort pathid,
-		  uchar user_data[16]);
+				     void *pgm_data);
 
-int iucv_resume (ushort pathid,
-		 uchar user_data[16]);
+/*                                                
+ * Name: iucv_unregister_program                  
+ * Purpose: Unregister application with IUCV      
+ * Input: address of handler                      
+ * Output: NA                                     
+ * Return: (0) - Normal return                    
+ *         (-EINVAL) - Internal error, wild pointer     
+*/
+int iucv_unregister_program (iucv_handle_t handle);
+
+/*
+ * Name: iucv_accept
+ * Purpose: This function is issued after the user receives a Connection Pending external
+ *          interrupt and now wishes to complete the IUCV communication path.
+ * Input:  pathid - u16 , Path identification number   
+ *         msglim_reqstd - u16, The number of outstanding messages requested.
+ *         user_data - uchar[16], Data specified by the iucv_connect function.
+ *	   flags1 - int, Contains options for this path.
+ *           -IPPRTY   - 0x20- Specifies if you want to send priority message.
+ *           -IPRMDATA - 0x80, Specifies whether your program can handle a message
+ *            	in  the parameter list.
+ *           -IPQUSCE  - 0x40, Specifies whether you want to quiesce the path being
+ *		established.
+ *         handle - iucv_handle_t, Address of handler.
+ *         pgm_data - void *, Application data passed to interrupt handlers.
+ *         flags1_out - int * Contains information about the path
+ *           - IPPRTY - 0x20, Indicates you may send priority messages.
+ *         msglim - *u16, Number of outstanding messages.
+ * Output: return code from CP IUCV call.
+*/
 
-int iucv_reject (ushort pathid,
-		 ulong msgid,
-		 ulong trgcls);
-
-int iucv_setmask (uchar non_priority_interrupts,
-		  uchar priority_interrupts,
-		  uchar non_priority_completion_interrupts,
-		  uchar priority_completion_interrupts);
+int iucv_accept (u16 pathid,
+		 u16 msglim_reqstd,
+		 uchar user_data[16],
+		 int flags1,
+		 iucv_handle_t handle,
+		 void *pgm_data, int *flags1_out, u16 * msglim);
 
-int iucv_connect (ushort * pathid,
-		  ushort msglim,
+/*
+ * Name: iucv_connect                                         
+ * Purpose: This function establishes an IUCV path. Although the connect may complete
+ *	    successfully, you are not able to use the path until you receive an IUCV 
+ *          Connection Complete external interrupt.            
+ * Input: pathid - u16 *, Path identification number          
+ *        msglim_reqstd - u16, Number of outstanding messages requested       
+ *        user_data - uchar[16], 16-byte user data                    
+ *	  userid - uchar[8], User identification
+ *        system_name - uchar[8], 8-byte identifying the system name 
+ *	  flags1 - int, Contains options for this path.
+ *          -IPPRTY -   0x20, Specifies if you want to send priority message.
+ *          -IPRMDATA - 0x80, Specifies whether your program can handle a message
+ *            	 in  the parameter list.
+ *          -IPQUSCE -  0x40, Specifies whether you want to quiesce the path being	 
+ *		established.
+ *          -IPLOCAL -  0X01, Allows an application to force the partner to be on 
+ *		the local system. If local is specified then target class cannot be
+ *		specified.                       
+ *        flags1_out - int * Contains information about the path
+ *           - IPPRTY - 0x20, Indicates you may send priority messages.
+ *        msglim - * u16, Number of outstanding messages
+ *        handle - iucv_handle_t, Address of handler                         
+ *        pgm_data - void *, Application data passed to interrupt handlers              
+ * Output: return code from CP IUCV call
+ *         rc - return code from iucv_declare_buffer
+ *         -EINVAL - Invalid handle passed by application 
+ *         -EINVAL - Pathid address is NULL 
+ *         add_pathid_result - Return code from internal function add_pathid         
+*/
+int
+    iucv_connect (u16 * pathid,
+		  u16 msglim_reqstd,
 		  uchar user_data[16],
 		  uchar userid[8],
 		  uchar system_name[8],
-		  uchar priority_requested,
-		  uchar prmdata,
-		  uchar quiesce,
-		  uchar control,
-		  uchar local,
-		  uchar * priority_permitted,
-		  iucv_handle_t handle,
-		  ulong pgm_data);
-
-int iucv_accept (ushort pathid,
-		 ushort msglim,
-		 uchar user_data[16],
-		 uchar priority_requested,
-		 uchar prmdata,
-		 uchar quiesce,
-		 uchar control,
-		 uchar * priority_permitted,
-		 iucv_handle_t handle,
-		 ulong pgm_data);
-
-int iucv_sever (ushort pathid,
-		uchar user_data[16]);
+		  int flags1,
+		  int *flags1_out,
+		  u16 * msglim, iucv_handle_t handle, void *pgm_data);
+
+/*                                                                     
+ * Name: iucv_purge                                                    
+ * Purpose: This function cancels a message that you have sent.        
+ * Input: pathid - Path identification number.                          
+ *        msgid - Specifies the message ID of the message to be purged.
+ *        srccls - Specifies the source message class.                  
+ * Output: audit - Contains information about asynchronous error       
+ *                 that may have affected the normal completion        
+ *                 of this message.                                    
+ * Return: Return code from CP IUCV call.                           
+*/
+int iucv_purge (u16 pathid, u32 msgid, u32 srccls, __u32 *audit);
+/*
+ * Name: iucv_query_maxconn
+ * Purpose: This function determines the maximum number of communication paths you
+ *	    may establish.
+ * Return:  maxconn - ulong, Maximum number of connection the virtual machine may
+ *          establish.
+*/
+ulong iucv_query_maxconn (void);
+
+/*
+ * Name: iucv_query_bufsize
+ * Purpose: This function determines how large an external interrupt
+ *          buffer IUCV requires to store information.
+ * Return:  bufsize - ulong, Size of external interrupt buffer.
+ */
+ulong iucv_query_bufsize (void);
 
-int iucv_receive (ushort pathid,
-		  ulong * msgid,
-		  ulong * trgcls,
-		  void *buffer, ulong buflen,
-		  uchar * reply_required,
-		  uchar * priority_msg,
-		  ulong * adds_curr_buffer,
-		  ulong * adds_curr_length);
-
-int iucv_receive_simple (ushort pathid,
-			 ulong msgid,
-			 ulong trgcls,
-			 void *buffer, ulong buflen);
-
-int iucv_receive_array (ushort pathid,
-			ulong * msgid,
-			ulong * trgcls,
+/*                                                                     
+ * Name: iucv_quiesce                                                  
+ * Purpose: This function temporarily suspends incoming messages on an 
+ *          IUCV path. You can later reactivate the path by invoking   
+ *          the iucv_resume function.                                  
+ * Input: pathid - Path identification number                          
+ *        user_data  - 16-bytes of user data                           
+ * Output: NA                                                          
+ * Return: Return code from CP IUCV call.                           
+*/
+int iucv_quiesce (u16 pathid, uchar user_data[16]);
+
+/*                                                                     
+ * Name: iucv_receive                                                  
+ * Purpose: This function receives messages that are being sent to you 
+ *          over established paths. Data will be returned in buffer for length of
+ *          buflen.
+ * Input: 
+ *       pathid - Path identification number.                          
+ *       buffer - Address of buffer to receive.                        
+ *       buflen - Length of buffer to receive.                         
+ *       msgid - Specifies the message ID.          
+ *       trgcls - Specifies target class.                       
+ * Output: 
+ *	 flags1_out: int *, Contains information about this path.
+ *         IPNORPY - 0x10 Specifies this is a one-way message and no reply is
+ *	   expected.      
+ *         IPPRTY  - 0x20 Specifies if you want to send priority message.       
+ *         IPRMDATA - 0x80 specifies the data is contained in the parameter list
+ *       residual_buffer - address of buffer updated by the number
+ *                         of bytes you have received.
+ *       residual_length -      
+ *              Contains one of the following values, if the receive buffer is:
+ *               The same length as the message, this field is zero.
+ *               Longer than the message, this field contains the number of
+ *                bytes remaining in the buffer.
+ *               Shorter than the message, this field contains the residual
+ *                count (that is, the number of bytes remaining in the
+ *                message that does not fit into the buffer. In this
+ *                case b2f0_result = 5.
+ * Return: Return code from CP IUCV call.                           
+ *         (-EINVAL) - buffer address is pointing to NULL                   
+*/
+int iucv_receive (u16 pathid,
+		  u32 msgid,
+		  u32 trgcls,
+		  void *buffer,
+		  ulong buflen,
+		  int *flags1_out,
+		  ulong * residual_buffer, ulong * residual_length);
+
+ /*                                                                     
+  * Name: iucv_receive_array                                            
+  * Purpose: This function receives messages that are being sent to you 
+  *          over established paths. Data will be returned in first buffer for
+  *          length of first buffer.
+  * Input: pathid - Path identification number.                          
+  *        msgid - specifies the message ID.
+  *        trgcls - Specifies target class.
+  *        buffer - Address of array of buffers.                         
+  *        buflen - Total length of buffers.                             
+  * Output:
+  *        flags1_out: int *, Contains information about this path.
+  *          IPNORPY - 0x10 Specifies this is a one-way message and no reply is
+  *          expected.
+  *          IPPRTY  - 0x20 Specifies if you want to send priority message.
+  *          IPRMDATA - 0x80 specifies the data is contained in the parameter list
+  *       residual_buffer - address points to the current list entry IUCV
+  *                         is working on.
+  *       residual_length -
+  *              Contains one of the following values, if the receive buffer is:
+  *               The same length as the message, this field is zero.
+  *               Longer than the message, this field contains the number of
+  *                bytes remaining in the buffer.
+  *               Shorter than the message, this field contains the residual
+  *                count (that is, the number of bytes remaining in the
+  *                message that does not fit into the buffer. In this
+  *                case b2f0_result = 5.
+  * Return: Return code from CP IUCV call.                           
+  *         (-EINVAL) - Buffer address is NULL.       
+  */
+int iucv_receive_array (u16 pathid,
+			u32 msgid,
+			u32 trgcls,
 			iucv_array_t * buffer,
-			ulong * buflen,
-			uchar * reply_required,
-			uchar * priority_msg,
-			ulong * adds_curr_buffer,
-			ulong * adds_curr_length);
-
-int iucv_send (ushort pathid,
-	       ulong * msgid,
-	       ulong trgcls,
-	       ulong srccls,
-	       ulong msgtag,
-	       uchar priority_msg,
-	       void *buffer,
-	       ulong buflen);
-
-int iucv_send_array (ushort pathid,
-		     ulong * msgid,
-		     ulong trgcls,
-		     ulong srccls,
-		     ulong msgtag,
-		     uchar priority_msg,
-		     iucv_array_t * buffer,
-		     ulong buflen);
-
-int iucv_send_prmmsg (ushort pathid,
-		      ulong * msgid,
-		      ulong trgcls,
-		      ulong srccls,
-		      ulong msgtag,
-		      uchar priority_msg,
-		      uchar prmmsg[8]);
-
-int iucv_send2way (ushort pathid,
-		   ulong * msgid,
-		   ulong trgcls,
-		   ulong srccls,
-		   ulong msgtag,
-		   uchar priority_msg,
-		   void *buffer,
-		   ulong buflen,
-		   void *ansbuf,
-		   ulong anslen);
-
-int iucv_send2way_array (ushort pathid,
-			 ulong * msgid,
-			 ulong trgcls,
-			 ulong srccls,
-			 ulong msgtag,
-			 uchar priority_msg,
-			 iucv_array_t * buffer,
-			 ulong buflen,
-			 iucv_array_t * ansbuf,
-			 ulong anslen);
-
-int iucv_send2way_prmmsg (ushort pathid,
-			  ulong * msgid,
-			  ulong trgcls,
-			  ulong srccls,
-			  ulong msgtag,
-			  uchar priority_msg,
-			  uchar prmmsg[8],
-			  void *ansbuf,
-			  ulong anslen);
-
-int iucv_send2way_prmmsg_array (ushort pathid,
-				ulong * msgid,
-				ulong trgcls, ulong srccls,
-				ulong msgtag,
-				uchar priority_msg,
-				uchar prmmsg[8],
-				iucv_array_t * ansbuf,
-				ulong anslen);
-int iucv_reply (ushort pathid,
-		ulong msgid,
-		ulong trgcls,
-		uchar priority_msg,
-		void *buf,
-		ulong buflen);
-
-int iucv_reply_array (ushort pathid,
-		      ulong msgid,
-		      ulong trgcls,
-		      uchar priority_msg,
+			ulong buflen,
+			int *flags1_out,
+			ulong * residual_buffer, ulong * residual_length);
+
+/*                                                                       
+ * Name: iucv_reject                                                     
+ * Purpose: The reject function refuses a specified message. Between the 
+ *          time you are notified of a message and the time that you     
+ *          complete the message, the message may be rejected.           
+ * Input: pathid - Path identification number.                            
+ *        msgid - Specifies the message ID.                   
+ *        trgcls - Specifies target class.                                
+ * Output: NA                                                            
+ * Return: Return code from CP IUCV call.                             
+*/
+int iucv_reject (u16 pathid, u32 msgid, u32 trgcls);
+
+/*                                                                     
+ * Name: iucv_reply                                                    
+ * Purpose: This function responds to the two-way messages that you    
+ *          receive. You must identify completely the message to       
+ *          which you wish to reply. ie, pathid, msgid, and trgcls.    
+ * Input: pathid - Path identification number.                          
+ *        msgid - Specifies the message ID.                
+ *        trgcls - Specifies target class.                              
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20, Specifies if you want to send priority message.        
+ *        buffer - Address of reply buffer.                             
+ *        buflen - Length of reply buffer.                              
+ * Output: residual_buffer - Address of buffer updated by the number 
+ *                    of bytes you have moved.              
+ *         residual_length - Contains on the the following values
+ *		If the answer buffer is the same length as the reply, this field
+ *		 contains zero.
+ *		If the answer buffer is longer than the reply, this field contains
+ *		 the number of bytes remaining in the buffer.  
+ *		If the answer buffer is shorter than the reply, this field contains
+ *		 a residual count (that is, the number of bytes remianing in the
+ *		 reply that does not fit into the buffer. In this
+ *               case b2f0_result = 5.
+ * Return: Return code from CP IUCV call.                           
+ *         (-EINVAL) - Buffer address is NULL.                               
+*/
+int iucv_reply (u16 pathid,
+		u32 msgid,
+		u32 trgcls,
+		int flags1,
+		void *buffer, ulong buflen, ulong * residual_buffer,
+		ulong * residual_length);
+
+/*                                                                       
+ * Name: iucv_reply_array                                                
+ * Purpose: This function responds to the two-way messages that you      
+ *          receive. You must identify completely the message to         
+ *          which you wish to reply. ie, pathid, msgid, and trgcls.      
+ *          The array identifies a list of addresses and lengths of      
+ *          discontiguous buffers that contains the reply data.          
+ * Input: pathid - Path identification number                            
+ *        msgid - Specifies the message ID. 
+ *        trgcls - Specifies target class.                                
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20, Specifies if you want to send priority message.
+ *        buffer - Address of array of reply buffers.                     
+ *        buflen - Total length of reply buffers.                         
+ * Output: residual_buffer - Address of buffer which IUCV is currently working on.
+ *         residual_length - Contains on the the following values
+ *              If the answer buffer is the same length as the reply, this field
+ *               contains zero.
+ *              If the answer buffer is longer than the reply, this field contains
+ *               the number of bytes remaining in the buffer.
+ *              If the answer buffer is shorter than the reply, this field contains
+ *               a residual count (that is, the number of bytes remianing in the
+ *               reply that does not fit into the buffer. In this
+ *               case b2f0_result = 5.
+ * Return: Return code from CP IUCV call.                             
+ *         (-EINVAL) - Buffer address is NULL.              
+*/
+int iucv_reply_array (u16 pathid,
+		      u32 msgid,
+		      u32 trgcls,
+		      int flags1,
 		      iucv_array_t * buffer,
-		      ulong buflen);
+		      ulong buflen, ulong * residual_address,
+		      ulong * residual_length);
 
-int iucv_reply_prmmsg (ushort pathid,
-		       ulong msgid,
-		       ulong trgcls,
-		       uchar priority_msg,
-		       uchar prmmsg[8]);
+/*                                                                  
+ * Name: iucv_reply_prmmsg                                          
+ * Purpose: This function responds to the two-way messages that you 
+ *          receive. You must identify completely the message to    
+ *          which you wish to reply. ie, pathid, msgid, and trgcls. 
+ *          Prmmsg signifies the data is moved into the             
+ *          parameter list.                                         
+ * Input: pathid - Path identification number.                       
+ *        msgid - Specifies the message ID.              
+ *        trgcls - Specifies target class.                           
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 Specifies if you want to send priority message.
+ *        prmmsg - 8-bytes of data to be placed into the parameter.  
+ *                 list.                                            
+ * Output: NA                                                       
+ * Return: Return code from CP IUCV call.                        
+*/
+int iucv_reply_prmmsg (u16 pathid,
+		       u32 msgid, u32 trgcls, int flags1, uchar prmmsg[8]);
+
+/*                                                                     
+ * Name: iucv_resume                                                   
+ * Purpose: This function restores communications over a quiesced path 
+ * Input: pathid - Path identification number.                          
+ *        user_data  - 16-bytes of user data.                           
+ * Output: NA                                                          
+ * Return: Return code from CP IUCV call.                           
+*/
+int iucv_resume (u16 pathid, uchar user_data[16]);
+
+/*                                                                   
+ * Name: iucv_send                                                   
+ * Purpose: This function transmits data to another application.     
+ *          Data to be transmitted is in a buffer and this is a      
+ *          one-way message and the receiver will not reply to the   
+ *          message.                                                 
+ * Input: pathid - Path identification number.                        
+ *        trgcls - Specifies target class.                            
+ *        srccls - Specifies the source message class.                
+ *        msgtag - Specifies a tag to be associated with the message. 
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 Specifies if you want to send priority message.
+ *        buffer - Address of send buffer.                            
+ *        buflen - Length of send buffer.                             
+ * Output: msgid - Specifies the message ID.                         
+ * Return: Return code from CP IUCV call.                         
+ *         (-EINVAL) - Buffer address is NULL.                             
+*/
+int iucv_send (u16 pathid,
+	       u32 * msgid,
+	       u32 trgcls,
+	       u32 srccls, u32 msgtag, int flags1, void *buffer, ulong buflen);
+
+/*                                                                   
+ * Name: iucv_send_array                                             
+ * Purpose: This function transmits data to another application.     
+ *          The contents of buffer is the address of the array of    
+ *          addresses and lengths of discontiguous buffers that hold 
+ *          the message text. This is a one-way message and the      
+ *          receiver will not reply to the message.                  
+ * Input: pathid - Path identification number.                        
+ *        trgcls - Specifies target class.                            
+ *        srccls - Specifies the source message class.                
+ *        msgtag - Specifies a tag to be associated witht the message.
+ *        flags1 - Option for path.
+ *          IPPRTY- specifies if you want to send priority message. 
+ *        buffer - Address of array of send buffers.                  
+ *        buflen - Total length of send buffers.                      
+ * Output: msgid - Specifies the message ID.                         
+ * Return: Return code from CP IUCV call.                         
+ *         (-EINVAL) - Buffer address is NULL.                             
+*/
+int iucv_send_array (u16 pathid,
+		     u32 * msgid,
+		     u32 trgcls,
+		     u32 srccls,
+		     u32 msgtag,
+		     int flags1, iucv_array_t * buffer, ulong buflen);
+
+/*                                                                     
+ * Name: iucv_send_prmmsg                                              
+ * Purpose: This function transmits data to another application.       
+ *          Prmmsg specifies that the 8-bytes of data are to be moved  
+ *          into the parameter list. This is a one-way message and the 
+ *          receiver will not reply to the message.                    
+ * Input: pathid - Path identification number.                          
+ *        trgcls - Specifies target class.                              
+ *        srccls - Specifies the source message class.                  
+ *        msgtag - Specifies a tag to be associated with the message.   
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 specifies if you want to send priority message.
+ *        prmmsg - 8-bytes of data to be placed into parameter list.    
+ * Output: msgid - Specifies the message ID.                           
+ * Return: Return code from CP IUCV call.                           
+*/
+int iucv_send_prmmsg (u16 pathid,
+		      u32 * msgid,
+		      u32 trgcls,
+		      u32 srccls, u32 msgtag, int flags1, uchar prmmsg[8]);
+
+/*                                                                
+ * Name: iucv_send2way                                            
+ * Purpose: This function transmits data to another application.  
+ *          Data to be transmitted is in a buffer. The receiver   
+ *          of the send is expected to reply to the message and   
+ *          a buffer is provided into which IUCV moves the reply  
+ *          to this message.                                      
+ * Input: pathid - Path identification number.                     
+ *        trgcls - Specifies target class.                         
+ *        srccls - Specifies the source message class.             
+ *        msgtag - Specifies a tag associated with the message.    
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 Specifies if you want to send priority message.
+ *        buffer - Address of send buffer.                         
+ *        buflen - Length of send buffer.                          
+ *        ansbuf - Address of buffer into which IUCV moves the reply of 
+ *                 this message.        
+ *        anslen - Address of length of buffer.          
+ * Output: msgid - Specifies the message ID.                      
+ * Return: Return code from CP IUCV call.                      
+ *         (-EINVAL) - Buffer or ansbuf address is NULL.    
+*/
+int iucv_send2way (u16 pathid,
+		   u32 * msgid,
+		   u32 trgcls,
+		   u32 srccls,
+		   u32 msgtag,
+		   int flags1,
+		   void *buffer, ulong buflen, void *ansbuf, ulong anslen);
+
+/*                                                                    
+ * Name: iucv_send2way_array                                          
+ * Purpose: This function transmits data to another application.      
+ *          The contents of buffer is the address of the array of     
+ *          addresses and lengths of discontiguous buffers that hold  
+ *          the message text. The receiver of the send is expected to 
+ *          reply to the message and a buffer is provided into which  
+ *          IUCV moves the reply to this message.                     
+ * Input: pathid - Path identification number.                         
+ *        trgcls - Specifies target class.                             
+ *        srccls - Specifies the source message class.                 
+ *        msgtag - Specifies a tag to be associated with the message.   
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 Specifies if you want to send priority message.
+ *        buffer - Sddress of array of send buffers.                   
+ *        buflen - Total length of send buffers.                       
+ *        ansbuf - Address of array of buffer into which IUCV moves the reply            
+ *                 of this message.                         
+ *        anslen - Address of length reply buffers.              
+ * Output: msgid - Specifies the message ID.                          
+ * Return: Return code from CP IUCV call.                          
+ *         (-EINVAL) - Buffer address is NULL.                              
+*/
+int iucv_send2way_array (u16 pathid,
+			 u32 * msgid,
+			 u32 trgcls,
+			 u32 srccls,
+			 u32 msgtag,
+			 int flags1,
+			 iucv_array_t * buffer,
+			 ulong buflen, iucv_array_t * ansbuf, ulong anslen);
+
+/*                                                                     
+ * Name: iucv_send2way_prmmsg                                          
+ * Purpose: This function transmits data to another application.       
+ *          Prmmsg specifies that the 8-bytes of data are to be moved  
+ *          into the parameter list. This is a two-way message and the 
+ *          receiver of the message is expected to reply. A buffer     
+ *          is provided into which IUCV moves the reply to this        
+ *          message.                                                   
+ * Input: pathid - Rath identification number.                          
+ *        trgcls - Specifies target class.                              
+ *        srccls - Specifies the source message class.                  
+ *        msgtag - Specifies a tag to be associated with the message.   
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 Specifies if you want to send priority message.
+ *        prmmsg - 8-bytes of data to be placed in parameter list.      
+ *        ansbuf - Address of buffer into which IUCV moves the reply of    
+ *                 this message.
+ *        anslen - Address of length of buffer.               
+ * Output: msgid - Specifies the message ID.                           
+ * Return: Return code from CP IUCV call.                           
+ *         (-EINVAL) - Buffer address is NULL.         
+*/
+int iucv_send2way_prmmsg (u16 pathid,
+			  u32 * msgid,
+			  u32 trgcls,
+			  u32 srccls,
+			  u32 msgtag,
+			  ulong flags1,
+			  uchar prmmsg[8], void *ansbuf, ulong anslen);
+
+/*                                                                      
+ * Name: iucv_send2way_prmmsg_array                                     
+ * Purpose: This function transmits data to another application.        
+ *          Prmmsg specifies that the 8-bytes of data are to be moved   
+ *          into the parameter list. This is a two-way message and the  
+ *          receiver of the message is expected to reply. A buffer      
+ *          is provided into which IUCV moves the reply to this         
+ *          message. The contents of ansbuf is the address of the       
+ *          array of addresses and lengths of discontiguous buffers     
+ *          that contain the reply.                                     
+ * Input: pathid - Path identification number.                           
+ *        trgcls - Specifies target class.                               
+ *        srccls - Specifies the source message class.                   
+ *        msgtag - Specifies a tag to be associated with the message.    
+ *        flags1 - Option for path.
+ *          IPPRTY- 0x20 specifies if you want to send priority message.
+ *        prmmsg - 8-bytes of data to be placed into the parameter list. 
+ *        ansbuf - Address of array of buffer into which IUCV moves the reply
+ *                 of this message.  
+ *        anslen - Address of length of reply buffers.                
+ * Output: msgid - Specifies the message ID.      
+ * Return: Return code from CP IUCV call.      
+ *         (-EINVAL) - Ansbuf address is NULL.          
+*/
+int iucv_send2way_prmmsg_array (u16 pathid,
+				u32 * msgid,
+				u32 trgcls,
+				u32 srccls,
+				u32 msgtag,
+				int flags1,
+				uchar prmmsg[8],
+				iucv_array_t * ansbuf, ulong anslen);
 
-#endif
+/*                                                                   
+ * Name: iucv_setmask                                                
+ * Purpose: This function enables or disables the following IUCV     
+ *          external interruptions: Nonpriority and priority message 
+ *          interrupts, nonpriority and priority reply interrupts.   
+ * Input: SetMaskFlag - options for interrupts
+ *           0x80 - Nonpriority_MessagePendingInterruptsFlag         
+ *           0x40 - Priority_MessagePendingInterruptsFlag            
+ *           0x20 - Nonpriority_MessageCompletionInterruptsFlag      
+ *           0x10 - Priority_MessageCompletionInterruptsFlag         
+ * Output: NA                                                        
+ * Return: Return code from CP IUCV call.                         
+*/
+int iucv_setmask (int SetMaskFlag);
+
+/*                                                  
+ * Name: iucv_sever                                 
+ * Purpose: This function terminates an IUCV path.  
+ * Input: pathid - Path identification number.       
+ *        user_data - 16-bytes of user data.         
+ * Output: NA       
+ * Return: Return code from CP IUCV call.                                
+ *         (-EINVAL) - Interal error, wild pointer.       
+*/
+int iucv_sever (u16 pathid, uchar user_data[16]);
diff -urN linux/drivers/s390/net/netiucv.c linux-2.4.7/drivers/s390/net/netiucv.c
--- linux/drivers/s390/net/netiucv.c	Wed Apr 18 17:40:07 2001
+++ linux-2.4.7/drivers/s390/net/netiucv.c	Mon Dec 17 13:42:42 2001
@@ -1,897 +1,2121 @@
 /*
- *  drivers/s390/net/netiucv.c
- *    Network driver for VM using iucv
+ * $Id: netiucv.c,v 1.12 2001/09/24 10:38:02 mschwide Exp $
  *
- *  S/390 version
- *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Stefan Hegewald <hegewald@de.ibm.com>
- *               Hartmut Penner <hpenner@de.ibm.com>
- *
- *
- *    2.3 Updates Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
- *                Martin Schwidefsky (schwidefsky@de.ibm.com)
- *
- *    Re-write:   Alan Altmark (Alan_Altmark@us.ibm.com)  Sept. 2000
- *                Uses iucv.c kernel module for IUCV services. 
- *
- * -------------------------------------------------------------------------- 
- *  An IUCV frame consists of one or more packets preceded by a 16-bit
- *  header.   The header contains the offset to the next packet header,
- *  measured from the beginning of the _frame_.  If zero, there are no more
- *  packets in the frame.  Consider a frame which contains a 10-byte packet
- *  followed by a 20-byte packet:
- *        +-----+----------------+-----+----------------------------+-----+
- *        |h'12'| 10-byte packet |h'34'|  20-byte packet            |h'00'|
- *        +-----+----------------+-----+----------------------------+-----+
- * Offset: 0     2                12    14                           34  
- *
- *  This means that each header will always have a larger value than the
- *  previous one (except for the final zero header, of course).
- *  
- *  For outbound packets, we send ONE frame per packet.  So, our frame is:
- *       AL2(packet length+2), packet, AL2(0)
- *  The maximum packet size is the MTU, so the maximum IUCV frame we send
- *  is MTU+4 bytes.
- *
- *  For inbound frames, we don't care how long the frame is.  We tear apart
- *  the frame, processing packets up to MTU size in length, until no more
- *  packets remain in the frame.
- *
- * --------------------------------------------------------------------------
- *  The code uses the 2.3.43 network driver interfaces.  If compiled on an
- *  an older level of the kernel, the module provides its own macros.
- *  Doc is in Linux Weekly News (lwn.net) memo from David Miller, 9 Feb 2000.
- *  There are a few other places with 2.3-specific enhancements.
- *
- * --------------------------------------------------------------------------
-*/
-//#define DEBUG 1
-
-/* If MAX_DEVICES increased, add initialization data to iucv_netdev[] array */
-/* (See bottom of program.)						    */
-#define MAX_DEVICES 10		/* Allows "iucv0" to "iucv9"    */
-#define MAX_VM_MTU 32764	/* 32K IUCV buffer, minus 4     */
-#define MAX_TX_Q 50		/* Maximum pending TX           */
-
+ * IUCV network driver
+ *
+ * Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
+ * Author(s): Fritz Elfert (elfert@de.ibm.com, felfert@millenux.com)
+ *
+ * Documentation used:
+ *  the source of the original IUCV driver by:
+ *    Stefan Hegewald <hegewald@de.ibm.com>
+ *    Hartmut Penner <hpenner@de.ibm.com>
+ *    Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
+ *    Martin Schwidefsky (schwidefsky@de.ibm.com)
+ *    Alan Altmark (Alan_Altmark@us.ibm.com)  Sept. 2000
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * RELEASE-TAG: IUCV network driver $Revision: 1.12 $
+ *
+ */
+
 #include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+
+#include <linux/signal.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+
+#include <linux/ip.h>
+#include <linux/if_arp.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/ctype.h>
+#include <net/dst.h>
+
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+
+#include "iucv.h"
+#include "fsm.h"
+
+#undef DEBUG
 
 #ifdef MODULE
-#include <linux/module.h>
 MODULE_AUTHOR
-    ("(C) 2000 IBM Corporation by Alan Altmark (Alan_Altmark@us.ibm.com)");
+    ("(C) 2001 IBM Corporation by Fritz Elfert (felfert@millenux.com)");
 MODULE_DESCRIPTION ("Linux for S/390 IUCV network driver");
-MODULE_PARM (iucv, "1-" __MODULE_STRING (MAX_DEVICES) "s");
+MODULE_PARM (iucv, "1s");
 MODULE_PARM_DESC (iucv,
-		  "Specify the userids associated with iucv0-iucv9:\n"
-		  "iucv=userid1,userid2,...,userid10\n");
-#else
-#define MOD_INC_USE_COUNT
-#define MOD_DEC_USE_COUNT
+		  "Specify the initial remote userids for iucv0 .. iucvn:\n"
+		  "iucv=userid0:userid1:...:useridN\n");
 #endif
 
-#include <linux/sched.h>	/* task queues                  */
-#include <linux/malloc.h>	/* kmalloc()                    */
-#include <linux/errno.h>	/* error codes                  */
-#include <linux/types.h>	/* size_t                       */
-#include <linux/interrupt.h>	/* mark_bh                      */
-#include <linux/netdevice.h>	/* struct net_device, etc.      */
-#include <linux/if_arp.h>	/* ARPHRD_SLIP                  */
-#include <linux/skbuff.h>	/* skb                          */
-#include <linux/init.h>		/* __setup()                    */
-#include <asm/io.h>		/* virt_to_phys()               */
-#include <asm/string.h>		/* memset, memcpy, etc.         */
-#include "iucv.h"
-#define min(a,b) (a < b) ? a : b
-
-#ifdef DEBUG
-#undef KERN_INFO
-#undef KERN_DEBUG
-#define KERN_INFO    KERN_EMERG
-#define KERN_DEBUG   KERN_EMERG
-#endif
+static char *iucv = "";
 
+/**
+ * compatibility stuff
+ */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
 typedef struct net_device net_device;
 #else
 typedef struct device net_device;
 #endif
 
-static __inline__ int
-netif_is_busy (net_device * dev)
+
+/**
+ * Per connection profiling data
+ */
+typedef struct connection_profile_t {
+	unsigned long maxmulti;
+	unsigned long maxcqueue;
+	unsigned long doios_single;
+	unsigned long doios_multi;
+	unsigned long txlen;
+	unsigned long tx_time;
+	struct timeval send_stamp;
+} connection_profile;
+
+/**
+ * Representation of one iucv connection
+ */
+typedef struct iucv_connection_t {
+	struct iucv_connection_t *next;
+	iucv_handle_t            handle;
+	__u16                    pathid;
+	struct sk_buff           *rx_buff;
+	struct sk_buff           *tx_buff;
+	struct sk_buff_head      collect_queue;
+	spinlock_t               collect_lock;
+	int                      collect_len;
+	int                      max_buffsize;
+	int                      flags;
+	fsm_timer                timer;
+	int                      retry;
+	fsm_instance             *fsm;
+	net_device               *netdev;
+	connection_profile       prof;
+	char                     userid[9];
+} iucv_connection;
+
+#define CONN_FLAGS_BUFSIZE_CHANGED 1
+
+/**
+ * Linked list of all connection structs.
+ */
+iucv_connection *connections;
+
+/**
+ * Representation of event-data for the
+ * connection state machine.
+ */
+typedef struct iucv_event_t {
+	iucv_connection *conn;
+	void            *data;
+} iucv_event;
+
+/**
+ * Private part of the network device structure
+ */
+typedef struct netiucv_priv_t {
+	struct net_device_stats stats;
+#if LINUX_VERSION_CODE >= 0x02032D
+	unsigned long           tbusy;
+#endif
+	fsm_instance            *fsm;
+        iucv_connection         *conn;
+	struct proc_dir_entry   *proc_dentry;
+	struct proc_dir_entry   *proc_stat_entry;
+	struct proc_dir_entry   *proc_buffer_entry;
+	struct proc_dir_entry   *proc_user_entry;
+	int                     proc_registered;
+} netiucv_priv;
+
+/**
+ * Link level header for a packet.
+ */
+typedef struct ll_header_t {
+	__u16 next;
+} ll_header;
+
+#define NETIUCV_HDRLEN           (sizeof(ll_header))
+#define NETIUCV_BUFSIZE_MAX      32768
+#define NETIUCV_BUFSIZE_DEFAULT  NETIUCV_BUFSIZE_MAX
+#define NETIUCV_MTU_MAX          (NETIUCV_BUFSIZE_MAX - NETIUCV_HDRLEN)
+#define NETIUCV_MTU_DEFAULT      9216
+#define NETIUCV_QUEUELEN_DEFAULT 50
+#define NETIUCV_TIMEOUT_5SEC     5000
+
+/**
+ * Compatibility macros for busy handling
+ * of network devices.
+ */
+#if LINUX_VERSION_CODE < 0x02032D
+static __inline__ void netiucv_clear_busy(net_device *dev)
+{
+	clear_bit(0 ,(void *)&dev->tbusy);
+	mark_bh(NET_BH);
+}
+
+static __inline__ int netiucv_test_and_set_busy(net_device *dev)
 {
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,45))
-	return (dev->tbusy);
+	return(test_and_set_bit(0, (void *)&dev->tbusy));
+}
+
+#define SET_DEVICE_START(device, value) dev->start = value
 #else
-	return (test_bit (__LINK_STATE_XOFF, &dev->flags));
+static __inline__ void netiucv_clear_busy(net_device *dev)
+{
+	clear_bit(0, &(((netiucv_priv *)dev->priv)->tbusy));
+	netif_start_queue(dev);
+}
+
+static __inline__ int netiucv_test_and_set_busy(net_device *dev)
+{
+	netif_stop_queue(dev);
+	return test_and_set_bit(0, &((netiucv_priv *)dev->priv)->tbusy);
+}
+
+#define SET_DEVICE_START(device, value)
+#endif
+
+#if LINUX_VERSION_CODE < 0x020400
+#  define dev_kfree_skb_irq(a) dev_kfree_skb(a)
 #endif
+
+__u8 iucv_host[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
+__u8 iucvMagic[16] = {
+	0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
+	0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
+};
+
+/**
+ * This mask means the 16-byte IUCV "magic" and the origin userid must
+ * match exactly as specified in order to give connection_pending()
+ * control.
+ */
+__u8 mask[] = {
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+};
+
+/**
+ * Convert an iucv userId to its printable
+ * form (strip whitespace at end).
+ *
+ * @param An iucv userId
+ *
+ * @returns The printable string (static data!!)
+ */
+static __inline__ char *
+netiucv_printname(char *name)
+{
+	static char tmp[9];
+	char *p = tmp;
+	memcpy(tmp, name, 8);
+	tmp[8] = '\0';
+	while (*p && (!isspace(*p)))
+		p++;
+	*p = '\0';
+	return tmp;
+}
+
+/**
+ * States of the interface statemachine.
+ */
+enum dev_states {
+	DEV_STATE_STOPPED,
+	DEV_STATE_STARTWAIT,
+	DEV_STATE_STOPWAIT,
+	DEV_STATE_RUNNING,
+	/**
+	 * MUST be always the last element!!
+	 */
+	NR_DEV_STATES
+};
+
+static const char *dev_state_names[] = {
+	"Stopped",
+	"StartWait",
+	"StopWait",
+	"Running",
+};
+
+/**
+ * Events of the interface statemachine.
+ */
+enum dev_events {
+	DEV_EVENT_START,
+	DEV_EVENT_STOP,
+	DEV_EVENT_CONUP,
+	DEV_EVENT_CONDOWN,
+	/**
+	 * MUST be always the last element!!
+	 */
+	NR_DEV_EVENTS
+};
+
+static const char *dev_event_names[] = {
+	"Start",
+	"Stop",
+	"Connection up",
+	"Connection down",
+};
+
+/**
+ * Events of the connection statemachine
+ */
+enum conn_events {
+	/**
+	 * Events, representing callbacks from
+	 * lowlevel iucv layer)
+	 */
+	CONN_EVENT_CONN_REQ,
+	CONN_EVENT_CONN_ACK,
+	CONN_EVENT_CONN_REJ,
+	CONN_EVENT_CONN_SUS,
+	CONN_EVENT_CONN_RES,
+	CONN_EVENT_RX,
+	CONN_EVENT_TXDONE,
+
+	/**
+	 * Events, representing errors return codes from
+	 * calls to lowlevel iucv layer
+	 */
+
+	/**
+	 * Event, representing timer expiry.
+	 */
+	CONN_EVENT_TIMER,
+
+	/**
+	 * Events, representing commands from upper levels.
+	 */
+	CONN_EVENT_START,
+	CONN_EVENT_STOP,
+
+	/**
+	 * MUST be always the last element!!
+	 */
+	NR_CONN_EVENTS,
+};
+
+static const char *conn_event_names[] = {
+	"Remote connection request",
+	"Remote connection acknowledge",
+	"Remote connection reject",
+	"Connection suspended",
+	"Connection resumed",
+	"Data received",
+	"Data sent",
+
+	"Timer",
+
+	"Start",
+	"Stop",
+};
+
+/**
+ * States of the connection statemachine.
+ */
+enum conn_states {
+	/**
+	 * Connection not assigned to any device,
+	 * initial state, invalid
+	 */
+	CONN_STATE_INVALID,
+
+	/**
+	 * Userid assigned but not operating
+	 */
+	CONN_STATE_STOPPED,
+
+	/**
+	 * Connection registered,
+	 * no connection request sent yet,
+	 * no connection request received
+	 */
+	CONN_STATE_STARTWAIT,
+
+	/**
+	 * Connection registered and connection request sent,
+	 * no acknowledge and no connection request received yet.
+	 */
+	CONN_STATE_SETUPWAIT,
+
+	/**
+	 * Connection up and running idle
+	 */
+	CONN_STATE_IDLE,
+
+	/**
+	 * Data sent, awaiting CONN_EVENT_TXDONE
+	 */
+	CONN_STATE_TX,
+
+	/**
+	 * Terminating
+	 */
+	CONN_STATE_TERM,
+
+	/**
+	 * Error during registration.
+	 */
+	CONN_STATE_REGERR,
+
+	/**
+	 * Error during registration.
+	 */
+	CONN_STATE_CONNERR,
+
+	/**
+	 * MUST be always the last element!!
+	 */
+	NR_CONN_STATES,
+};
+
+static const char *conn_state_names[] = {
+	"Invalid",
+	"Stopped",
+	"StartWait",
+	"SetupWait",
+	"Idle",
+	"TX",
+	"Terminating",
+	"Registration error",
+	"Connect error",
+};
+
+
+/**
+ * Callback-wrappers, called from lowlevel iucv layer.
+ *****************************************************************************/
+
+static void
+netiucv_callback_rx(iucv_MessagePending *eib, void *pgm_data)
+{
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+
+	fsm_event(conn->fsm, CONN_EVENT_RX, &ev);
 }
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,45))
-	/* Provide our own 2.3.45 interfaces */
-#define netif_enter_interrupt(dev) dev->interrupt=1
-#define netif_exit_interrupt(dev) dev->interrupt=0
-#define netif_start(dev) dev->start=1
-#define netif_stop(dev) dev->start=0
+static void
+netiucv_callback_txdone(iucv_MessageComplete *eib, void *pgm_data)
+{
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_TXDONE, &ev);
+}
+
+static void
+netiucv_callback_connack(iucv_ConnectionComplete *eib, void *pgm_data)
+{
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_CONN_ACK, &ev);
+}
 
-static __inline__ void
-netif_stop_queue (net_device * dev)
+static void
+netiucv_callback_connreq(iucv_ConnectionPending *eib, void *pgm_data)
 {
-	dev->tbusy = 1;
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_CONN_REQ, &ev);
 }
 
-static __inline__ void
-netif_start_queue (net_device * dev)
+static void
+netiucv_callback_connrej(iucv_ConnectionSevered *eib, void *pgm_data)
 {
-	dev->tbusy = 0;
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_CONN_REJ, &ev);
 }
 
-static __inline__ void
-netif_wake_queue (net_device * dev)
+static void
+netiucv_callback_connsusp(iucv_ConnectionQuiesced *eib, void *pgm_data)
 {
-	dev->tbusy = 0;
-	mark_bh (NET_BH);
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
+
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_CONN_SUS, &ev);
 }
 
-#else
-	/* As of 2.3.45, we don't do these things anymore */
-#define netif_enter_interrupt(dev)
-#define netif_exit_interrupt(dev)
-#define netif_start(dev)
-#define netif_stop(dev)
-#endif
-
-static int iucv_start (net_device *);
-static int iucv_stop (net_device *);
-static int iucv_change_mtu (net_device *, int);
-static int iucv_init (net_device *);
-static void iucv_rx (net_device *, uchar *, int);
-static int iucv_tx (struct sk_buff *, net_device *);
-
-static void connection_severed (iucv_ConnectionSevered *, ulong);
-static void connection_pending (iucv_ConnectionPending *, ulong);
-static void connection_complete (iucv_ConnectionComplete *, ulong);
-static void message_pending (iucv_MessagePending *, ulong);
-static void send_complete (iucv_MessageComplete *, ulong);
+static void
+netiucv_callback_connres(iucv_ConnectionResumed *eib, void *pgm_data)
+{
+	iucv_connection *conn = (iucv_connection *)pgm_data;
+	iucv_event ev;
 
-void register_iucv_dev (int, char *);
+	ev.conn = conn;
+	ev.data = (void *)eib;
+	fsm_event(conn->fsm, CONN_EVENT_CONN_RES, &ev);
+}
 
 static iucv_interrupt_ops_t netiucv_ops = {
-	&connection_pending,
-	&connection_complete,
-	&connection_severed,
-	NULL,			/* Quiesced             */
-	NULL,			/* Resumed              */
-	&message_pending,	/* Message pending      */
-	&send_complete		/* Message complete     */
-};
-
-static char iucv_userid[MAX_DEVICES][8];
-net_device iucv_netdev[MAX_DEVICES];
-static char eodata[2] = { '\0', '\0' };
-
-/* This structure is private to each device. It contains the    */
-/* information necessary to do IUCV operations.                 */
-struct iucv_priv {
-	struct net_device_stats stats;
-	net_device *dev;
-	iucv_handle_t handle;
-	uchar userid[9];	/* Printable userid */
-	uchar userid2[8];	/* Used for IUCV operations */
-
-	/* Note: atomic_compare_and_swap() return value is backwards */
-	/*       from what you might think: FALSE=0=OK, TRUE=1=FAIL  */
-	atomic_t state;
-#define FREE 0
-#define CONNECTING 1
-#define CONNECTED 2
-	u16 pathid;
-};
-
-struct iucvtag {
-	iucv_array_t iucvvec[3];
-	u16 framelen;
-	struct sk_buff *skb;
+	ConnectionPending:  netiucv_callback_connreq,
+	ConnectionComplete: netiucv_callback_connack,
+	ConnectionSevered:  netiucv_callback_connrej,
+	ConnectionQuiesced: netiucv_callback_connsusp,
+	ConnectionResumed:  netiucv_callback_connres,
+	MessagePending:     netiucv_callback_rx,
+	MessageComplete:    netiucv_callback_txdone
 };
 
-uchar iucv_host[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
-uchar iucvMagic[16] = { 0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
-	0xF0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
-};
+/**
+ * Dummy NOP action for all statemachines
+ */
+static void
+fsm_action_nop(fsm_instance *fi, int event, void *arg)
+{
+}
+
+/**
+ * Actions of the connection statemachine
+ *****************************************************************************/
+
+/**
+ * Helper function for conn_action_rx()
+ * Unpack a just received skb and hand it over to
+ * upper layers.
+ *
+ * @param conn The connection where this skb has been received.
+ * @param pskb The received skb.
+ */
+//static __inline__ void
+static void
+netiucv_unpack_skb(iucv_connection *conn, struct sk_buff *pskb)
+{
+	net_device     *dev = conn->netdev;
+	netiucv_priv   *privptr = (netiucv_priv *)dev->priv;
+	__u16          offset = 0;
+
+	skb_put(pskb, NETIUCV_HDRLEN);
+	pskb->dev = dev;
+	pskb->ip_summed = CHECKSUM_NONE;
+	pskb->protocol = ntohs(ETH_P_IP);
+
+	while (1) {
+		struct sk_buff *skb;
+		ll_header *header = (ll_header *)pskb->data;
 
-/* This mask means the 16-byte IUCV "magic" and the origin userid must */
-/* match exactly as specified in order to give connection_pending()    */
-/* control. 							       */
-const char mask[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
-};
+		if (header->next == 0)
+			break;
 
-#ifdef DEBUG
-/*--------------------------*/
-/* Dump buffer formatted    */
-/*--------------------------*/
-static void
-dumpit (char *buf, int len)
-{
-	int i;
-	printk (KERN_DEBUG);
-	for (i = 0; i < len; i++) {
-		if (!(i % 32) && i != 0)
-			printk ("\n");
-		else if (!(i % 4) && i != 0)
-			printk (" ");
-		printk ("%02X", buf[i]);
-	}
-	if (len % 32)
-		printk ("\n");
-}
-#endif
-
-/*-----------------------------------------------------------------*/
-/* Open a connection to another Linux or VM TCP/IP stack.          */
-/* Called by kernel.						   */
-/*                                                                 */
-/* 1. Register a handler. (Up to now, any attempt by another stack */
-/*    has been rejected by the IUCV handler.)  We give the handler */
-/*    the net_device* so that we can locate the dev associated     */
-/*    with the partner userid if he tries to connect to us or      */
-/*    if the connection is broken.                                 */
-/*                                                                 */
-/* 2. Connect to remote stack.  If we get a connection pending     */
-/*    interrupt while we're in the middle of connecting, don't     */
-/*    worry.  VM will sever its and use ours, because the DEVICE   */
-/*    is defined to be:                                            */
-/*           DEVICE devname IUCV 0 0 linuxvm A                     */
-/*        or DEVICE devname IUCV 0 0 linuxvm B                     */
-/*    In EBCDIC, "0" (0xF0) is greater than "A" (0xC1) or "B", so  */
-/*    win all races.  We will sever any connects that occur while  */
-/*    we are connecting.  The "0 0" is where we get iucvMagic from.*/
-/*								   */
-/*    FIXME: If two Linux machines get into this race condition,   */
-/*           both will sever.  Manual intervention required.       */
-/*           Need a better IUCV "hello"-like function that permits */
-/*           some negotiation.  But can't do that until VM TCP/IP  */
-/*           would support it.                                     */
-/*                                                                 */
-/* 3. Return 0 to indicate device ok.  Anything else is an error.  */
-/*-----------------------------------------------------------------*/
-static int
-iucv_start (net_device * dev)
-{
-	int rc, i;
-	uchar pri;
-	uchar unused = '\0';
-	struct iucv_priv *p = (struct iucv_priv *) dev->priv;
-
-	pr_debug ("iucv_start(%s)\n", dev->name);
-
-	if (p == NULL) {
-		/* Allocate priv data */
-		p = (struct iucv_priv *) kmalloc (sizeof (struct iucv_priv),
-						  GFP_KERNEL);
-		if (p == NULL) {
-			printk (KERN_CRIT "%s: no memory for dev->priv.\n",
-				dev->name);
-			return -ENOMEM;
-		}
-		memset (p, 0, sizeof (struct iucv_priv));
-		dev->priv = p;
-		p->dev = dev;
-
-		memcpy (p->userid, iucv_userid[dev - iucv_netdev], 8);	/* Save userid */
-		memcpy (p->userid2, p->userid, 8);	/* Again, with feeling.  */
-
-		for (i = 0; i < 8; i++) {	/* Change userid to printable form */
-			if (p->userid[i] == ' ') {
-				p->userid[i] = '\0';
-				break;
-			}
+		skb_pull(pskb, NETIUCV_HDRLEN);
+		header->next -= offset;
+		offset += header->next;
+		header->next -= NETIUCV_HDRLEN;
+		if (skb_tailroom(pskb) < header->next) {
+			printk(KERN_WARNING
+			       "%s: Ilegal next field in iucv header: %d > %d\n",
+			       dev->name, header->next, skb_tailroom(pskb));
+			return;
 		}
-		p->userid[8] = '\0';
-		atomic_set (&p->state, FREE);
-		p->handle =
-		    iucv_register_program (iucvMagic, p->userid2, (char *) mask,
-					   &netiucv_ops, (ulong) dev);
-		if (p->handle <= 0) {
-			printk (KERN_ERR
-				"%s: iucv_register_program error, rc=%i\n",
-				dev->name, (int) p->handle);
-			dev->priv = NULL;
-			kfree (p);
-			return -ENODEV;
+		skb_put(pskb, header->next);
+		pskb->mac.raw = pskb->data;
+		skb = dev_alloc_skb(pskb->len);
+		if (!skb) {
+			printk(KERN_WARNING
+			       "%s Out of memory in netiucv_unpack_skb\n",
+			       dev->name);
+			privptr->stats.rx_dropped++;
+			return;
 		}
-		pr_debug ("state@ = %p\n", &p->state);
-		MOD_INC_USE_COUNT;
-	}
-
-	if (atomic_compare_and_swap (FREE, CONNECTING, &p->state) != 0) {
-		pr_debug ("Other side connecting during start\n");
-		return 0;
+		memcpy(skb_put(skb, pskb->len), pskb->data, pskb->len);
+		skb->mac.raw = skb->data;
+		skb->dev = pskb->dev;
+		skb->protocol = pskb->protocol;
+		pskb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_rx(skb);
+		privptr->stats.rx_packets++;
+		privptr->stats.rx_bytes += skb->len;
+		skb_pull(pskb, header->next);
+		skb_put(pskb, NETIUCV_HDRLEN);
 	}
+}
 
-	rc =
-	    iucv_connect (&(p->pathid), MAX_TX_Q, iucvMagic, p->userid2,
-			  iucv_host, unused, unused, unused, unused, unused,
-			  &pri, p->handle, (ulong) p);
-
-	/* Some errors are not fatal.  In these cases we will report "OK". */
-	switch (rc) {
-	case 0:		/* Wait for connection to complete */
-		pr_debug ("...waiting for connection to complete...");
-		return 0;
-	case 11:		/* Wait for parter to connect */
-		printk (KERN_NOTICE "Device %s: "
-			"User %s is not available now.\n",
-			dev->name, p->userid);
-		atomic_set (&p->state, FREE);
-		return 0;
-	case 12:		/* Wait for partner to connect */
-		printk (KERN_NOTICE "Device %s: "
-			"User %s is not ready to talk now.\n",
-			dev->name, p->userid);
-		atomic_set (&p->state, FREE);
-		return 0;
-	case 13:		/* Fatal */
-		printk (KERN_ERR "Device %s: "
-			"You have too many IUCV connections."
-			"Check MAXCONN in CP directory.\n", dev->name);
-		break;
-	case 14:		/* Fatal */
-		printk (KERN_ERR "Device %s: "
-			"User %s has too many IUCV connections."
-			"Check MAXCONN in CP directory.\n",
-			dev->name, p->userid);
-		break;
-	case 15:		/* Fatal */
-		printk (KERN_ERR "Device %s: "
-			"No IUCV authorization found in CP directory.\n",
-			dev->name);
-		break;
-	default:		/* Really fatal! Should not occur!! */
-		printk (KERN_ERR "%s: "
-			"return code %i from iucv_connect()\n", dev->name, rc);
-	}
-
-	rc = iucv_unregister (p->handle);
-	dev->priv = NULL;
-	kfree (p);
-	MOD_DEC_USE_COUNT;
-	return -ENODEV;
-}				/* end iucv_start() */
+static void
+conn_action_rx(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	iucv_MessagePending *eib = (iucv_MessagePending *)ev->data;
+	netiucv_priv *privptr = (netiucv_priv *)conn->netdev->priv;
 
-/*********************************************************************/
-/* Our connection TO another stack has been accepted.                */
-/*********************************************************************/
-static void
-connection_complete (iucv_ConnectionComplete * cci, ulong pgm_data)
-{
-	struct iucv_priv *p = (struct iucv_priv *) pgm_data;
-	pr_debug ("...%s connection complete... txq=%u\n",
-		  p->dev->name, cci->ipmsglim);
-	atomic_set (&p->state, CONNECTED);
-	p->pathid = cci->ippathid;
-	p->dev->tx_queue_len = cci->ipmsglim;
-	netif_start (p->dev);
-	netif_start_queue (p->dev);
-	printk (KERN_INFO "%s: Connection to user %s is up\n",
-		p->dev->name, p->userid);
-}				/* end connection_complete() */
-
-/*********************************************************************/
-/* A connection FROM another stack is pending.  If we are in the     */
-/* middle of connecting, sever the new connection.                   */
-/*								     */
-/* We only get here if we've done an iucv_register(), so we know     */
-/* the remote user is the correct user.                              */
-/*********************************************************************/
-static void
-connection_pending (iucv_ConnectionPending * cpi, ulong pgm_data)
-{
-	/* Only get this far if handler is set up, so we know userid is ok. */
-	/* and the device is started.                                       */
-	/* pgm_data is different for this one.  We get dev*, not priv*.     */
-	net_device *dev = (net_device *) pgm_data;
-	struct iucv_priv *p = (struct iucv_priv *) dev->priv;
+	__u16 msglen = eib->ln1msg2.ipbfln1f;
 	int rc;
-	uchar udata[16];
-	uchar no = '\0';
-	uchar na;
-
-	/* If we're not waiting on a connect, reject the connection */
-	if (atomic_compare_and_swap (FREE, CONNECTING, &p->state) != 0) {
-		iucv_sever (cpi->ippathid, udata);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	if (!conn->netdev) {
+		/* FRITZ: How to tell iucv LL to drop the msg? */
+		printk(KERN_WARNING
+		       "Received data for unlinked connection\n"); 
 		return;
 	}
+	if (msglen > conn->max_buffsize) {
+		/* FRITZ: How to tell iucv LL to drop the msg? */
+		privptr->stats.rx_dropped++;
+		return;
+	}
+	conn->rx_buff->data = conn->rx_buff->tail = conn->rx_buff->head;
+	conn->rx_buff->len = 0;
+	rc = iucv_receive(conn->pathid, eib->ipmsgid, eib->iptrgcls,
+			  conn->rx_buff->data, msglen, NULL, NULL, NULL);
+	if (rc != 0 || msglen < 5) {
+		privptr->stats.rx_errors++;
+		return;
+	}
+	netiucv_unpack_skb(conn, conn->rx_buff);
+}
 
-	rc = iucv_accept (cpi->ippathid,	/* Path id              */
-			  MAX_TX_Q,	/* msglimit                     */
-			  udata,	/* user_Data                    */
-			  no,	/* will we send priority msgs?  */
-			  no,	/* do we accept prmdata?        */
-			  no,	/* quiece immediately?          */
-			  no,	/* control path?                */
-			  &na,	/* other side accept prmdata?   */
-			  p->handle,	/* registration handle  */
-			  (ulong) p);	/* private data         */
-	if (rc != 0) {
-		atomic_set (&p->state, FREE);
-		printk (KERN_ERR "%s: iucv accept failed rc=%i\n",
-			p->dev->name, rc);
+static void
+conn_action_txdone(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	iucv_MessageComplete *eib = (iucv_MessageComplete *)ev->data;
+	netiucv_priv *privptr = NULL;
+	struct sk_buff *skb = (struct sk_buff *)eib->ipmsgtag;
+	__u32 txbytes = 0;
+	__u32 txpackets = 0;
+	__u32 stat_maxcq = 0;
+	unsigned long saveflags;
+	ll_header header;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	fsm_deltimer(&conn->timer);
+	if (conn && conn->netdev && conn->netdev->priv)
+		privptr = (netiucv_priv *)conn->netdev->priv;
+	if (skb) {
+		if (privptr) {
+			privptr->stats.tx_packets++;
+			privptr->stats.tx_bytes +=
+				(skb->len - NETIUCV_HDRLEN - NETIUCV_HDRLEN);
+		}
+		dev_kfree_skb_any(skb);
 	} else {
-		p->pathid = cpi->ippathid;
-		p->dev->tx_queue_len = cpi->ipmsglim;
-		netif_start (p->dev);
-		netif_start_queue (p->dev);
-		atomic_set (&p->state, CONNECTED);
-		printk (KERN_INFO "Device %s: Connection to user %s is up\n",
-			p->dev->name, p->userid);
+		conn->tx_buff->data = conn->tx_buff->tail = conn->tx_buff->head;
+		conn->tx_buff->len = 0;
+	}
+	spin_lock_irqsave(&conn->collect_lock, saveflags);
+	while ((skb = skb_dequeue(&conn->collect_queue))) {
+		header.next = conn->tx_buff->len + skb->len + NETIUCV_HDRLEN;
+		memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,
+		       NETIUCV_HDRLEN);
+		memcpy(skb_put(conn->tx_buff, skb->len), skb->data, skb->len);
+		txbytes += skb->len;
+		txpackets++;
+		stat_maxcq++;
+		atomic_dec(&skb->users);
+		dev_kfree_skb_any(skb);
 	}
-}				/* end connection_pending() */
+	if (conn->collect_len > conn->prof.maxmulti)
+		conn->prof.maxmulti = conn->collect_len;
+	conn->collect_len = 0;
+	spin_unlock_irqrestore(&conn->collect_lock, saveflags);
+	if (conn->tx_buff->len) {
+		int rc;
+
+		header.next = 0;
+		memcpy(skb_put(conn->tx_buff, NETIUCV_HDRLEN), &header,
+		       NETIUCV_HDRLEN);
+
+		fsm_addtimer(&conn->timer, NETIUCV_TIMEOUT_5SEC,
+			     CONN_EVENT_TIMER, conn);
+		conn->prof.send_stamp = xtime;
+		rc = iucv_send(conn->pathid, NULL, 0, 0, 0, 0,
+			       conn->tx_buff->data, conn->tx_buff->len);
+		conn->prof.doios_multi++;
+		conn->prof.txlen += conn->tx_buff->len;
+		if (rc != 0) {
+			fsm_deltimer(&conn->timer);
+			fsm_newstate(fi, CONN_STATE_IDLE);
+			if (privptr)
+				privptr->stats.tx_errors += txpackets;
+		} else {
+			if (privptr) {
+				privptr->stats.tx_packets += txpackets;
+				privptr->stats.tx_bytes += txbytes;
+			}
+			if (stat_maxcq > conn->prof.maxcqueue)
+				conn->prof.maxcqueue = stat_maxcq;
+		}
+	} else
+		fsm_newstate(fi, CONN_STATE_IDLE);
+}
 
-/*********************************************************************/
-/* Our connection to another stack has been severed.                 */
-/*********************************************************************/
 static void
-connection_severed (iucv_ConnectionSevered * eib, ulong pgm_data)
+conn_action_connaccept(fsm_instance *fi, int event, void *arg)
 {
-	struct iucv_priv *p = (struct iucv_priv *) pgm_data;
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	iucv_ConnectionPending *eib = (iucv_ConnectionPending *)ev->data;
+	net_device *netdev = conn->netdev;
+	netiucv_priv *privptr = (netiucv_priv *)netdev->priv;
+	int rc;
+	__u16 msglimit;
+	__u8 udata[16];
 
-	printk (KERN_INFO "%s: Connection to user %s is down\n",
-		p->dev->name, p->userid);
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	rc = iucv_accept(eib->ippathid, NETIUCV_QUEUELEN_DEFAULT, udata, 0,
+			 conn->handle, conn, NULL, &msglimit);
+	if (rc != 0) {
+		printk(KERN_WARNING
+		       "%s: IUCV accept failed with error %d\n",
+		       netdev->name, rc);
+		return;
+	}
+	fsm_newstate(fi, CONN_STATE_IDLE);
+	conn->pathid = eib->ippathid;
+	netdev->tx_queue_len = msglimit;
+	fsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);
+}
 
-	if (atomic_compare_and_swap (CONNECTED, FREE, &p->state) != 0)
-		return;		/* In case reconnect in progress already */
+static void
+conn_action_connreject(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	// iucv_connection *conn = ev->conn;
+	iucv_ConnectionPending *eib = (iucv_ConnectionPending *)ev->data;
+	__u8 udata[16];
 
-	netif_stop_queue (p->dev);
-	netif_stop (p->dev);
-}				/* end connection_severed() */
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	iucv_sever(eib->ippathid, udata);
+}
 
-/*-----------------------------------------------------*/
-/* STOP device.                   Called by kernel.    */
-/*-----------------------------------------------------*/
-static int
-iucv_stop (net_device * dev)
+static void
+conn_action_connack(fsm_instance *fi, int event, void *arg)
 {
-	int rc = 0;
-	struct iucv_priv *p;
-	pr_debug ("%s: iucv_stop\n", dev->name);
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	iucv_ConnectionComplete *eib = (iucv_ConnectionComplete *)ev->data;
+	net_device *netdev = conn->netdev;
+	netiucv_priv *privptr = (netiucv_priv *)netdev->priv;
 
-	netif_stop_queue (dev);
-	netif_stop (dev);
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	fsm_newstate(fi, CONN_STATE_IDLE);
+	conn->pathid = eib->ippathid;
+	netdev->tx_queue_len = eib->ipmsglim;
+	fsm_event(privptr->fsm, DEV_EVENT_CONUP, netdev);
+}
 
-	p = (struct iucv_priv *) (dev->priv);
-	if (p == NULL)
-		return 0;
+static void
+conn_action_connsever(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	// iucv_ConnectionSevered *eib = (iucv_ConnectionSevered *)ev->data;
+	net_device *netdev = conn->netdev;
+	netiucv_priv *privptr = (netiucv_priv *)netdev->priv;
+	int state = fsm_getstate(fi);
 
-	rc = iucv_unregister (p->handle);	/* Will sever connections */
-	dev->priv = NULL;
-	kfree (p);
-	MOD_DEC_USE_COUNT;
-	return 0;
-}				/* end  iucv_stop() */
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	switch (state) {
+		case CONN_STATE_IDLE:
+		case CONN_STATE_TX:
+			printk(KERN_INFO "%s: Remote dropped connection\n",
+			       netdev->name);
+			iucv_unregister_program(conn->handle);
+			conn->handle = 0;
+			fsm_newstate(fi, CONN_STATE_STOPPED);
+			fsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);
+			break;
+	}
+}
 
-/*---------------------------------------------------------------------*/
-/* Inbound packets from other host are ready for receipt.  Receive     */
-/* them (they arrive as a single transmission), break them up into     */
-/* separate packets, and send them to the "generic" packet processor.  */
-/*---------------------------------------------------------------------*/
 static void
-message_pending (iucv_MessagePending * mpi, ulong pgm_data)
+conn_action_start(fsm_instance *fi, int event, void *arg)
 {
-	struct iucv_priv *p = (struct iucv_priv *) pgm_data;
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+
 	int rc;
-	u32 buffer_length;
-	u16 packet_offset, prev_offset = 0;
-	void *buffer;
-
-	buffer_length = mpi->ln1msg2.ipbfln1f;
-	pr_debug ("message_pending: ID=%p Length=%u\n", (void *) mpi->ipmsgid,
-		  buffer_length);
-
-	buffer = kmalloc (buffer_length, GFP_ATOMIC | GFP_DMA);
-	if (buffer == NULL) {
-		p->stats.rx_dropped++;
-		return;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	if (conn->handle == 0) {
+		conn->handle =
+			iucv_register_program(iucvMagic, conn->userid, mask,
+					      &netiucv_ops, conn);
+		fsm_newstate(fi, CONN_STATE_STARTWAIT);
+		if (conn->handle <= 0) {
+			fsm_newstate(fi, CONN_STATE_REGERR);
+			conn->handle = 0;
+			return;
+		}
+#ifdef DEBUG
+		printk(KERN_DEBUG "%s('%s'): registered successfully\n",
+		       conn->netdev->name, conn->userid);
+#endif
 	}
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s('%s'): connecting ...\n",
+	       conn->netdev->name, conn->userid);
+#endif
+	rc = iucv_connect(&(conn->pathid), NETIUCV_QUEUELEN_DEFAULT, iucvMagic,
+			  conn->userid, iucv_host, 0, NULL, NULL, conn->handle,
+			  conn);
+	fsm_newstate(fi, CONN_STATE_SETUPWAIT);
+	switch (rc) {
+		case 0:
+			return;
+		case 11:
+			printk(KERN_NOTICE
+			       "%s: User %s is currently not available.\n",
+			       conn->netdev->name,
+			       netiucv_printname(conn->userid));
+			fsm_newstate(fi, CONN_STATE_STARTWAIT);
+			return;
+		case 12:
+			printk(KERN_NOTICE
+			       "%s: User %s is currently not ready.\n",
+			       conn->netdev->name,
+			       netiucv_printname(conn->userid));
+			fsm_newstate(fi, CONN_STATE_STARTWAIT);
+			return;
+		case 13:
+			printk(KERN_WARNING
+			       "%s: Too many IUCV connections.\n",
+			       conn->netdev->name);
+			fsm_newstate(fi, CONN_STATE_CONNERR);
+			break;
+		case 14:
+			printk(KERN_WARNING
+			       "%s: User %s has too many IUCV connections.\n",
+			       conn->netdev->name,
+			       netiucv_printname(conn->userid));
+			fsm_newstate(fi, CONN_STATE_CONNERR);
+			break;
+		case 15:
+			printk(KERN_WARNING
+			       "%s: No IUCV authorization in CP directory.\n",
+			       conn->netdev->name);
+			fsm_newstate(fi, CONN_STATE_CONNERR);
+			break;
+		default:
+			printk(KERN_WARNING
+			       "%s: iucv_connect returned error %d\n",
+			       conn->netdev->name, rc);
+			fsm_newstate(fi, CONN_STATE_CONNERR);
+			break;
+	}
+	iucv_unregister_program(conn->handle);
+	conn->handle = 0;
+}
 
-	rc = iucv_receive_simple (p->pathid, mpi->ipmsgid, mpi->iptrgcls,
-				  buffer, buffer_length);
+static void
+netiucv_purge_skb_queue(struct sk_buff_head *q)
+{
+	struct sk_buff *skb;
 
-	if (rc != 0 || buffer_length < 5) {
-		printk (KERN_INFO
-			"%s: iucv_receive error. rc=%X, length=%u\n",
-			p->dev->name, rc, buffer_length);
-		p->stats.rx_errors++;
-		kfree (buffer);
-		return;
+	while ((skb = skb_dequeue(q))) {
+		atomic_dec(&skb->users);
+		dev_kfree_skb_any(skb);
 	}
+}
 
-	packet_offset = *((u16 *) buffer);
+static void
+conn_action_stop(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	net_device *netdev = conn->netdev;
+	netiucv_priv *privptr = (netiucv_priv *)netdev->priv;
 
-	while (packet_offset != 0) {
-		if (packet_offset <= prev_offset
-		    || packet_offset > buffer_length - 2) {
-			printk (KERN_INFO "%s: bad inbound packet offset %u, "
-				"prev %u, total %u\n", p->dev->name,
-				packet_offset, prev_offset, buffer_length);
-			p->stats.rx_errors++;
-			break;
-		} else {
-			/* Kick the packet upstairs */
-			iucv_rx (p->dev,
-				 buffer + prev_offset + 2,
-				 packet_offset - prev_offset - 2);
-			prev_offset = packet_offset;
-			packet_offset = *((u16 *) (buffer + packet_offset));
-		}
-	}
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	fsm_newstate(fi, CONN_STATE_STOPPED);
+	netiucv_purge_skb_queue(&conn->collect_queue);
+	iucv_unregister_program(conn->handle);
+	conn->handle = 0;
+	fsm_event(privptr->fsm, DEV_EVENT_CONDOWN, netdev);
+}
 
-	kfree (buffer);
-	return;
-}				/* end message_pending() */
+static void
+conn_action_inval(fsm_instance *fi, int event, void *arg)
+{
+	iucv_event *ev = (iucv_event *)arg;
+	iucv_connection *conn = ev->conn;
+	net_device *netdev = conn->netdev;
+
+	printk(KERN_WARNING
+	       "%s: Cannot connect without username\n",
+	       netdev->name);
+}
+
+static const fsm_node conn_fsm[] = {
+	{ CONN_STATE_INVALID,   CONN_EVENT_START,    conn_action_inval      },
+	{ CONN_STATE_STOPPED,   CONN_EVENT_START,    conn_action_start      },
+	{ CONN_STATE_STARTWAIT, CONN_EVENT_START,    conn_action_start      },
+
+	{ CONN_STATE_STARTWAIT, CONN_EVENT_STOP,     conn_action_stop       },
+	{ CONN_STATE_SETUPWAIT, CONN_EVENT_STOP,     conn_action_stop       },
+	{ CONN_STATE_IDLE,      CONN_EVENT_STOP,     conn_action_stop       },
+	{ CONN_STATE_TX,        CONN_EVENT_STOP,     conn_action_stop       },
+	{ CONN_STATE_REGERR,    CONN_EVENT_STOP,     conn_action_stop       },
+	{ CONN_STATE_CONNERR,   CONN_EVENT_STOP,     conn_action_stop       },
+
+	{ CONN_STATE_STOPPED,   CONN_EVENT_CONN_REQ, conn_action_connreject },
+        { CONN_STATE_STARTWAIT, CONN_EVENT_CONN_REQ, conn_action_connaccept },
+	{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_REQ, conn_action_connaccept },
+	{ CONN_STATE_IDLE,      CONN_EVENT_CONN_REQ, conn_action_connreject },
+	{ CONN_STATE_TX,        CONN_EVENT_CONN_REQ, conn_action_connreject },
+
+	{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_ACK, conn_action_connack    },
+
+	{ CONN_STATE_SETUPWAIT, CONN_EVENT_CONN_REJ, conn_action_connsever  },
+	{ CONN_STATE_IDLE,      CONN_EVENT_CONN_REJ, conn_action_connsever  },
+	{ CONN_STATE_TX,        CONN_EVENT_CONN_REJ, conn_action_connsever  },
+
+	{ CONN_STATE_IDLE,      CONN_EVENT_RX,       conn_action_rx         },
+	{ CONN_STATE_TX,        CONN_EVENT_RX,       conn_action_rx         },
+
+	{ CONN_STATE_TX,        CONN_EVENT_TXDONE,   conn_action_txdone     },
+};
+
+static const int CONN_FSM_LEN = sizeof(conn_fsm) / sizeof(fsm_node);
 
-/*-------------------------------------------------------------*/
-/* Add meta-data to packet and send upstairs.                  */
-/*-------------------------------------------------------------*/
+
+/**
+ * Actions for interface - statemachine.
+ *****************************************************************************/
+
+/**
+ * Startup connection by sending CONN_EVENT_START to it.
+ *
+ * @param fi    An instance of an interface statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from net_device * upon call.
+ */
 static void
-iucv_rx (net_device * dev, uchar * buf, int len)
+dev_action_start(fsm_instance *fi, int event, void *arg)
 {
-	struct iucv_priv *p = (struct iucv_priv *) dev->priv;
-	struct sk_buff *skb;
+	net_device   *dev = (net_device *)arg;
+	netiucv_priv *privptr = dev->priv;
+	iucv_event   ev;
 
-	pr_debug ("%s: iucv_rx len=%u\n", p->dev->name, len);
 #ifdef DEBUG
-	dumpit (buf, 20);
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
 #endif
+	ev.conn = privptr->conn;
+	fsm_newstate(fi, DEV_STATE_STARTWAIT);
+	fsm_event(privptr->conn->fsm, CONN_EVENT_START, &ev);
+}
 
-	if (len > p->dev->mtu) {
-		printk (KERN_INFO
-			"%s: inbound packet length %u exceeds MTU %i\n",
-			p->dev->name, len, p->dev->mtu);
-		p->stats.rx_errors++;
-		return;
+/**
+ * Shutdown connection by sending CONN_EVENT_STOP to it.
+ *
+ * @param fi    An instance of an interface statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from net_device * upon call.
+ */
+static void
+dev_action_stop(fsm_instance *fi, int event, void *arg)
+{
+	net_device   *dev = (net_device *)arg;
+	netiucv_priv *privptr = dev->priv;
+	iucv_event   ev;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	ev.conn = privptr->conn;
+
+	fsm_newstate(fi, DEV_STATE_STOPWAIT);
+	fsm_event(privptr->conn->fsm, CONN_EVENT_STOP, &ev);
+}
+
+/**
+ * Called from connection statemachine
+ * when a connection is up and running.
+ *
+ * @param fi    An instance of an interface statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from net_device * upon call.
+ */
+static void
+dev_action_connup(fsm_instance *fi, int event, void *arg)
+{
+	net_device   *dev = (net_device *)arg;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	switch (fsm_getstate(fi)) {
+		case DEV_STATE_STARTWAIT:
+			fsm_newstate(fi, DEV_STATE_RUNNING);
+			printk(KERN_INFO
+			       "%s: connected with remote side\n",
+			       dev->name);
+			break;
+		case DEV_STATE_STOPWAIT:
+			printk(KERN_INFO
+			       "%s: got connection UP event during shutdown!!\n",
+			       dev->name);
+			break;
 	}
+}
 
-	skb = dev_alloc_skb (len);
-	if (!skb) {
-		p->stats.rx_dropped++;
-		return;
+/**
+ * Called from connection statemachine
+ * when a connection has been shutdown.
+ *
+ * @param fi    An instance of an interface statemachine.
+ * @param event The event, just happened.
+ * @param arg   Generic pointer, casted from net_device * upon call.
+ */
+static void
+dev_action_conndown(fsm_instance *fi, int event, void *arg)
+{
+	net_device   *dev = (net_device *)arg;
+	netiucv_priv *privptr = dev->priv;
+	iucv_event   ev;
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "%s() called\n", __FUNCTION__);
+#endif
+	switch (fsm_getstate(fi)) {
+		case DEV_STATE_RUNNING:
+			fsm_newstate(fi, DEV_STATE_STARTWAIT);
+			ev.conn = privptr->conn;
+			fsm_event(privptr->conn->fsm, CONN_EVENT_START, &ev);
+			break;
+		case DEV_STATE_STARTWAIT:
+			break;
+		case DEV_STATE_STOPWAIT:
+			fsm_newstate(fi, DEV_STATE_STOPPED);
+			break;
 	}
+}
 
-	/* If not enough room, skb_put will panic */
-	memcpy (skb_put (skb, len), buf, len);
+static const fsm_node dev_fsm[] = {
+	{ DEV_STATE_STOPPED,   DEV_EVENT_START,   dev_action_start    },
 
-	/* Write metadata, and then pass to the receive level.  Since we */
-	/* are not an Ethernet device, we have special fields to set.    */
-	/* This is all boilerplace, not to be messed with.               */
-	skb->dev = p->dev;	/* Set device       */
-	skb->mac.raw = skb->data;	/* Point to packet  */
-	skb->pkt_type = PACKET_HOST;	/* ..for this host. */
-	skb->protocol = htons (ETH_P_IP);	/* IP packet        */
-	skb->ip_summed = CHECKSUM_UNNECESSARY;	/* No checksum      */
-	p->stats.rx_packets++;
-	p->stats.rx_bytes += len;
-	netif_rx (skb);
+	{ DEV_STATE_STOPWAIT,  DEV_EVENT_START,   dev_action_start    },
+	{ DEV_STATE_STOPWAIT,  DEV_EVENT_CONDOWN, dev_action_conndown },
 
-	return;
-}				/* end  iucv_rx() */
+	{ DEV_STATE_STARTWAIT, DEV_EVENT_STOP,    dev_action_stop     },
+	{ DEV_STATE_STARTWAIT, DEV_EVENT_CONUP,   dev_action_connup   },
+	{ DEV_STATE_STARTWAIT, DEV_EVENT_CONDOWN, dev_action_conndown },
+
+	{ DEV_STATE_RUNNING,   DEV_EVENT_STOP,    dev_action_stop     },
+	{ DEV_STATE_RUNNING,   DEV_EVENT_CONDOWN, dev_action_conndown },
+	{ DEV_STATE_RUNNING,   DEV_EVENT_CONUP,   fsm_action_nop      },
+};
 
-/*-------------------------------------------------------------*/
-/* TRANSMIT a packet.            	    Called by kernel.  */
-/* This function deals with hw details of packet transmission. */
-/*-------------------------------------------------------------*/
+static const int DEV_FSM_LEN = sizeof(dev_fsm) / sizeof(fsm_node);
+
+/**
+ * Transmit a packet.
+ * This is a helper function for netiucv_tx().
+ *
+ * @param conn Connection to be used for sending.
+ * @param skb Pointer to struct sk_buff of packet to send.
+ *            The linklevel header has already been set up
+ *            by netiucv_tx().
+ *
+ * @return 0 on success, -ERRNO on failure. (Never fails.)
+ */
 static int
-iucv_tx (struct sk_buff *skb, net_device * dev)
-{
-	int rc, pktlen;
-	struct iucvtag *tag;
-	struct iucv_priv *p = (struct iucv_priv *) dev->priv;
+netiucv_transmit_skb(iucv_connection *conn, struct sk_buff *skb) {
+	unsigned long saveflags;
+	ll_header header;
+	int       rc = 0;
+
+	if (fsm_getstate(conn->fsm) != CONN_STATE_IDLE) {
+		int l = skb->len + NETIUCV_HDRLEN;
+
+		spin_lock_irqsave(&conn->collect_lock, saveflags);
+		if (conn->collect_len + l >
+		    (conn->max_buffsize - NETIUCV_HDRLEN))
+			rc = -EBUSY;
+		else {
+			atomic_inc(&skb->users);
+			skb_queue_tail(&conn->collect_queue, skb);
+			conn->collect_len += l;
+		}
+		spin_unlock_irqrestore(&conn->collect_lock, saveflags);
+	} else {
+		struct sk_buff *nskb = skb;
+		/**
+		 * Copy the skb to a new allocated skb in lowmem only if the
+		 * data is located above 2G in memory or tailroom is < 2.
+		 */
+		unsigned long hi =
+			((unsigned long)(skb->tail + NETIUCV_HDRLEN)) >> 31;
+		int copied = 0;
+		if (hi || (skb_tailroom(skb) < 2)) {
+			nskb = alloc_skb(skb->len + NETIUCV_HDRLEN +
+					 NETIUCV_HDRLEN, GFP_ATOMIC | GFP_DMA);
+			if (!nskb) {
+				printk(KERN_WARNING
+				       "%s: Could not allocate tx_skb\n",
+				       conn->netdev->name);
+				rc = -ENOMEM;
+			} else {
+				skb_reserve(nskb, NETIUCV_HDRLEN);
+				memcpy(skb_put(nskb, skb->len),
+				       skb->data, skb->len);
+			}
+			copied = 1;
+		}
+		/**
+		 * skb now is below 2G and has enough room. Add headers.
+		 */
+		header.next = nskb->len + NETIUCV_HDRLEN;
+		memcpy(skb_push(nskb, NETIUCV_HDRLEN), &header, NETIUCV_HDRLEN);
+		header.next = 0;
+		memcpy(skb_put(nskb, NETIUCV_HDRLEN), &header,  NETIUCV_HDRLEN);
+
+		conn->retry = 0;
+		fsm_newstate(conn->fsm, CONN_STATE_TX);
+		fsm_addtimer(&conn->timer, NETIUCV_TIMEOUT_5SEC,
+			     CONN_EVENT_TIMER, conn);
+		conn->prof.send_stamp = xtime;
+		rc = iucv_send(conn->pathid, NULL, 0, 0, (__u32)nskb, 0,
+			       nskb->data, nskb->len);
+		conn->prof.doios_single++;
+		conn->prof.txlen += skb->len;
+		if (rc != 0) {
+			fsm_deltimer(&conn->timer);
+			if (copied)
+				dev_kfree_skb(nskb);
+			else {
+				/**
+				 * Remove our headers. They get added
+				 * again on retransmit.
+				 */
+				skb_pull(skb, NETIUCV_HDRLEN);
+				skb_trim(skb, skb->len - NETIUCV_HDRLEN);
+			}
+		} else {
+			if (copied)
+				dev_kfree_skb(skb);
+		}
+	}
+
+	return rc;
+}
+
+/**
+ * Interface API for upper network layers
+ *****************************************************************************/
+
+/**
+ * Open an interface.
+ * Called from generic network layer when ifconfig up is run.
+ *
+ * @param dev Pointer to interface struct.
+ *
+ * @return 0 on success, -ERRNO on failure. (Never fails.)
+ */
+static int
+netiucv_open(net_device *dev) {
+	MOD_INC_USE_COUNT;
+	fsm_event(((netiucv_priv *)dev->priv)->fsm, DEV_EVENT_START, dev);
+	return 0;
+}
+
+/**
+ * Close an interface.
+ * Called from generic network layer when ifconfig down is run.
+ *
+ * @param dev Pointer to interface struct.
+ *
+ * @return 0 on success, -ERRNO on failure. (Never fails.)
+ */
+static int
+netiucv_close(net_device *dev) {
+	SET_DEVICE_START(dev, 0);
+	fsm_event(((netiucv_priv *)dev->priv)->fsm, DEV_EVENT_STOP, dev);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+/**
+ * Start transmission of a packet.
+ * Called from generic network device layer.
+ *
+ * @param skb Pointer to buffer containing the packet.
+ * @param dev Pointer to interface struct.
+ *
+ * @return 0 if packet consumed, !0 if packet rejected.
+ *         Note: If we return !0, then the packet is free'd by
+ *               the generic network layer.
+ */
+static int netiucv_tx(struct sk_buff *skb, net_device *dev)
+{
+	int          rc = 0;
+	netiucv_priv *privptr = (netiucv_priv *)dev->priv;
+
+	/**
+	 * Some sanity checks ...
+	 */
+	if (skb == NULL) {
+		printk(KERN_WARNING "%s: NULL sk_buff passed\n", dev->name);
+		privptr->stats.tx_dropped++;
+		return 0;
+	}
+	if (skb_headroom(skb) < (NETIUCV_HDRLEN)) {
+		printk(KERN_WARNING
+		       "%s: Got sk_buff with head room < %ld bytes\n",
+		       dev->name, NETIUCV_HDRLEN);
+		dev_kfree_skb(skb);
+		privptr->stats.tx_dropped++;
+		return 0;
+	}
 
-	if (skb == NULL)	/* Nothing to do */
+	/**
+	 * If connection is not running, try to restart it
+	 * notify anybody about a link failure and throw
+	 * away packet. 
+	 */
+	if (fsm_getstate(privptr->fsm) != DEV_STATE_RUNNING) {
+		fsm_event(privptr->fsm, DEV_EVENT_START, dev);
+		dst_link_failure(skb);
+		dev_kfree_skb(skb);
+		privptr->stats.tx_dropped++;
+		privptr->stats.tx_errors++;
+		privptr->stats.tx_carrier_errors++;
 		return 0;
+	}
 
-	if (netif_is_busy (dev)) {
-		p->stats.tx_dropped++;
-		dev_kfree_skb (skb);
-		printk (KERN_ERR "%s: tx conflict! leave iucv_tx.\n",
-			dev->name);
+	if (netiucv_test_and_set_busy(dev))
 		return -EBUSY;
+
+	dev->trans_start = jiffies;
+	if (netiucv_transmit_skb(privptr->conn, skb) != 0)
+		rc = 1;
+	netiucv_clear_busy(dev);
+	return rc;
+}
+
+/**
+ * Returns interface statistics of a device.
+ *
+ * @param dev Pointer to interface struct.
+ *
+ * @return Pointer to stats struct of this interface.
+ */
+static struct net_device_stats *
+netiucv_stats (net_device * dev)
+{
+	return &((netiucv_priv *)dev->priv)->stats;
+}
+
+/**
+ * Sets MTU of an interface.
+ *
+ * @param dev     Pointer to interface struct.
+ * @param new_mtu The new MTU to use for this interface.
+ *
+ * @return 0 on success, -EINVAL if MTU is out of valid range.
+ *         (valid range is 576 .. NETIUCV_MTU_MAX).
+ */
+static int
+netiucv_change_mtu (net_device * dev, int new_mtu)
+{
+	if ((new_mtu < 576) || (new_mtu > NETIUCV_MTU_MAX))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+
+/**
+ * procfs related structures and routines
+ *****************************************************************************/
+
+static net_device *
+find_netdev_by_ino(unsigned long ino)
+{
+	iucv_connection *conn = connections;
+	net_device *dev = NULL;
+	netiucv_priv *privptr;
+
+	while (conn) {
+		if (conn->netdev != dev) {
+			dev = conn->netdev;
+			privptr = (netiucv_priv *)dev->priv;
+
+			if ((privptr->proc_buffer_entry->low_ino == ino) ||
+			    (privptr->proc_user_entry->low_ino == ino)   ||
+			    (privptr->proc_stat_entry->low_ino == ino)     )
+				return dev;
+		}
+		conn = conn->next;
 	}
+	return NULL;
+}
 
-	netif_stop_queue (dev);	/* transmission is busy */
+#if LINUX_VERSION_CODE < 0x020363
+/**
+ * Lock the module, if someone changes into
+ * our proc directory.
+ */
+static void
+netiucv_fill_inode(struct inode *inode, int fill)
+{
+	if (fill) {
+		MOD_INC_USE_COUNT;
+	} else
+		MOD_DEC_USE_COUNT;
+}
+#endif
 
-	dev->trans_start = jiffies;	/* save the timestamp */
+#define CTRL_BUFSIZE 40
 
-	/* Tag contains data that must survive exit from this */
-	/* routine.  MessageComplete exit will free the tag   */
-	/* and any structures it points to.                   */
-	tag =
-	    (struct iucvtag *) kmalloc (sizeof (struct iucvtag),
-					GFP_DMA | GFP_KERNEL);
-	if (!tag) {
-		p->stats.tx_dropped++;
-		dev_kfree_skb (skb);
+static int
+netiucv_buffer_open(struct inode *inode, struct file *file)
+{
+	file->private_data = kmalloc(CTRL_BUFSIZE, GFP_KERNEL);
+	if (file->private_data == NULL)
 		return -ENOMEM;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
+static int
+netiucv_buffer_close(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static ssize_t
+netiucv_buffer_write(struct file *file, const char *buf, size_t count,
+			   loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	net_device   *dev;
+	netiucv_priv *privptr;
+	char         *e;
+	int          bs1;
+	char         tmp[CTRL_BUFSIZE];
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	if (off != &file->f_pos)
+		return -ESPIPE;
+
+	privptr = (netiucv_priv *)dev->priv;
+
+	if (count >= 39)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+	tmp[count+1] = '\0';
+	bs1 = simple_strtoul(tmp, &e, 0);
+
+	if ((bs1 > NETIUCV_BUFSIZE_MAX) ||
+	    (e && (!isspace(*e))))
+		return -EINVAL;
+	if ((dev->flags & IFF_RUNNING) &&
+	    (bs1 < (dev->mtu + NETIUCV_HDRLEN + 2)))
+		return -EINVAL;
+	if (bs1 < (576 + NETIUCV_HDRLEN + NETIUCV_HDRLEN))
+		return -EINVAL;
+
+
+	privptr->conn->max_buffsize = bs1;
+	if (!(dev->flags & IFF_RUNNING))
+		dev->mtu = bs1 - NETIUCV_HDRLEN - NETIUCV_HDRLEN;
+	privptr->conn->flags |= CONN_FLAGS_BUFSIZE_CHANGED;
+
+	return count;
+}
+
+static ssize_t
+netiucv_buffer_read(struct file *file, char *buf, size_t count, loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	char *sbuf = (char *)file->private_data;
+	net_device *dev;
+	netiucv_priv *privptr;
+	ssize_t ret = 0;
+	char *p = sbuf;
+	int l;
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	if (off != &file->f_pos)
+		return -ESPIPE;
+
+	privptr = (netiucv_priv *)dev->priv;
+
+	if (file->f_pos == 0)
+		sprintf(sbuf, "%d\n", privptr->conn->max_buffsize);
+
+	l = strlen(sbuf);
+	p = sbuf;
+	if (file->f_pos < l) {
+		p += file->f_pos;
+		l = strlen(p);
+		ret = (count > l) ? l : count;
+		if (copy_to_user(buf, p, ret))
+			return -EFAULT;
 	}
+	file->f_pos += ret;
+	return ret;
+}
 
-	pktlen = skb->len;
-	tag->framelen = (u16) pktlen + 2;
-	tag->skb = skb;
-	tag->iucvvec[0].address = &tag->framelen;
-	tag->iucvvec[0].length = 2;
-	tag->iucvvec[1].address = (void *) virt_to_phys (skb->data);
-	tag->iucvvec[1].length = pktlen;
-	tag->iucvvec[2].address = (void *) virt_to_phys (eodata);
-	tag->iucvvec[2].length = 2;
-	pr_debug ("iucv_tx: length=%i, skb=%p tag=%p\n", pktlen, tag->skb, tag);
-
-	/* Ok, now the packet is ready for transmission: send it. */
-	rc =
-	    iucv_send_array (p->pathid, NULL, 0, 0, (ulong) tag, 0,
-			     tag->iucvvec, pktlen + 4);
-	if (rc == 0)
-		p->stats.tx_packets++;
-	else {
-		if (rc == 3)	/* Exceeded MSGLIMIT */
-			p->stats.tx_dropped++;
-		else {
-			p->stats.tx_errors++;
-			printk (KERN_INFO "%s: iucv send failed, rc=%i\n",
-				p->dev->name, rc);
-		}
-		dev_kfree_skb (skb);
-		kfree (tag);
-	}
-
-	netif_wake_queue (p->dev);
-	return rc;		/* zero == done; nonzero == fail */
-}				/* end iucv_tx() */
-
-/*-----------------------------------------------------------*/
-/* SEND COMPLETE                    Called by IUCV handler.  */
-/* Free SKB associated with this transmission and free       */
-/* the IUCV buffer list and SKB pointer.                     */
-/*-----------------------------------------------------------*/
-static void
-send_complete (iucv_MessageComplete * mci, ulong pgm_data)
-{
-	struct iucvtag *tag = (struct iucvtag *) mci->ipmsgtag;
-	pr_debug ("TX COMPLETE: Tag=%p skb=%p\n", tag, tag->skb);
-	dev_kfree_skb (tag->skb);
-	kfree (tag);
-}				/* end send_complete() */
-
-/*-----------------------------------------------------------*/
-/* STATISTICS reporting.                  Called by kernel.  */
-/*-----------------------------------------------------------*/
-static struct net_device_stats *
-iucv_stats (net_device * dev)
+static int
+netiucv_user_open(struct inode *inode, struct file *file)
 {
-	struct iucv_priv *p = (struct iucv_priv *) dev->priv;
-	return &p->stats;
-}				/* end iucv_stats() */
-
-/*-----------------------------------------------------------*/
-/* MTU change    .                        Called by kernel.  */
-/* IUCV can handle mtu sizes from 576 (the IP architectural  */
-/* minimum) up to maximum supported by VM.  I don't think IP */
-/* pays attention to new mtu until device is restarted.      */
-/*-----------------------------------------------------------*/
+	file->private_data = kmalloc(CTRL_BUFSIZE, GFP_KERNEL);
+	if (file->private_data == NULL)
+		return -ENOMEM;
+	MOD_INC_USE_COUNT;
+	return 0;
+}
+
 static int
-iucv_change_mtu (net_device * dev, int new_mtu)
+netiucv_user_close(struct inode *inode, struct file *file)
 {
-	if ((new_mtu < 576) || (new_mtu > MAX_VM_MTU))
-		return -EINVAL;
-	dev->mtu = new_mtu;
+	kfree(file->private_data);
+	MOD_DEC_USE_COUNT;
 	return 0;
-}				/* end iucv_change_mtu() */
+}
+
+static ssize_t
+netiucv_user_write(struct file *file, const char *buf, size_t count,
+			   loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	net_device   *dev;
+	netiucv_priv *privptr;
+	int          i;
+	char         *p;
+	char         tmp[CTRL_BUFSIZE];
+	char         user[9];
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	if (off != &file->f_pos)
+		return -ESPIPE;
+
+	privptr = (netiucv_priv *)dev->priv;
+
+	if (count >= 39)
+		return -EINVAL;
+
+	if (copy_from_user(tmp, buf, count))
+		return -EFAULT;
+	tmp[count+1] = '\0';
+
+	memset(user, ' ', sizeof(user));
+	user[8] = '\0';
+	for (p = tmp, i = 0; *p && (!isspace(*p)); p++) {
+		if (i > 7)
+			return -EINVAL;
+		user[i++] = *p;
+	}
+
+	if (memcmp(user, privptr->conn->userid, 8) != 0) {
+		/* username changed */
+		if (dev->flags & IFF_RUNNING)
+			return -EBUSY;
+	}
+	memcpy(privptr->conn->userid, user, 9);
+	return count;
+}
+
+static ssize_t
+netiucv_user_read(struct file *file, char *buf, size_t count, loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	char *sbuf = (char *)file->private_data;
+	net_device *dev;
+	netiucv_priv *privptr;
+	ssize_t ret = 0;
+	char *p = sbuf;
+	int l;
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	if (off != &file->f_pos)
+		return -ESPIPE;
+
+	privptr = (netiucv_priv *)dev->priv;
+
+
+	if (file->f_pos == 0)
+		sprintf(sbuf, "%s\n",
+			netiucv_printname(privptr->conn->userid));
+
+	l = strlen(sbuf);
+	p = sbuf;
+	if (file->f_pos < l) {
+		p += file->f_pos;
+		l = strlen(p);
+		ret = (count > l) ? l : count;
+		if (copy_to_user(buf, p, ret))
+			return -EFAULT;
+	}
+	file->f_pos += ret;
+	return ret;
+}
 
-/*-----------------------------------------------------------*/
-/* INIT device.                           Called by kernel.  */
-/* Called by register_netdev() in kernel.                    */
-/*-----------------------------------------------------------*/
-static int
-iucv_init (net_device * dev)
-{
-	dev->open = iucv_start;
-	dev->stop = iucv_stop;
-	dev->hard_start_xmit = iucv_tx;
-	dev->get_stats = iucv_stats;
-	dev->change_mtu = iucv_change_mtu;
-	dev->hard_header_len = 0;
-	dev->addr_len = 0;
-	dev->type = ARPHRD_SLIP;
-	dev->tx_queue_len = MAX_TX_Q;	/* Default - updated based on IUCV */
-	/* keep the default flags, just add NOARP and POINTOPOINT */
-	dev->flags = IFF_NOARP | IFF_POINTOPOINT;
-	dev->mtu = 9216;
+#define STATS_BUFSIZE 2048
 
-	pr_debug ("%s: iucv_init  dev@=%p\n", dev->name, dev);
+static int
+netiucv_stat_open(struct inode *inode, struct file *file)
+{
+	file->private_data = kmalloc(STATS_BUFSIZE, GFP_KERNEL);
+	if (file->private_data == NULL)
+		return -ENOMEM;
+	MOD_INC_USE_COUNT;
 	return 0;
 }
 
-#ifndef MODULE
-/*-----------------------------------------------------------------*/
-/* Process iucv=userid1,...,useridn kernel parameter.              */
-/*                                                                 */
-/* Each user id provided will be associated with device 'iucvnn'.  */
-/* iucv_init will be called to initialize each device.             */
-/*-----------------------------------------------------------------*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
-#define init_return(a) return a
-static int __init
-iucv_setup (char *iucv)
+static int
+netiucv_stat_close(struct inode *inode, struct file *file)
+{
+	kfree(file->private_data);
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static ssize_t
+netiucv_stat_write(struct file *file, const char *buf, size_t count, loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	net_device *dev;
+	netiucv_priv *privptr;
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	privptr = (netiucv_priv *)dev->priv;
+	privptr->conn->prof.maxmulti = 0;
+	privptr->conn->prof.maxcqueue = 0;
+	privptr->conn->prof.doios_single = 0;
+	privptr->conn->prof.doios_multi = 0;
+	privptr->conn->prof.txlen = 0;
+	privptr->conn->prof.tx_time = 0;
+	return count;
+}
+
+static ssize_t
+netiucv_stat_read(struct file *file, char *buf, size_t count, loff_t *off)
+{
+	unsigned int ino = ((struct inode *)file->f_dentry->d_inode)->i_ino;
+	char *sbuf = (char *)file->private_data;
+	net_device *dev;
+	netiucv_priv *privptr;
+	ssize_t ret = 0;
+	char *p = sbuf;
+	int l;
+
+	if (!(dev = find_netdev_by_ino(ino)))
+		return -ENODEV;
+	if (off != &file->f_pos)
+		return -ESPIPE;
+
+	privptr = (netiucv_priv *)dev->priv;
+
+	if (file->f_pos == 0) {
+		p += sprintf(p, "Device FSM state: %s\n",
+			     fsm_getstate_str(privptr->fsm));
+		p += sprintf(p, "RX channel FSM state: %s\n",
+			     fsm_getstate_str(privptr->conn->fsm));
+		p += sprintf(p, "TX channel FSM state: %s\n",
+			     fsm_getstate_str(privptr->conn->fsm));
+		p += sprintf(p, "Max. TX buffer used: %ld\n",
+			     privptr->conn->prof.maxmulti);
+		p += sprintf(p, "Max. chained SKBs: %ld\n",
+			     privptr->conn->prof.maxcqueue);
+		p += sprintf(p, "TX single write ops: %ld\n",
+			     privptr->conn->prof.doios_single);
+		p += sprintf(p, "TX multi write ops: %ld\n",
+			     privptr->conn->prof.doios_multi);
+		p += sprintf(p, "Netto bytes written: %ld\n",
+			     privptr->conn->prof.txlen);
+		p += sprintf(p, "Max. TX IO-time: %ld\n",
+			     privptr->conn->prof.tx_time);
+	}
+	l = strlen(sbuf);
+	p = sbuf;
+	if (file->f_pos < l) {
+		p += file->f_pos;
+		l = strlen(p);
+		ret = (count > l) ? l : count;
+		if (copy_to_user(buf, p, ret))
+			return -EFAULT;
+	}
+	file->f_pos += ret;
+	return ret;
+}
+
+static struct file_operations netiucv_stat_fops = {
+	read:    netiucv_stat_read,
+	write:   netiucv_stat_write,
+	open:    netiucv_stat_open,
+	release: netiucv_stat_close,
+};
+
+static struct file_operations netiucv_buffer_fops = {
+	read:    netiucv_buffer_read,
+	write:   netiucv_buffer_write,
+	open:    netiucv_buffer_open,
+	release: netiucv_buffer_close,
+};
+
+static struct file_operations netiucv_user_fops = {
+	read:    netiucv_user_read,
+	write:   netiucv_user_write,
+	open:    netiucv_user_open,
+	release: netiucv_user_close,
+};
+
+static struct inode_operations netiucv_stat_iops = {
+#if LINUX_VERSION_CODE < 0x020363
+	default_file_ops: &netiucv_stat_fops
+#endif
+};
+static struct inode_operations netiucv_buffer_iops = {
+#if LINUX_VERSION_CODE < 0x020363
+	default_file_ops: &netiucv_buffer_fops
+#endif
+};
+
+static struct inode_operations netiucv_user_iops = {
+#if LINUX_VERSION_CODE < 0x020363
+	default_file_ops: &netiucv_user_fops
+#endif
+};
+
+static struct proc_dir_entry stat_entry = {
+	0,                           /* low_ino */
+	10,                          /* namelen */
+	"statistics",                /* name    */
+	S_IFREG | S_IRUGO | S_IWUSR, /* mode    */
+	1,                           /* nlink   */
+	0,                           /* uid     */
+	0,                           /* gid     */
+	0,                           /* size    */
+	&netiucv_stat_iops           /* ops     */
+};
+
+static struct proc_dir_entry buffer_entry = {
+	0,                           /* low_ino */
+	10,                          /* namelen */
+	"buffersize",                /* name    */
+	S_IFREG | S_IRUSR | S_IWUSR, /* mode    */
+	1,                           /* nlink   */
+	0,                           /* uid     */
+	0,                           /* gid     */
+	0,                           /* size    */
+	&netiucv_buffer_iops         /* ops     */
+};
+
+static struct proc_dir_entry user_entry = {
+	0,                           /* low_ino */
+	8,                           /* namelen */
+	"username",                  /* name    */
+	S_IFREG | S_IRUSR | S_IWUSR, /* mode    */
+	1,                           /* nlink   */
+	0,                           /* uid     */
+	0,                           /* gid     */
+	0,                           /* size    */
+	&netiucv_user_iops           /* ops     */
+};
+
+#if LINUX_VERSION_CODE < 0x020363
+static struct proc_dir_entry netiucv_dir = {
+	0,                           /* low_ino  */
+	4,                           /* namelen  */
+	"iucv",                      /* name     */
+	S_IFDIR | S_IRUGO | S_IXUGO, /* mode     */
+	2,                           /* nlink    */
+	0,                           /* uid      */
+	0,                           /* gid      */
+	0,                           /* size     */
+	0,                           /* ops      */
+	0,                           /* get_info */
+	netiucv_fill_inode           /* fill_ino (for locking) */
+};
+
+static struct proc_dir_entry netiucv_template =
+{
+	0,                           /* low_ino  */
+	0,                           /* namelen  */
+	"",                          /* name     */
+	S_IFDIR | S_IRUGO | S_IXUGO, /* mode     */
+	2,                           /* nlink    */
+	0,                           /* uid      */
+	0,                           /* gid      */
+	0,                           /* size     */
+	0,                           /* ops      */
+	0,                           /* get_info */
+	netiucv_fill_inode           /* fill_ino (for locking) */
+};
 #else
-#define init_return(a) return
-__initfunc (void iucv_setup (char *iucv, int *ints))
+static struct proc_dir_entry *netiucv_dir = NULL;
+static struct proc_dir_entry *netiucv_template = NULL;
 #endif
+
+/**
+ * Create the driver's main directory /proc/net/iucv
+ */
+static void
+netiucv_proc_create_main(void)
+{
+	/**
+	 * If not registered, register main proc dir-entry now
+	 */
+#if LINUX_VERSION_CODE > 0x020362
+	if (!netiucv_dir)
+		netiucv_dir = proc_mkdir("iucv", proc_net);
+#else
+	if (netiucv_dir.low_ino == 0)
+		proc_net_register(&netiucv_dir);
+#endif
+}
+
+#ifdef MODULE
+/**
+ * Destroy /proc/net/iucv
+ */
+static void
+netiucv_proc_destroy_main(void)
 {
-	int i, devnumber;
-	char *s;
-	char temp_userid[9];
+#if LINUX_VERSION_CODE > 0x020362
+	remove_proc_entry("iucv", proc_net);
+#else
+	proc_net_unregister(netiucv_dir.low_ino);
+#endif
+}
+#endif MODULE
 
-	i = devnumber = 0;
-	memset (temp_userid, ' ', 8);
-	temp_userid[8] = '\0';
+/**
+ * Create a device specific subdirectory in /proc/net/iucv/ with the
+ * same name like the device. In that directory, create 3 entries
+ * "statistics", "buffersize" and "username".
+ *
+ * @param dev The device for which the subdirectory should be created.
+ *
+ */
+static void
+netiucv_proc_create_sub(net_device *dev) {
+	netiucv_priv *privptr = dev->priv;
 
-	if (!iucv)
-		init_return (0);
+#if LINUX_VERSION_CODE > 0x020362
+	privptr->proc_dentry = proc_mkdir(dev->name, netiucv_dir);
+	privptr->proc_stat_entry =
+		create_proc_entry("statistics",
+				  S_IFREG | S_IRUSR | S_IWUSR,
+				  privptr->proc_dentry);
+	privptr->proc_stat_entry->proc_fops = &netiucv_stat_fops;
+	privptr->proc_stat_entry->proc_iops = &netiucv_stat_iops;
+	privptr->proc_buffer_entry =
+		create_proc_entry("buffersize",
+				  S_IFREG | S_IRUSR | S_IWUSR,
+				  privptr->proc_dentry);
+	privptr->proc_buffer_entry->proc_fops = &netiucv_buffer_fops;
+	privptr->proc_buffer_entry->proc_iops = &netiucv_buffer_iops;
+	privptr->proc_user_entry =
+		create_proc_entry("username",
+				  S_IFREG | S_IRUSR | S_IWUSR,
+				  privptr->proc_dentry);
+	privptr->proc_user_entry->proc_fops = &netiucv_user_fops;
+	privptr->proc_user_entry->proc_iops = &netiucv_user_iops;
+#else
+	privptr->proc_dentry->name = dev->name;
+	privptr->proc_dentry->namelen = strlen(dev->name);
+	proc_register(&netiucv_dir, privptr->proc_dentry);
+	proc_register(privptr->proc_dentry, privptr->proc_stat_entry);
+	proc_register(privptr->proc_dentry, privptr->proc_buffer_entry);
+	proc_register(privptr->proc_dentry, privptr->proc_user_entry);
+#endif
+	privptr->proc_registered = 1;
+}
 
-	for (s = iucv; *s != '\0'; s++) {
-		if (*s == ' ')	/* Compress out blanks */
-			continue;
 
-		if (devnumber >= MAX_DEVICES) {
-			printk (KERN_ERR "More than %i IUCV hosts specified\n",
-				MAX_DEVICES);
-			init_return (-ENODEV);
+/**
+ * Destroy a device specific subdirectory.
+ *
+ * @param privptr Pointer to device private data.
+ */
+static void
+netiucv_proc_destroy_sub(netiucv_priv *privptr) {
+	if (!privptr->proc_registered)
+		return;
+#if LINUX_VERSION_CODE > 0x020362
+	remove_proc_entry("statistics", privptr->proc_dentry);
+	remove_proc_entry("buffersize", privptr->proc_dentry);
+	remove_proc_entry("username", privptr->proc_dentry);
+	remove_proc_entry(privptr->proc_dentry->name, netiucv_dir);
+#else
+	proc_unregister(privptr->proc_dentry,
+			privptr->proc_stat_entry->low_ino);
+	proc_unregister(privptr->proc_dentry,
+			privptr->proc_buffer_entry->low_ino);
+	proc_unregister(privptr->proc_dentry,
+			privptr->proc_user_entry->low_ino);
+	proc_unregister(&netiucv_dir,
+			privptr->proc_dentry->low_ino);
+#endif
+	privptr->proc_registered = 0;
+}
+
+
+/**
+ * Allocate and initialize a new connection structure.
+ * Add it to the list of connections;
+ */
+static iucv_connection *
+netiucv_new_connection(net_device *dev, char *username)
+{
+	iucv_connection **clist = &connections;
+	iucv_connection *conn =
+		(iucv_connection *)kmalloc(sizeof(iucv_connection), GFP_KERNEL);
+	if (conn) {
+		memset(conn, 0, sizeof(iucv_connection));
+		skb_queue_head_init(&conn->collect_queue);
+		conn->max_buffsize = NETIUCV_BUFSIZE_DEFAULT;
+		conn->netdev = dev;
+
+		conn->rx_buff = alloc_skb(NETIUCV_BUFSIZE_DEFAULT, GFP_DMA);
+		if (!conn->rx_buff) {
+			kfree(conn);
+			return NULL;
 		}
+		conn->tx_buff = alloc_skb(NETIUCV_BUFSIZE_DEFAULT, GFP_DMA);
+		if (!conn->tx_buff) {
+			kfree_skb(conn->rx_buff);
+			kfree(conn);
+			return NULL;
+		}
+		conn->fsm = init_fsm("netiucvconn", conn_state_names,
+				     conn_event_names, NR_CONN_STATES,
+				     NR_CONN_EVENTS, conn_fsm, CONN_FSM_LEN,
+				     GFP_KERNEL);
+		if (!conn->fsm) {
+			kfree_skb(conn->tx_buff);
+			kfree_skb(conn->rx_buff);
+			kfree(conn);
+			return NULL;
+		}
+		fsm_settimer(conn->fsm, &conn->timer);
+		fsm_newstate(conn->fsm, CONN_STATE_INVALID);
 
-		if (*s != ',') {
-			temp_userid[i++] = *s;
+		if (username) {
+			memcpy(conn->userid, username, 9);
+			fsm_newstate(conn->fsm, CONN_STATE_STOPPED);
+		}
 
-			if (i == 8 || *(s + 1) == ',' || *(s + 1) == '\0') {
-				register_iucv_dev (devnumber, temp_userid);
-				devnumber++;
-				i = 0;
-				memset (temp_userid, ' ', 8);
-				if (*(s + 1) != '\0')
-					*(s + 1) = ' ';
+		conn->next = *clist;
+		*clist = conn;
+	}
+	return conn;
+}
+
+/**
+ * Release a connection structure and remove it from the
+ * list of connections.
+ */
+static void
+netiucv_remove_connection(iucv_connection *conn)
+{
+	iucv_connection **clist = &connections;
+
+	if (conn == NULL)
+		return;
+	while (*clist) {
+		if (*clist == conn) {
+			*clist = conn->next;
+			if (conn->handle != 0) {
+				iucv_unregister_program(conn->handle);
+				conn->handle = 0;
 			}
+			fsm_deltimer(&conn->timer);
+			kfree_fsm(conn->fsm);
+			kfree_skb(conn->rx_buff);
+			kfree_skb(conn->tx_buff);
+			return;
 		}
-	}			/* while */
-
-	init_return (1);
+		clist = &((*clist)->next);
+	}
 }
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
-__setup ("iucv=", iucv_setup);
+/**
+ * Allocate and initialize everything of a net device.
+ */
+static net_device *
+netiucv_init_netdevice(int ifno, char *username)
+{
+	netiucv_priv *privptr;
+	int          priv_size;
+
+	net_device *dev = kmalloc(sizeof(net_device)
+#if LINUX_VERSION_CODE < 0x020300
+		      + 11 /* name + zero */
 #endif
-#else				/* BUILT AS MODULE */
-/*-------------------------------------------------------------------*/
-/* Process iucv=userid1,...,useridn module paramter.                 */
-/*                                                                   */
-/* insmod passes the module an array of string pointers, each of     */
-/* which points to a userid.  The commas are stripped out by insmod. */
-/* MODULE_PARM defines the name of the array.  (See start of module.)*/
-/*                                                                   */
-/* Each user id provided will be associated with device 'iucvnn'.    */
-/* iucv_init will be called to initialize each device.               */
-/*-------------------------------------------------------------------*/
-char *iucv[MAX_DEVICES] = { NULL };
-int
-init_module (void)
-{
-	int i;
-	for (i = 0; i < MAX_DEVICES; i++) {
-		if (iucv[i] == NULL)
-			break;
-		register_iucv_dev (i, iucv[i]);
+		      , GFP_KERNEL);
+	if (!dev)
+		return NULL;
+	memset(dev, 0, sizeof(net_device));
+#if LINUX_VERSION_CODE < 0x020300
+	dev->name = (char *)dev + sizeof(net_device);
+#endif
+	sprintf(dev->name, "iucv%d", ifno);
+
+	priv_size = sizeof(netiucv_priv) + sizeof(netiucv_template) +
+		sizeof(stat_entry) + sizeof(buffer_entry) + sizeof(user_entry);
+	dev->priv = kmalloc(priv_size, GFP_KERNEL);
+	if (dev->priv == NULL) {
+		kfree(dev);
+		return NULL;
 	}
-	return 0;
+        memset(dev->priv, 0, priv_size);
+        privptr = (netiucv_priv *)dev->priv;
+        privptr->proc_dentry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(netiucv_priv));
+        privptr->proc_stat_entry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(netiucv_priv) +
+		 sizeof(netiucv_template));
+        privptr->proc_buffer_entry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(netiucv_priv) +
+		 sizeof(netiucv_template) + sizeof(stat_entry));
+        privptr->proc_user_entry = (struct proc_dir_entry *)
+		(((char *)privptr) + sizeof(netiucv_priv) +
+		 sizeof(netiucv_template) + sizeof(stat_entry) +
+		 sizeof(buffer_entry));
+	memcpy(privptr->proc_dentry, &netiucv_template,
+	       sizeof(netiucv_template));
+	memcpy(privptr->proc_stat_entry, &stat_entry, sizeof(stat_entry));
+	memcpy(privptr->proc_buffer_entry, &buffer_entry, sizeof(buffer_entry));
+	memcpy(privptr->proc_user_entry, &user_entry, sizeof(user_entry));
+	privptr->fsm = init_fsm("netiucvdev", dev_state_names,
+				dev_event_names, NR_DEV_STATES, NR_DEV_EVENTS,
+				dev_fsm, DEV_FSM_LEN, GFP_KERNEL);
+	if (privptr->fsm == NULL) {
+		kfree(privptr);
+		kfree(dev);
+		return NULL;
+	}
+	privptr->conn = netiucv_new_connection(dev, username);
+	if (!privptr->conn) {
+		kfree_fsm(privptr->fsm);
+		kfree(privptr);
+		kfree(dev);
+		return NULL;
+	}
+
+	fsm_newstate(privptr->fsm, DEV_STATE_STOPPED);
+	dev->mtu	         = NETIUCV_MTU_DEFAULT;
+	dev->hard_start_xmit     = netiucv_tx;
+	dev->open	         = netiucv_open;
+	dev->stop	         = netiucv_close;
+	dev->get_stats	         = netiucv_stats;
+	dev->change_mtu          = netiucv_change_mtu;
+	dev->hard_header_len     = NETIUCV_HDRLEN;
+	dev->addr_len            = 0;
+	dev->type                = ARPHRD_SLIP;
+	dev->tx_queue_len        = NETIUCV_QUEUELEN_DEFAULT;
+	SET_DEVICE_START(dev, 1);
+	dev_init_buffers(dev);
+	dev->flags	         = IFF_POINTOPOINT | IFF_NOARP;
+	return dev;
 }
 
-void
-cleanup_module (void)
+/**
+ * Allocate and initialize everything of a net device.
+ */
+static void
+netiucv_free_netdevice(net_device *dev)
 {
-	int i;
-	for (i = 0; i < MAX_DEVICES; i++) {
-		if (iucv[i])
-			unregister_netdev (&iucv_netdev[i]);
+	netiucv_priv *privptr;
+
+	if (!dev)
+		return;
+
+	privptr = (netiucv_priv *)dev->priv;
+	if (privptr) {
+		if (privptr->conn)
+			netiucv_remove_connection(privptr->conn);
+		if (privptr->fsm)
+			kfree_fsm(privptr->fsm);
+		netiucv_proc_destroy_sub(privptr);
+		kfree(privptr);
 	}
-	return;
+	kfree(dev);
 }
-#endif				/* MODULE */
 
-void
-register_iucv_dev (int devnumber, char *userid)
+static void
+netiucv_banner(void)
 {
-	int rc;
-	net_device *dev;
+	char vbuf[] = "$Revision: 1.12 $";
+	char *version = vbuf;
 
-	memset (iucv_userid[devnumber], ' ', 8);
-	memcpy (iucv_userid[devnumber], userid, min (strlen (userid), 8));
-	dev = &iucv_netdev[devnumber];
-	sprintf (dev->name, "iucv%i", devnumber);
-
-	pr_debug ("netiucv: registering %s\n", dev->name);
-
-	if ((rc = register_netdev (dev))) {
-		printk (KERN_ERR
-			"netiucv: register_netdev(%s) error %i\n",
-			dev->name, rc);
+	if ((version = strchr(version, ':'))) {
+		char *p = strchr(version + 1, '$');
+		if (p)
+			*p = '\0';
+	} else
+		version = " ??? ";
+	printk(KERN_INFO "NETIUCV driver Version%s initialized\n", version);
+}
+
+#ifndef MODULE
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
+#  define init_return(a) return a
+static int __init
+iucv_setup(char *param)
+# else
+#  define init_return(a) return
+__initfunc (void iucv_setup(char *param, int *ints))
+# endif
+{
+	/**
+	* We do not parse parameters here because at the time of
+	* calling iucv_setup(), the kernel does not yet have
+	* memory management running. We delay this until probing
+	* is called.
+	*/
+	iucv = param;
+	init_return(1);
+}
+
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0))
+__setup ("iucv=", iucv_setup);
+# endif
+#else
+static void
+netiucv_exit(void)
+{
+	while (connections) {
+		net_device *dev = connections->netdev;
+		unregister_netdev(dev);
+		netiucv_free_netdevice(dev);
 	}
+	netiucv_proc_destroy_main();
+
+	printk(KERN_INFO "NETIUCV driver unloaded\n");
 	return;
 }
+#endif
+
+static int
+netiucv_init(void)
+{
+	char *p = iucv;
+	int ifno = 0;
+	int i = 0;
+	char username[10];
+
+	netiucv_proc_create_main();
+	while (p) {
+		if (isalnum(*p)) {
+			username[i++] = *p++;
+			username[i] = '\0';
+			if (i > 8) {
+				printk(KERN_WARNING
+				       "netiucv: Invalid user name '%s'\n",
+				       username);
+				while (*p && (*p != ':') && (*p != ','))
+					p++;
+			}
+		} else {
+			if (*p && (*p != ':') && (*p != ',')) {
+				printk(KERN_WARNING
+				       "netiucv: Invalid delimiter '%c'\n",
+				       *p);
+				while (*p && (*p != ':') && (*p != ','))
+					p++;
+			} else {
+				if (i) {
+					net_device *dev;
+
+					while (i < 9)
+						username[i++] = ' ';
+					username[9] = '\0';
+					dev = netiucv_init_netdevice(ifno,
+								     username);
+					if (!dev)
+						printk(KERN_WARNING
+						       "netiucv: Could not allocate network device structure for user '%s'\n", netiucv_printname(username));
+					else {
+						if (register_netdev(dev)) {
+							printk(KERN_WARNING
+							       "netiucv: Could not register '%s'\n", dev->name);
+							netiucv_free_netdevice(dev);
+						} else {
+							printk(KERN_INFO "%s: '%s'\n", dev->name, netiucv_printname(username));
+							netiucv_proc_create_sub(dev);
+							ifno++;
+						}
+					}						
+				}
+				if (!(*p))
+					break;
+				i = 0;
+				p++;
+			}
+		}
+	}
+	netiucv_banner();
+	return 0;
+}
 
-/* These structures are static because setup() can be called very */
-/* early in kernel init if this module is built into the kernel.  */
-/* Certainly no kmalloc() is available, probably no C runtime.    */
-/* If support changed to be module only, this can all be done     */
-/* dynamically.                                                   */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-static char iucv_names[MAX_DEVICES][8];	/* Allows "iucvXXX" plus null */
-#endif
-net_device iucv_netdev[MAX_DEVICES] = {
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[0][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[1][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[2][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[3][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[4][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[5][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[6][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[7][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[8][0],  /* Name filled in at load time  */
-#endif
-		init: iucv_init 	  /* probe function               */
-	},
-	{
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0))
-		name: &iucv_names[9][0],  /* Name filled in at load time  */
+module_init(netiucv_init);
+#ifdef MODULE
+module_exit(netiucv_exit);
 #endif
-		init: iucv_init 	  /* probe function               */
-	},
-};
diff -urN linux/drivers/s390/s390dyn.c linux-2.4.7/drivers/s390/s390dyn.c
--- linux/drivers/s390/s390dyn.c	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/drivers/s390/s390dyn.c	Mon Dec 17 13:41:20 2001
@@ -112,32 +112,23 @@
                         if (ioinfo->ui.flags.dval != 1 ||
 		            ioinfo->devno != pdevreg->ci.devno)
 				continue;
-                } else if ((flag & DEVREG_TYPE_DEVCHARS) &&
-		           (flag & DEVREG_EXACT_MATCH)) {
-			if (pdevreg->ci.hc.ctype != sid->cu_type ||
-			    pdevreg->ci.hc.cmode != sid->cu_model ||
-			    pdevreg->ci.hc.dtype != sid->dev_type ||
-			    pdevreg->ci.hc.dmode != sid->dev_model)
-				continue;
 		} else if (flag & DEVREG_TYPE_DEVCHARS) {
-			if (!(flag & DEVREG_NO_CU_INFO) &&
-			    pdevreg->ci.hc.ctype != sid->cu_type)
+			if ( (flag & DEVREG_MATCH_CU_TYPE) &&
+			     pdevreg->ci.hc.ctype != sid->cu_type )
+				continue;
+			if ( (flag & DEVREG_MATCH_CU_MODEL) &&
+			     pdevreg->ci.hc.cmode != sid->cu_model )
+				continue;
+			if ( (flag & DEVREG_MATCH_DEV_TYPE) &&
+			     pdevreg->ci.hc.dtype != sid->dev_type )
+				continue;
+			if ( (flag & DEVREG_MATCH_DEV_MODEL) &&
+			     pdevreg->ci.hc.dmode != sid->dev_model )
 				continue;
-
-                        if (!(flag & DEVREG_NO_CU_INFO) &&
-			    !(flag & DEVREG_MATCH_CU_TYPE) &&
-                            pdevreg->ci.hc.cmode != sid->cu_model)
-                                continue;
-
-                        if (!(flag & DEVREG_NO_DEV_INFO) &&
-                            pdevreg->ci.hc.dtype != sid->dev_type)
-                                continue;
-
-                        if (!(flag & DEVREG_NO_DEV_INFO) &&
-                            !(flag & DEVREG_MATCH_DEV_TYPE) &&
-                            pdevreg->ci.hc.dmode != sid->dev_model)
-                                continue;
+		} else {
+			continue;
 		}
+		
 		return pdevreg;
 	}
 	return NULL;
diff -urN linux/drivers/s390/s390io.c linux-2.4.7/drivers/s390/s390io.c
--- linux/drivers/s390/s390io.c	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/drivers/s390/s390io.c	Mon Dec 17 13:43:29 2001
@@ -1,12 +1,13 @@
 /*
- *  arch/s390/kernel/s390io.c
+ *  drivers/s390/s390io.c
  *   S/390 common I/O routines
  *
  *  S390 version
  *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH,
  *                             IBM Corporation
  *    Author(s): Ingo Adlung (adlung@de.ibm.com)
- *    ChangeLog: 01/04/2001 Holger Smolinski (smolinsk@de.ibm.com)
+ *    ChangeLog: 01/07/2001 Blacklist cleanup (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
+ *               01/04/2001 Holger Smolinski (smolinsk@de.ibm.com)
  *                          Fixed lost interrupts and do_adapter_IO
  *               xx/xx/xxxx nnn          multiple changes not reflected
  *               03/12/2001 Ingo Adlung  blacklist= - changed to cio_ignore=  
@@ -15,6 +16,14 @@
  *                                       decrease retry2 on busy while 
  *                                        disabling sync_isc; reset isc_cnt
  *                                        on io error during sync_isc enablement
+ *               05/09/2001 Cornelia Huck added exploitation of debug feature
+ *               05/16/2001 Cornelia Huck added /proc/deviceinfo/<devno>/
+ *               05/22/2001 Cornelia Huck added /proc/cio_ignore
+ *                                        un-ignore blacklisted devices by piping 
+ *                                        to /proc/cio_ignore
+ *               xx/xx/xxxx some bugfixes & cleanups
+ *               08/02/2001 Cornelia Huck not already known devices can be blacklisted
+ *                                        by piping to /proc/cio_ignore
  */
 
 #include <linux/module.h>
@@ -24,7 +33,7 @@
 #include <linux/signal.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/smp.h>
 #include <linux/threads.h>
@@ -45,16 +54,26 @@
 #include <asm/lowcore.h>
 #include <asm/idals.h>
 #include <asm/uaccess.h> 
+#include <asm/cpcmd.h>
 
 #include <asm/s390io.h>
 #include <asm/s390dyn.h>
 #include <asm/s390mach.h>
+#include <asm/debug.h>
+#include <asm/queue.h>
 
 #ifndef TRUE
 #define TRUE  1
 #define FALSE 0
 #endif
 
+#define SANITY_CHECK(irq) do { \
+if (irq > highest_subchannel || irq < 0) \
+		return (-ENODEV); \
+	if (ioinfo[irq] == INVALID_STORAGE_AREA) \
+		return (-ENODEV); \
+	} while(0) 
+
 #undef  CONFIG_DEBUG_IO
 #define CONFIG_DEBUG_CRW
 
@@ -79,10 +98,19 @@
 static __u64      irq_IPL_TOD;
 static adapter_int_handler_t adapter_handler   = NULL;
 
+/* for use of debug feature */
+debug_info_t *cio_debug_msg_id = NULL;  
+debug_info_t *cio_debug_trace_id = NULL;
+debug_info_t *cio_debug_crw_id = NULL;
+int cio_debug_initialized = 0;
+
 static void init_IRQ_handler( int irq, void *dev_id, struct pt_regs *regs);
 static void s390_process_subchannels( void);
 static void s390_device_recognition_all( void);
 static void s390_device_recognition_irq( int irq);
+#ifdef CONFIG_PROC_FS
+static void s390_redo_validation(void);
+#endif
 static int  s390_validate_subchannel( int irq, int enable);
 static int  s390_SenseID( int irq, senseid_t *sid, __u8 lpm);
 static int  s390_SetPGID( int irq, __u8 lpm, pgid_t *pgid);
@@ -91,7 +119,9 @@
 static int  enable_subchannel( unsigned int irq);
 static int  disable_subchannel( unsigned int irq);
 
-void chan_proc_init( void );
+#ifdef CONFIG_PROC_FS
+static int chan_proc_init( void );
+#endif 
 
 static inline void do_adapter_IO( __u32 intparm );
 
@@ -105,6 +135,23 @@
 
 asmlinkage void do_IRQ( struct pt_regs regs );
 
+#ifdef CONFIG_PROC_FS
+#define MAX_CIO_PROCFS_ENTRIES 0x300
+/* magic number; we want to have some room to spare */
+
+int cio_procfs_device_create(int devno);
+int cio_procfs_device_remove(int devno);
+int cio_procfs_device_purge(void);
+#endif
+
+int cio_notoper_msg = 1;
+#ifdef CONFIG_PROC_FS
+int cio_proc_devinfo = 0; /* switch off the /proc/deviceinfo/ stuff by default
+			     until problems are dealt with */
+#endif
+
+unsigned long s390_irq_count[NR_CPUS]; /* trace how many irqs have occured per cpu... */
+int cio_count_irqs = 1;       /* toggle use here... */
 
 /* 
  * "Blacklisting" of certain devices:
@@ -116,109 +163,84 @@
  */
 
 typedef struct dev_blacklist_range_t {
+     struct dev_blacklist_range_t *next;  /* next range in list */
      unsigned int from;                   /* beginning of range */
      unsigned int to;                     /* end of range */
-     struct dev_blacklist_range_t *next;  /* next range in list */
+     int  kmalloced;	
+    
 } dev_blacklist_range_t;
 
 static dev_blacklist_range_t *dev_blacklist_range_head = NULL; /* Anchor for list of ranges */
+static dev_blacklist_range_t *dev_blacklist_unused_head = NULL;
+
 static spinlock_t blacklist_lock = SPIN_LOCK_UNLOCKED;
+static int nr_blacklisted_ranges = 0;
 
 /* Handling of the blacklist ranges */
 
-/* 
- * Function: blacklist_range_create
- * Creates a range from the given parameters
- */
-static inline dev_blacklist_range_t *blacklist_range_create( int from, int to)
-{
-     dev_blacklist_range_t *range = NULL;
-     range = ( dev_blacklist_range_t *) alloc_bootmem( sizeof( dev_blacklist_range_t ) );
-     if (range == NULL)
-	  return NULL;
-     memset( range, 0, sizeof( dev_blacklist_range_t ));
-     range->from = from;
-     if (to == 0) {           /* only a single device is given */
-	  range->to = from;
-     } else {
-	  range->to = to;
-     }
-     return range;
-}
-
-/* 
- * Function: blacklist_range_destroy
- * Free the given range
- */
-
-static inline void blacklist_range_destroy( dev_blacklist_range_t *range )
-{
-     kfree( range );
-}
-
-/*
- * Function: blacklist_range_append
- * Append a range to the list of blacklisted ranges anchored at dev_blacklist_range_head
- */
-
-static inline void blacklist_range_append( dev_blacklist_range_t *range )
+static inline void blacklist_range_destroy( dev_blacklist_range_t *range,int locked )
 {
-     dev_blacklist_range_t *temp;
-     long flags;
-
-     spin_lock_irqsave( &blacklist_lock, flags );
-     if (dev_blacklist_range_head == NULL) {
-	  dev_blacklist_range_head = range;
-     } else {
-	  for ( temp = dev_blacklist_range_head;
-		temp && temp->next;
-		temp = temp->next );
-	  temp->next = range;
-     }
-     spin_unlock_irqrestore( &blacklist_lock, flags );
+	 long flags;
+	 
+	 if(!locked)
+		 spin_lock_irqsave( &blacklist_lock, flags ); 
+	 if(!remove_from_list((list **)&dev_blacklist_range_head,(list *)range))
+		 BUG();
+	 nr_blacklisted_ranges--;
+	 if(range->kmalloced)
+		 kfree(range);
+	 else
+		 add_to_list((list **)&dev_blacklist_unused_head,(list *)range); 
+	 if(!locked)
+		 spin_unlock_irqrestore( &blacklist_lock, flags );
 }
 
-/*
- * Function: blacklist_range_dechain
- * Remove a range from the list of blacklisted ranges
- */
 
-static inline void blacklist_range_dechain( dev_blacklist_range_t *range )
-{
-     dev_blacklist_range_t *temp, *prev = NULL;
-     long flags;
-     
-     spin_lock_irqsave( &blacklist_lock, flags );
-     for ( temp = dev_blacklist_range_head; temp != NULL; temp = temp->next ) {
-	  if ( temp == range )
-	       break;
-	  prev = temp;
-     }
-     if (!temp)
-	  BUG();
-     if (prev) {
-	  prev->next = range->next;
-     } else {
-	  dev_blacklist_range_head = range->next;
-     }
-     spin_unlock_irqrestore( &blacklist_lock, flags );
-}
 
 /* 
  * Function: blacklist_range_add
  * Creates a range from the specified arguments and appends it to the list of
- * blacklisted devices 
+ * blacklisted devices
  */
 
-static inline dev_blacklist_range_t *blacklist_range_add( int from, int to )
+static inline dev_blacklist_range_t *blacklist_range_add( int from, int to,int locked)
 {
-     dev_blacklist_range_t *temp;
+ 
+     dev_blacklist_range_t *range = NULL;
+     unsigned long flags;
 
-     temp = blacklist_range_create( from, to );
-     if (!temp) 
-	  return NULL;
-     blacklist_range_append( temp );
-     return temp;
+     if (to && (from>to)) {
+	     printk(KERN_WARNING "Invalid blacklist range %x to %x, skipping\n", from, to);
+	     return NULL;
+     }
+     if(!locked)
+	     spin_lock_irqsave( &blacklist_lock, flags );
+     if(dev_blacklist_unused_head)
+	     range=(dev_blacklist_range_t *)
+		     remove_listhead((list **)&dev_blacklist_unused_head);
+     else if (init_IRQ_complete) {
+	     if((range = ( dev_blacklist_range_t *) 
+		 kmalloc( sizeof( dev_blacklist_range_t ), GFP_KERNEL)))
+		     range->kmalloced=1;
+     } else {
+	     if((range = ( dev_blacklist_range_t *) 
+		 alloc_bootmem( sizeof( dev_blacklist_range_t ) )))
+		     range->kmalloced=0;
+     }
+     if (range)
+     {
+	     add_to_list((list **)&dev_blacklist_range_head,(list *)range);
+	     range->from = from;
+	     if (to == 0) {           /* only a single device is given */
+		     range->to = from;
+	     } else {
+		     range->to = to;
+	     }
+	     nr_blacklisted_ranges++;
+     }
+     if(!locked)
+	     spin_unlock_irqrestore( &blacklist_lock, flags );
+     return range;
 }
 
 /* 
@@ -229,12 +251,14 @@
 static inline void blacklist_range_remove( int from, int to )
 {
      dev_blacklist_range_t *temp;
+     long flags;
 
+     spin_lock_irqsave( &blacklist_lock, flags );
      for ( temp = dev_blacklist_range_head; 
 	   (temp->from != from) && (temp->to != to);
 	   temp = temp->next );
-     blacklist_range_dechain( temp );
-     blacklist_range_destroy( temp );
+     blacklist_range_destroy( temp,1 );
+     spin_unlock_irqrestore( &blacklist_lock, flags );
 }
 
 /* Parsing the commandline for blacklist parameters */
@@ -322,7 +346,7 @@
 	       temp++;
 	       to = blacklist_strtoul( temp, &temp );
 	  }
-	  if (!blacklist_range_add( from, to )) {
+	  if (!blacklist_range_add( from, to,0 )) {
 	       printk( KERN_WARNING "Blacklisting range from %X to %X failed!\n", from, to);
 	  }
 #ifdef CONFIG_DEBUG_IO
@@ -342,6 +366,9 @@
 #ifdef CONFIG_DEBUG_IO     
      printk( "Reading blacklist...\n");
 #endif
+     if (cio_debug_initialized)
+	     debug_sprintf_event(cio_debug_msg_id, 6,
+				 "Reading blacklist\n");
      blacklist_split_parm_string( blacklist_parm_string );
      blacklist_parse( blacklist );
 }
@@ -366,6 +393,9 @@
 #ifdef CONFIG_DEBUG_IO
 	printk( "Reading blacklist parameters...\n" );
 #endif
+	if (cio_debug_initialized)
+		debug_sprintf_event(cio_debug_msg_id, 6,
+				    "Reading blacklist parameters\n");
         blacklist_setup(str,&dummy);
 	
 	blacklist_init(); /* Blacklist ranges must be ready when device recognition starts */
@@ -385,26 +415,191 @@
 static inline int is_blacklisted( int devno )
 {
      dev_blacklist_range_t *temp;
+     long flags;
+     int retval=0;
 
      if (dev_blacklist_range_head == NULL) {  
 	  /* no blacklist */
 	  return 0;
      }
 
+     spin_lock_irqsave( &blacklist_lock, flags ); 
      temp = dev_blacklist_range_head;
      while (temp) {
 	  if ((temp->from <= devno) && (temp->to >= devno)) {
-	       return 1;                      /* Deviceno is blacklisted */
+		  retval=1;                      /* Deviceno is blacklisted */
+		  break;
 	  }
 	  temp = temp->next;
      }
-     return 0;
+     spin_unlock_irqrestore( &blacklist_lock, flags );
+     return retval;
+}
+
+/*
+ * Function: blacklist_free_all_ranges
+ * set all blacklisted devices free...
+ */
+
+void blacklist_free_all_ranges(void) 
+{
+	dev_blacklist_range_t *tmp = dev_blacklist_range_head;
+	unsigned long flags;
+
+	spin_lock_irqsave( &blacklist_lock, flags ); 
+	while (tmp) {
+		blacklist_range_destroy(tmp,1);
+		tmp = dev_blacklist_range_head;
+	}
+	spin_unlock_irqrestore( &blacklist_lock, flags );
 }
 
+#ifdef CONFIG_PROC_FS
+/*
+ * Function: blacklist_parse_proc_parameters
+ * parse the stuff which is piped to /proc/cio_ignore
+ */
+void blacklist_parse_proc_parameters(char *buf)
+{
+	char *tmp;
+	int i;
+	char *end;
+	int len = -1;
+	char *param;
+	int from = 0;
+	int to = 0;
+	int changed = 0;
+	dev_blacklist_range_t *range, *temp;
+	long flags;
+	int err = 0;
+
+	tmp = buf;
+	if (strstr(tmp, "free ")) {
+		for (i=0; i<5; i++) {
+			tmp++;
+		}
+		if (strstr(tmp, "all")) {
+			blacklist_free_all_ranges();
+			s390_redo_validation();
+		} else {
+			while (tmp != NULL) {
+				end = strchr(tmp, ',');
+				if (end == NULL) {
+					len = strlen(tmp) + 1;
+				} else {
+					len = (long)end - (long) tmp + 1;
+					*end = '\0';
+					end++;
+				}
+				param =  (char*) kmalloc(len * sizeof(char) + 1, GFP_KERNEL);
+				strncpy(param, (const char *) tmp, len);
+				tmp = end;
+				from = blacklist_strtoul(param, &param);
+				if (*param == '-') {
+					param++;
+					to = blacklist_strtoul(param, &param);
+				} else {
+					to = from;
+				}
+				spin_lock_irqsave( &blacklist_lock, flags ); 
+				range = dev_blacklist_range_head;
+				while (range != NULL) {
+					temp = range->next;
+					if ((from <= range->from) && (to >= range->to)) {
+						blacklist_range_destroy(range,1);
+						changed = 1;
+					} else if ((from <= range->from) && (to>=range->from) && (to < range->to)) {
+						blacklist_range_add(to+1, range->to,1);
+						blacklist_range_destroy(range,1);
+						changed = 1;
+					} else if ((from > range->from) && (from<=range->to) && (to >= range->to)) {
+						blacklist_range_add(range->from, from-1,1);
+						blacklist_range_destroy(range,1);
+						changed = 1;
+					} else if ((from > range->from) && (to < range->to)) {
+						blacklist_range_add(range->from, from-1,1);
+						blacklist_range_add(to+1, range->to,1);
+						blacklist_range_destroy(range,1);
+						changed = 1;
+					}
+					range = temp;
+				}
+				spin_unlock_irqrestore( &blacklist_lock, flags );
+				kfree(param);
+			}
+			if (changed)
+				s390_redo_validation();
+		}
+	} else if (strstr(tmp, "add ")) {
+		for (i=0;i<4;i++){
+			tmp++;
+		}
+		while (tmp != NULL) {
+			end = strchr(tmp, ',');
+			if (end == NULL) {
+				len = strlen(tmp) + 1;
+			} else {
+				len = (long)end - (long) tmp + 1;
+				*end = '\0';
+				end++;
+			}
+			param =  (char*) kmalloc(len * sizeof(char) + 1, GFP_KERNEL);
+			strncpy(param, (const char *) tmp, len);
+			tmp = end;
+			from = blacklist_strtoul(param, &param);
+			if (*param == '-') {
+				param++;
+				to = blacklist_strtoul(param, &param);
+			} else {
+				to = from;
+			}
+			spin_lock_irqsave( &blacklist_lock, flags ); 
+			
+			/*
+			 * Don't allow for already known devices to be
+			 * blacklisted
+			 * The criterion is a bit dumb, devices which once were
+			 * there but are already gone are also caught...
+			 */
+			
+			err = 0;
+			for (i=0; i<=highest_subchannel; i++) {
+				if (ioinfo[i]!=INVALID_STORAGE_AREA) {
+					if (   (ioinfo[i]->schib.pmcw.dev >= from)
+					    && (ioinfo[i]->schib.pmcw.dev <= to)  ) {
+						printk(KERN_WARNING "cio_ignore: Won't blacklist "
+						       "already known devices, skipping range "
+						       "%x to %x\n", from, to);
+						err = 1;
+						break;
+					}
+				}
+			}
+
+			/*
+			 * Note: We allow for overlapping ranges here, 
+			 * since the user might specify overlapping ranges
+			 * and we walk through all ranges when freeing anyway.
+			 */
+
+			if (!err) 
+				blacklist_range_add(from, to, 1);
+			
+			spin_unlock_irqrestore( &blacklist_lock, flags );
+			kfree(param);
+		}
+
+	} else {
+		printk("cio_ignore: Parse error; try using 'free all|<devno-range>,<devno-range>,...'\n");
+		printk("or 'add <devno-range>,<devno-range>,...'\n");
+	}
+}
+#endif
 /* End of blacklist handling */
 
 
 void s390_displayhex(char *str,void *ptr,s32 cnt);
+void s390_displayhex2(char *str, void *ptr, s32 cnt, int level);
 
 void s390_displayhex(char *str,void *ptr,s32 cnt)
 {
@@ -425,6 +620,25 @@
 	}
 }
 
+void s390_displayhex2(char *str, void *ptr, s32 cnt, int level)
+{
+	s32 cnt1, cnt2, maxcnt2;
+	u32 *currptr = (__u32 *)ptr;
+	char buffer[cnt*12];
+
+	debug_sprintf_event(cio_debug_msg_id, level, "%s\n", str);
+
+	for (cnt1 = 0; cnt1<cnt; cnt1+=16) {
+		sprintf(buffer, "%08lX ", (unsigned long)currptr);
+		maxcnt2 = cnt - cnt1;
+		if (maxcnt2 > 16)
+			maxcnt2 = 16;
+		for (cnt2 = 0; cnt2 < maxcnt2; cnt2 += 4)
+			sprintf(buffer, "%08X ", *currptr++);
+	}
+	debug_sprintf_event(cio_debug_msg_id, level, "%s\n",buffer);
+}
+
 static int __init cio_setup( char *parm )
 {
 	if ( !strcmp( parm, "yes") )
@@ -446,6 +660,37 @@
 
 __setup("cio_msg=", cio_setup);
 
+static int __init cio_notoper_setup(char *parm)
+{
+	if (!strcmp(parm, "yes")) {
+		cio_notoper_msg = 1;
+	} else if (!strcmp(parm, "no")) {
+		cio_notoper_msg = 0;
+	} else {
+		printk("cio_notoper_setup: invalid cio_notoper_msg parameter '%s'", parm);
+	}
+
+	return 1;
+}
+	
+__setup("cio_notoper_msg=", cio_notoper_setup);
+
+#ifdef CONFIG_PROC_FS
+static int __init cio_proc_devinfo_setup(char *parm)
+{
+	if (!strcmp(parm, "yes")) {
+		cio_proc_devinfo = 1;
+	} else if (!strcmp(parm, "no")) {
+		cio_proc_devinfo = 0;
+	} else {
+		printk("cio_proc_devinfo_setup: invalid parameter '%s'\n",parm);
+	}
+
+	return 1;
+}
+
+__setup("cio_proc_devinfo=", cio_proc_devinfo_setup);
+#endif
 
 /*
  * register for adapter interrupts
@@ -461,6 +706,9 @@
 int  s390_register_adapter_interrupt( adapter_int_handler_t handler )
 {
 	int ret = 0;
+	
+	if (cio_debug_initialized)
+		debug_text_event(cio_debug_trace_id, 4, "rgaint");
 
 	spin_lock( &adapter_lock );
 
@@ -480,6 +728,9 @@
 int  s390_unregister_adapter_interrupt( adapter_int_handler_t handler )
 {
 	int ret = 0;
+	
+	if (cio_debug_initialized)
+		debug_text_event(cio_debug_trace_id, 4, "urgaint");
 
 	spin_lock( &adapter_lock ); 	
 
@@ -497,6 +748,9 @@
 
 static inline void do_adapter_IO( __u32 intparm )
 {
+	if (cio_debug_initialized)
+		debug_text_event(cio_debug_trace_id, 4, "doaio");
+	
 	spin_lock( &adapter_lock ); 	
 
 	if ( adapter_handler )
@@ -507,7 +761,10 @@
 	return;  	
 }
 
-
+/*
+ * Note : internal use of irqflags SA_PROBE for NOT path grouping 
+ *
+ */
 int s390_request_irq_special( int                      irq,
                               io_handler_func_t        io_handler,
                               not_oper_handler_func_t  not_oper_handler,
@@ -517,6 +774,8 @@
 {
 	int		retval = 0;
 	unsigned long	flags;
+	char            dbf_txt[15];
+	int             retry;
 
 	if (irq >= __MAX_SUBCHANNELS)
 		return -EINVAL;
@@ -528,6 +787,12 @@
 		return -ENODEV;
 
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "reqsp");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	/*
 	 * The following block of code has to be executed atomically
 	 */
@@ -535,12 +800,28 @@
 
 	if ( !ioinfo[irq]->ui.flags.ready )
 	{
+		retry = 5;
+		
 		ioinfo[irq]->irq_desc.handler = io_handler;
 		ioinfo[irq]->irq_desc.name    = devname;
 		ioinfo[irq]->irq_desc.dev_id  = dev_id;
 		ioinfo[irq]->ui.flags.ready   = 1;
+		
+		
+		do {
+			retval = enable_subchannel(irq);
+			if (retval) {
+				ioinfo[irq]->ui.flags.ready = 0;
+				break;
+			}
+			
+			stsch(irq,&ioinfo[irq]->schib);
+			if (ioinfo[irq]->schib.pmcw.ena) 
+				retry = 0;
+			else
+				retry--;
 
-		enable_subchannel(irq);
+		} while (retry);
 	}
 	else
 	{
@@ -558,7 +839,8 @@
 
 	if ( retval == 0 )
 	{
-		s390_DevicePathVerification( irq, 0 );
+		if ( !(irqflags & SA_PROBE))
+			s390_DevicePathVerification( irq, 0 );
 
 		ioinfo[irq]->ui.flags.newreq = 1;
 		ioinfo[irq]->nopfunc         = not_oper_handler;  	
@@ -598,6 +880,7 @@
 	int          ret;
 
 	unsigned int count = 0;
+	char dbf_txt[15];
 
 	if ( irq >= __MAX_SUBCHANNELS || ioinfo[irq] == INVALID_STORAGE_AREA )
 	{
@@ -605,6 +888,12 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 2, "free");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 2, dbf_txt);
+	}
+
 	s390irq_spin_lock_irqsave( irq, flags);
 
 #ifdef  CONFIG_KERNEL_DEBUG
@@ -614,6 +903,8 @@
 
 	} /* endif */
 #endif
+	if (cio_debug_initialized)
+		debug_sprintf_event(cio_debug_msg_id, 2, "Trying to free IRQ %d\n", irq);
 
 	/*
 	 * disable the device and reset all IRQ info if
@@ -626,6 +917,15 @@
 			/* start deregister */
 			ioinfo[irq]->ui.flags.unready = 1;
 
+			/*
+			 * Try to stop IO first...
+			 * ... it seems disable_subchannel is sometimes
+			 * successfully called with IO still pending.
+			 */
+			halt_IO( irq,
+				 0xC8C1D3E3,
+				 DOIO_WAIT_FOR_INTERRUPT );
+
 			do
 			{
 				ret = disable_subchannel( irq);
@@ -676,19 +976,23 @@
 					} /* endif */
 
 					if ( count == 2 )
-               {
+					{
 						/* give it a very last try ... */
 						disable_subchannel( irq);
 
 						if ( ioinfo[irq]->ui.flags.busy )
-					   {
+					        {
 							printk( KERN_CRIT"free_irq(%04X) "
 							       "- device %04X busy, retry "
 							       "count exceeded\n",
-						   	    irq,
-						      	 ioinfo[irq]->devstat.devno);
+								irq,
+								ioinfo[irq]->devstat.devno);
+							if (cio_debug_initialized)
+								debug_sprintf_event(cio_debug_msg_id, 0,
+										    "free_irq(%04X) - device %04X busy, retry count exceeded\n",
+										    irq, ioinfo[irq]->devstat.devno);
 
-                  } /* endif */
+						} /* endif */
 						
 						break; /* sigh, let's give up ... */
 
@@ -710,7 +1014,10 @@
 			s390irq_spin_unlock_irqrestore( irq, flags);
 
 			printk( "free_irq(%04X) : error, "
-			        "dev_id does not match !", irq);
+			        "dev_id does not match !\n", irq);
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_msg_id, 0, 
+						    "free_irq(%04X) : error, dev_id does not match !\n", irq);
 
 		} /* endif */
 
@@ -721,6 +1028,9 @@
 
 		printk( "free_irq(%04X) : error, "
 		        "no action block ... !\n", irq);
+		if (cio_debug_initialized)
+			debug_sprintf_event(cio_debug_msg_id, 0,
+					    "free_irq(%04X) : error, no action block ... !\n", irq);
 
 	} /* endif */
 
@@ -733,13 +1043,19 @@
 {
 	unsigned long flags;
 	int           ret;
+	char dbf_txt[15];
 
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-		return( -ENODEV);
+	SANITY_CHECK(irq);
 
 	if ( !ioinfo[irq]->ui.flags.ready )
 		return -ENODEV;
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "disirq");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	s390irq_spin_lock_irqsave(irq, flags);
 	ret = disable_subchannel(irq);
 	s390irq_spin_unlock_irqrestore(irq, flags);
@@ -753,13 +1069,19 @@
 {
 	unsigned long flags;
 	int           ret;
+	char dbf_txt[15];
 
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-		return( -ENODEV);
+	SANITY_CHECK(irq);
 
 	if ( !ioinfo[irq]->ui.flags.ready )
 		return -ENODEV;
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "enirq");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	s390irq_spin_lock_irqsave(irq, flags);
 	ret = enable_subchannel(irq);
 	s390irq_spin_unlock_irqrestore(irq, flags);
@@ -772,18 +1094,18 @@
  */
 static int enable_subchannel( unsigned int irq)
 {
-	int   ret;
+	int   ret = 0;
 	int   ccode;
 	int   retry = 5;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		return( -ENODEV );
-
-	} /* endif */
+	SANITY_CHECK(irq);
 
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-		return( -ENODEV);
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 2, "ensch");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 2, dbf_txt);
+	}
 
 	/*
 	 * If a previous disable request is pending we reset it. However, this
@@ -821,19 +1143,12 @@
 				ccode = msch( irq, &(ioinfo[irq]->schib) );
 
 				switch (ccode) {
-				case 0:
+				case 0: /* ok */
 					ret = 0;
+					retry = 0;
 					break;
 
-				case 1:
-					/*
-					 * very bad, requires interrupt alike
-					 *  processing, where "rbh" is a dummy
-					 *  parameter for interface compatibility
-					 *  only. Bottom-half handling cannot be
-					 *  required as this must be an
-					 *  unsolicited interrupt (!busy).
-					 */
+				case 1: /* status pending */
 
 					ioinfo[irq]->ui.flags.s_pend = 1;
 					s390_process_IRQ( irq );
@@ -841,32 +1156,24 @@
 
 					ret = -EIO;    /* might be overwritten */
 					               /* ... on re-driving    */
-					               /* ... the msch() */
+					               /* ... the msch()       */
 					retry--;
 					break;
 
-				case 2:
+				case 2: /* busy */
 					udelay(100);	/* allow for recovery */
 					ret = -EBUSY;
 					retry--;
 					break;
 
-				case 3:
+				case 3: /* not oper */
 					ioinfo[irq]->ui.flags.oper = 0;
+					retry = 0;
 					ret = -ENODEV;
 					break;
-
-				default:
-					printk( KERN_CRIT"enable_subchannel(%04X) "
-					        " : ccode 2 on msch() for device "
-					        "%04X received !\n",
-					        irq,
-					        ioinfo[irq]->devstat.devno);
-
-					ret = -ENODEV; // never reached
 				}
 
-			} while ( (ccode == 1) && retry );
+			} while ( retry );
 
 		} /* endif */
 
@@ -882,18 +1189,13 @@
 static int disable_subchannel( unsigned int irq)
 {
 	int  cc;          /* condition code */
-	int  ret;         /* function return value */
+	int  ret = 0;     /* function return value */
 	int  retry = 5;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel )
-	{
-		ret = -ENODEV;
-	}
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-	}
-	else if ( ioinfo[irq]->ui.flags.busy )
+	SANITY_CHECK(irq);
+	
+	if ( ioinfo[irq]->ui.flags.busy )
 	{
 		/*
 		 * the disable function must not be called while there are
@@ -903,6 +1205,12 @@
 	}
 	else
 	{
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 2, "dissch");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 2, dbf_txt);
+		}
+		
 		/*
 		 * If device isn't operational we have to perform delayed
 		 *  disabling when the next interrupt occurs - unless the
@@ -926,19 +1234,12 @@
 				cc = msch( irq, &(ioinfo[irq]->schib) );
 
 				switch (cc) {
-				case 0 :
-					ret = 0;   /* done */
+				case 0: /* ok */
+					retry = 0;
+					ret = 0;   
 					break;
 
-				case 1 :
-					/*
-					 * very bad, requires interrupt alike
-  					 *  processing, where "rbh" is a dummy
-					 *  parm for interface compatibility
-					 *  only. Bottom-half handling cannot
-					 *  be required as this must be an
-					 *  unsolicited interrupt (!busy).
-					 */
+				case 1: /* status pending */
 					ioinfo[irq]->ui.flags.s_pend = 1;
 					s390_process_IRQ( irq );
 					ioinfo[irq]->ui.flags.s_pend = 0;
@@ -949,41 +1250,36 @@
 					retry--;
 					break;
 
-				case 2 :
-					/*
-					 * *** must not occur !              ***
-					 * ***                               ***
-					 * *** indicates our internal        ***
-					 * *** interrupt accounting is out   ***
-					 * ***  of sync ===> panic()         ***
-					 */
+				case 2: /* busy; this should not happen! */
 					printk( KERN_CRIT"disable_subchannel(%04X) "
 					        "- unexpected busy condition for "
-							  "device %04X received !\n",
+						"device %04X received !\n",
 					        irq,
 					        ioinfo[irq]->devstat.devno);
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 0, 
+								    "disable_subchannel(%04X) - unexpected busy condition for device %04X received !\n",
+								    irq, ioinfo[irq]->devstat.devno);
+					retry = 0;
 					ret = -EBUSY;
 					break;
 
-				case 3 :
+				case 3: /* not oper */
 					/*
 					 * should hardly occur ?!
 					 */
 					ioinfo[irq]->ui.flags.oper      = 0;
 					ioinfo[irq]->ui.flags.d_disable = 1;
+					retry = 0;
 
 					ret = 0; /* if the device has gone we */
 					         /* ... don't need to disable */
-					         /* ... it anymore !    */
-					break;
-
-				default :
-					ret = -ENODEV;  // never reached ...
+					         /* ... it anymore !          */
 					break;
 
 				} /* endswitch */
 
-			} while ( (cc == 1) && retry );
+			} while ( retry );
 
 		} /* endif */
 
@@ -998,14 +1294,6 @@
 	unsigned long flags;     /* PSW flags */
 	long          cr6 __attribute__ ((aligned (8)));
 
-	// Hopefully bh_count's will get set when we copy the prefix lowcore
-	// structure to other CPI's ( DJB )
-	softirq_active(smp_processor_id()) = 0;
-	softirq_mask(smp_processor_id()) = 0;
-	local_bh_count(smp_processor_id()) = 0;
-	local_irq_count(smp_processor_id()) = 0;
-	syscall_count(smp_processor_id()) = 0;
-
 	asm volatile ("STCK %0" : "=m" (irq_IPL_TOD));
 
 	p_init_schib = alloc_bootmem_low( sizeof(schib_t));
@@ -1032,6 +1320,12 @@
 
 	s390_process_subchannels();
 
+	if (cio_count_irqs) {
+		int i;
+		for (i=0; i<NR_CPUS; i++) 
+			s390_irq_count[i]=0;
+	}
+
 	/*
 	 * enable default I/O-interrupt sublass 3
 	 */
@@ -1065,6 +1359,10 @@
 {
 	int            ccode;
 	int            ret = 0;
+	char buffer[80];
+	char dbf_txt[15];
+
+	SANITY_CHECK(irq);
 
 	/*
 	 * The flag usage is mutal exclusive ...
@@ -1076,6 +1374,12 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "stIO");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	/*
 	 * setup ORB
 	 */
@@ -1367,18 +1671,17 @@
 			{
 				ret                         = -ENODEV;
 				ioinfo[irq]->ui.flags.oper  = 0;
-         }
+			}
 			else
 			{
 				ret = -EIO;
 
-         } /* endif */
+			} /* endif */
 
 			ioinfo[irq]->devstat.flag  |= DEVSTAT_NOT_OPER;
 
 #ifdef CONFIG_DEBUG_IO
 			{
-			char buffer[80];
 
 			stsch(irq, &(ioinfo[irq]->schib) );
 
@@ -1416,6 +1719,41 @@
 			} /* endif */
 			}
 #endif
+			if (cio_debug_initialized) {
+				stsch(irq, &(ioinfo[irq]->schib) );
+				
+				sprintf( buffer, "s390_start_IO(%04X) - irb for "
+					 "device %04X, after status pending\n",
+					 irq,
+					 ioinfo[irq]->devstat.devno );
+				
+				s390_displayhex2( buffer,
+						 &(ioinfo[irq]->devstat.ii.irb) ,
+						 sizeof(irb_t), 2);
+				
+				sprintf( buffer, "s390_start_IO(%04X) - schib for "
+					 "device %04X, after status pending\n",
+					 irq,
+					 ioinfo[irq]->devstat.devno );
+				
+				s390_displayhex2( buffer,
+						 &(ioinfo[irq]->schib) ,
+						 sizeof(schib_t), 2);
+				
+				
+				if (ioinfo[irq]->devstat.flag & DEVSTAT_FLAG_SENSE_AVAIL) {
+					sprintf( buffer, "s390_start_IO(%04X) - sense "
+						 "data for "
+						 "device %04X, after status pending\n",
+						 irq,
+						 ioinfo[irq]->devstat.devno );
+					
+					s390_displayhex2( buffer,
+							  ioinfo[irq]->irq_desc.dev_id->ii.sense.data,
+							  ioinfo[irq]->irq_desc.dev_id->rescnt, 2);
+					
+				} /* endif */
+			}
 		}
 		else
 		{
@@ -1457,9 +1795,8 @@
 		        &(ioinfo[irq]->devstat),
 		        sizeof( devstat_t) );
 
+
 #ifdef CONFIG_DEBUG_IO
-		{
-			char buffer[80];
 
    			stsch(irq, &(ioinfo[irq]->schib) );
 
@@ -1471,8 +1808,20 @@
 			s390_displayhex( buffer,
 			                 &(ioinfo[irq]->schib),
 			                 sizeof(schib_t));
-      	}
 #endif
+		if (cio_debug_initialized) {
+			stsch(irq, &(ioinfo[irq]->schib) );
+
+			sprintf( buffer, "s390_start_IO(%04X) - schib for "
+			         "device %04X, after 'not oper' status\n",
+			         irq,
+			         ioinfo[irq]->devstat.devno );
+
+			s390_displayhex2( buffer,
+			                 &(ioinfo[irq]->schib),
+			                 sizeof(schib_t), 2);
+		}
+			
 		break;
 
 	} /* endswitch */
@@ -1499,17 +1848,9 @@
            unsigned long  flag)         /* flags : see above */
 {
 	int ret = 0;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		return( -ENODEV );
-
-	} /* endif */
-
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-   }
+	SANITY_CHECK(irq);
 
 	/* handler registered ? or free_irq() in process already ? */
 	if ( !ioinfo[irq]->ui.flags.ready || ioinfo[irq]->ui.flags.unready )
@@ -1518,6 +1859,12 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "doIO");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	/*
 	 * Note: We ignore the device operational status - if not operational,
 	 *        the SSCH will lead to an -ENODEV condition ...
@@ -1538,7 +1885,7 @@
 		 *  but its intparm must be returned (see halt_IO() processing)
 		 */
 		if (     ioinfo[irq]->ui.flags.w4final
-           && !ioinfo[irq]->ui.flags.doio_q )
+		      && !ioinfo[irq]->ui.flags.doio_q )
 		{
 			ioinfo[irq]->qflag    = flag;
 			ioinfo[irq]->qcpa     = cpa;
@@ -1567,16 +1914,14 @@
 int resume_IO( int irq)
 {
 	int ret = 0;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		return( -ENODEV );
-
-	} /* endif */
+	SANITY_CHECK(irq);
 
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "resIO");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
 	}
 
 	/*
@@ -1635,21 +1980,14 @@
 {
 	int            ret;
 	int            ccode;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		ret = -ENODEV;
-	}
-
-	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-   }
+	SANITY_CHECK(irq);
 
 	/*
 	 * we only allow for halt_IO if the device has an I/O handler associated
 	 */
-	else if ( !ioinfo[irq]->ui.flags.ready )
+	if ( !ioinfo[irq]->ui.flags.ready )
 	{
 		ret = -ENODEV;
 	}
@@ -1661,6 +1999,7 @@
 	{
 		ret = 0;
 	}
+#if 0
 	/*
 	 * We don't allow for halt_io with a sync do_IO() requests pending.
 	 */
@@ -1669,8 +2008,14 @@
 	{
 		ret = -EBUSY;
 	}
+#endif
 	else
 	{
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 2, "haltIO");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 2, dbf_txt);
+		}
 		/*
 		 * If sync processing was requested we lock the sync ISC,
 		 *  modify the device to present interrupts for this ISC only
@@ -1818,7 +2163,7 @@
 			 * Let the common interrupt handler process the pending
 			 *  status. However, we must avoid calling the user
 			 *  action handler, as it won't be prepared to handle
-                        *  a pending status during do_IO() processing inline.
+			 *  a pending status during do_IO() processing inline.
 			 *  This also implies that s390_process_IRQ must
 			 *  terminate synchronously - especially if device
 			 *  sensing is required.
@@ -1893,13 +2238,11 @@
               unsigned long user_intparm,
               unsigned long flag)  /* possible DOIO_WAIT_FOR_INTERRUPT */
 {
-	int            ret;
+	int            ret = 0;
 	int            ccode;
+	char dbf_txt[15];
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		ret = -ENODEV;
-	}
+	SANITY_CHECK(irq);
 
 	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
 	{
@@ -1907,22 +2250,23 @@
    }
 
 	/*
-	 * we only allow for halt_IO if the device has an I/O handler associated
+	 * we only allow for clear_IO if the device has an I/O handler associated
 	 */
-	else if ( !ioinfo[irq]->ui.flags.ready )
+	if ( !ioinfo[irq]->ui.flags.ready )
 	{
 		ret = -ENODEV;
 	}
 	/*
-	 * we ignore the halt_io() request if ending_status was received but
+	 * we ignore the clear_io() request if ending_status was received but
 	 *  a SENSE operation is waiting for completion.
 	 */
 	else if ( ioinfo[irq]->ui.flags.w4sense )
 	{
 		ret = 0;
 	}
+#if 0
 	/*
-	 * We don't allow for halt_io with a sync do_IO() requests pending.
+	 * We don't allow for clear_io with a sync do_IO() requests pending.
 	 *  Concurrent I/O is possible in SMP environments only, but the
 	 *  sync. I/O request can be gated to one CPU at a time only.
 	 */
@@ -1930,8 +2274,14 @@
 	{
 		ret = -EBUSY;
 	}
+#endif
 	else
 	{
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 2, "clearIO");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 2, dbf_txt);
+		}
 		/*
 		 * If sync processing was requested we lock the sync ISC,
 		 *  modify the device to present interrupts for this ISC only
@@ -1951,7 +2301,7 @@
 		} /* endif */
 
 		/*
-		 * Issue "Halt subchannel" and process condition code
+		 * Issue "Clear subchannel" and process condition code
 		 */
 		ccode = csch( irq );
 
@@ -2032,7 +2382,7 @@
 					                    | _PSW_IO_WAIT;
 					break;
 				default:
-					panic( "halt_IO() : unexpected "
+					panic( "clear_IO() : unexpected "
 					       "address-space-control %d\n",
 					       ccode);
 					break;
@@ -2065,65 +2415,13 @@
 			ret = 0;
 			break;
 
-		case 1 :            /* status pending */
-	
-			ioinfo[irq]->devstat.flag |= DEVSTAT_STATUS_PENDING;
-
-			/*
-			 * initialize the device driver specific devstat irb area
-			 */
-			memset( &ioinfo[irq]->irq_desc.dev_id->ii.irb,
-			        '\0', sizeof( irb_t) );
-
-			/*
-			 * Let the common interrupt handler process the pending
-			 *  status. However, we must avoid calling the user
-			 *  action handler, as it won't be prepared to handle
-                        *  a pending status during do_IO() processing inline.
-			 *  This also implies that s390_process_IRQ must
-			 *  terminate synchronously - especially if device
-			 *  sensing is required.
-			 */
-			ioinfo[irq]->ui.flags.s_pend   = 1;
-			ioinfo[irq]->ui.flags.busy     = 1;
-			ioinfo[irq]->ui.flags.doio     = 1;
-
-			s390_process_IRQ( irq );
-			
-			ioinfo[irq]->ui.flags.s_pend   = 0;
-			ioinfo[irq]->ui.flags.busy     = 0;
-			ioinfo[irq]->ui.flags.doio     = 0;
-			ioinfo[irq]->ui.flags.repall   = 0;
-			ioinfo[irq]->ui.flags.w4final  = 0;
-
-			ioinfo[irq]->devstat.flag     |= DEVSTAT_FINAL_STATUS;
-
-			/*
-			 * In multipath mode a condition code 3 implies the last
-			 *  path has gone, except we have previously restricted
-			 *  the I/O to a particular path. A condition code 1
-			 *  (0 won't occur) results in return code EIO as well
-			 *  as 3 with another path than the one used (i.e. path available mask is non-zero).
-			 */
-			if ( ioinfo[irq]->devstat.ii.irb.scsw.cc == 3 )
-			{
-				ret                         = -ENODEV;
-				ioinfo[irq]->devstat.flag  |= DEVSTAT_NOT_OPER;
-				ioinfo[irq]->ui.flags.oper  = 0;
-			}
-			else
-			{
-				ret                         = -EIO;
-				ioinfo[irq]->devstat.flag  &= ~DEVSTAT_NOT_OPER;
-				ioinfo[irq]->ui.flags.oper  = 1;
-
-			} /* endif */
-
+		case 1 :            /* no status pending for csh */
+			BUG();
 			break;
 
-		case 2 :            /* busy */
 
-			ret = -EBUSY;
+		case 2 :            /* no busy for csh*/
+			BUG();
 			break;
 
 		default:            /* device not operational */
@@ -2172,7 +2470,6 @@
 		return;
 	} /* endif */
 
-	
 #ifdef CONFIG_FAST_IRQ
 	do {
 #endif /*  CONFIG_FAST_IRQ */
@@ -2244,7 +2541,6 @@
 	unsigned int           fctl;       /* function control */
 	unsigned int           stctl;      /* status   control */
 	unsigned int           actl;       /* activity control */
-	struct pt_regs         regs;       /* for interface compatibility only */
 
 	int               issense         = 0;
 	int               ending_status   = 0;
@@ -2252,11 +2548,23 @@
 	int               chnchk          = 0;
 	devstat_t        *dp;
 	devstat_t        *udp;
-#if 0
-	int               cpu             = smp_processor_id();
 
-	kstat.irqs[cpu][irq]++;
-#endif
+	char dbf_txt[15];
+	char buffer[80];
+
+
+	if (cio_count_irqs) {
+		int cpu = smp_processor_id();
+		s390_irq_count[cpu]++;
+	}
+	
+	
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 3, "procIRQ");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 3, dbf_txt);
+	}
 
 	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
 	{
@@ -2270,7 +2578,6 @@
 	udp = ioinfo[irq]->irq_desc.dev_id;
 	
 
-#ifdef CONFIG_DEBUG_IO
 	/*
 	 * It might be possible that a device was not-oper. at the time
 	 *  of free_irq() processing. This means the handler is no longer
@@ -2281,16 +2588,20 @@
 	{
 		if ( !ioinfo[irq]->ui.flags.d_disable )
 		{
+#ifdef CONFIG_DEBUG_IO
 			printk( KERN_CRIT"s390_process_IRQ(%04X) "
 			        "- no interrupt handler registered "
 					  "for device %04X !\n",
 			        irq,
 			        ioinfo[irq]->devstat.devno);
-
+#endif /* CONFIG_DEBUG_IO */
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_msg_id, 0,
+						    "s390_process_IRQ(%04X) - no interrupt handler registered for device %04X !\n",
+						    irq, ioinfo[irq]->devstat.devno);
 		} /* endif */
 
 	} /* endif */
-#endif
 
 	/*
 	 * retrieve the i/o interrupt information (irb),
@@ -2349,9 +2660,28 @@
 	 *  secondary status are presented with different interrupts.
 	 */
 	if ( dp->ii.irb.scsw.stctl
-	           & (   SCSW_STCTL_PRIM_STATUS | SCSW_STCTL_INTER_STATUS ) )
-	{
-		dp->rescnt = dp->ii.irb.scsw.count;
+	     & ( SCSW_STCTL_PRIM_STATUS | SCSW_STCTL_INTER_STATUS ) ) {
+
+		/*
+		 * If the subchannel status shows status pending
+		 * and we received a check condition, the count
+		 * information is not meaningful.
+		 */
+		
+		 if ( !(    (dp->ii.irb.scsw.stctl & SCSW_STCTL_STATUS_PEND) 
+			 && (   dp->ii.irb.scsw.cstat 
+			      & (   SCHN_STAT_CHN_DATA_CHK
+				  | SCHN_STAT_CHN_CTRL_CHK
+				  | SCHN_STAT_INTF_CTRL_CHK
+				  | SCHN_STAT_PROG_CHECK
+				  | SCHN_STAT_PROT_CHECK
+				  | SCHN_STAT_CHAIN_CHECK )))) {
+
+			 dp->rescnt = dp->ii.irb.scsw.count;
+		 } else {
+			 dp->rescnt = SENSE_MAX_COUNT;
+		 }
+
 		dp->cpa    = dp->ii.irb.scsw.cpa;
 
 #ifdef CONFIG_DEBUG_IO
@@ -2360,6 +2690,10 @@
 			        "residual count from irb after tsch() %d\n",
 			        irq, dp->rescnt );
 #endif
+		if (cio_debug_initialized)
+			debug_sprintf_event(cio_debug_msg_id, 6,
+					    "s390_process_IRQ( %04X ) : residual count from irq after tsch() %d\n",
+					    irq, dp->rescnt);
 
 	} /* endif */
 
@@ -2372,17 +2706,24 @@
 	if (    (dp->ii.irb.scsw.cstat
 	            & (  SCHN_STAT_CHN_DATA_CHK
 	               | SCHN_STAT_CHN_CTRL_CHK
-	               | SCHN_STAT_INTF_CTRL_CHK )       )
-	     && (irq != cons_dev                         ) )
+			 | SCHN_STAT_INTF_CTRL_CHK )))
 	{
-		printk( "Channel-Check or Interface-Control-Check "
-		        "received\n"
-		        " ... device %04X on subchannel %04X, dev_stat "
-		        ": %02X sch_stat : %02X\n",
-		        ioinfo[irq]->devstat.devno,
-		        irq,
-		        dp->dstat,
-		        dp->cstat);
+		if (irq != cons_dev)
+			printk( "Channel-Check or Interface-Control-Check "
+				"received\n"
+				" ... device %04X on subchannel %04X, dev_stat "
+				": %02X sch_stat : %02X\n",
+				ioinfo[irq]->devstat.devno,
+				irq,
+				dp->dstat,
+				dp->cstat);
+		if (cio_debug_initialized) {
+			debug_sprintf_event(cio_debug_msg_id, 0,
+					    "Channel-Check or Interface-Control-Check received\n");
+			debug_sprintf_event(cio_debug_msg_id, 0,
+					    "... device %04X on subchannel %04X, dev_stat: %02X sch_stat: %02X\n",
+					    ioinfo[irq]->devstat.devno, irq, dp->dstat, dp->cstat);
+		}
 
 		chnchk = 1;
 
@@ -2393,13 +2734,13 @@
 		issense=0;
 	}
 	else if (    (dp->ii.irb.scsw.stctl == SCSW_STCTL_STATUS_PEND)
-	     &&	(dp->ii.irb.scsw.eswf  == 0                     ))
+	          && (dp->ii.irb.scsw.eswf  == 0                     ))
 	{
 		issense = 0;
 	}
-	else if (    (dp->ii.irb.scsw.stctl ==
-	                (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_INTER_STATUS)) 
-	          && ((dp->ii.irb.scsw.actl & SCSW_ACTL_SUSPENDED) == 0))
+	else if (   (dp->ii.irb.scsw.stctl ==
+		      (SCSW_STCTL_STATUS_PEND | SCSW_STCTL_INTER_STATUS)) 
+		 && ((dp->ii.irb.scsw.actl & SCSW_ACTL_SUSPENDED) == 0)  )
 	{
 		issense = 0;
 	}
@@ -2422,6 +2763,10 @@
 			        "concurrent sense bytes avail %d\n",
 			        irq, dp->scnt );
 #endif
+		if (cio_debug_initialized)
+			debug_sprintf_event(cio_debug_msg_id, 4,
+					    "s390_process_IRQ( %04X ): concurrent sense bytes avail %d\n",
+					    irq, dp->scnt);
 	}
 	else
 	{
@@ -2443,8 +2788,6 @@
 
 		if ( chnchk )
 		{
-			char buffer[80];
-   	
 			sprintf( buffer, "s390_process_IRQ(%04X) - irb for "
 			         "device %04X after channel check\n",
 			         irq,
@@ -2453,14 +2796,24 @@
 			s390_displayhex( buffer,
 			                 &(dp->ii.irb) ,
 			                 sizeof(irb_t));
+			if (cio_debug_initialized) {
+				
+				sprintf( buffer, "s390_process_IRQ(%04X) - irb for "
+			         "device %04X after channel check\n",
+			         irq,
+			         dp->devno );
+
+				s390_displayhex2( buffer,
+						  &(dp->ii.irb) ,
+						  sizeof(irb_t), 0);
+			}
 		} /* endif */
 			
 		ioinfo[irq]->stctl |= stctl;
 
-		ending_status =    ( stctl & SCSW_STCTL_SEC_STATUS                          )
-			|| ( stctl == (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND)         )
-		   || ( (fctl == SCSW_FCTL_HALT_FUNC)  && (stctl == SCSW_STCTL_STATUS_PEND) )
-		   || ( (fctl == SCSW_FCTL_CLEAR_FUNC) && (stctl == SCSW_STCTL_STATUS_PEND) );
+		ending_status =    ( stctl & SCSW_STCTL_SEC_STATUS )
+			        || ( stctl == (SCSW_STCTL_ALERT_STATUS | SCSW_STCTL_STATUS_PEND) )
+			        || ( stctl == SCSW_STCTL_STATUS_PEND);
 
 		/*
 		 * Check for unsolicited interrupts - for debug purposes only
@@ -2473,20 +2826,18 @@
 		 *       unsolicited interrupt applies to the console device
 		 *       itself !
 		 */
+		if (    !( stctl & SCSW_STCTL_ALERT_STATUS )
+		     &&  ( ioinfo[irq]->ui.flags.busy == 0 ) )
+		{
 #ifdef CONFIG_DEBUG_IO
-		if (     ( irq != cons_dev                 )
-			 && !( stctl & SCSW_STCTL_ALERT_STATUS )
-			 &&  ( ioinfo[irq]->ui.flags.busy == 0  ) )
-		{
-			char buffer[80];
-
-			printk( "Unsolicited interrupt received for device %04X on subchannel %04X\n"
-				" ... device status : %02X subchannel status : %02X\n",
-				dp->devno,
-				irq,
-				dp->dstat,
-				dp->cstat);
-
+			if (irq != cons_dev)
+				printk( "Unsolicited interrupt received for device %04X on subchannel %04X\n"
+					" ... device status : %02X subchannel status : %02X\n",
+					dp->devno,
+					irq,
+					dp->dstat,
+					dp->cstat);
+			
 			sprintf( buffer, "s390_process_IRQ(%04X) - irb for "
 			         "device %04X, ending_status %d\n",
 			         irq,
@@ -2496,10 +2847,27 @@
 			s390_displayhex( buffer,
 			                 &(dp->ii.irb) ,
 			                 sizeof(irb_t));
-
+#endif
+			if (cio_debug_initialized) {
+				debug_sprintf_event(cio_debug_msg_id, 2, 
+						    "Unsolicited interrupt received for device %04X on subchannel %04X\n"
+						    " ... device status : %02X subchannel status : %02X\n",
+						    dp->devno,
+						    irq,
+						    dp->dstat,
+						    dp->cstat);
+				sprintf( buffer, "s390_process_IRQ(%04X) - irb for "
+					 "device %04X, ending_status %d\n",
+					 irq,
+					 dp->devno,
+					 ending_status);
+				
+				s390_displayhex2( buffer,
+						 &(dp->ii.irb) ,
+						 sizeof(irb_t), 2);	
+			}
 		} /* endif */
 
-#endif
 		/*
 		 * take fast exit if no handler is available
 		 */
@@ -2514,7 +2882,7 @@
 		 *       violates the ESA/390 architecture and doesn't present an
 		 *       operand exception for virtual devices without concurrent
 		 *       sense facility available/supported when enabling the
-       *       concurrent sense facility.
+		 *       concurrent sense facility.
 		 */
 		if (    (    (dp->ii.irb.scsw.dstat & DEV_STAT_UNIT_CHECK )
 		          && (!issense                                    ) )
@@ -2611,8 +2979,8 @@
 		if ( allow4handler )
 		{
 			allow4handler =    ending_status
-			   || ( ioinfo[irq]->ui.flags.repall                                      )
-			   || ( stctl & SCSW_STCTL_INTER_STATUS                                   )
+				|| ( ioinfo[irq]->ui.flags.repall                                      )
+				|| ( stctl & SCSW_STCTL_INTER_STATUS                                   )
 				|| ( (ioinfo[irq]->ui.flags.fast ) && (stctl & SCSW_STCTL_PRIM_STATUS) )
 				|| ( ioinfo[irq]->ui.flags.oper == 0                                   );
 
@@ -2639,11 +3007,15 @@
 				int sense_count = SENSE_MAX_COUNT-ioinfo[irq]->devstat.rescnt;
 
 #ifdef CONFIG_DEBUG_IO
-      if ( irq != cons_dev )
-         printk( "s390_process_IRQ( %04X ) : "
-                 "BASIC SENSE bytes avail %d\n",
-                 irq, sense_count );
-#endif
+				if ( irq != cons_dev )
+					printk( "s390_process_IRQ( %04X ) : "
+						"BASIC SENSE bytes avail %d\n",
+						irq, sense_count );
+#endif
+				if (cio_debug_initialized)
+					debug_sprintf_event(cio_debug_msg_id, 4,
+							    "s390_process_IRQ( %04X ): BASIC SENSE bytes avail %d\n",
+							    irq, sense_count);
 				ioinfo[irq]->ui.flags.w4sense = 0;
 				udp->flag |= DEVSTAT_FLAG_SENSE_AVAIL;
 				udp->scnt  = sense_count;
@@ -2656,15 +3028,10 @@
 				}
 				else
 				{
-#if 1
 					panic( "s390_process_IRQ(%04x) encountered "
 					       "negative sense count\n",
 					       irq);
-#else
-					printk( KERN_CRIT"s390_process_IRQ(%04x) encountered "
-					        "negative sense count\n",
-					        irq);
-#endif
+
 				} /* endif */
 			}
 			else
@@ -2673,7 +3040,7 @@
 
 			}  /* endif */
 
-      } /* endif */
+		} /* endif */
 
 		/*
 		 * for status pending situations other than deferred interrupt
@@ -2728,7 +3095,7 @@
 				dp->flag  |= DEVSTAT_FINAL_STATUS;
 				udp->flag |= DEVSTAT_FINAL_STATUS;
 
-				ioinfo[irq]->irq_desc.handler( irq, udp, &regs );
+				ioinfo[irq]->irq_desc.handler( irq, udp, NULL );
 
 				//
 				// reset intparm after final status or we will badly present unsolicited
@@ -2760,7 +3127,7 @@
 					 */
 					if ( ret )
 					{
-						ioinfo[irq]->irq_desc.handler( irq, udp, &regs );
+						ioinfo[irq]->irq_desc.handler( irq, udp, NULL );
 
 					} /* endif */
 
@@ -2788,7 +3155,7 @@
 
 				} /* endif */
 
-				ioinfo[irq]->irq_desc.handler( irq, udp, &regs );
+				ioinfo[irq]->irq_desc.handler( irq, udp, NULL );
 
 			} /* endif */
 
@@ -2871,7 +3238,7 @@
 
 		if ( !ioinfo[irq]->ui.flags.s_pend )
 		{
-			ioinfo[irq]->irq_desc.handler( irq, udp, &regs );
+			ioinfo[irq]->irq_desc.handler( irq, udp, NULL );
 
 		} /* endif */
 
@@ -2906,21 +3273,22 @@
 	int           ccode;
 	unsigned long cr6 __attribute__ ((aligned (8)));
 	int           rc = 0;
+	char dbf_txt[15];
+
+	SANITY_CHECK(irq);
 
 	if ( cons_dev != -1  )
 	{
 		rc = -EBUSY;
 	}
-	else if ( (irq > highest_subchannel) || (irq < 0) )
-	{
-		rc = -ENODEV;
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-   }
 	else
 	{
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 4, "scons");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+		}
+		
 		/*
 		 * modify the indicated console device to operate
 		 *  on special console interrupt sublass 7
@@ -2967,21 +3335,22 @@
 	int     rc = 0;
 	int     ccode;
 	long    cr6 __attribute__ ((aligned (8)));
+	char dbf_txt[15];
+
+	SANITY_CHECK(irq);
 
 	if ( cons_dev != -1  )
 	{
 		rc = -EBUSY;
 	}
-	else if ( (irq > highest_subchannel) || (irq < 0) )
-	{
-		rc = -ENODEV;
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-   }
 	else
 	{
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 4, "rcons");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+		}
+
 		/*
 		 * reset the indicated console device to operate
 		 *  on default console interrupt sublass 3
@@ -3028,10 +3397,17 @@
 {
 	int              rc = 0;
 	long             save_cr6;
+	char dbf_txt[15];
 
 	if ( irq == cons_dev )
 	{
 
+		if (cio_debug_initialized) {
+			debug_text_event(cio_debug_trace_id, 4, "wcons");
+			sprintf(dbf_txt, "%x", irq);
+			debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+		}
+
 		/*
 		 * before entering the spinlock we may already have
 		 *  processed the interrupt on a different CPU ...
@@ -3085,8 +3461,15 @@
 	int             ccode;
 	long            cr6 __attribute__ ((aligned (8)));
 
-	int             count = 0;
+	int             retry = 3;
 	int             rc    = 0;
+	char dbf_txt[15];
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "enisc");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
 
 	/* This one spins until it can get the sync_isc lock for irq# irq */
 
@@ -3120,48 +3503,44 @@
 					ccode = msch( irq,
 					              &(ioinfo[irq]->schib) );
 
-					if (ccode == 0 )
-					{
+					switch (ccode) {
+					case 0: 
 						/*
 						 * enable special isc
 						 */
-					__ctl_store( cr6, 6, 6);
-					cr6 |= 0x04000000;  // enable sync isc 5
-					cr6 &= 0xEFFFFFFF;  // disable standard isc 3
-					__ctl_load( cr6, 6, 6);
-					}
-					else if (ccode == 3)
-					{
-						rc = -ENODEV;  // very unlikely
-
-					}
-					else if (ccode == 2)
-					{
-						rc = -EBUSY; // device busy ...
-
-					}
-					else if (ccode == 1)
-					{
+						__ctl_store( cr6, 6, 6);
+						cr6 |= 0x04000000;  // enable sync isc 5
+						cr6 &= 0xEFFFFFFF;  // disable standard isc 3
+						__ctl_load( cr6, 6, 6);
+						retry = 0;
+						break;
+					
+					case 1:
 						//
 						// process pending status
 						//
 						ioinfo[irq]->ui.flags.s_pend = 1;
-
 						s390_process_IRQ( irq );
-
 						ioinfo[irq]->ui.flags.s_pend = 0;
+						
+						rc = -EIO;  /* might be overwritten... */
+						retry--;
+						break;
 
-						count++;
+					case 2: /* busy */
+						retry = 0;
+						rc = -EBUSY; 
+						break;
 
-					} /* endif */
+					case 3: /* not oper*/
+						retry = 0;
+						rc = -ENODEV; 
+						break;
+					
+					}
 
-				} while ( ccode == 1 && count < 3 );
+				} while ( retry );
 
-				if ( count == 3)
-				{
-					rc = -EIO;
-                       	
-				} /* endif */
 			}
 			else
 			{
@@ -3171,6 +3550,7 @@
 
 		} /* endif */
 
+
 		if ( rc )	/* can only happen if stsch/msch fails */
 		{
 			sync_isc_cnt = 0;
@@ -3200,6 +3580,14 @@
 	int     ccode;
 	long    cr6 __attribute__ ((aligned (8)));
 
+	char dbf_txt[15];
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "disisc");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	if ( irq <= highest_subchannel && ioinfo[irq] != INVALID_STORAGE_AREA )
 	{
 		/*
@@ -3224,6 +3612,7 @@
 
 			do
 			{
+			        retry2 = 5;
 				do
 				{
 					ccode = msch( irq, &(ioinfo[irq]->schib) );
@@ -3233,27 +3622,33 @@
 						/*
 						 * disable special interrupt subclass in CPU
 						 */
-				__ctl_store( cr6, 6, 6);
-				cr6 &= 0xFBFFFFFF; // disable sync isc 5
-				cr6 |= 0x10000000; // enable standard isc 3
-				__ctl_load( cr6, 6, 6);
+						__ctl_store( cr6, 6, 6);
+						cr6 &= 0xFBFFFFFF; // disable sync isc 5
+						cr6 |= 0x10000000; // enable standard isc 3
+						__ctl_load( cr6, 6, 6);
+
+						retry2 = 0;
 						break;
-					case 1:
+
+					case 1: /* status pending */
 						ioinfo[irq]->ui.flags.s_pend = 1;
 						s390_process_IRQ( irq );
 						ioinfo[irq]->ui.flags.s_pend = 0;
+
 						retry2--;
 						break;
-					case 2:
+
+					case 2: /* busy */
 					        retry2--;
 						udelay( 100); // give it time
 						break;
-					default:
+						
+					default: /* not oper */
 						retry2 = 0;
 						break;
 					} /* endswitch */
 
-				} while ( retry2 && (ccode != 0) );
+				} while ( retry2 );
 
 				retry1--;
 
@@ -3311,6 +3706,9 @@
 
 	int        error = 0;
 
+	if (cio_debug_initialized) 
+		debug_text_event(cio_debug_trace_id, 4, "VMvdinf");
+
 	if ( init_IRQ_complete )
 	{
 		p_diag_data = kmalloc( sizeof( diag210_t), GFP_DMA );
@@ -3596,6 +3994,19 @@
 			p_diag_data->vrdcrccl,
 			p_diag_data->vrdccrty,
 			p_diag_data->vrdccrmd );
+		if (cio_debug_initialized)
+			debug_sprintf_event( cio_debug_msg_id, 0,
+					     "DIAG X'210' for "
+					     "device %04X returned "
+					     "(cc = %d): vdev class : %02X, "
+					     "vdev type : %04X \n ...  rdev class : %02X, rdev type : %04X, rdev model: %02X\n",
+					     devno,
+					     ccode,
+					     p_diag_data->vrdcvcla,
+					     p_diag_data->vrdcvtyp,
+					     p_diag_data->vrdcrccl,
+					     p_diag_data->vrdccrty,
+					     p_diag_data->vrdccrmd );
 
 	} /* endif */
 
@@ -3630,27 +4041,21 @@
 	ccw1_t       *rdc_ccw;
 	devstat_t     devstat;
 	char         *rdc_buf;
-	int           devflag;
+	int           devflag = 0;
 
 	int           ret      = 0;
 	int           emulated = 0;
 	int           retry    = 5;
 
+	char dbf_txt[15];
+
 	if ( !buffer || !length )
 	{
 		return( -EINVAL );
 
 	} /* endif */
 
-	if ( (irq > highest_subchannel) || (irq < 0 ) )
-	{
-	return( -ENODEV );
-
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-   }
+	SANITY_CHECK(irq);
 
 	if ( ioinfo[irq]->ui.flags.oper == 0 )
 	{
@@ -3658,6 +4063,12 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "rddevch");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	/*
 	 * Before playing around with irq locks we should assure
 	 *   running disabled on (just) our CPU. Sync. I/O requests
@@ -3675,7 +4086,7 @@
 	{
 		ret = request_irq( irq,
 		                   init_IRQ_handler,
-		                   0, "RDC", &devstat );
+		                   SA_PROBE, "RDC", &devstat );
 
 		if ( !ret )
 		{
@@ -3708,22 +4119,27 @@
 				rdc_ccw->cmd_code = CCW_CMD_RDC;
 				rdc_ccw->count    = length;
 				rdc_ccw->flags    = CCW_FLAG_SLI;
-				set_normalized_cda( rdc_ccw, (unsigned long)rdc_buf );
+				ret = set_normalized_cda( rdc_ccw, (unsigned long)rdc_buf );
+				if (!ret) {
 
-				memset( ioinfo[irq]->irq_desc.dev_id,
-				        '\0',
-				        sizeof( devstat_t));
+					memset( ioinfo[irq]->irq_desc.dev_id,
+						'\0',
+						sizeof( devstat_t));
 
-				ret = s390_start_IO( irq,
-				                     rdc_ccw,
-				                     0x00524443, // RDC
-				                     0,          // n/a
-				                     DOIO_WAIT_FOR_INTERRUPT
-				                      | DOIO_DONT_CALL_INTHDLR );
-				retry--;
-				devflag = ioinfo[irq]->irq_desc.dev_id->flag;   
-    
-				clear_normalized_cda( rdc_ccw);  
+					ret = s390_start_IO( irq,
+							     rdc_ccw,
+							     0x00524443, // RDC
+							     0,          // n/a
+							     DOIO_WAIT_FOR_INTERRUPT
+							     | DOIO_DONT_CALL_INTHDLR );
+					retry--;
+					devflag = ioinfo[irq]->irq_desc.dev_id->flag;   
+					
+					clear_normalized_cda( rdc_ccw);  
+				} else {
+					udelay(100);  //wait for recovery
+					retry--;
+				}
 
 			} while (    ( retry                                     )
 			          && ( ret || (devflag & DEVSTAT_STATUS_PENDING) ) );
@@ -3732,7 +4148,7 @@
 
 		if ( !retry )
 		{
-			ret = -EBUSY;
+			ret = (ret==-ENOMEM)?-ENOMEM:-EBUSY;
 
 		} /* endif */
 
@@ -3769,15 +4185,11 @@
 	int           found  = 0; // RCD CIW found
 	int           ret    = 0; // return code
 
-	if ( (irq > highest_subchannel) || (irq < 0 ) )
-	{
-		return( -ENODEV );
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-	}
-	else if ( !buffer || !length )
+	char dbf_txt[15];
+
+	SANITY_CHECK(irq);
+
+	if ( !buffer || !length )
 	{
 		return( -EINVAL);
 	}
@@ -3791,6 +4203,12 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "rdconf");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	/*
 	 * scan for RCD command in extended SenseID data
 	 */
@@ -3808,11 +4226,11 @@
 
 			} /* endif */
 
-      	break;
+			break;
 
-      } /* endif */
+		} /* endif */
 
-   } /* endfor */
+	} /* endfor */
 
 	if ( found )
 	{
@@ -3833,7 +4251,7 @@
 			pdevstat = &devstat;
 			ret      = request_irq( irq,
 			                        init_IRQ_handler,
-			                        0, "RCD", pdevstat );
+			                        SA_PROBE, "RCD", pdevstat );
 
 			if ( !ret )
 			{
@@ -3899,30 +4317,29 @@
 					                     0x00524344,  // == RCD
 					                     lpm,
 					                     ioflags );
+					switch ( ret ) {
+					case 0:
+					case -EIO:
+						
+						if ( !(pdevstat->flag & (   DEVSTAT_STATUS_PENDING
+									    | DEVSTAT_NOT_OPER
+									    | DEVSTAT_FLAG_SENSE_AVAIL ) ) )
+						{
+							retry = 0;  // we got it ...
+						}
+						else
+						{
+							retry--;    // try again ...
+								
+						} /* endif */
+						
+						break;
 
-	            switch ( ret ) {
-   	         case 0    :
-      	      case -EIO :
-
-	               if ( !(pdevstat->flag & (   DEVSTAT_STATUS_PENDING
-   	                                      | DEVSTAT_NOT_OPER
-      	                                   | DEVSTAT_FLAG_SENSE_AVAIL ) ) )
-	               {
-   	               retry = 0;  // we got it ...
-      	         }
-         	      else
-            	   {
-               	   retry--;    // try again ...
-
-	               } /* endif */
-
-   	            break;
-
-	            default :   // -EBUSY, -ENODEV, ???
-   	            retry = 0;
-
-      	      } /* endswitch */
-
+					default:   // -EBUSY, -ENODEV, ???
+						retry = 0;
+						
+					} /* endswitch */
+					
 				} while ( retry );
 
 			} /* endif */
@@ -3981,31 +4398,16 @@
 
 static int __inline__ get_next_available_irq( ioinfo_t *pi)
 {
-	int ret_val;
+	int ret_val = -ENODEV;
 
-	while ( TRUE )
-	{
-		if ( pi->ui.flags.oper )
-		{
+	while ( pi!=NULL ) {
+		if ( pi->ui.flags.oper ) {
 			ret_val = pi->irq;
 			break;
-		}
-		else
-		{
+		} else {
 			pi = pi->next;
-
-			//
-			// leave at end of list unconditionally
-			//
-			if ( pi == NULL )
-			{
-				ret_val = -ENODEV;
-				break;
-			}
-
-		} /* endif */
-
-	} /* endwhile */
+		}
+	}
 
 	return ret_val;
 }
@@ -4077,54 +4479,44 @@
 int get_dev_info_by_irq( int irq, s390_dev_info_t *pdi)
 {
 
-	if ( irq > highest_subchannel || irq < 0 )
-	{
-		return -ENODEV;
-	}
-	else if ( pdi == NULL )
-	{
+	SANITY_CHECK(irq);
+
+	if ( pdi == NULL )
 		return -EINVAL;
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
+
+	pdi->devno = ioinfo[irq]->schib.pmcw.dev;
+	pdi->irq   = irq;
+	
+	if (   ioinfo[irq]->ui.flags.oper
+	    && !ioinfo[irq]->ui.flags.unknown ) 
 	{
-		return( -ENODEV);
+		pdi->status = 0;
+		memcpy( &(pdi->sid_data),
+			&ioinfo[irq]->senseid,
+			sizeof( senseid_t));
+	}
+	else if ( ioinfo[irq]->ui.flags.unknown )
+	{
+		pdi->status = DEVSTAT_UNKNOWN_DEV;
+		memset( &(pdi->sid_data),
+			'\0',
+			sizeof( senseid_t));
+		pdi->sid_data.cu_type = 0xFFFF;
+			
 	}
 	else
 	{
-		pdi->devno = ioinfo[irq]->schib.pmcw.dev;
-		pdi->irq   = irq;
-
-		if (     ioinfo[irq]->ui.flags.oper
-           && !ioinfo[irq]->ui.flags.unknown )
-		{
-			pdi->status = 0;
-			memcpy( &(pdi->sid_data),
-			        &ioinfo[irq]->senseid,
-			        sizeof( senseid_t));
-		}
-		else if ( ioinfo[irq]->ui.flags.unknown )
-		{
-			pdi->status = DEVSTAT_UNKNOWN_DEV;
-			memset( &(pdi->sid_data),
-			        '\0',
-			        sizeof( senseid_t));
-			pdi->sid_data.cu_type = 0xFFFF;
-
-		}
-		else
-		{
-			pdi->status = DEVSTAT_NOT_OPER;
-			memset( &(pdi->sid_data),
-			        '\0',
-			        sizeof( senseid_t));
-			pdi->sid_data.cu_type = 0xFFFF;
-
-		} /* endif */
-
-		if ( ioinfo[irq]->ui.flags.ready )
-			pdi->status |= DEVSTAT_DEVICE_OWNED;
-
+		pdi->status = DEVSTAT_NOT_OPER;
+		memset( &(pdi->sid_data),
+			'\0',
+			sizeof( senseid_t));
+		pdi->sid_data.cu_type = 0xFFFF;
+		
 	} /* endif */
+	
+	if ( ioinfo[irq]->ui.flags.ready )
+		pdi->status |= DEVSTAT_DEVICE_OWNED;
+
 
 	return 0;
 }
@@ -4136,70 +4528,60 @@
 	int rc = -ENODEV;
 
 	if ( devno > 0x0000ffff )
-	{
 		return -ENODEV;
-	}
-	else if ( pdi == NULL )
-	{
+        if ( pdi == NULL )
 		return -EINVAL;
-	}
-	else
-	{
 
-		for ( i=0; i <= highest_subchannel; i++ )
+	for ( i=0; i <= highest_subchannel; i++ ) {
+		
+		if (    ioinfo[i] != INVALID_STORAGE_AREA
+		     && ioinfo[i]->schib.pmcw.dev == devno )
 		{
-
-			if (    ioinfo[i] != INVALID_STORAGE_AREA
-			     && ioinfo[i]->schib.pmcw.dev == devno )
+			
+			pdi->irq   = i;
+			pdi->devno = devno;
+			
+			if (    ioinfo[i]->ui.flags.oper
+			     && !ioinfo[i]->ui.flags.unknown )
 			{
+				pdi->status = 0;
+				memcpy( &(pdi->sid_data),
+					&ioinfo[i]->senseid,
+					sizeof( senseid_t));
+			}
+			else if ( ioinfo[i]->ui.flags.unknown )
+			{
+				pdi->status = DEVSTAT_UNKNOWN_DEV;
 
-				pdi->irq   = i;
-				pdi->devno = devno;
-
-				if (    ioinfo[i]->ui.flags.oper
-                 && !ioinfo[i]->ui.flags.unknown )
-				{
-					pdi->status = 0;
-
-					memcpy( &(pdi->sid_data),
-					        &ioinfo[i]->senseid,
-					        sizeof( senseid_t));
-				}
-				else if ( ioinfo[i]->ui.flags.unknown )
-				{
-					pdi->status = DEVSTAT_UNKNOWN_DEV;
-
-					memset( &(pdi->sid_data),
-                       '\0',
-                       sizeof( senseid_t));
-
-					pdi->sid_data.cu_type = 0xFFFF;
-				}
-				else
-				{
-					pdi->status = DEVSTAT_NOT_OPER;
-	
-					memset( &(pdi->sid_data),
-                       '\0',
-                       sizeof( senseid_t));
+				memset( &(pdi->sid_data),
+					'\0',
+					sizeof( senseid_t));
 
-					pdi->sid_data.cu_type = 0xFFFF;
+				pdi->sid_data.cu_type = 0xFFFF;
+			}
+			else
+			{
+				pdi->status = DEVSTAT_NOT_OPER;
+				
+				memset( &(pdi->sid_data),
+					'\0',
+					sizeof( senseid_t));
 
-				} /* endif */
+				pdi->sid_data.cu_type = 0xFFFF;
 
-				if ( ioinfo[i]->ui.flags.ready )
-					pdi->status |= DEVSTAT_DEVICE_OWNED;
+			} /* endif */
 
-				rc = 0; /* found */
-				break;
+			if ( ioinfo[i]->ui.flags.ready )
+				pdi->status |= DEVSTAT_DEVICE_OWNED;
 
-			} /* endif */
+			rc = 0; /* found */
+			break;
 
-		} /* endfor */
+		} /* endif */
 
-		return( rc);
+	} /* endfor */
 
-	} /* endif */
+	return( rc);
 
 }
 
@@ -4262,6 +4644,13 @@
 void s390_device_recognition_irq( int irq )
 {
 	int           ret;
+	char dbf_txt[15];
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "devrec");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
 
 	/*
 	 * We issue the SenseID command on I/O subchannels we think are
@@ -4274,9 +4663,9 @@
 		int       irq_ret;
 		devstat_t devstat;
 
-	   irq_ret = request_irq( irq,
+		irq_ret = request_irq( irq,
 		                       init_IRQ_handler,
-		                       0,
+		                       SA_PROBE,
 		                       "INIT",
 		                       &devstat);
 
@@ -4284,7 +4673,7 @@
 		{
 			ret = enable_cpu_sync_isc( irq );
 
-			if ( !ret )
+			if ( !ret ) 
 			{
 				ioinfo[irq]->ui.flags.unknown = 0;
 
@@ -4305,9 +4694,8 @@
 
 					if ( !ret )	// on success only ...
 					{
-#ifdef CONFIG_DEBUG_IO
 						char buffer[80];
-
+#ifdef CONFIG_DEBUG_IO
 						sprintf( buffer,
 						         "RCD for device(%04X)/"
 						         "subchannel(%04X) returns :\n",
@@ -4316,6 +4704,15 @@
 
 						s390_displayhex( buffer, prcd, lrcd );
 #endif      				
+						if (cio_debug_initialized) {
+							sprintf( buffer,
+								 "RCD for device(%04X)/"
+								 "subchannel(%04X) returns :\n",
+								 ioinfo[irq]->schib.pmcw.dev,
+								 irq );
+							
+							s390_displayhex2( buffer, prcd, lrcd, 2);
+						}
 						if ( init_IRQ_complete )
 						{
 							kfree( prcd );
@@ -4326,11 +4723,10 @@
 
  			  			} /* endif */
 
-	   			} /* endif */
-
-     	      } /* endif */
+					} /* endif */
+					
+				} /* endif */
 #endif
-				s390_DevicePathVerification( irq, 0 );
 
 				disable_cpu_sync_isc( irq );
 
@@ -4364,6 +4760,46 @@
 
 }
 
+/*
+ * Function: s390_redo_validation
+ * Look for no longer blacklisted devices
+ * FIXME: there must be a better way to do this...
+ */
+
+void s390_redo_validation(void) 
+{
+	int irq = 0;
+	int ret;
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 0, "redoval");
+	}
+	do {
+		if (ioinfo[irq] == INVALID_STORAGE_AREA) {
+			ret = s390_validate_subchannel(irq, 0);
+			if (!ret) {
+				s390_device_recognition_irq(irq);
+				if (ioinfo[irq]->ui.flags.oper) {
+					devreg_t *pdevreg;
+					
+					pdevreg = s390_search_devreg( ioinfo[irq] );
+					if ( pdevreg != NULL ) {
+						if ( pdevreg->oper_func != NULL )
+							pdevreg->oper_func( irq, pdevreg );
+						
+					} 
+				}
+#ifdef CONFIG_PROC_FS
+				if (cio_proc_devinfo) 
+					if (irq < MAX_CIO_PROCFS_ENTRIES) {
+						cio_procfs_device_create(ioinfo[irq]->devno);
+				}
+#endif
+			}
+		}
+		irq++;
+	} while (irq<=highest_subchannel);
+}
 
 /*
  * s390_search_devices
@@ -4389,6 +4825,10 @@
 
 	printk( "Highest subchannel number detected (hex) : %04X\n",
 	        highest_subchannel);
+	if (cio_debug_initialized)
+		debug_sprintf_event(cio_debug_msg_id, 0, 
+				    "Highest subchannel number detected (hex) : %04X\n",
+				    highest_subchannel);	
 }
 
 /*
@@ -4405,6 +4845,14 @@
 	int      ccode2;    /* condition code for other I/O routines */
 	schib_t *p_schib;
 	int      ret;
+	
+	char dbf_txt[15];
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "valsch");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
 
 	/*
 	 * The first subchannel that is not-operational (ccode==3)
@@ -4444,6 +4892,10 @@
 			        "non-I/O subchannel type %04X\n",
 			        irq,
 			        p_schib->pmcw.st);
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_msg_id, 0,
+						    "Subchannel %04X reports non-I/O subchannel type %04X\n",
+						    irq, p_schib->pmcw.st);
 
 			if ( ioinfo[irq] != INVALID_STORAGE_AREA )
 				ioinfo[irq]->ui.flags.oper = 0;
@@ -4460,6 +4912,10 @@
 #ifdef CONFIG_DEBUG_IO
 			  printk( "Blacklisted device detected at devno %04X\n", p_schib->pmcw.dev );
 #endif
+			  if (cio_debug_initialized)
+				  debug_sprintf_event(cio_debug_msg_id, 0,
+						      "Blacklisted device detected at devno %04X\n",
+						      p_schib->pmcw.dev);
 			  ret = -ENODEV;
 		     } else {
 		        if ( ioinfo[irq] == INVALID_STORAGE_AREA )
@@ -4508,8 +4964,8 @@
 				{
 					ioinfo_t *pi = ioinfo_head;
 
-					do
-					{
+					for (pi=ioinfo_head; pi!=NULL; pi=pi->next) {
+
 						if ( irq < pi->next->irq )
 						{
 							ioinfo[irq]->next = pi->next;
@@ -4519,11 +4975,7 @@
 							break;
 						
 						} /* endif */
-
-						pi = pi->next;
-
-					} while ( 1 );
-      	
+					}
 				} /* endif */
 
 			} /* endif */
@@ -4547,6 +4999,16 @@
 			 	       ioinfo[irq]->schib.pmcw.pom);
 
 			} /* endif */
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_msg_id, 0,
+						    "Detected device %04X "
+						    "on subchannel %04X"
+						    " - PIM = %02X, PAM = %02X, POM = %02X\n",
+						    ioinfo[irq]->schib.pmcw.dev,
+						    irq,
+						    ioinfo[irq]->schib.pmcw.pim,
+						    ioinfo[irq]->schib.pmcw.pam,
+						    ioinfo[irq]->schib.pmcw.pom);
 
 			/*
 			 * initialize ioinfo structure
@@ -4661,6 +5123,10 @@
 							{
 								printk( " ... msch() (2) failed with CC = %X\n",
 								        ccode2 );
+								if (cio_debug_initialized)
+									debug_sprintf_event(cio_debug_msg_id, 0,
+											    "msch() (2) failed with CC=%X\n",
+											    ccode2);
 								ioinfo[irq]->ui.flags.oper = 0;
 								ret                        = -EIO;
 							}
@@ -4676,6 +5142,10 @@
 						{
 							printk( " ... msch() (1) failed with CC = %X\n",
 							        ccode2);
+							if (cio_debug_initialized)
+								debug_sprintf_event(cio_debug_msg_id, 0,
+										    "msch() (1) failed with CC = %X\n",
+										    ccode2);
 							ioinfo[irq]->ui.flags.oper = 0;
 							ret                        = -EIO;
 
@@ -4694,6 +5164,11 @@
 					        "subchannel %04X exceeded, CC = %d\n",
 					        irq,
 					        ccode2);
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 0,
+								    " ... msch() retry count for "
+								    "subchannel %04X exceeded, CC = %d\n",
+								    irq, ccode2);		    
 
 				} /* endif */
 			}
@@ -4748,18 +5223,13 @@
 	int        io_retry;      /* retry indicator */
 
 	senseid_t *psid     = sid;/* start with the external buffer */	
-	int        sbuffer  = 0; /* switch SID data buffer */
+	int        sbuffer  = 0;  /* switch SID data buffer */
 
-	if ( (irq > highest_subchannel) || (irq < 0 ) )
-	{
-		return( -ENODEV );
+	char dbf_txt[15];
 
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
+	int failure = 0;          /* nothing went wrong yet */
 
-	} /* endif */
+	SANITY_CHECK(irq);
 
 	if ( ioinfo[irq]->ui.flags.oper == 0 )
 	{
@@ -4767,6 +5237,14 @@
 
 	} /* endif */
 
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "snsID");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
+	inlreq = 0; /* to make the compiler quiet... */
+
 	if ( !ioinfo[irq]->ui.flags.ready )
 	{
 
@@ -4778,7 +5256,7 @@
 		 *  requests and evaluate the devstat area on return therefore
 		 *  we don't need a real I/O handler in place.
 		 */
-		irq_ret = request_irq( irq, init_IRQ_handler, 0, "SID", &devstat);
+		irq_ret = request_irq( irq, init_IRQ_handler, SA_PROBE, "SID", &devstat);
 
 		if ( irq_ret == 0 )
 			inlreq = 1;
@@ -4792,8 +5270,8 @@
   	} /* endif */
 
 	if ( irq_ret == 0 )
-   {
-      int i;
+	{
+		int i;
 
 		s390irq_spin_lock( irq);
 
@@ -4840,6 +5318,9 @@
 
 			if ( domask )
 			{
+				failure = 0;
+				
+				psid->reserved   = 0;
 				psid->cu_type    = 0xFFFF;  /* initialize fields ... */
 				psid->cu_model   = 0;
 				psid->dev_type   = 0;
@@ -4860,23 +5341,18 @@
 					irq_ret = s390_start_IO( irq,
 					                         sense_ccw,
 					                         0x00E2C9C4,  // == SID
-			   		                      domask,
+								 domask,
 					                         DOIO_WAIT_FOR_INTERRUPT
 					                          | DOIO_TIMEOUT
 					                          | DOIO_VALID_LPM
 					                          | DOIO_DONT_CALL_INTHDLR );
 
-					//
-					// The OSA_E FE card possibly causes -ETIMEDOUT
-					//  conditions, as the SenseID may stay start
-					//  pending. This will cause start_IO() to finally
-					//  halt the operation we should retry. If the halt
-					//  fails this may cause -EBUSY we simply retry
-					//  and eventually clean up with free_irq().   	     		
-					//
 
 					if ( psid->cu_type  == 0xFFFF )
 					{
+
+						failure = 1;
+
 						if ( pdevstat->flag & DEVSTAT_STATUS_PENDING )
 						{
 #ifdef CONFIG_DEBUG_IO
@@ -4885,12 +5361,21 @@
 							        "reports pending status, "
 							        "retry : %d\n",
 							        ioinfo[irq]->schib.pmcw.dev,
-					   		     irq,
+								irq,
 							        retry);
 #endif
+							if (cio_debug_initialized)
+								debug_sprintf_event(cio_debug_msg_id, 2,
+										    "SenseID : device %04X on "
+										    "Subchannel %04X "
+										    "reports pending status, "
+										    "retry : %d\n",
+										    ioinfo[irq]->schib.pmcw.dev,
+										    irq,
+										    retry);		    
 						} /* endif */
 
-						if ( pdevstat->flag & DEVSTAT_FLAG_SENSE_AVAIL )
+						else if ( pdevstat->flag & DEVSTAT_FLAG_SENSE_AVAIL )
 						{
 							/*
 							 * if the device doesn't support the SenseID
@@ -4907,11 +5392,20 @@
 								        ioinfo[irq]->schib.pmcw.dev,
 								        irq);
 #endif
-								io_retry = 1;
+								if (cio_debug_initialized)
+									debug_sprintf_event(cio_debug_msg_id, 2,
+											    "SenseID : device %04X on "
+											    "Subchannel %04X "
+											    "reports cmd reject or "
+											    "intervention required\n",
+											    ioinfo[irq]->schib.pmcw.dev,
+											    irq);		    
+								io_retry = 0;
 							}
-#ifdef CONFIG_DEBUG_IO
+
 							else
 							{
+#ifdef CONFIG_DEBUG_IO							
 								printk( "SenseID : UC on "
 								        "dev %04X, "
 								        "retry %d, "
@@ -4932,12 +5426,39 @@
 								        pdevstat->ii.sense.data[5],
 								        pdevstat->ii.sense.data[6],
 								        pdevstat->ii.sense.data[7]);
-
-							} /* endif */
 #endif
+								if (cio_debug_initialized) {
+									debug_sprintf_event(cio_debug_msg_id, 2,
+											    "SenseID : UC on "
+											    "dev %04X, "
+											    "retry %d, "
+											    "lpum %02X, "
+											    "cnt %02d, "
+											    "sns :"
+											    " %02X%02X%02X%02X "
+											    "%02X%02X%02X%02X ...\n",
+											    ioinfo[irq]->schib.pmcw.dev,
+											    retry,
+											    pdevstat->lpum,
+											    pdevstat->scnt,
+											    pdevstat->ii.sense.data[0],
+											    pdevstat->ii.sense.data[1],
+											    pdevstat->ii.sense.data[2],
+											    pdevstat->ii.sense.data[3],
+											    pdevstat->ii.sense.data[4],
+											    pdevstat->ii.sense.data[5],
+											    pdevstat->ii.sense.data[6],
+											    pdevstat->ii.sense.data[7]);	    
+									if (psid->reserved != 0xFF) 
+										debug_sprintf_event(cio_debug_msg_id, 2,
+												    "SenseID was not properly "
+												    "executed!\n");
+								}
+							} /* endif */
+
 						}
 						else if (    ( pdevstat->flag & DEVSTAT_NOT_OPER )
-					             || ( irq_ret        == -ENODEV         ) )
+							  || ( irq_ret        == -ENODEV         ) )
 						{
 #ifdef CONFIG_DEBUG_IO
 							printk( "SenseID : path %02X for "
@@ -4948,18 +5469,28 @@
 							        ioinfo[irq]->schib.pmcw.dev,
 							        irq);
 #endif
+							if (cio_debug_initialized)
+								debug_sprintf_event(cio_debug_msg_id, 2, 
+										    "SenseID : path %02X for "
+										    "device %04X on "
+										    "subchannel %04X "
+										    "is 'not operational'\n",
+										    domask,
+										    ioinfo[irq]->schib.pmcw.dev,
+										    irq);		    
 
 							io_retry          = 0;
 							ioinfo[irq]->opm &= ~domask;
       	
 						}
-#ifdef CONFIG_DEBUG_IO
-						else if (     (pdevstat->flag !=
-						                    (   DEVSTAT_START_FUNCTION
-						                      | DEVSTAT_FINAL_STATUS    ) )
-						           && !(pdevstat->flag &
-						                    DEVSTAT_STATUS_PENDING        ) )
+
+						else if (     ( pdevstat->flag !=
+							       (   DEVSTAT_START_FUNCTION
+								 | DEVSTAT_FINAL_STATUS    ) )
+							   && !( pdevstat->flag &
+								DEVSTAT_STATUS_PENDING       ) )
 						{
+#ifdef CONFIG_DEBUG_IO
 							printk( "SenseID : start_IO() for "
 							        "device %04X on "
 							        "subchannel %04X "
@@ -4970,51 +5501,73 @@
 							        irq_ret,
 							        retry,
 							        pdevstat->flag);
+#endif
+							if (cio_debug_initialized)
+								debug_sprintf_event(cio_debug_msg_id, 2,
+										    "SenseID : start_IO() for "
+										    "device %04X on "
+										    "subchannel %04X "
+										    "returns %d, retry %d, "
+										    "status %04X\n",
+										    ioinfo[irq]->schib.pmcw.dev,
+										    irq,
+										    irq_ret,
+										    retry,
+										    pdevstat->flag);		    
 
 						} /* endif */
-#endif
+
 					}
 					else   // we got it ...
 					{
-						if ( !sbuffer )	// switch buffers
-						{
-							/*
-							 * we report back the
-							 *  first hit only
-							 */
-							psid = &isid;
+						if (psid->reserved != 0xFF) {
+							/* No, we failed after all... */
+							failure = 1;
+							retry--;
 
-							if ( ioinfo[irq]->schib.pmcw.pim != 0x80 )
-							{
-								sense_ccw[1].cda = (__u32)virt_to_phys( psid );
-							}
-							else
+						} else {
+					       
+							if ( !sbuffer )	// switch buffers
 							{
-								sense_ccw[0].cda = (__u32)virt_to_phys( psid );
-
+								/*
+								 * we report back the
+								 *  first hit only
+								 */
+								psid = &isid;
+								
+								if ( ioinfo[irq]->schib.pmcw.pim != 0x80 )
+								{
+									sense_ccw[1].cda = (__u32)virt_to_phys( psid );
+								}
+								else
+								{
+									sense_ccw[0].cda = (__u32)virt_to_phys( psid );
+
+								} /* endif */
+
+								/*
+								 * if just the very first
+								 *  was requested to be
+								 *  sensed disable further
+								 *  scans.
+								 */	
+								if ( !lpm )
+									lpm = domask;
+								
+								sbuffer = 1;
+								
 							} /* endif */
 
-							/*
-							 * if just the very first
-							 *  was requested to be
-							 *  sensed disable further
-							 *  scans.
-							 */	
-							if ( !lpm )
-								lpm = domask;
-
-							sbuffer = 1;
-
-						} /* endif */
-
-					   if ( pdevstat->rescnt < (sizeof( senseid_t) - 8) )
-						{
-							ioinfo[irq]->ui.flags.esid = 1;
+							if ( pdevstat->rescnt < (sizeof( senseid_t) - 8) )
+							{
+								ioinfo[irq]->ui.flags.esid = 1;
        							
-						} /* endif */
+							} /* endif */
 
-						io_retry = 0;
+							io_retry = 0;
 						
+						}
+
 					} /* endif */
 
 					if ( io_retry )
@@ -5028,7 +5581,19 @@
 						} /* endif */
       	
 					} /* endif */
-	
+
+					if ((failure) && (io_retry)) {
+						/* reset fields... */
+
+						failure = 0;
+						
+						psid->reserved   = 0;
+						psid->cu_type    = 0xFFFF;  
+						psid->cu_model   = 0;
+						psid->dev_type   = 0;
+						psid->dev_model  = 0;
+					}
+						
 				} while ( (io_retry) );
 
  			} /* endif - domask */
@@ -5059,7 +5624,7 @@
 		 *  only if we suffered a command reject, but it doesn't harm
 		 */
 		if (    ( sid->cu_type == 0xFFFF    )
-		     && ( MACHINE_IS_VM              ) )
+		     && ( MACHINE_IS_VM             ) )
 		{
 			VM_virtual_device_info( ioinfo[irq]->schib.pmcw.dev,
 			                        sid );
@@ -5079,38 +5644,54 @@
 			        ioinfo[irq]->schib.pmcw.dev,
 			        irq);
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_msg_id, 2,
+						    "SenseID : unknown device %04X on subchannel %04X\n",
+						    ioinfo[irq]->schib.pmcw.dev,
+						    irq);		    
 			ioinfo[irq]->ui.flags.unknown = 1;
 
 		} /* endif */
 
-		if ( cio_show_msg )
-		{
-			/*
-			 * Issue device info message if unit was operational .
-			 */
-			if ( !ioinfo[irq]->ui.flags.unknown )
-			{
-				if ( sid->dev_type != 0 )
-				{
+	
+		/*
+		 * Issue device info message if unit was operational .
+		 */
+		if ( !ioinfo[irq]->ui.flags.unknown ) {
+			if ( sid->dev_type != 0 ) {
+				if ( cio_show_msg ) 
 					printk( KERN_INFO"SenseID : device %04X reports: "
-					        "CU  Type/Mod = %04X/%02X,"
-				      	  " Dev Type/Mod = %04X/%02X\n",
-				   	     ioinfo[irq]->schib.pmcw.dev,
-					        sid->cu_type,
-					        sid->cu_model,
-					        sid->dev_type,
-					        sid->dev_model);
-				}
-				else
-				{
+						"CU  Type/Mod = %04X/%02X,"
+						" Dev Type/Mod = %04X/%02X\n",
+						ioinfo[irq]->schib.pmcw.dev,
+						sid->cu_type,
+						sid->cu_model,
+						sid->dev_type,
+						sid->dev_model);
+				if (cio_debug_initialized)
+					debug_sprintf_event(cio_debug_msg_id, 2,
+							    "SenseID : device %04X reports: "
+							    "CU  Type/Mod = %04X/%02X,"
+							    " Dev Type/Mod = %04X/%02X\n",
+							    ioinfo[irq]->schib.pmcw.dev,
+							    sid->cu_type,
+							    sid->cu_model,
+							    sid->dev_type,
+							    sid->dev_model);
+			} else {
+				if ( cio_show_msg ) 
 					printk( KERN_INFO"SenseID : device %04X reports:"
-				   	     " Dev Type/Mod = %04X/%02X\n",
-					        ioinfo[irq]->schib.pmcw.dev,
-					        sid->cu_type,
-					        sid->cu_model);
-
-				} /* endif */
-
+						" Dev Type/Mod = %04X/%02X\n",
+						ioinfo[irq]->schib.pmcw.dev,
+						sid->cu_type,
+						sid->cu_model);
+				if (cio_debug_initialized)
+					debug_sprintf_event(cio_debug_msg_id, 2,
+							    "SenseID : device %04X reports:"
+							    " Dev Type/Mod = %04X/%02X\n",
+							    ioinfo[irq]->schib.pmcw.dev,
+							    sid->cu_type,
+							    sid->cu_model);		    
 			} /* endif */
 
 		} /* endif */
@@ -5149,16 +5730,25 @@
  *  available. Further, a path group ID is set, if possible in multipath
  *  mode, otherwise in single path mode.
  *
+ * Note : This function must not be called during normal device recognition,
+ *         but during device driver initiated request_irq() processing only.
  */
 int s390_DevicePathVerification( int irq, __u8 usermask )
 {
-#if 1
 	int  ccode;
 	__u8 pathmask;
 	__u8 domask;
 
 	int ret = 0;
 
+	char dbf_txt[15];
+
+	if (cio_debug_initialized) {
+		debug_text_event(cio_debug_trace_id, 4, "dpver");
+		sprintf(dbf_txt, "%x", irq);
+		debug_text_event(cio_debug_trace_id, 4, dbf_txt);
+	}
+
 	if ( ioinfo[irq]->ui.flags.pgid_supp == 0 )
 	{
 		return( 0);	// just exit ...
@@ -5270,16 +5860,30 @@
 						        irq,
 						        ioinfo[irq]->schib.pmcw.dev);
 #endif
+						if (cio_debug_initialized)
+							debug_sprintf_event(cio_debug_msg_id, 2,
+									    "PathVerification(%04X) "
+									    "- Device %04X doesn't "
+									    " support path grouping\n",
+									    irq,
+									    ioinfo[irq]->schib.pmcw.dev);		    
 
 					} /* endif */
 				}
-				else if ( ret == -EIO )
+				else if ( ret == -EIO ) 
 				{
 #ifdef CONFIG_DEBUG_IO
 					printk("PathVerification(%04X) - I/O error "
 					       "on device %04X\n", irq,
 					       ioinfo[irq]->schib.pmcw.dev);
 #endif
+
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 2,
+								    "PathVerification(%04X) - I/O error "
+								    "on device %04X\n", irq,
+								    ioinfo[irq]->schib.pmcw.dev);
+
 					ioinfo[irq]->ui.flags.pgid_supp = 0;
 		    
 				} else {
@@ -5289,6 +5893,13 @@
 						irq,
 						ioinfo[irq]->schib.pmcw.dev);
 #endif
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 2,
+								    "PathVerification(%04X) - "
+								    "Unexpected error on device %04X\n",
+								    irq,
+								    ioinfo[irq]->schib.pmcw.dev);		    
+					
 					ioinfo[irq]->ui.flags.pgid_supp = 0;
 					
 				} /* endif */
@@ -5300,9 +5911,7 @@
 	} /* endif */
 
 	return ret;
-#else
-	return 0;
-#endif
+
 }
 
 /*
@@ -5324,16 +5933,7 @@
 	int        inlreq  = 0; /* inline request_irq() */
 	int        mpath   = 1; /* try multi-path first */
 
-	if ( (irq > highest_subchannel) || (irq < 0 ) )
-	{
-		return( -ENODEV );
-
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-
-	} /* endif */
+	SANITY_CHECK(irq);
 
 	if ( ioinfo[irq]->ui.flags.oper == 0 )
 	{
@@ -5344,20 +5944,20 @@
 	if ( !ioinfo[irq]->ui.flags.ready )
 	{
 		/*
-		 * Perform SENSE ID command processing. We have to request device
+		 * Perform SetPGID command processing. We have to request device
 		 *  ownership and provide a dummy I/O handler. We issue sync. I/O
 		 *  requests and evaluate the devstat area on return therefore
 		 *  we don't need a real I/O handler in place.
 		 */
 		irq_ret = request_irq( irq,
 		                       init_IRQ_handler,
-		                       0,
+		                       SA_PROBE,
 		                       "SPID",
 		                       pdevstat);
 
 		if ( irq_ret == 0 )
 			inlreq = 1;
-   }
+	}
 	else
 	{
 		pdevstat = ioinfo[irq]->irq_desc.dev_id;
@@ -5378,7 +5978,7 @@
 
 		} /* endif */
 
-		spid_ccw[0].cmd_code = 0x5B;	/* suspend multipath reconnect */
+		spid_ccw[0].cmd_code = CCW_CMD_SUSPEND_RECONN;	
 		spid_ccw[0].cda      = 0;
 		spid_ccw[0].count    = 0;
 		spid_ccw[0].flags    = CCW_FLAG_SLI | CCW_FLAG_CC;
@@ -5391,7 +5991,7 @@
 		pgid->inf.fc = SPID_FUNC_MULTI_PATH | SPID_FUNC_ESTABLISH;
 
 		/*
-		 * We now issue a SenseID request. In case of BUSY
+		 * We now issue a SetPGID request. In case of BUSY
 		 *  or STATUS PENDING conditions we retry 5 times.
 		 */
 		do
@@ -5419,12 +6019,24 @@
 					        irq,
 					        retry);
 #endif
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 2,
+								    "SPID - Device %04X "
+								    "on Subchannel %04X "
+								    "reports pending status, "
+								    "retry : %d\n",
+								    ioinfo[irq]->schib.pmcw.dev,
+								    irq,
+								    retry);	    
+					retry--;
+					irq_ret = -EIO;
 				} /* endif */
 
 				if ( pdevstat->flag == (   DEVSTAT_START_FUNCTION
 				                         | DEVSTAT_FINAL_STATUS   ) )
 				{
 					retry = 0;	// successfully set ...
+					irq_ret = 0;
 				}
 				else if ( pdevstat->flag & DEVSTAT_FLAG_SENSE_AVAIL )
 				{
@@ -5437,10 +6049,23 @@
 					{
 						if ( mpath )
 						{
+							/*
+							 * We now try single path mode.
+							 * Note we must not issue the suspend
+							 * multipath reconnect, or we will get
+							 * a command reject by tapes.
+							 */
+							
+							spid_ccw[0].cmd_code = CCW_CMD_SET_PGID;
+							spid_ccw[0].cda      = (__u32)virt_to_phys( pgid );
+							spid_ccw[0].count    = sizeof( pgid_t);
+							spid_ccw[0].flags    = CCW_FLAG_SLI;
+
 							pgid->inf.fc =   SPID_FUNC_SINGLE_PATH
 							               | SPID_FUNC_ESTABLISH;
 							mpath        = 0;
 							retry--;
+							irq_ret = -EIO;
 						}
 						else
 						{
@@ -5468,19 +6093,51 @@
 						        pdevstat->ii.sense.data[5],
 						        pdevstat->ii.sense.data[6],
 						        pdevstat->ii.sense.data[7]);
-
 #endif
-						retry--;
 
+						if (cio_debug_initialized)
+							debug_sprintf_event(cio_debug_msg_id, 2,
+									    "SPID - device %04X,"
+									    " unit check,"
+									    " retry %d, cnt %02d,"
+									    " sns :"
+									    " %02X%02X%02X%02X %02X%02X%02X%02X ...\n",
+									    ioinfo[irq]->schib.pmcw.dev,
+									    retry,
+									    pdevstat->scnt,
+									    pdevstat->ii.sense.data[0],
+									    pdevstat->ii.sense.data[1],
+									    pdevstat->ii.sense.data[2],
+									    pdevstat->ii.sense.data[3],
+									    pdevstat->ii.sense.data[4],
+									    pdevstat->ii.sense.data[5],
+									    pdevstat->ii.sense.data[6],
+									    pdevstat->ii.sense.data[7]);
+
+						retry--;
+						irq_ret = -EIO;
+		    
 					} /* endif */
+
 				}
 				else if ( pdevstat->flag & DEVSTAT_NOT_OPER )
 				{
-					printk( "SPID - Device %04X "
-					        "on Subchannel %04X "
-					        "became 'not operational'\n",
-					        ioinfo[irq]->schib.pmcw.dev,
-					        irq);
+					/* don't issue warnings during startup unless requested*/
+					if (init_IRQ_complete || cio_notoper_msg) {   
+						
+						printk( "SPID - Device %04X "
+							"on Subchannel %04X "
+							"became 'not operational'\n",
+							ioinfo[irq]->schib.pmcw.dev,
+							irq);
+						if (cio_debug_initialized)
+							debug_sprintf_event(cio_debug_msg_id, 2,
+									    "SPID - Device %04X "
+									    "on Subchannel %04X "
+									    "became 'not operational'\n",
+									    ioinfo[irq]->schib.pmcw.dev,
+									    irq);		    
+					}
 
 					retry = 0;
 					irq_ret = -EIO;
@@ -5490,20 +6147,17 @@
 			else if ( irq_ret != -ENODEV )
 			{
 				retry--;
+				irq_ret = -EIO;
 			}
 			else
 			{
 				retry = 0;
+				irq_ret = -ENODEV;
 
 			} /* endif */
 
 		} while ( retry > 0 );
 
-		if ( retry == 0 )
-		{
-			irq_ret = -EIO;
-
-		} /* endif */		
 
 		if ( init_IRQ_complete )
 		{
@@ -5545,17 +6199,9 @@
 	int        irq_ret = 0; /* return code */
 	int        retry   = 5; /* retry count */
 	int        inlreq  = 0; /* inline request_irq() */
+	unsigned long flags;
 
-	if ( (irq > highest_subchannel) || (irq < 0 ) )
-	{
-		return( -ENODEV );
-
-	}
-	else if ( ioinfo[irq] == INVALID_STORAGE_AREA )
-	{
-		return( -ENODEV);
-
-	} /* endif */
+	SANITY_CHECK(irq);
 
 	if ( ioinfo[irq]->ui.flags.oper == 0 )
 	{
@@ -5566,14 +6212,14 @@
 	if ( !ioinfo[irq]->ui.flags.ready )
 	{
 		/*
-		 * Perform SENSE ID command processing. We have to request device
+		 * Perform SENSE PGID command processing. We have to request device
 		 *  ownership and provide a dummy I/O handler. We issue sync. I/O
 		 *  requests and evaluate the devstat area on return therefore
 		 *  we don't need a real I/O handler in place.
 		 */
 		irq_ret = request_irq( irq,
 		                       init_IRQ_handler,
-		                       0,
+		                       SA_PROBE,
 		                       "SNID",
 		                       pdevstat);
 
@@ -5589,7 +6235,7 @@
 
 	if ( irq_ret == 0 )
 	{
-		s390irq_spin_lock( irq);
+		s390irq_spin_lock_irqsave( irq, flags);
 
 		if ( init_IRQ_complete )
 		{
@@ -5607,7 +6253,7 @@
 		snid_ccw->flags    = CCW_FLAG_SLI;
 
 		/*
-		 * We now issue a SenseID request. In case of BUSY
+		 * We now issue a SensePGID request. In case of BUSY
 		 *  or STATUS PENDING conditions we retry 5 times.
 		 */
 		do
@@ -5659,32 +6305,66 @@
 						        pdevstat->ii.sense.data[7]);
 
 #endif
+						if (cio_debug_initialized)
+							debug_sprintf_event(cio_debug_msg_id, 2,
+									    "SNID - device %04X,"
+									    " unit check,"
+									    " flag %04X, "
+									    " retry %d, cnt %02d,"
+									    " sns :"
+									    " %02X%02X%02X%02X %02X%02X%02X%02X ...\n",
+									    ioinfo[irq]->schib.pmcw.dev,
+									    pdevstat->flag,
+									    retry,
+									    pdevstat->scnt,
+									    pdevstat->ii.sense.data[0],
+									    pdevstat->ii.sense.data[1],
+									    pdevstat->ii.sense.data[2],
+									    pdevstat->ii.sense.data[3],
+									    pdevstat->ii.sense.data[4],
+									    pdevstat->ii.sense.data[5],
+									    pdevstat->ii.sense.data[6],
+									    pdevstat->ii.sense.data[7]);		    
 						retry--;
+						irq_ret = -EIO;
 
 					} /* endif */
 				}
 				else if ( pdevstat->flag & DEVSTAT_NOT_OPER )
 				{
-					printk( "SNID - Device %04X "
-					        "on Subchannel %04X "
-					        "became 'not operational'\n",
-					        ioinfo[irq]->schib.pmcw.dev,
-					        irq);
+					/* don't issue warnings during startup unless requested*/
+					if (init_IRQ_complete || cio_notoper_msg) {  
+						printk( "SNID - Device %04X "
+							"on Subchannel %04X "
+							"became 'not operational'\n",
+							ioinfo[irq]->schib.pmcw.dev,
+							irq);
+						if (cio_debug_initialized)
+							debug_sprintf_event(cio_debug_msg_id, 2,
+									    "SNID - Device %04X "
+									    "on Subchannel %04X "
+									    "became 'not operational'\n",
+									    ioinfo[irq]->schib.pmcw.dev,
+									    irq);		    
+					}
 
 					retry = 0;
+					irq_ret = -EIO;
 
 				}
 				else
 				{
 					retry = 0; // success ...
+					irq_ret = 0;
 
 				} /* endif */
 			}
 			else if ( irq_ret != -ENODEV ) // -EIO, or -EBUSY
 			{
-#ifdef CONFIG_DEBUG_IO
+
 				if ( pdevstat->flag & DEVSTAT_STATUS_PENDING )
 				{
+#ifdef CONFIG_DEBUG_IO
 					printk( "SNID - Device %04X "
 					        "on Subchannel %04X "
 					        "reports pending status, "
@@ -5692,28 +6372,41 @@
 					        ioinfo[irq]->schib.pmcw.dev,
 					        irq,
 					        retry);
-				} /* endif */
 #endif
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_msg_id, 2,
+								    "SNID - Device %04X "
+								    "on Subchannel %04X "
+								    "reports pending status, "
+								    "retry : %d\n",
+								    ioinfo[irq]->schib.pmcw.dev,
+								    irq,
+								    retry);		    
+				} /* endif */
+
 
 				printk( "SNID - device %04X,"
 				        " start_io() reports rc : %d, retrying ...\n",
 				        ioinfo[irq]->schib.pmcw.dev,
 				        irq_ret);
+				if (cio_debug_initialized)
+					debug_sprintf_event(cio_debug_msg_id, 2, 
+							    "SNID - device %04X,"
+							    " start_io() reports rc : %d, retrying ...\n",
+							    ioinfo[irq]->schib.pmcw.dev,
+							    irq_ret);
 				retry--;
+				irq_ret = -EIO;
 			}
 			else	// -ENODEV ...
 			{
 				retry = 0;
+				irq_ret = -ENODEV;
 
 			} /* endif */
 
 		} while ( retry > 0 );
 
-		if ( retry == 0 )
-		{
-			irq_ret = -EIO;
-
-		} /* endif */
 
 		if ( init_IRQ_complete )
 		{
@@ -5725,7 +6418,7 @@
 
 		} /* endif */
 
-		s390irq_spin_unlock( irq);
+		s390irq_spin_unlock_irqrestore( irq, flags);
 
 		/*
 		 * If we installed the irq action handler we have to
@@ -5758,7 +6451,9 @@
 #ifdef CONFIG_DEBUG_CRW
 	printk( "do_crw_pending : starting ...\n");
 #endif
-
+	if (cio_debug_initialized) 
+		debug_sprintf_event(cio_debug_crw_id, 2, 
+				    "do_crw_pending: starting\n");
 	while ( pcrwe != NULL )
 	{
 		int is_owned = 0;
@@ -5772,7 +6467,9 @@
 			printk( KERN_INFO"do_crw_pending : source is "
 			        "subchannel %04X\n", irq);
 #endif
-
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "source is subchannel %04X\n", irq);
 			/*
 			 * If the device isn't known yet
 			 *   we can't lock it ...
@@ -5794,6 +6491,9 @@
 #ifdef CONFIG_DEBUG_CRW
 			printk( "do_crw_pending : subchannel validation - start ...\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 4,
+						    "subchannel validation - start\n");
 			s390_validate_subchannel( irq, is_owned );
 
 			if ( irq > highest_subchannel )
@@ -5802,6 +6502,9 @@
 #ifdef CONFIG_DEBUG_CRW
 			printk( "do_crw_pending : subchannel validation - done\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 4,
+						    "subchannel validation - done\n");
 			/*
 			 * After the validate processing
 			 *   the ioinfo control block
@@ -5813,26 +6516,48 @@
 
 			} /* endif */
 
-#ifdef CONFIG_DEBUG_CRW
+
 			if ( ioinfo[irq] != INVALID_STORAGE_AREA )
 			{
-				printk( "do_crw_pending : ioinfo at %08X\n",
+#ifdef CONFIG_DEBUG_CRW
+				printk( "do_crw_pending : ioinfo at "
+#ifdef CONFIG_ARCH_S390X
+					"%08lX\n",
+					(unsigned long)ioinfo[irq]);
+#else /* CONFIG_ARCH_S390X */
+					"%08X\n",
 				        (unsigned)ioinfo[irq]);
-
-			} /* endif */
+#endif /* CONFIG_ARCH_S390X */
 #endif
+				if (cio_debug_initialized)
+					debug_sprintf_event(cio_debug_crw_id, 4,
+							    "ioinfo at "
+#ifdef CONFIG_ARCH_S390X
+							    "%08lX\n",
+							    (unsigned long)ioinfo[irq]);
+#else /* CONFIG_ARCH_S390X */
+				                            "%08X\n",
+							    (unsigned)ioinfo[irq]);
+#endif /* CONFIG_ARCH_S390X */
+			} /* endif */
+
 
 			if ( ioinfo[irq] != INVALID_STORAGE_AREA )
 			{
 				if ( ioinfo[irq]->ui.flags.oper == 0 )
 				{
 					 not_oper_handler_func_t nopfunc=ioinfo[irq]->nopfunc;
+#ifdef CONFIG_PROC_FS					 
+					 /* remove procfs entry */
+					 if (cio_proc_devinfo)
+						 cio_procfs_device_remove(dev_no);
+#endif
 					/*
 					 * If the device has gone
 					 *  call not oper handler        	
 					 */       	
-					if (    (             dev_oper == 1    )
-					     && ( nopfunc != NULL ) )
+					 if (( dev_oper == 1 )
+					     && ( nopfunc != NULL))
 					{
 						
 						free_irq( irq,ioinfo[irq]->irq_desc.dev_id );
@@ -5846,13 +6571,18 @@
 					printk( "do_crw_pending : device "
 					        "recognition - start ...\n");
 #endif
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_crw_id, 4,
+								    "device recognition - start\n");
 					s390_device_recognition_irq( irq );
 
 #ifdef CONFIG_DEBUG_CRW
 					printk( "do_crw_pending : device "
 					        "recognition - done\n");
 #endif
-		
+					if (cio_debug_initialized)
+						debug_sprintf_event(cio_debug_crw_id, 4,
+								    "device recognition - done\n");
 					/*
 					 * the device became operational
 					 */
@@ -5868,6 +6598,13 @@
 								pdevreg->oper_func( irq, pdevreg );
 
 						} /* endif */
+#ifdef CONFIG_PROC_FS
+						/* add new procfs entry */
+						if (cio_proc_devinfo) 
+							if (highest_subchannel < MAX_CIO_PROCFS_ENTRIES) {
+								cio_procfs_device_create(ioinfo[irq]->devno);
+							}
+#endif
 					}
 					/*
 					 * ... it is and was operational, but
@@ -5875,13 +6612,26 @@
 					 */
 					else if ((ioinfo[irq]->devno != dev_no) && ( ioinfo[irq]->nopfunc != NULL ))   					
 					{
+#ifdef CONFIG_PROC_FS
+						int devno_old = ioinfo[irq]->devno;
+#endif
 						ioinfo[irq]->nopfunc( irq,
 						                      DEVSTAT_REVALIDATE );				
-
+#ifdef CONFIG_PROC_FS
+						/* remove old entry, add new */
+						if (cio_proc_devinfo) {
+							cio_procfs_device_remove(devno_old);
+							cio_procfs_device_create(ioinfo[irq]->devno);
+						}
+#endif
 					} /* endif */
 
 				} /* endif */
-
+#ifdef CONFIG_PROC_FS
+				/* get rid of dead procfs entries */
+				if (cio_proc_devinfo) 
+					cio_procfs_device_purge();
+#endif
 			} /* endif */
 
 			break;
@@ -5892,6 +6642,9 @@
 			printk( "do_crw_pending : source is "
 			        "monitoring facility\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "source is monitoring facility\n");
 			break;
 
 		case CRW_RSC_CPATH :   	
@@ -5902,6 +6655,9 @@
 			printk( "do_crw_pending : source is "
 			        "channel path %02X\n", chpid);
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "source is channel path %02X\n");
 			break;
 
 		case CRW_RSC_CONFIG : 	
@@ -5910,6 +6666,9 @@
 			printk( "do_crw_pending : source is "
 			        "configuration-alert facility\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "source is configuration-alert facility\n");
 			break;
 
 		case CRW_RSC_CSS :
@@ -5918,6 +6677,9 @@
 			printk( "do_crw_pending : source is "
 			        "channel subsystem\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "source is channel subsystem\n");
 			break;
 
 		default :
@@ -5925,6 +6687,9 @@
 #ifdef CONFIG_DEBUG_CRW
 			printk( "do_crw_pending : unknown source\n");
 #endif
+			if (cio_debug_initialized)
+				debug_sprintf_event(cio_debug_crw_id, 2,
+						    "unknown source\n");
 			break;		
 
 		} /* endswitch */
@@ -5936,7 +6701,9 @@
 #ifdef CONFIG_DEBUG_CRW
 	printk( "do_crw_pending : done\n");
 #endif
-
+	if (cio_debug_initialized)
+		debug_sprintf_event(cio_debug_crw_id, 2,
+				    "do_crw_pending: done\n");
    return;
 }
 
@@ -5964,13 +6731,70 @@
 		do_reipl( 0x10000 | sch );
 }
 
-/* Display info on subchannels in /proc/subchannels. *
- * Adapted from procfs stuff in dasd.c by Cornelia Huck, 02/28/01.      */
 
-typedef struct {
-     char *data;
-     int len;
-} tempinfo_t;
+/*
+ * Function: cio_debug_init
+ * Initializes three debug logs (under /proc/s390dbf) for common I/O:
+ * - cio_msg logs the messages which are printk'ed when CONFIG_DEBUG_IO is on
+ * - cio_trace logs the calling of different functions
+ * - cio_crw logs the messages which are printk'ed when CONFIG_DEBUG_CRW is on
+ * debug levels depend on CONFIG_DEBUG_IO resp. CONFIG_DEBUG_CRW
+ */
+int cio_debug_init( void )
+{
+	int ret = 0;
+
+	cio_debug_msg_id = debug_register("cio_msg",4,4,16*sizeof(long));
+	if (cio_debug_msg_id != NULL) {
+		debug_register_view(cio_debug_msg_id, &debug_sprintf_view);
+#ifdef CONFIG_DEBUG_IO
+		debug_set_level(cio_debug_msg_id, 6);
+#else /* CONFIG_DEBUG_IO */
+		debug_set_level(cio_debug_msg_id, 2);
+#endif /* CONFIG_DEBUG_IO */
+	} else {
+		ret = -1;
+	}
+	cio_debug_trace_id = debug_register("cio_trace",4,4,8);
+	if (cio_debug_trace_id != NULL) {
+		debug_register_view(cio_debug_trace_id, &debug_hex_ascii_view);
+#ifdef CONFIG_DEBUG_IO
+		debug_set_level(cio_debug_trace_id, 6);
+#else /* CONFIG_DEBUG_IO */
+		debug_set_level(cio_debug_trace_id, 2);
+#endif /* CONFIG_DEBUG_IO */
+	} else {
+		ret = -1;
+	}
+	cio_debug_crw_id = debug_register("cio_crw",2,4,16*sizeof(long));
+	if (cio_debug_crw_id != NULL) {
+		debug_register_view(cio_debug_crw_id, &debug_sprintf_view);
+#ifdef CONFIG_DEBUG_CRW
+		debug_set_level(cio_debug_crw_id, 6);
+#else /* CONFIG_DEBUG_CRW */
+		debug_set_level(cio_debug_crw_id, 2);
+#endif /* CONFIG_DEBUG_CRW */
+	} else {
+		ret = -1;
+	}
+	if (ret)
+		return ret;
+	cio_debug_initialized = 1;
+	return 0;
+}
+
+__initcall(cio_debug_init);
+
+#ifdef CONFIG_PROC_FS
+/* 
+ * Display info on subchannels in /proc/subchannels. 
+ * Adapted from procfs stuff in dasd.c by Cornelia Huck, 02/28/01.      
+ */
+
+typedef struct {
+     char *data;
+     int len;
+} tempinfo_t;
 
 #define MIN(a,b) ((a)<(b)?(a):(b))
 
@@ -6022,7 +6846,7 @@
 				    ioinfo[i]->senseid.cu_model );
 	       } else {
 		    len += sprintf( info->data+len, 
-				    "%04X/%02X          ", 
+				    "          %04X/%02X", 
 				    ioinfo[i]->senseid.cu_type, 
 				    ioinfo[i]->senseid.cu_model );
 	       }
@@ -6090,10 +6914,12 @@
      release:chan_subch_close,
 };
 
-void chan_proc_init( void )
+static int chan_proc_init( void )
 {
      chan_subch_entry = create_proc_entry( "subchannels", S_IFREG|S_IRUGO, &proc_root);
      chan_subch_entry->proc_fops = &chan_subch_file_ops;
+
+     return 1;
 }
 
 __initcall(chan_proc_init);
@@ -6103,6 +6929,611 @@
      remove_proc_entry( "subchannels", &proc_root);
 }
 
+/* 
+ * Display device specific information under /proc/deviceinfo/<devno>
+ */
+
+static struct proc_dir_entry *cio_procfs_deviceinfo_root = NULL;
+
+/* 
+ * cio_procfs_device_list holds all devno-specific procfs directories
+ */
+
+typedef struct {
+	int devno;
+	struct proc_dir_entry *cio_device_entry;
+	struct proc_dir_entry *cio_sensedata_entry;
+	struct proc_dir_entry *cio_in_use_entry;
+	struct proc_dir_entry *cio_chpid_entry;
+} cio_procfs_entry_t;
+
+typedef struct _cio_procfs_device{
+	struct _cio_procfs_device *next;
+	cio_procfs_entry_t *entry;
+} cio_procfs_device_t;
+
+cio_procfs_device_t *cio_procfs_device_list = NULL;
+
+/*
+ * File operations
+ */
+
+static int cio_device_entry_close( struct inode *inode, struct file *file)
+{
+     int rc = 0;
+     tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+
+     if (p_info) {
+	  if (p_info->data)
+	       vfree( p_info->data );
+	  vfree( p_info );
+     }
+     
+     return rc;
+}
+
+static ssize_t cio_device_entry_read( struct file *file, char *user_buf, size_t user_len, loff_t * offset)
+{
+     loff_t len;
+     tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+     
+     if ( *offset>=p_info->len) {
+	  return 0;
+     } else {
+	  len = MIN(user_len, (p_info->len - *offset));
+	  if (copy_to_user( user_buf, &(p_info->data[*offset]), len))
+	       return -EFAULT; 
+	  (* offset) += len;
+	  return len;
+     }
+}
+
+
+static int cio_sensedata_entry_open( struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	int size = 1;
+	int len = 0;
+	tempinfo_t *info;
+	int irq;
+	int devno;
+	char * devno_str;
+
+	info = (tempinfo_t *) vmalloc(sizeof(tempinfo_t));
+	if (info == NULL) {
+		printk( KERN_WARNING "No memory available for data\n");
+		rc = -ENOMEM;
+	} else {
+		file->private_data = (void *) info;
+		size += 2 * 32;
+		info->data = (char *) vmalloc(size);
+		if (size && info->data == NULL) {
+			printk(KERN_WARNING "No memory available for data\n");
+			vfree(info);
+			rc = -ENOMEM;
+		} else {
+			devno_str = kmalloc(6*sizeof(char), GFP_KERNEL);
+			memset(devno_str, 0, 6*sizeof(char));
+			memcpy(devno_str,file->f_dentry->d_parent->d_name.name, strlen(file->f_dentry->d_parent->d_name.name)+1);
+			devno = simple_strtoul(devno_str, &devno_str, 16);
+			irq = get_irq_by_devno(devno);
+			if (irq != -1) {
+				len += sprintf(info->data+len, "Dev Type/Mod: ");
+				if (ioinfo[irq]->senseid.dev_type == 0) {
+					len += sprintf(info->data+len, "%04X/%02X\n",
+						       ioinfo[irq]->senseid.cu_type,
+						       ioinfo[irq]->senseid.cu_model);
+				} else {
+					len += sprintf(info->data+len, "%04X/%02X\n",
+						       ioinfo[irq]->senseid.dev_type,
+						       ioinfo[irq]->senseid.dev_model);
+					len+= sprintf(info->data+len, "CU Type/Mod:  %04X/%02X\n",
+						      ioinfo[irq]->senseid.cu_type,
+						      ioinfo[irq]->senseid.cu_model);
+				}
+			}
+			info->len = len;
+		}
+	}
+	
+	return rc;
+}
+
+static int cio_in_use_entry_open( struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	int size = 1;
+	int len = 0;
+	tempinfo_t *info;
+	int irq;
+	int devno;
+	char * devno_str;
+
+	info = (tempinfo_t *) vmalloc(sizeof(tempinfo_t));
+	if (info == NULL) {
+		printk( KERN_WARNING "No memory available for data\n");
+		rc = -ENOMEM;
+	} else {
+		file->private_data = (void *) info;
+		size += 8;
+		info->data = (char *) vmalloc(size);
+		if (size && info->data == NULL) {
+			printk(KERN_WARNING "No memory available for data\n");
+			vfree(info);
+			rc = -ENOMEM;
+		} else {
+			devno_str = kmalloc(6*sizeof(char), GFP_KERNEL);
+			memset(devno_str, 0, 6*sizeof(char));
+			memcpy(devno_str,file->f_dentry->d_parent->d_name.name, strlen(file->f_dentry->d_parent->d_name.name)+1);
+			devno = simple_strtoul(devno_str, &devno_str, 16);
+			irq = get_irq_by_devno(devno);
+			if (irq != -1) {
+				len += sprintf(info->data+len, "%s\n", ioinfo[irq]->ui.flags.ready?"yes":"no");
+			}
+			info->len = len;
+		}
+	}
+	
+	return rc;
+}
+
+static int cio_chpid_entry_open( struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	int size = 1;
+	int len = 0;
+	tempinfo_t *info;
+	int irq;
+	int devno;
+	int i;
+	char * devno_str;
+
+	info = (tempinfo_t *) vmalloc(sizeof(tempinfo_t));
+	if (info == NULL) {
+		printk( KERN_WARNING "No memory available for data\n");
+		rc = -ENOMEM;
+	} else {
+		file->private_data = (void *) info;
+		size += 8*16;
+		info->data = (char *) vmalloc(size);
+		if (size && info->data == NULL) {
+			printk(KERN_WARNING "No memory available for data\n");
+			vfree(info);
+			rc = -ENOMEM;
+		} else {
+			devno_str = kmalloc(6*sizeof(char), GFP_KERNEL);
+			memset(devno_str, 0, 6*sizeof(char));
+			memcpy(devno_str,file->f_dentry->d_parent->d_name.name, strlen(file->f_dentry->d_parent->d_name.name)+1);
+			devno = simple_strtoul(devno_str, &devno_str, 16);
+			irq = get_irq_by_devno(devno);
+			if (irq != -1) {
+				for (i=0; i<8; i++) {
+					len += sprintf(info->data+len, "CHPID[%d]: ", i);
+					len += sprintf(info->data+len, "%02X\n", ioinfo[irq]->schib.pmcw.chpid[i]);
+				}
+			}
+			info->len = len;
+		}
+	}
+
+	return rc;
+}
+
+static struct file_operations cio_sensedata_entry_file_ops =
+{
+     read:cio_device_entry_read,
+     open:cio_sensedata_entry_open,
+     release:cio_device_entry_close,
+};
+
+static struct file_operations cio_in_use_entry_file_ops =
+{
+     read:cio_device_entry_read,
+     open:cio_in_use_entry_open,
+     release:cio_device_entry_close,
+};
+
+static struct file_operations cio_chpid_entry_file_ops =
+{
+     read:cio_device_entry_read,
+     open:cio_chpid_entry_open,
+     release:cio_device_entry_close,
+};
+
+/*
+ * Function: cio_procfs_device_create
+ * create procfs entry for given device number
+ * and insert it into list
+ */
+int cio_procfs_device_create(int devno)
+{
+	cio_procfs_entry_t *entry;
+	cio_procfs_device_t *tmp;
+	cio_procfs_device_t *where;
+	char buf[8];
+	int i;
+	int rc = 0;
+
+
+	/* create the directory entry */
+	entry = (cio_procfs_entry_t *)kmalloc(sizeof(cio_procfs_entry_t), GFP_KERNEL);
+	if (entry) {
+		entry->devno = devno;
+		sprintf(buf, "%x", devno);
+		entry->cio_device_entry = proc_mkdir(buf, cio_procfs_deviceinfo_root);
+		
+		if (entry->cio_device_entry) {
+			tmp = (cio_procfs_device_t *)kmalloc(sizeof(cio_procfs_device_t), GFP_KERNEL);
+			if (tmp) {
+				tmp->entry = entry;
+				
+				if (cio_procfs_device_list == NULL) {
+					cio_procfs_device_list = tmp;
+					tmp->next = NULL;
+				} else {
+					where = cio_procfs_device_list;
+					i = where->entry->devno;
+					while ((devno>i) && (where->next != NULL)) {
+						where = where->next;
+						i = where->entry->devno;
+					}
+					if (where->next == NULL) {
+						where->next = tmp;
+						tmp->next = NULL;
+					} else {
+						tmp->next = where->next;
+						where->next = tmp;
+					}
+				}
+				/* create the different entries */
+				entry->cio_sensedata_entry = create_proc_entry( "sensedata", S_IFREG|S_IRUGO, entry->cio_device_entry);
+				entry->cio_sensedata_entry->proc_fops = &cio_sensedata_entry_file_ops;
+				entry->cio_in_use_entry = create_proc_entry( "in_use", S_IFREG|S_IRUGO, entry->cio_device_entry);
+				entry->cio_in_use_entry->proc_fops = &cio_in_use_entry_file_ops;
+				entry->cio_chpid_entry = create_proc_entry( "chpids", S_IFREG|S_IRUGO, entry->cio_device_entry);
+				entry->cio_chpid_entry->proc_fops = &cio_chpid_entry_file_ops;
+			} else {
+				printk("Error, could not allocate procfs structure!\n");
+				remove_proc_entry(buf, cio_procfs_deviceinfo_root);
+				kfree(entry);
+				rc = -ENOMEM;
+			}
+		} else {
+			printk("Error, could not allocate procfs structure!\n");
+			kfree(entry);
+			rc = -ENOMEM;
+		}
+
+	} else {
+		printk("Error, could not allocate procfs structure!\n");
+		rc = -ENOMEM;
+	}
+	return rc;
+}
+
+/*
+ * Function: cio_procfs_device_remove
+ * remove procfs entry for given device number
+ */
+int cio_procfs_device_remove(int devno)
+{
+	int rc = 0;
+	cio_procfs_device_t *tmp;
+	cio_procfs_device_t *prev = NULL;
+
+	tmp=cio_procfs_device_list;
+	while (tmp) {
+		if (tmp->entry->devno == devno)
+			break;
+		prev = tmp;
+		tmp = tmp->next;
+	}
+
+	if (tmp) {
+		char buf[8];
+		
+		remove_proc_entry("sensedata", tmp->entry->cio_device_entry);
+		remove_proc_entry("in_use", tmp->entry->cio_device_entry);
+		remove_proc_entry("chpid", tmp->entry->cio_device_entry);
+		sprintf(buf, "%x", devno);
+		remove_proc_entry(buf, cio_procfs_deviceinfo_root);
+		
+		if (tmp == cio_procfs_device_list) {
+			cio_procfs_device_list = tmp->next;
+		} else {
+			prev->next = tmp->next;
+		}
+		kfree(tmp->entry);
+		kfree(tmp);
+	} else {
+		rc = -ENODEV;
+	}
+
+	return rc;
+}
+
+/*
+ * Function: cio_procfs_purge
+ * purge /proc/deviceinfo of entries for gone devices
+ */
+
+int cio_procfs_device_purge(void) 
+{
+	int i;
+
+	for (i=0; i<=highest_subchannel; i++) {
+		if (ioinfo[i] != INVALID_STORAGE_AREA) {
+			if (!ioinfo[i]->ui.flags.oper) 
+				cio_procfs_device_remove(ioinfo[i]->devno);
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Function: cio_procfs_create
+ * create /proc/deviceinfo/ and subdirs for the devices
+ */
+static int cio_procfs_create( void )
+{
+	int irq;
+
+	if (cio_proc_devinfo) {
+
+		cio_procfs_deviceinfo_root = proc_mkdir( "deviceinfo", &proc_root);
+		
+		if (highest_subchannel >= MAX_CIO_PROCFS_ENTRIES) {
+			printk(KERN_ALERT "Warning: Not enough inodes for creating all entries under /proc/deviceinfo/. "
+			       "Not every device will get an entry.\n");
+		}
+		
+		for (irq=0; irq<=highest_subchannel; irq++) {
+			if (irq >= MAX_CIO_PROCFS_ENTRIES)
+				break;
+			if (ioinfo[irq] != INVALID_STORAGE_AREA) {
+				if (ioinfo[irq]->ui.flags.oper) 
+					if (cio_procfs_device_create(ioinfo[irq]->devno) == -ENOMEM) {
+						printk(KERN_CRIT "Out of memory while creating entries in /proc/deviceinfo/, "
+						       "not all devices might show up\n");
+					break;
+					}
+			}
+		}
+	
+	}
+	
+	return 1;
+}
+
+__initcall(cio_procfs_create);
+
+/*
+ * Entry /proc/cio_ignore to display blacklisted ranges of devices.
+ * un-ignore devices by piping to /proc/cio_ignore:
+ * free all frees all blacklisted devices, free <range>,<range>,...
+ * frees specified ranges of devnos
+ * add <range>,<range>,... will add a range of devices to blacklist -
+ * but only for devices not already known
+ */
+
+static struct proc_dir_entry *cio_ignore_proc_entry;
+
+static int cio_ignore_proc_open(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	int size = 1;
+	int len = 0;
+	tempinfo_t *info;
+	dev_blacklist_range_t *tmp;
+	long flags;
+
+	info = (tempinfo_t *) vmalloc(sizeof(tempinfo_t));
+	if (info == NULL) {
+		printk( KERN_WARNING "No memory available for data\n");
+		rc = -ENOMEM;
+	} else {
+		file->private_data = (void *) info;
+		size += nr_blacklisted_ranges * 32;
+		info->data = (char *) vmalloc(size);
+		if (size && info->data == NULL) {
+			printk( KERN_WARNING "No memory available for data\n");
+			vfree (info);
+			rc = -ENOMEM;
+		} else {
+			spin_lock_irqsave( &blacklist_lock, flags ); 
+			tmp = dev_blacklist_range_head;
+			while (tmp) {
+				len += sprintf(info->data+len, "%04x ", tmp->from);
+				if (tmp->to != tmp->from) 
+					len += sprintf(info->data+len, "- %04x", tmp->to);
+				len += sprintf(info->data+len, "\n");
+				tmp = tmp->next;
+			}
+			spin_unlock_irqrestore( &blacklist_lock, flags );
+			info->len = len;
+		}
+	}
+	return rc;
+}
+
+static int cio_ignore_proc_close(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+
+     if (p_info) {
+	  if (p_info->data)
+	       vfree( p_info->data );
+	  vfree( p_info );
+     }
+     
+     return rc;
+}
+
+static ssize_t cio_ignore_proc_read( struct file *file, char *user_buf, size_t user_len, loff_t * offset)
+{
+     loff_t len;
+     tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+     
+     if ( *offset>=p_info->len) {
+	  return 0;
+     } else {
+	  len = MIN(user_len, (p_info->len - *offset));
+	  if (copy_to_user( user_buf, &(p_info->data[*offset]), len))
+	       return -EFAULT; 
+	  (* offset) += len;
+	  return len;
+     }
+}
+
+static ssize_t cio_ignore_proc_write (struct file *file, const char *user_buf,
+				      size_t user_len, loff_t * offset)
+{
+	char *buffer = vmalloc (user_len);
+
+	if (buffer == NULL)
+		return -ENOMEM;
+	if (copy_from_user (buffer, user_buf, user_len)) {
+		vfree (buffer);
+		return -EFAULT;
+	}
+	buffer[user_len]='\0';
+#ifdef CIO_DEBUG_IO
+	printk ("/proc/cio_ignore: '%s'\n", buffer);
+#endif /* CIO_DEBUG_IO */
+	if (cio_debug_initialized)
+		debug_sprintf_event(cio_debug_msg_id, 2, "/proc/cio_ignore: '%s'\n",buffer);
+
+	blacklist_parse_proc_parameters(buffer);
+
+	return user_len;
+}
+
+static struct file_operations cio_ignore_proc_file_ops =
+{
+	read:cio_ignore_proc_read,
+	open:cio_ignore_proc_open,
+	write:cio_ignore_proc_write,
+	release:cio_ignore_proc_close,
+};
+
+static int cio_ignore_proc_init(void)
+{
+	cio_ignore_proc_entry = create_proc_entry("cio_ignore", S_IFREG|S_IRUGO|S_IWUSR, &proc_root);
+	cio_ignore_proc_entry->proc_fops = &cio_ignore_proc_file_ops;
+
+	return 1;
+}
+
+__initcall(cio_ignore_proc_init);
+
+/*
+ * Entry /proc/irq_count
+ * display how many irqs have occured per cpu...
+ */
+
+static struct proc_dir_entry *cio_irq_proc_entry;
+
+static int cio_irq_proc_open(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	int size = 1;
+	int len = 0;
+	tempinfo_t *info;
+	int i;
+
+	info = (tempinfo_t *) vmalloc(sizeof(tempinfo_t));
+	if (info == NULL) {
+		printk( KERN_WARNING "No memory available for data\n");
+		rc = -ENOMEM;
+	} else {
+		file->private_data = (void *) info;
+		size += NR_CPUS * 16;
+		info->data = (char *) vmalloc(size);
+		if (size && info->data == NULL) {
+			printk( KERN_WARNING "No memory available for data\n");
+			vfree (info);
+			rc = -ENOMEM;
+		} else {
+			for (i=0; i< NR_CPUS; i++) {
+				if (s390_irq_count[i] != 0) 
+					len += sprintf(info->data+len, "%lx\n", s390_irq_count[i]);
+			}
+			info->len = len;
+		}
+	}
+	return rc;
+}
+
+static int cio_irq_proc_close(struct inode *inode, struct file *file)
+{
+	int rc = 0;
+	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+
+	if (p_info) {
+		if (p_info->data) 
+			vfree(p_info->data);
+		vfree(p_info);
+	}
+
+	return rc;
+}
+
+static ssize_t cio_irq_proc_read( struct file *file, char *user_buf, size_t user_len, loff_t * offset)
+{
+	loff_t len;
+	tempinfo_t *p_info = (tempinfo_t *) file->private_data;
+	
+	if ( *offset>=p_info->len) {
+		return 0;
+	} else {
+		len = MIN(user_len, (p_info->len - *offset));
+		if (copy_to_user( user_buf, &(p_info->data[*offset]), len))
+			return -EFAULT; 
+		(* offset) += len;
+		return len;
+	}
+}
+
+static struct file_operations cio_irq_proc_file_ops = 
+	{
+		read:    cio_irq_proc_read,
+		open:    cio_irq_proc_open,
+		release: cio_irq_proc_close,
+	};
+
+static int cio_irq_proc_init(void)
+{
+
+	int i;
+
+	if (cio_count_irqs) {
+		for (i=0; i<NR_CPUS; i++) 
+			s390_irq_count[i]=0;
+		cio_irq_proc_entry = create_proc_entry("irq_count", S_IFREG|S_IRUGO, &proc_root);
+		cio_irq_proc_entry->proc_fops = &cio_irq_proc_file_ops;
+	}
+
+	return 1;
+}
+
+__initcall(cio_irq_proc_init);	
+
+/* end of procfs stuff */
+#endif
+
+schib_t *s390_get_schib( int irq )
+{
+	if ( (irq > highest_subchannel) || (irq < 0) )
+		return NULL;
+	if ( ioinfo[irq] == INVALID_STORAGE_AREA )
+		return NULL;
+	return &ioinfo[irq]->schib;
+
+}
+
+
 EXPORT_SYMBOL(halt_IO);
 EXPORT_SYMBOL(clear_IO);
 EXPORT_SYMBOL(do_IO);
@@ -6117,3 +7548,6 @@
 EXPORT_SYMBOL(read_conf_data);
 EXPORT_SYMBOL(read_dev_chars);
 EXPORT_SYMBOL(s390_request_irq_special);
+EXPORT_SYMBOL(s390_get_schib);
+EXPORT_SYMBOL(s390_register_adapter_interrupt);
+EXPORT_SYMBOL(s390_unregister_adapter_interrupt);
diff -urN linux/drivers/s390/s390mach.c linux-2.4.7/drivers/s390/s390mach.c
--- linux/drivers/s390/s390mach.c	Fri Mar  2 14:12:07 2001
+++ linux-2.4.7/drivers/s390/s390mach.c	Mon Dec 17 13:42:47 2001
@@ -11,7 +11,7 @@
 #include <linux/config.h>
 #include <linux/spinlock.h>
 #include <linux/init.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #ifdef CONFIG_SMP
 #include <linux/smp.h>
 #endif
@@ -170,7 +170,7 @@
 static int s390_machine_check_handler( void *parm)
 {
 	struct semaphore *sem = parm;
-	int               flags;
+	unsigned long     flags;
 	mache_t          *pmache;
 
 	int               found = 0;
diff -urN linux/drivers/s390/sysinfo.c linux-2.4.7/drivers/s390/sysinfo.c
--- linux/drivers/s390/sysinfo.c	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/drivers/s390/sysinfo.c	Mon Dec 17 13:42:47 2001
@@ -0,0 +1,354 @@
+/*
+ *  drivers/s390/sysinfo.c
+ *
+ *    Copyright (C) 2001 IBM Deutschland Entwicklung GmbH, IBM Corporation
+ *    Author(s): Ulrich Weigand (Ulrich.Weigand@de.ibm.com)
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <asm/ebcdic.h>
+
+struct sysinfo_1_1_1
+{
+	char reserved_0[32];
+	char manufacturer[16];
+	char type[4];
+	char reserved_1[12];
+	char model[16];
+	char sequence[16];
+	char plant[4];
+};
+
+struct sysinfo_1_2_1
+{
+	char reserved_0[80];
+	char sequence[16];
+	char plant[4];
+	char reserved_1[2];
+	unsigned short cpu_address;
+};
+
+struct sysinfo_1_2_2
+{
+	char reserved_0[32];
+	unsigned int capability;
+	unsigned short cpus_total;
+	unsigned short cpus_configured;
+	unsigned short cpus_standby;
+	unsigned short cpus_reserved;
+	unsigned short adjustment[0];
+};
+
+struct sysinfo_2_2_1
+{
+	char reserved_0[80];
+	char sequence[16];
+	char plant[4];
+	unsigned short cpu_id;
+	unsigned short cpu_address;
+};
+
+struct sysinfo_2_2_2
+{
+	char reserved_0[32];
+	unsigned short lpar_number;
+	char reserved_1;
+	unsigned char characteristics;
+	#define LPAR_CHAR_DEDICATED	(1 << 7)
+	#define LPAR_CHAR_SHARED	(1 << 6)
+	#define LPAR_CHAR_LIMITED	(1 << 5)
+	unsigned short cpus_total;
+	unsigned short cpus_configured;
+	unsigned short cpus_standby;
+	unsigned short cpus_reserved;
+	char name[8];
+	unsigned int caf;
+	char reserved_2[16];
+	unsigned short cpus_dedicated;
+	unsigned short cpus_shared;
+};
+
+struct sysinfo_3_2_2
+{
+	char reserved_0[31];
+	unsigned char count;
+	struct
+	{
+		char reserved_0[4];
+		unsigned short cpus_total;
+		unsigned short cpus_configured;
+		unsigned short cpus_standby;
+		unsigned short cpus_reserved;
+		char name[8];
+		unsigned int caf;
+		char cpi[16];
+		char reserved_1[24];
+
+	} vm[8];
+};
+
+union s390_sysinfo
+{
+	struct sysinfo_1_1_1 sysinfo_1_1_1;
+	struct sysinfo_1_2_1 sysinfo_1_2_1;
+	struct sysinfo_1_2_2 sysinfo_1_2_2;
+	struct sysinfo_2_2_1 sysinfo_2_2_1;
+	struct sysinfo_2_2_2 sysinfo_2_2_2;
+	struct sysinfo_3_2_2 sysinfo_3_2_2;
+};
+
+static inline int stsi (void *sysinfo, 
+                        int fc, int sel1, int sel2)
+{
+	int cc, retv;
+
+#ifndef CONFIG_ARCH_S390X
+	__asm__ __volatile__ (	"lr\t0,%2\n"
+				"\tlr\t1,%3\n"
+				"\tstsi\t0(%4)\n"
+				"0:\tipm\t%0\n"
+				"\tsrl\t%0,28\n"
+				"1:lr\t%1,0\n"
+				".section .fixup,\"ax\"\n"
+				"2:\tlhi\t%0,3\n"
+				"\tbras\t1,3f\n"
+				"\t.long 1b\n"
+				"3:\tl\t1,0(1)\n"
+				"\tbr\t1\n"
+				".previous\n"
+				".section __ex_table,\"a\"\n"
+				"\t.align 4\n"
+				"\t.long 0b,2b\n"
+				".previous\n"
+				: "=d" (cc), "=d" (retv)
+				: "d" ((fc << 28) | sel1), "d" (sel2), "a" (sysinfo) 
+				: "cc", "memory", "0", "1" );
+#else
+	__asm__ __volatile__ (	"lr\t0,%2\n"
+				"lr\t1,%3\n"
+				"\tstsi\t0(%4)\n"
+				"0:\tipm\t%0\n"
+				"\tsrl\t%0,28\n"
+				"1:lr\t%1,0\n"
+				".section .fixup,\"ax\"\n"
+				"2:\tlhi\t%0,3\n"
+				"\tjg\t1b\n"
+				".previous\n"
+				".section __ex_table,\"a\"\n"
+				"\t.align 8\n"
+				"\t.quad 0b,2b\n"
+				".previous\n"
+				: "=d" (cc), "=d" (retv)
+				: "d" ((fc << 28) | sel1), "d" (sel2), "a" (sysinfo) 
+				: "cc", "memory", "0", "1" );
+#endif
+
+	return cc? -1 : retv;
+}
+
+static inline int stsi_0 (void)
+{
+	int rc = stsi (NULL, 0, 0, 0);
+	return rc == -1 ? rc : (((unsigned int)rc) >> 28);
+}
+
+static inline int stsi_1_1_1 (struct sysinfo_1_1_1 *info)
+{
+	int rc = stsi (info, 1, 1, 1);
+	if (rc != -1)
+	{
+		EBCASC (info->manufacturer, sizeof(info->manufacturer));
+		EBCASC (info->type, sizeof(info->type));
+		EBCASC (info->model, sizeof(info->model));
+		EBCASC (info->sequence, sizeof(info->sequence));
+		EBCASC (info->plant, sizeof(info->plant));
+	}
+	return rc == -1 ? rc : 0;
+}
+
+static inline int stsi_1_2_1 (struct sysinfo_1_2_1 *info)
+{
+	int rc = stsi (info, 1, 2, 1);
+	if (rc != -1)
+	{
+		EBCASC (info->sequence, sizeof(info->sequence));
+		EBCASC (info->plant, sizeof(info->plant));
+	}
+	return rc == -1 ? rc : 0;
+}
+
+static inline int stsi_1_2_2 (struct sysinfo_1_2_2 *info)
+{
+	int rc = stsi (info, 1, 2, 2);
+	return rc == -1 ? rc : 0;
+}
+
+static inline int stsi_2_2_1 (struct sysinfo_2_2_1 *info)
+{
+	int rc = stsi (info, 2, 2, 1);
+	if (rc != -1)
+	{
+		EBCASC (info->sequence, sizeof(info->sequence));
+		EBCASC (info->plant, sizeof(info->plant));
+	}
+	return rc == -1 ? rc : 0;
+}
+
+static inline int stsi_2_2_2 (struct sysinfo_2_2_2 *info)
+{
+	int rc = stsi (info, 2, 2, 2);
+	if (rc != -1)
+	{
+		EBCASC (info->name, sizeof(info->name));
+  	}
+	return rc == -1 ? rc : 0;
+}
+
+static inline int stsi_3_2_2 (struct sysinfo_3_2_2 *info)
+{
+	int rc = stsi (info, 3, 2, 2);
+	if (rc != -1)
+	{
+		int i;
+		for (i = 0; i < info->count; i++)
+		{
+			EBCASC (info->vm[i].name, sizeof(info->vm[i].name));
+			EBCASC (info->vm[i].cpi, sizeof(info->vm[i].cpi));
+		}
+	}
+	return rc == -1 ? rc : 0;
+}
+
+
+static int proc_read_sysinfo(char *page, char **start,
+                             off_t off, int count,
+                             int *eof, void *data)
+{
+	unsigned long info_page = get_free_page (GFP_KERNEL); 
+	union s390_sysinfo *info = (union s390_sysinfo *) info_page;
+	int len = 0;
+	int level;
+	int i;
+	
+	if (!info)
+		return 0;
+
+	level = stsi_0 ();
+
+	if (level < 1)
+		goto out;
+	if (stsi_1_1_1 (&info->sysinfo_1_1_1))
+		goto out;
+
+	len += sprintf (page+len, "Manufacturer:         %-16.16s\n",
+			info->sysinfo_1_1_1.manufacturer);
+	len += sprintf (page+len, "Type:                 %-4.4s\n",
+			info->sysinfo_1_1_1.type);
+	len += sprintf (page+len, "Model:                %-16.16s\n",
+			info->sysinfo_1_1_1.model);
+	len += sprintf (page+len, "Sequence Code:        %-16.16s\n",
+			info->sysinfo_1_1_1.sequence);
+	len += sprintf (page+len, "Plant:                %-4.4s\n",
+			info->sysinfo_1_1_1.plant);
+
+	if (stsi_1_2_2 (&info->sysinfo_1_2_2))
+		goto out;
+
+	len += sprintf (page+len, "\n");
+	len += sprintf (page+len, "CPUs Total:           %d\n",
+			info->sysinfo_1_2_2.cpus_total);
+	len += sprintf (page+len, "CPUs Configured:      %d\n",
+			info->sysinfo_1_2_2.cpus_configured);
+	len += sprintf (page+len, "CPUs Standby:         %d\n",
+			info->sysinfo_1_2_2.cpus_standby);
+	len += sprintf (page+len, "CPUs Reserved:        %d\n",
+			info->sysinfo_1_2_2.cpus_reserved);
+
+	len += sprintf (page+len, "Capability:           %d\n",
+			info->sysinfo_1_2_2.capability);
+
+	for (i = 2; i <= info->sysinfo_1_2_2.cpus_total; i++)
+		len += sprintf (page+len, "Adjustment %02d-way:    %d\n",
+				i, info->sysinfo_1_2_2.adjustment[i-2]);
+			
+	if (level < 2)
+		goto out;
+	if (stsi_2_2_2 (&info->sysinfo_2_2_2))
+		goto out;
+
+	len += sprintf (page+len, "\n");
+	len += sprintf (page+len, "LPAR Number:          %d\n",
+			info->sysinfo_2_2_2.lpar_number);
+
+	len += sprintf (page+len, "LPAR Characteristics: ");
+	if (info->sysinfo_2_2_2.characteristics & LPAR_CHAR_DEDICATED)
+		len += sprintf (page+len, "Dedicated ");
+	if (info->sysinfo_2_2_2.characteristics & LPAR_CHAR_SHARED)
+		len += sprintf (page+len, "Shared ");
+	if (info->sysinfo_2_2_2.characteristics & LPAR_CHAR_LIMITED)
+		len += sprintf (page+len, "Limited ");
+	len += sprintf (page+len, "\n");
+
+	len += sprintf (page+len, "LPAR Name:            %-8.8s\n",
+			info->sysinfo_2_2_2.name);
+
+	len += sprintf (page+len, "LPAR Adjustment:      %d\n",
+			info->sysinfo_2_2_2.caf);
+
+	len += sprintf (page+len, "LPAR CPUs Total:      %d\n",
+			info->sysinfo_2_2_2.cpus_total);
+	len += sprintf (page+len, "LPAR CPUs Configured: %d\n",
+			info->sysinfo_2_2_2.cpus_configured);
+	len += sprintf (page+len, "LPAR CPUs Standby:    %d\n",
+			info->sysinfo_2_2_2.cpus_standby);
+	len += sprintf (page+len, "LPAR CPUs Reserved:   %d\n",
+			info->sysinfo_2_2_2.cpus_reserved);
+	len += sprintf (page+len, "LPAR CPUs Dedicated:  %d\n",
+			info->sysinfo_2_2_2.cpus_dedicated);
+	len += sprintf (page+len, "LPAR CPUs Shared:     %d\n",
+			info->sysinfo_2_2_2.cpus_shared);
+
+	if (level < 3)
+		goto out;
+	if (stsi_3_2_2 (&info->sysinfo_3_2_2))
+		goto out;
+
+	for (i = 0; i < info->sysinfo_3_2_2.count; i++)
+	{
+		len += sprintf (page+len, "\n");
+		len += sprintf (page+len, "VM%02d Name:            %-8.8s\n",
+				i, info->sysinfo_3_2_2.vm[i].name);
+		len += sprintf (page+len, "VM%02d Control Program: %-16.16s\n",
+				i, info->sysinfo_3_2_2.vm[i].cpi);
+
+		len += sprintf (page+len, "VM%02d Adjustment:      %d\n",
+				i, info->sysinfo_3_2_2.vm[i].caf);
+
+		len += sprintf (page+len, "VM%02d CPUs Total:      %d\n",
+				i, info->sysinfo_3_2_2.vm[i].cpus_total);
+		len += sprintf (page+len, "VM%02d CPUs Configured: %d\n",
+				i, info->sysinfo_3_2_2.vm[i].cpus_configured);
+		len += sprintf (page+len, "VM%02d CPUs Standby:    %d\n",
+				i, info->sysinfo_3_2_2.vm[i].cpus_standby);
+		len += sprintf (page+len, "VM%02d CPUs Reserved:   %d\n",
+				i, info->sysinfo_3_2_2.vm[i].cpus_reserved);
+	}
+
+out:
+	free_page (info_page);
+        return len;
+}
+
+static __init int create_proc_sysinfo(void)
+{
+	create_proc_read_entry ("sysinfo", 0444, NULL, 
+				proc_read_sysinfo, NULL);
+	return 0;
+}
+
+__initcall(create_proc_sysinfo);
+
diff -urN linux/fs/partitions/Makefile linux-2.4.7/fs/partitions/Makefile
--- linux/fs/partitions/Makefile	Fri Apr 13 23:26:07 2001
+++ linux-2.4.7/fs/partitions/Makefile	Mon Dec 17 13:41:20 2001
@@ -9,7 +9,7 @@
 
 O_TARGET := partitions.o
 
-export-objs := check.o ibm.o
+export-objs := check.o 
 
 obj-y := check.o
 
diff -urN linux/fs/partitions/check.c linux-2.4.7/fs/partitions/check.c
--- linux/fs/partitions/check.c	Wed Jul 11 17:55:41 2001
+++ linux-2.4.7/fs/partitions/check.c	Mon Dec 17 13:41:20 2001
@@ -72,12 +72,18 @@
 	NULL
 };
 
+#ifdef CONFIG_ARCH_S390
+int (*genhd_dasd_name)(char*,int,int,struct gendisk*) = NULL;
+EXPORT_SYMBOL(genhd_dasd_name);
+#endif
+
 /*
  * disk_name() is used by partition check code and the md driver.
  * It formats the devicename of the indicated disk into
  * the supplied buffer (of size at least 32), and returns
  * a pointer to that same buffer (for convenience).
  */
+
 char *disk_name (struct gendisk *hd, int minor, char *buf)
 {
 	unsigned int part;
@@ -92,6 +98,12 @@
 		if (pos >= 0)
 			return buf + pos;
 	}
+
+#ifdef CONFIG_ARCH_S390
+	if (genhd_dasd_name
+	    && genhd_dasd_name (buf, unit - 'a', part, hd) == 0)
+		return buf;
+#endif
 	/*
 	 * IDE devices use multiple major numbers, but the drives
 	 * are named as:  {hda,hdb}, {hdc,hdd}, {hde,hdf}, {hdg,hdh}..
@@ -313,6 +325,7 @@
 	int devnum = minor >> dev->minor_shift;
 	devfs_handle_t dir;
 	unsigned int devfs_flags = DEVFS_FL_DEFAULT;
+	umode_t devfs_perm  = S_IFBLK | S_IRUSR | S_IWUSR;
 	char devname[16];
 
 	if (dev->part[minor + part].de) return;
@@ -320,11 +333,14 @@
 	if (!dir) return;
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
 		devfs_flags |= DEVFS_FL_REMOVABLE;
+	if (is_read_only(MKDEV(dev->major, minor+part))) {
+	        devfs_perm &= ~(S_IWUSR);
+	}
 	sprintf (devname, "part%d", part);
 	dev->part[minor + part].de =
 	    devfs_register (dir, devname, devfs_flags,
 			    dev->major, minor + part,
-			    S_IFBLK | S_IRUSR | S_IWUSR,
+			    devfs_perm,
 			    dev->fops, NULL);
 }
 
@@ -336,12 +352,16 @@
 	int devnum = minor >> dev->minor_shift;
 	devfs_handle_t dir, slave;
 	unsigned int devfs_flags = DEVFS_FL_DEFAULT;
+	umode_t devfs_perm  = S_IFBLK | S_IRUSR | S_IWUSR;
 	char dirname[64], symlink[16];
 	static devfs_handle_t devfs_handle;
 
 	if (dev->part[minor].de) return;
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
 		devfs_flags |= DEVFS_FL_REMOVABLE;
+	if (is_read_only(MKDEV(dev->major, minor))) {
+	        devfs_perm &= ~(S_IWUSR);
+	}
 	if (dev->de_arr) {
 		dir = dev->de_arr[devnum];
 		if (!dir)  /*  Aware driver wants to block disc management  */
@@ -363,7 +383,7 @@
 			  dirname + pos, &slave, NULL);
 	dev->part[minor].de =
 	    devfs_register (dir, "disc", devfs_flags, dev->major, minor,
-			    S_IFBLK | S_IRUSR | S_IWUSR, dev->fops, NULL);
+			    devfs_perm, dev->fops, NULL);
 	devfs_auto_unregister (dev->part[minor].de, slave);
 	if (!dev->de_arr)
 		devfs_auto_unregister (slave, dir);
diff -urN linux/fs/partitions/ibm.c linux-2.4.7/fs/partitions/ibm.c
--- linux/fs/partitions/ibm.c	Sun May 20 15:11:39 2001
+++ linux-2.4.7/fs/partitions/ibm.c	Mon Dec 17 13:42:47 2001
@@ -10,14 +10,14 @@
  * 02/13/00 VTOC partition support added
  */
 
-#include <linux/module.h>
+#include <linux/config.h>
 #include <linux/fs.h>
 #include <linux/genhd.h>
 #include <linux/kernel.h>
 #include <linux/major.h>
 #include <linux/string.h>
 #include <linux/blk.h>
-#include <linux/malloc.h>
+#include <linux/slab.h>
 #include <linux/hdreg.h>
 #include <linux/ioctl.h>
 #include <linux/version.h>
@@ -29,56 +29,31 @@
 #include "check.h"
 #include <asm/vtoc.h>
 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-/* We hook in when DASD is a module... */
-int (*genhd_dasd_name)(char*,int,int,struct gendisk*) = NULL;
-int (*genhd_dasd_fillgeo)(int,struct hd_geometry *) = NULL;
-EXPORT_SYMBOL(genhd_dasd_fillgeo);
-EXPORT_SYMBOL(genhd_dasd_name);
-#endif /* LINUX_IS_24 */
-
-typedef enum {
-  ibm_partition_lnx1 = 0,
-  ibm_partition_vol1 = 1,
-  ibm_partition_cms1 = 2,
-  ibm_partition_none = 3
-} ibm_partition_t;
-
-static char* part_names[] = {   [ibm_partition_lnx1] = "LNX1",
-			     [ibm_partition_vol1] = "VOL1",
-			     [ibm_partition_cms1] = "CMS1",
-			     [ibm_partition_none] = "(nonl)"
-};
-
-static ibm_partition_t
-get_partition_type ( char * type )
+static int
+get_drive_geometry(struct block_device *bdev, struct hd_geometry *geo) 
 {
-	int i;
-	for ( i = 0; i < 3; i ++) {
-		if ( ! strncmp (type,part_names[i],4) ) 
-			break;
+	int rc;
+
+	rc = blkdev_get(bdev, 0, 1, BDEV_FILE);
+	if (rc == 0) {
+		rc = ioctl_by_bdev(bdev, HDIO_GETGEO, (unsigned long) geo);
+		blkdev_put(bdev, BDEV_FILE);
 	}
-        return i;
+	return rc;
 }
 
-/*
- * add the two default partitions
- * - whole dasd
- * - whole dasd without "offset"
- */
-static inline void
-two_partitions(struct gendisk *hd,
-	       int minor,
-	       int blocksize,
-	       int offset,
-	       int size) {
-
-        add_gd_partition( hd, minor, 0,size);
-	add_gd_partition( hd, minor + 1, 
-			   offset * (blocksize >> 9),
-			   size-offset*(blocksize>>9));
-}
+static int
+get_drive_info(struct block_device *bdev, dasd_information_t *info) 
+{
+	int rc;
 
+	rc = blkdev_get(bdev, 0, 1, BDEV_FILE);
+	if (rc == 0) {
+		rc = ioctl_by_bdev(bdev, BIODASDINFO, (unsigned long) info);
+		blkdev_put(bdev, BDEV_FILE);
+	}
+	return rc;
+}
 
 /*
  * compute the block number from a 
@@ -106,100 +81,122 @@
 ibm_partition(struct gendisk *hd, kdev_t dev, unsigned long first_sector, int
 first_part_minor)
 {
-	struct buffer_head *bh, *buf;
-	ibm_partition_t partition_type;
+	struct block_device *bdev = bdget(dev);
+	int blocksize, offset, size;
+	dasd_information_t info;
+	struct hd_geometry geo;
+	struct buffer_head *bh;
 	char type[5] = {0,};
 	char name[7] = {0,};
-	struct hd_geometry geo;
-	int blocksize;
-	int offset=0, size=0, psize=0, counter=0;
-	unsigned int blk;
-	format1_label_t f1;
 	volume_label_t vlabel;
 
-	if ( first_sector != 0 ) {
+	if ( first_sector != 0 )
 		BUG();
-	}
-	if ( !genhd_dasd_fillgeo ) {
+
+	if (get_drive_info(bdev, &info) != 0 ||
+	    get_drive_geometry(bdev, &geo) != 0 ||
+	    hardsect_size[MAJOR(dev)][MINOR(dev)] <= 0)
 		return 0;
-	}
-	genhd_dasd_fillgeo(dev,&geo);
 	blocksize = hardsect_size[MAJOR(dev)][MINOR(dev)];
-	if ( blocksize <= 0 ) {
-		return 0;
-	}
 
+	/*
+	 * Get volume label, extract name and type.
+	 */
 	set_blocksize(dev, blocksize);  /* OUCH !! */
-	if ( ( bh = bread( dev, geo.start, blocksize) ) != NULL ) {
-		strncpy ( type,bh -> b_data + 0, 4);
-		strncpy ( name,bh -> b_data + 4, 6);
-		memcpy (&vlabel, bh->b_data, sizeof(volume_label_t));
-        } else {
+	if ((bh = bread(dev, info.label_block, blocksize)) == NULL)
 		return 0;
-	}
-	EBCASC(type,4);
-	EBCASC(name,6);
+	strncpy (type, bh->b_data, 4);
+	if ((!info.FBA_layout) && (!strcmp(info.type, "ECKD")))
+		strncpy(name, bh->b_data + 8, 6);
+	else
+		strncpy(name, bh->b_data + 4, 6);
+	memcpy (&vlabel, bh->b_data, sizeof(volume_label_t));
+	bforget(bh);
+
+	EBCASC(type, 4);
+	EBCASC(name, 6);
 
-	partition_type = get_partition_type(type);
-	printk ( "%6s/%6s:",part_names[partition_type],name);
-	switch ( partition_type ) {
-	case ibm_partition_cms1:
-		if (* (((long *)bh->b_data) + 13) != 0) {
+	/*
+	 * Three different types: CMS1, VOL1 and LNX1/unlabeled
+	 */
+	if (strncmp(type, "CMS1", 4) == 0) {
+		/*
+		 * VM style CMS1 labeled disk
+		 */
+		long *label = (long *) bh->b_data;
+
+		if (label[13] != 0) {
+			printk("CMS1/%8s(MDSK):", name);
 			/* disk is reserved minidisk */
-			long *label=(long*)bh->b_data;
 			blocksize = label[3];
 			offset = label[13];
-			size = (label[7]-1)*(blocksize>>9); 
-			printk ("(MDSK)");
+			size = (label[7] - 1)*(blocksize >> 9);
 		} else {
-			offset = (geo.start + 1);
-			size = hd -> sizes[MINOR(dev)]<<1;
+			printk("CMS1/%8s:", name);
+			offset = (info.label_block + 1);
+			size = hd->sizes[MINOR(dev)] << 1;
 		}
-		two_partitions( hd, MINOR(dev), blocksize, 
-				offset, size);
-		break;
-	case ibm_partition_lnx1: 
-	case ibm_partition_none:
-		offset = (geo.start + 1);
-		size = hd -> sizes[MINOR(dev)]<<1;
-		two_partitions( hd, MINOR(dev), blocksize, 
-				offset, size);
-		break;
-	case ibm_partition_vol1:
-		add_gd_partition(hd, MINOR(dev), 0, size);
-
-		/* get block number and read then first format1 label */
+		add_gd_partition( hd, MINOR(dev), 0, size);
+		add_gd_partition( hd, MINOR(dev)+1, offset*(blocksize >> 9),
+				  size-offset*(blocksize >> 9));
+	} else if (strncmp(type, "VOL1", 4) == 0) {
+		/*
+		 * New style VOL1 labeled disk
+		 */
+		unsigned int blk;
+		int counter;
+
+		printk("VOL1/%8s:", name);
+		add_gd_partition(hd, MINOR(dev), 0, hd->sizes[MINOR(dev)]<<1);
+		
+		/* get block number and read then go through format1 labels */
 		blk = cchhb2blk(&vlabel.vtoc, &geo) + 1;
-		if ((buf = bread( dev, blk, blocksize)) != NULL) {
-		        memcpy (&f1, buf->b_data, sizeof(format1_label_t));
-			bforget(buf);
-		}
+		counter = 1;
+		while ((bh = bread(dev, blk, blocksize)) != NULL) {
+			format1_label_t f1;
+
+			memcpy(&f1, bh->b_data, sizeof(format1_label_t));
+			bforget(bh);
+
+			/* skip FMT4 / FMT5 / FMT7 labels */
+			if (f1.DS1FMTID == _ascebc['4']
+			    || f1.DS1FMTID == _ascebc['5']
+			    || f1.DS1FMTID == _ascebc['7']) {
+			        blk++;
+				continue;
+			}
+
+			/* only FMT1 valid at this point */
+			if (f1.DS1FMTID != _ascebc['1'])
+				break;
 
-		while (f1.DS1FMTID == _ascebc['1']) {
+			/* OK, we got valid partition data */
 		        offset = cchh2blk(&f1.DS1EXT1.llimit, &geo);
-			psize  = cchh2blk(&f1.DS1EXT1.ulimit, &geo) - 
-				offset + 1;
-			
-			counter++;
+			size  = cchh2blk(&f1.DS1EXT1.ulimit, &geo) - 
+				offset + geo.sectors;
+			if (counter >= hd->max_p)
+				break;
 			add_gd_partition(hd, MINOR(dev) + counter, 
-					  offset * (blocksize >> 9),
-					  psize * (blocksize >> 9));
-			
+					 offset * (blocksize >> 9),
+					 size * (blocksize >> 9));
+			counter++;
 			blk++;
-			if ((buf = bread( dev, blk, blocksize)) != NULL) {
-			        memcpy (&f1, buf->b_data, 
-					sizeof(format1_label_t));
-				bforget(buf);
-			}
 		}
-		break;
-	default:
-		add_gd_partition( hd, MINOR(dev), 0, 0);
-		add_gd_partition( hd, MINOR(dev) + 1, 0, 0);
+	} else {
+		/*
+		 * Old style LNX1 or unlabeled disk
+		 */
+		if (strncmp(type, "LNX1", 4) == 0)
+			printk ("LNX1/%8s:", name);
+		else
+			printk("(nonl)/%8s:", name);
+		offset = (info.label_block + 1);
+		size = hd->sizes[MINOR(dev)] << 1;
+		add_gd_partition( hd, MINOR(dev), 0, size);
+		add_gd_partition( hd, MINOR(dev)+1, offset*(blocksize >> 9),
+				  size-offset*(blocksize >> 9));
 	}
 
-	printk ( "\n" );
-	bforget(bh);
+	printk("\n");
 	return 1;
 }
-
diff -urN linux/include/asm-alpha/pgalloc.h linux-2.4.7/include/asm-alpha/pgalloc.h
--- linux/include/asm-alpha/pgalloc.h	Thu May 24 18:20:18 2001
+++ linux-2.4.7/include/asm-alpha/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -343,4 +343,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _ALPHA_PGALLOC_H */
diff -urN linux/include/asm-arm/pgalloc.h linux-2.4.7/include/asm-arm/pgalloc.h
--- linux/include/asm-arm/pgalloc.h	Thu Apr 12 15:20:31 2001
+++ linux-2.4.7/include/asm-arm/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -138,4 +138,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif
diff -urN linux/include/asm-generic/pgalloc.h linux-2.4.7/include/asm-generic/pgalloc.h
--- linux/include/asm-generic/pgalloc.h	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/include/asm-generic/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -0,0 +1,34 @@
+#ifndef _ASM_GENERIC_PGALLOC_H
+#define _ASM_GENERIC_PGALLOC_H
+
+static inline int ptep_test_and_clear_and_flush_young(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
+{
+	if (!ptep_test_and_clear_young(ptep))
+		return 0;
+	flush_tlb_page(vma, address);
+	return 1;
+}
+
+static inline int ptep_test_and_clear_and_flush_dirty(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
+{
+	if (!ptep_test_and_clear_dirty(ptep))
+		return 0;
+	flush_tlb_page(vma, address);
+	return 1;
+}
+
+static inline void ptep_establish(struct vm_area_struct *vma, unsigned long address, pte_t *ptep, pte_t entry)
+{
+	set_pte(ptep, entry);
+	flush_tlb_page(vma, address);
+	update_mmu_cache(vma, address, entry);
+}
+
+static inline pte_t ptep_invalidate(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
+{
+	pte_t pte = ptep_get_and_clear(ptep);
+	flush_tlb_page(vma, address);
+	return pte;
+}
+
+#endif /* _ASM_GENERIC_PGALLOC_H */
diff -urN linux/include/asm-i386/pgalloc.h linux-2.4.7/include/asm-i386/pgalloc.h
--- linux/include/asm-i386/pgalloc.h	Fri Jul 20 15:52:18 2001
+++ linux-2.4.7/include/asm-i386/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -225,4 +225,6 @@
 	/* i386 does not keep any page table caches in TLB */
 }
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _I386_PGALLOC_H */
diff -urN linux/include/asm-ia64/pgalloc.h linux-2.4.7/include/asm-ia64/pgalloc.h
--- linux/include/asm-ia64/pgalloc.h	Mon Apr 23 18:28:07 2001
+++ linux-2.4.7/include/asm-ia64/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -273,4 +273,6 @@
 	set_bit(PG_arch_1, &page->flags);	/* mark page as clean */
 }
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _ASM_IA64_PGALLOC_H */
diff -urN linux/include/asm-m68k/pgalloc.h linux-2.4.7/include/asm-m68k/pgalloc.h
--- linux/include/asm-m68k/pgalloc.h	Mon Jun 11 22:15:27 2001
+++ linux-2.4.7/include/asm-m68k/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -162,4 +162,6 @@
 #include <asm/motorola_pgalloc.h>
 #endif
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* M68K_PGALLOC_H */
diff -urN linux/include/asm-mips/pgalloc.h linux-2.4.7/include/asm-mips/pgalloc.h
--- linux/include/asm-mips/pgalloc.h	Mon Jul  2 16:56:40 2001
+++ linux-2.4.7/include/asm-mips/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -177,4 +177,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _ASM_PGALLOC_H */
diff -urN linux/include/asm-mips64/pgalloc.h linux-2.4.7/include/asm-mips64/pgalloc.h
--- linux/include/asm-mips64/pgalloc.h	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/include/asm-mips64/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -197,4 +197,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _ASM_PGALLOC_H */
diff -urN linux/include/asm-parisc/pgalloc.h linux-2.4.7/include/asm-parisc/pgalloc.h
--- linux/include/asm-parisc/pgalloc.h	Mon Apr 23 18:28:07 2001
+++ linux-2.4.7/include/asm-parisc/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -401,4 +401,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif
diff -urN linux/include/asm-ppc/pgalloc.h linux-2.4.7/include/asm-ppc/pgalloc.h
--- linux/include/asm-ppc/pgalloc.h	Mon May 21 18:02:06 2001
+++ linux-2.4.7/include/asm-ppc/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -146,5 +146,7 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _PPC_PGALLOC_H */
 #endif /* __KERNEL__ */
diff -urN linux/include/asm-s390/atomic.h linux-2.4.7/include/asm-s390/atomic.h
--- linux/include/asm-s390/atomic.h	Tue Jul 10 00:27:45 2001
+++ linux-2.4.7/include/asm-s390/atomic.h	Mon Dec 17 13:42:42 2001
@@ -20,18 +20,18 @@
  * S390 uses 'Compare And Swap' for atomicity in SMP enviroment
  */
 
-typedef struct { volatile int counter; } atomic_t __attribute__ ((aligned (4)));
+typedef struct { volatile int counter; } __attribute__ ((aligned (4))) atomic_t;
 #define ATOMIC_INIT(i)  { (i) }
 
 #define atomic_eieio()          __asm__ __volatile__ ("BCR 15,0")
 
-#define __CS_LOOP(old, new, ptr, op_val, op_string)			\
+#define __CS_LOOP(old_val, new_val, ptr, op_val, op_string)		\
         __asm__ __volatile__("   l     %0,0(%2)\n"			\
                              "0: lr    %1,%0\n"				\
                              op_string "  %1,%3\n"			\
                              "   cs    %0,%1,0(%2)\n"			\
                              "   jl    0b"				\
-                             : "=&d" (old), "=&d" (new)			\
+                             : "=&d" (old_val), "=&d" (new_val)		\
 			     : "a" (ptr), "d" (op_val) : "cc" );
 
 static __inline__ int atomic_read(atomic_t *v)
@@ -52,80 +52,80 @@
 
 static __inline__ void atomic_add(int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "ar");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "ar");
 }
 
 static __inline__ int atomic_add_return (int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "ar");
-	return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "ar");
+	return new_val;
 }
 
 static __inline__ int atomic_add_negative(int i, atomic_t *v)
 {
-	int old, new;
-        __CS_LOOP(old, new, v, i, "ar");
-        return new < 0;
+	int old_val, new_val;
+        __CS_LOOP(old_val, new_val, v, i, "ar");
+        return new_val < 0;
 }
 
 static __inline__ void atomic_sub(int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "sr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "sr");
 }
 
 static __inline__ void atomic_inc(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
 }
 
 static __inline__ int atomic_inc_return(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
-        return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
+        return new_val;
 }
 
 static __inline__ int atomic_inc_and_test(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
-	return new != 0;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
+	return new_val != 0;
 }
 
 static __inline__ void atomic_dec(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
 }
 
 static __inline__ int atomic_dec_return(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
-        return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
+        return new_val;
 }
 
 static __inline__ int atomic_dec_and_test(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
-        return new == 0;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
+        return new_val == 0;
 }
 
 static __inline__ void atomic_clear_mask(unsigned long mask, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, ~mask, "nr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, ~mask, "nr");
 }
 
 static __inline__ void atomic_set_mask(unsigned long mask, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, mask, "or");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, mask, "or");
 }
 
 /*
diff -urN linux/include/asm-s390/bitops.h linux-2.4.7/include/asm-s390/bitops.h
--- linux/include/asm-s390/bitops.h	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/include/asm-s390/bitops.h	Mon Dec 17 13:41:20 2001
@@ -831,7 +831,7 @@
                         "   icm  %0,2,1(%1)\n"
                         "   icm  %0,4,2(%1)\n"
                         "   icm  %0,8,3(%1)"
-                        : "=&a" (word) : "a" (p) );
+                        : "=&a" (word) : "a" (p) : "cc" );
 		word >>= bit;
                 res = bit;
                 /* Look for zero in first longword */
diff -urN linux/include/asm-s390/byteorder.h linux-2.4.7/include/asm-s390/byteorder.h
--- linux/include/asm-s390/byteorder.h	Fri May 12 14:41:44 2000
+++ linux-2.4.7/include/asm-s390/byteorder.h	Mon Dec 17 13:41:20 2001
@@ -23,7 +23,7 @@
           "        icm   %0,4,2(%1)\n"
           "        icm   %0,2,1(%1)\n"
           "        ic    %0,0(%1)"
-          : "+&d" (x) : "a" (&temp) : "memory" );
+          : "+&d" (x) : "a" (&temp) : "cc" );
   return x;
 }
 
@@ -36,7 +36,7 @@
           "        icm   %0,4,2(%1)\n"
           "        icm   %0,2,1(%1)\n"
           "        ic    %0,0(%1)"
-          : "=&d" (result) : "a" (x) );
+          : "=&d" (result) : "a" (x) : "cc" );
   return result;
 }
 
@@ -48,7 +48,7 @@
           "        icm   0,2,1(%0)\n"
           "        ic    0,0(%0)\n"
           "        st    0,0(%0)"
-          : : "a" (x) : "0", "memory");
+          : : "a" (x) : "0", "memory", "cc");
 }
 
 static __inline__ __const__ __u16 ___arch__swab16(__u16 x)
@@ -59,7 +59,7 @@
           "        sth   %0,0(%1)\n"
           "        icm   %0,2,1(%1)\n"
           "        ic    %0,0(%1)\n"
-          : "+&d" (x) : "a" (&temp) : "memory");
+          : "+&d" (x) : "a" (&temp) : "memory", "cc" );
   return x;
 }
 
@@ -71,7 +71,7 @@
           "        sr    %0,%0\n"
           "        icm   %0,2,1(%1)\n"
           "        ic    %0,0(%1)\n"
-          : "=&d" (result) : "a" (x) );
+          : "=&d" (result) : "a" (x) : "cc" );
   return result;
 }
 
@@ -81,7 +81,7 @@
           "        icm   0,2,1(%0)\n"
           "        ic    0,0(%0)\n"
           "        sth   0,0(%0)"
-          : : "a" (x) : "0", "memory");
+          : : "a" (x) : "0", "memory", "cc" );
 }
 
 #define __arch__swab32(x) ___arch__swab32(x)
diff -urN linux/include/asm-s390/cache.h linux-2.4.7/include/asm-s390/cache.h
--- linux/include/asm-s390/cache.h	Fri May 12 14:41:44 2000
+++ linux-2.4.7/include/asm-s390/cache.h	Mon Dec 17 13:41:20 2001
@@ -11,6 +11,7 @@
 #ifndef __ARCH_S390_CACHE_H
 #define __ARCH_S390_CACHE_H
 
-#define L1_CACHE_BYTES     16
+#define L1_CACHE_BYTES     256
+#define L1_CACHE_SHIFT     8
 
 #endif
diff -urN linux/include/asm-s390/chandev.h linux-2.4.7/include/asm-s390/chandev.h
--- linux/include/asm-s390/chandev.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/chandev.h	Mon Dec 17 13:41:20 2001
@@ -6,49 +6,86 @@
  * 
  *  Generic channel device initialisation support. 
  */
+#ifndef __S390_CHANDEV_H
+#define __S390_CHANDEV_H
 #include <linux/version.h>
 #include <asm/types.h>
 #include <linux/netdevice.h>
 
+
+/* Setting this flag to true causes a device name to be built based on the read_devno of the device */
+/* this is exported so external code can look at this flags setting */
+extern int chandev_use_devno_names;
+
+
 /* chandev_type is a bitmask for registering & describing device types. */
 typedef enum
 {
-	none=0x0,
-	ctc=0x1,
-	escon=0x2,
-	lcs=0x4,
-	osad=0x8,
-	qeth=0x10,
-	claw=0x20,
+	chandev_type_none=0x0,
+	chandev_type_ctc=0x1,
+	chandev_type_escon=0x2,
+	chandev_type_lcs=0x4,
+	chandev_type_osad=0x8,
+	chandev_type_qeth=0x10,
+	chandev_type_claw=0x20,
 } chandev_type;
 
 typedef enum
 {
-	no_category,
-	network_device,
-	serial_device,
+	chandev_category_none,
+	chandev_category_network_device,
+	chandev_category_serial_device,
 } chandev_category;
 
+
+
+typedef struct
+{
+	int     irq;
+	u16     devno;
+	u16     cu_type;      /* control unit type */
+	u8      cu_model;     /* control unit model */
+	u16     dev_type;     /* device type */
+	u8      dev_model;    /* device model */
+	u8      pim;          /* path installed mask */
+	u8      chpid[8];     /* CHPID 0-7 (if available) */
+} chandev_subchannel_info;
+
+#define CLAW_NAMELEN 9
+/* CLAW specific parameters other drivers should ignore these fields */
+typedef struct
+{
+	
+	char	 host_name[CLAW_NAMELEN];    /* local host name */
+	char	 adapter_name[CLAW_NAMELEN]; /* workstation adapter name */
+	char	 api_type[CLAW_NAMELEN];     /* API type either TCPIP or API */
+} chandev_claw_info;
+
 /*
  * The chandev_probeinfo structure is passed to the device driver with configuration
  * info for which irq's & ports to use when attempting to probe the device.
  */
 typedef struct
 {
-        int     read_irq;
-	int     write_irq;
-	u16     read_devno;
-	u16     write_devno;
-        s16     port_protocol_no; /* -1 don't care */
+	chandev_subchannel_info read;
+	chandev_subchannel_info write;
+	chandev_subchannel_info data;
+	/* memory_usage_in_k is the suggested memory the driver should attempt to use for io */
+	/* buffers -1 means use the driver default the driver should set this field to the */
+	/* amount of memory it actually uses when returning this probeinfo to the channel */
+	/* device layer with chandev_initdevice */
+	s32     memory_usage_in_k;
+	chandev_claw_info       claw;
+	u8      data_exists; /* whether this device has a data channel */
+	u8      cu_dev_info_inconsistent; /* either ctc or we possibly had a bad sense_id */
+	u8      chpid_info_inconsistent;  /* either ctc or schib info bad */
+        s16     port_protocol_no; /* 0 by default, set specifically when forcing */
 	u8      hint_port_no;   /* lcs specific */
-	u8      max_port_no;    /* lcs specific */
+	u8      max_port_no;    /* lcs/qeth specific */
 	chandev_type chan_type;
 	u8      checksum_received_ip_pkts;
 	u8      use_hw_stats; /* where available e.g. lcs */
-	u16     cu_type;      /* control unit type */
-	u8      cu_model;     /* control unit model */
-	u16     dev_type;     /* device type */
-	u8      dev_model;    /* device model */
+	u8      device_forced; /* indicates the device hasn't been autodetected */
 	char    *parmstr;       /* driver specific parameters added by add_parms keyword */
 	/* newdevice used internally by chandev.c */
 	struct  chandev_activelist *newdevice; 
@@ -75,19 +112,21 @@
 
 typedef enum
 {
-	good=0,
-	not_oper,
-	first_msck=not_oper,
-	no_path,
-	revalidate,
-	gone,
-	last_msck,
+	chandev_status_good,
+	chandev_status_not_oper,
+	chandev_status_first_msck=chandev_status_not_oper,
+	chandev_status_no_path,
+	chandev_status_revalidate,
+	chandev_status_gone,
+	chandev_status_last_msck,
+	chandev_status_all_chans_good /* pseudo machine check to indicate all channels are healthy */
 } chandev_msck_status;
 
 typedef int (*chandev_probefunc)(chandev_probeinfo *probeinfo);
-typedef void (*chandev_shutdownfunc)(void *device);
+typedef int (*chandev_shutdownfunc)(void *device);
 typedef void (*chandev_unregfunc)(void *device);
-typedef void (*chandev_reoperfunc)(void *device,int msck_for_read_chan,chandev_msck_status prevstatus);
+typedef void (*chandev_msck_notification_func)(void *device,int msck_irq,
+chandev_msck_status prevstatus,chandev_msck_status newstatus);
 
 
 
@@ -100,10 +139,14 @@
  * not operational the previous status is sent in the prevstatus variable.
  * This can be used in cases when the default handling isn't quite adequete
  * e.g. if a ssch is needed to reinitialize long running channel programs.
+ *
+ * This returns the number of devices found or -ENOMEM if the code didn't
+ * have enough memory to allocate the chandev control block
+ * or -EPERM if a duplicate entry is found.
  */
 int chandev_register_and_probe(chandev_probefunc probefunc,
 			       chandev_shutdownfunc shutdownfunc,
-			       chandev_reoperfunc reoperfunc,
+			       chandev_msck_notification_func msck_notfunc,
 			       chandev_type chan_type);
 
 /* The chandev_unregister function is typically called when a module is being removed 
@@ -117,6 +160,33 @@
 int chandev_initdevice(chandev_probeinfo *probeinfo,void *dev_ptr,u8 port_no,char *devname,
 chandev_category category,chandev_unregfunc unreg_dev);
 
+/* This function builds a device name & copies it into destnamebuff suitable for calling 
+   init_trdev or whatever & it honours the use_devno_names flag, it is used by chandev_initnetdevice 
+   setting the buildfullname flag to TRUE will cause it to always build a full unique name based 
+   on basename either honouring the chandev_use_devno_names flag if set or starting at index 
+   0 & checking the namespace of the channel device layer itself for a free index, this
+   may be useful when one doesn't have control of the name an upper layer may choose.
+   It returns NULL on error.
+*/
+char *chandev_build_device_name(chandev_probeinfo *probeinfo,char *destnamebuff,char *basename,int buildfullname);
+
+
+
+
+/* chandev_init_netdev registers with the normal network device layer */
+/* it doesn't update any of the chandev internal structures. */
+/* i.e. it is optional */
+/* it was part of chandev_initnetdevice but I separated it as */
+/* chandev_initnetdevice may make too many assumptions for some users */
+/* chandev_initnetdevice = chandev_initdevice followed by chandev_init_netdev */
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
+struct net_device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct net_device *dev, int sizeof_priv,struct net_device *(*init_netdevfunc)(struct net_device *dev, int sizeof_priv));
+#else
+struct device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct device *dev, int sizeof_priv,struct device *(*init_netdevfunc)(struct device *dev, int sizeof_priv));
+#endif
+
 /* chandev_initnetdevice registers a network device with the channel layer. 
  * It returns the device structure if successful,if dev=NULL it kmallocs it, 
  * On device initialisation failure it will kfree it under ALL curcumstances
@@ -148,8 +218,18 @@
 				     void (*unreg_netdevfunc)(struct device *dev));
 #endif
 
-
-
+/* chandev_add & delete model shouldn't normally be needed by drivers except if */
+/* someone is developing a driver which the channel device layer doesn't know about */
+void chandev_add_model(chandev_type chan_type,s32 cu_type,s16 cu_model,
+		       s32 dev_type,s16 dev_model,u8 max_port_no,int auto_msck_recovery,
+		        u8 default_checksum_received_ip_pkts,u8 default_use_hw_stats);
+void chandev_del_model(s32 cu_type,s16 cu_model,s32 dev_type,s16 dev_model);
+
+/* modules should use chandev_persist to see if they should stay loaded */
+/* this is useful for debugging purposes where you may wish to examine */
+/* /proc/s390dbf/ entries */
+int chandev_persist(chandev_type chan_type);
+#endif /* __S390_CHANDEV_H */
 
 
 
diff -urN linux/include/asm-s390/checksum.h linux-2.4.7/include/asm-s390/checksum.h
--- linux/include/asm-s390/checksum.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/checksum.h	Mon Dec 17 13:41:20 2001
@@ -67,19 +67,26 @@
  *
  * here even more important to align src and dst on a 32-bit (or even
  * better 64-bit) boundary
+ *
+ * Copy from userspace and compute checksum.  If we catch an exception
+ * then zero the rest of the buffer.
  */
-
 extern inline unsigned int 
-csum_partial_copy_from_user(const char *src, char *dst,
-                            int len, unsigned int sum, int *errp)
+csum_partial_copy_from_user (const char *src, char *dst,
+                                          int len, unsigned int sum,
+                                          int *err_ptr)
 {
-	if (copy_from_user(dst, src, len)) {
-		*errp = -EFAULT;
-		memset(dst, 0, len);
-		return sum;
-        }
-        return csum_partial(dst, len, sum);
+	int missing;
+
+	missing = copy_from_user(dst, src, len);
+	if (missing) {
+		memset(dst + len - missing, 0, missing);
+		*err_ptr = -EFAULT;
+	}
+		
+	return csum_partial(dst, len, sum);
 }
+
 
 extern inline unsigned int
 csum_partial_copy_nocheck (const char *src, char *dst, int len, unsigned int sum)
diff -urN linux/include/asm-s390/current.h linux-2.4.7/include/asm-s390/current.h
--- linux/include/asm-s390/current.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/current.h	Mon Dec 17 13:41:49 2001
@@ -19,8 +19,8 @@
 {
         struct task_struct *current;
         __asm__("lhi   %0,-8192\n\t"
-                "nr    %0,15"
-                : "=&r" (current) );
+                "al    %0,0xc40"
+                : "=&r" (current) : : "cc" );
         return current;
  }
 
diff -urN linux/include/asm-s390/dasd.h linux-2.4.7/include/asm-s390/dasd.h
--- linux/include/asm-s390/dasd.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/dasd.h	Mon Dec 17 13:41:49 2001
@@ -4,43 +4,40 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
+ * This file is the interface of the DASD device driver, which is exported to user space
+ * any future changes wrt the API will result in a change of the APIVERSION reported
+ * to userspace by the DASDAPIVER-ioctl
+ *
  * History of changes (starts July 2000)
- * 02/01/01 added dynamic registration of ioctls
+ * 05/04/01 created by moving the kernel interface to drivers/s390/block/dasd_int.h
  */
 
 #ifndef DASD_H
 #define DASD_H
-
-#undef ERP_DEBUG               /* enable debug messages */
-#undef ERP_FULL_ERP            /* enable full ERP - experimental code !!!! */
-#define CONFIG_DASD_DYNAMIC
-
 #include <linux/ioctl.h>
-#include <asm/irq.h>
 
-#define IOCTL_LETTER 'D'
-/* Disable the volume (for Linux) */
-#define BIODASDDISABLE _IO(IOCTL_LETTER,0) 
-/* Enable the volume (for Linux) */
-#define BIODASDENABLE  _IO(IOCTL_LETTER,1) 
-/* Issue a reserve/release command, rsp. */
-#define BIODASDRSRV    _IO(IOCTL_LETTER,2) /* reserve */
-#define BIODASDRLSE    _IO(IOCTL_LETTER,3) /* release */
-#define BIODASDSLCK    _IO(IOCTL_LETTER,4) /* steal lock */
-/* Read sense ID infpormation */
-#define BIODASDRSID    _IOR(IOCTL_LETTER,0,senseid_t)
-/* Format the volume or an extent */
-#define BIODASDFORMAT  _IOW(IOCTL_LETTER,0,format_data_t) 
-/* translate blocknumber of partition to absolute */
-#define BIODASDRWTB    _IOWR(IOCTL_LETTER,0,int)
+#define DASD_IOCTL_LETTER 'D'
 
-typedef int(*dasd_ioctl_fn_t) (struct inode *inp, int no, long args);
-int dasd_ioctl_no_register(int no, dasd_ioctl_fn_t handler);
-int dasd_ioctl_no_unregister(int no, dasd_ioctl_fn_t handler);
+#if (DASD_API_VERSION == 0)
 
-#define DASD_NAME "dasd"
 #define DASD_PARTN_BITS 2
-#define DASD_PER_MAJOR ( 1U<<(MINORBITS-DASD_PARTN_BITS))
+
+/* 
+ * struct profile_info_t
+ * holds the profinling information 
+ */
+typedef struct dasd_profile_info_t {
+        unsigned int dasd_io_reqs;	 /* number of requests processed at all */
+        unsigned int dasd_io_sects;	 /* number of sectors processed at all */
+        unsigned int dasd_io_secs[32];	 /* histogram of request's sizes */
+        unsigned int dasd_io_times[32];	 /* histogram of requests's times */
+        unsigned int dasd_io_timps[32];	 /* histogram of requests's times per sector */
+        unsigned int dasd_io_time1[32];	 /* histogram of time from build to start */
+        unsigned int dasd_io_time2[32];	 /* histogram of time from start to irq */
+        unsigned int dasd_io_time2ps[32]; /* histogram of time from start to irq */
+        unsigned int dasd_io_time3[32];	 /* histogram of time from irq to end */
+        unsigned int dasd_io_nr_req[32]; /* histogram of # of requests in chanq */
+} dasd_profile_info_t;
 
 /* 
  * struct format_data_t
@@ -50,334 +47,65 @@
 	int start_unit; /* from track */
 	int stop_unit;  /* to track */
 	int blksize;    /* sectorsize */
-        int intensity;  /* 0: normal, 1:record zero, 3:home address, 4 invalidate tracks */
-} __attribute__ ((packed)) format_data_t;
-
-#define DASD_FORMAT_DEFAULT_START_UNIT 0
-#define DASD_FORMAT_DEFAULT_STOP_UNIT -1
-#define DASD_FORMAT_DEFAULT_BLOCKSIZE -1
-#define DASD_FORMAT_DEFAULT_INTENSITY -1
-
-#define DASD_FORMAT_INTENS_WRITE_RECZERO 0x01
-#define DASD_FORMAT_INTENS_WRITE_HOMEADR 0x02
-#define DASD_FORMAT_INTENS_INVALIDATE    0x04
-#define DASD_FORMAT_INTENS_CDL 0x08
-#ifdef __KERNEL__
-#include <linux/version.h>
-#include <linux/major.h>
-#include <linux/wait.h>
-#include <asm/ccwcache.h>
-#include <linux/blk.h> 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-#include <linux/blkdev.h> 
-#include <linux/devfs_fs_kernel.h>
-#endif
-#include <linux/genhd.h>
-#include <linux/hdreg.h>
-#include <linux/compatmac.h>
+        int intensity;  
+} format_data_t;
 
-#include <asm/s390dyn.h>
-#include <asm/todclk.h>
-#include <asm/debug.h>
-
-/* Kernel Version Compatibility section */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
-typedef struct request *request_queue_t;
-#define block_device_operations file_operations
-#define __setup(x,y) struct dasd_device_t
-#define devfs_register_blkdev(major,name,ops) register_blkdev(major,name,ops)
-#define register_disk(dd,dev,partn,ops,size) \
-do { \
-	dd->sizes[MINOR(dev)] = size >> 1; \
-	resetup_one_dev(dd,MINOR(dev)>>DASD_PARTN_BITS); \
-} while(0)
-#define init_waitqueue_head(x) do { *x = NULL; } while(0)
-#define blk_cleanup_queue(x) do {} while(0)
-#define blk_init_queue(x...) do {} while(0)
-#define blk_queue_headactive(x...) do {} while(0)
-#define blk_queue_make_request(x) do {} while(0)
-#define list_empty(x) (0)
-#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
-do { \
-        blk_dev[d_major].request_fn = d_request_fn; \
-        blk_dev[d_major].queue = d_queue_fn; \
-        blk_dev[d_major].current_request = d_current; \
-} while(0)
-#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
-	major:D_MAJOR, \
-	major_name:D_NAME, \
-	minor_shift:D_PARTN_BITS, \
-	max_p:1 << D_PARTN_BITS, \
-	max_nr:D_PER_MAJOR, \
-	nr_real:D_PER_MAJOR,
-static inline struct request * 
-dasd_next_request( request_queue_t *queue ) 
-{
-    return *queue;
-}
-static inline void 
-dasd_dequeue_request( request_queue_t * q, struct request *req )
-{
-        *q = req->next;
-        req->next = NULL;
-}
-#else
-#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
-do { \
-        blk_dev[d_major].queue = d_queue_fn; \
-} while(0)
-#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
-	major:D_MAJOR, \
-	major_name:D_NAME, \
-	minor_shift:D_PARTN_BITS, \
-	max_p:1 << D_PARTN_BITS, \
-	nr_real:D_PER_MAJOR,
-static inline struct request * 
-dasd_next_request( request_queue_t *queue ) 
-{
-        return blkdev_entry_next_request(&queue->queue_head);
-}
-static inline void 
-dasd_dequeue_request( request_queue_t * q, struct request *req )
-{
-        blkdev_dequeue_request (req);
-}
-#endif
-
-/* dasd_range_t are used for dynamic device att-/detachment */
-typedef struct dasd_devreg_t {
-        devreg_t devreg; /* the devreg itself */
-        /* build a linked list of devregs, needed for cleanup */
-        struct list_head list;
-} dasd_devreg_t;
-
-typedef struct {
-	struct list_head list;
-	int no;
-	dasd_ioctl_fn_t handler;
-} dasd_ioctl_list_t;
-
-typedef enum {
-	dasd_era_fatal = -1,	/* no chance to recover              */
-	dasd_era_none = 0,	/* don't recover, everything alright */
-	dasd_era_msg = 1,	/* don't recover, just report...     */
-	dasd_era_recover = 2	/* recovery action recommended       */
-} dasd_era_t;
-
-/* BIT DEFINITIONS FOR SENSE DATA */
-#define DASD_SENSE_BIT_0 0x80
-#define DASD_SENSE_BIT_1 0x40
-#define DASD_SENSE_BIT_2 0x20
-#define DASD_SENSE_BIT_3 0x10
-
-#define check_then_set(where,from,to) \
-do { \
-        if ((*(where)) != (from) ) { \
-                printk (KERN_ERR PRINTK_HEADER "was %d\n", *(where)); \
-                BUG(); \
-        } \
-        (*(where)) = (to); \
-} while (0)
-
-#define DASD_MESSAGE(d_loglevel,d_device,d_string,d_args...)\
-do { \
-        int d_devno = d_device->devinfo.devno; \
-        int d_irq = d_device->devinfo.irq; \
-        char *d_name = d_device->name; \
-        int d_major = MAJOR(d_device->kdev); \
-        int d_minor = MINOR(d_device->kdev); \
-        printk(d_loglevel PRINTK_HEADER \
-               "/dev/%s(%d:%d),%04X IRQ0x%x:" \
-               d_string "\n",d_name,d_major,d_minor,d_devno,d_irq,d_args ); \
-} while(0)
-
-/* 
- * struct dasd_sizes_t
- * represents all data needed to access dasd with properly set up sectors
- */
-typedef
-struct dasd_sizes_t {
-	unsigned long blocks; /* size of volume in blocks */
-	unsigned int bp_block; /* bytes per block */
-	unsigned int s2b_shift; /* log2 (bp_block/512) */
-        unsigned int pt_block; /* from which block to read the partn table */
-} dasd_sizes_t;
-
-/* 
- * struct dasd_chanq_t 
- * represents a queue of channel programs related to a single device
- */
-typedef
-struct dasd_chanq_t {
-	ccw_req_t *head;
-	ccw_req_t *tail;
-} dasd_chanq_t;
-
-#define DASD_DEVICE_FORMAT_STRING "Device: %p"
-#define DASD_DEVICE_DEBUG_EVENT(d_level, d_device, d_str, d_data...)\
-do {\
-        if ( d_device->debug_area != NULL )\
-        debug_sprintf_event(d_device->debug_area,d_level,\
-                    DASD_DEVICE_FORMAT_STRING d_str "\n",\
-                    d_device, d_data);\
-} while(0);
-#define DASD_DEVICE_DEBUG_EXCEPTION(d_level, d_device, d_str, d_data...)\
-do {\
-        if ( d_device->debug_area != NULL )\
-        debug_sprintf_exception(d_device->debug_area,d_level,\
-                        DASD_DEVICE_FORMAT_STRING d_str "\n",\
-                        d_device, d_data);\
-} while(0);
-
-#define DASD_DRIVER_FORMAT_STRING "Driver: <[%p]>"
-#define DASD_DRIVER_DEBUG_EVENT(d_level, d_fn, d_str, d_data...)\
-do {\
-        if ( dasd_debug_area != NULL )\
-        debug_sprintf_event(dasd_debug_area, d_level,\
-                    DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
-                    d_fn, d_data);\
-} while(0);
-#define DASD_DRIVER_DEBUG_EXCEPTION(d_level, d_fn, d_str, d_data...)\
-do {\
-        if ( dasd_debug_area != NULL )\
-        debug_sprintf_exception(dasd_debug_area, d_level,\
-                        DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
-                        d_fn, d_data);\
-} while(0);
-
-struct dasd_device_t;
-struct request;
+/*
+ * values to be used for format_data_t.intensity
+ * 0/8: normal format
+ * 1/9: also write record zero
+ * 3/11: also write home address
+ * 4/12: invalidate track
+ */
+#define DASD_FMT_INT_FMT_R0 1 /* write record zero */
+#define DASD_FMT_INT_FMT_HA 2 /* write home address, also set FMT_R0 ! */
+#define DASD_FMT_INT_INVAL  4 /* invalidate tracks */
+#define DASD_FMT_INT_COMPAT 8 /* use OS/390 compatible disk layout */
 
 /* 
- * signatures for the functions of dasd_discipline_t 
- * make typecasts much easier
- */
-typedef ccw_req_t *(*dasd_erp_action_fn_t) (ccw_req_t * cqr);
-typedef ccw_req_t *(*dasd_erp_postaction_fn_t) (ccw_req_t * cqr);
-
-typedef int (*dasd_ck_id_fn_t) (s390_dev_info_t *);
-typedef int (*dasd_ck_characteristics_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_fill_geometry_fn_t) (struct dasd_device_t *, struct hd_geometry *);
-typedef ccw_req_t *(*dasd_format_fn_t) (struct dasd_device_t *, struct format_data_t *);
-typedef ccw_req_t *(*dasd_init_analysis_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_do_analysis_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_io_starter_fn_t) (ccw_req_t *);
-typedef void (*dasd_int_handler_fn_t)(int irq, void *, struct pt_regs *);
-typedef dasd_era_t (*dasd_error_examine_fn_t) (ccw_req_t *, devstat_t * stat);
-typedef dasd_erp_action_fn_t (*dasd_error_analyse_fn_t) (ccw_req_t *);
-typedef dasd_erp_postaction_fn_t (*dasd_erp_analyse_fn_t) (ccw_req_t *);
-typedef ccw_req_t *(*dasd_cp_builder_fn_t)(struct dasd_device_t *,struct request *);
-typedef char *(*dasd_dump_sense_fn_t)(struct dasd_device_t *,ccw_req_t *);
-typedef ccw_req_t *(*dasd_reserve_fn_t)(struct dasd_device_t *);
-typedef ccw_req_t *(*dasd_release_fn_t)(struct dasd_device_t *);
-typedef ccw_req_t *(*dasd_merge_cp_fn_t)(struct dasd_device_t *);
-
-
-/*
- * the dasd_discipline_t is
- * sth like a table of virtual functions, if you think of dasd_eckd
- * inheriting dasd...
- * no, currently we are not planning to reimplement the driver in C++
+ * struct dasd_information_t
+ * represents any data about the data, which is visible to userspace
  */
-typedef struct dasd_discipline_t {
-	char ebcname[8]; /* a name used for tagging and printks */
-        char name[8];		/* a name used for tagging and printks */
-	int max_blocks;	/* maximum number of blocks to be chained */
-	dasd_ck_id_fn_t id_check;	/* to check sense data */
-	dasd_ck_characteristics_fn_t check_characteristics;	/* to check the characteristics */
-	dasd_init_analysis_fn_t init_analysis;	/* to start the analysis of the volume */
-	dasd_do_analysis_fn_t do_analysis;	/* to complete the analysis of the volume */
-	dasd_fill_geometry_fn_t fill_geometry;	/* to set up hd_geometry */
-	dasd_io_starter_fn_t start_IO;
-        dasd_format_fn_t format_device;		/* to format the device */
-	dasd_error_examine_fn_t examine_error;
-	dasd_error_analyse_fn_t erp_action;
-	dasd_erp_analyse_fn_t erp_postaction;
-        dasd_cp_builder_fn_t build_cp_from_req;
-        dasd_dump_sense_fn_t dump_sense;
-        dasd_int_handler_fn_t int_handler;
-        dasd_reserve_fn_t reserve;
-        dasd_release_fn_t release;
-        dasd_merge_cp_fn_t merge_cp;
-	
-	struct dasd_discipline_t *next;	/* used for list of disciplines */
-} dasd_discipline_t;
-
-#define DASD_MAJOR_INFO_REGISTERED 1
-#define DASD_MAJOR_INFO_IS_STATIC 2
-
-typedef struct major_info_t {
-	struct list_head list;
-	struct dasd_device_t **dasd_device;
-	int flags;
-	struct gendisk gendisk; /* actually contains the major number */
-} __attribute__ ((packed)) major_info_t;
-
-typedef struct dasd_profile_info_t {
-        unsigned long dasd_io_reqs;	/* number of requests processed at all */
-        unsigned long dasd_io_secs[32];	/* histogram of request's sizes */
-        unsigned long dasd_io_times[32];	/* histogram of requests's times */
-        unsigned long dasd_io_timps[32];	/* histogram of requests's times per sector */
-        unsigned long dasd_io_time1[32];	/* histogram of time from build to start */
-       unsigned  long dasd_io_time2[32];	/* histogram of time from start to irq */
-        unsigned long dasd_io_time2ps[32];	/* histogram of time from start to irq */
-        unsigned long dasd_io_time3[32];	/* histogram of time from irq to end */
-} dasd_profile_info_t;
-
-typedef struct dasd_device_t {
-	s390_dev_info_t devinfo;
-	dasd_discipline_t *discipline;
-	int level;
-        int open_count;
-        kdev_t kdev;
-        major_info_t *major_info;
-	struct dasd_chanq_t queue;
-        wait_queue_head_t wait_q;
-        request_queue_t request_queue;
-        struct timer_list timer;      
-	devstat_t dev_status; /* needed ONLY!! for request_irq */
-        dasd_sizes_t sizes;
-        char name[16]; /* The name of the device in /dev */
-	char *private;	/* to be used by the discipline internally */
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-        devfs_handle_t devfs_entry;
-#endif /* LINUX_IS_24 */
-	struct tq_struct bh_tq;
-        atomic_t bh_scheduled;
-        debug_info_t *debug_area;
-        dasd_profile_info_t profile;
-        struct proc_dir_entry *proc_dir; /* directory node */
-        struct proc_dir_entry *proc_info; /* information from dasd_device_t */
-        struct proc_dir_entry *proc_stats; /* statictics information */
-}  dasd_device_t;
-
-/* dasd_device_t.level can be: */
-#define DASD_DEVICE_LEVEL_UNKNOWN 0x00
-#define DASD_DEVICE_LEVEL_RECOGNIZED 0x01
-#define DASD_DEVICE_LEVEL_ANALYSIS_PENDING 0x02
-#define DASD_DEVICE_LEVEL_ANALYSIS_PREPARED 0x04
-#define DASD_DEVICE_LEVEL_ANALYSED 0x08
-#define DASD_DEVICE_LEVEL_ONLINE 0x10
-
-int dasd_init (void);
-void dasd_discipline_enq (dasd_discipline_t *);
-int dasd_discipline_deq(dasd_discipline_t *);
-int dasd_start_IO (ccw_req_t *);
-void dasd_int_handler (int , void *, struct pt_regs *);
-ccw_req_t *default_erp_action (ccw_req_t *);
-ccw_req_t *default_erp_postaction (ccw_req_t *);
-int dasd_chanq_deq (dasd_chanq_t *, ccw_req_t *);
-ccw_req_t *dasd_alloc_request (char *, int, int);
-void dasd_free_request (ccw_req_t *);
-extern int (*genhd_dasd_name) (char *, int, int, struct gendisk *);
-extern int (*genhd_dasd_fillgeo) (int, struct hd_geometry *);
-int dasd_oper_handler (int irq, devreg_t * devreg);
-void dasd_schedule_bh (dasd_device_t *);
-
-debug_info_t *dasd_debug_area;
-
-#endif /* __KERNEL__ */
+typedef struct dasd_information_t {
+        unsigned int devno; /* S/390 devno */
+        unsigned int real_devno; /* for aliases */
+        unsigned int schid; /* S/390 subchannel identifier */
+        unsigned int cu_type  : 16; /* from SenseID */
+        unsigned int cu_model :  8; /* from SenseID */
+        unsigned int dev_type : 16; /* from SenseID */
+        unsigned int dev_model : 8; /* from SenseID */
+        unsigned int open_count; 
+        unsigned int req_queue_len; 
+        unsigned int chanq_len;
+        char type[4]; /* from discipline.name, 'none' for unknown */
+        unsigned int status; /* current device level */
+        unsigned int label_block; /* where to find the VOLSER */
+        unsigned int FBA_layout; /* fixed block size (like AIXVOL) */
+        unsigned int characteristics_size;
+        unsigned int confdata_size;
+        char characteristics[64]; /* from read_device_characteristics */
+        char configuration_data[256]; /* from read_configuration_data */
+} dasd_information_t;
 
+/* Disable the volume (for Linux) */
+#define BIODASDDISABLE _IO(DASD_IOCTL_LETTER,0) 
+/* Enable the volume (for Linux) */
+#define BIODASDENABLE  _IO(DASD_IOCTL_LETTER,1)  
+/* Issue a reserve/release command, rsp. */
+#define BIODASDRSRV    _IO(DASD_IOCTL_LETTER,2) /* reserve */
+#define BIODASDRLSE    _IO(DASD_IOCTL_LETTER,3) /* release */
+#define BIODASDSLCK    _IO(DASD_IOCTL_LETTER,4) /* steal lock */
+/* reset profiling information of a device */
+#define BIODASDPRRST   _IO(DASD_IOCTL_LETTER,5)
+/* retrieve API version number */
+#define DASDAPIVER     _IOR(DASD_IOCTL_LETTER,0,int)
+/* Get information on a dasd device */
+#define BIODASDINFO    _IOR(DASD_IOCTL_LETTER,1,dasd_information_t)
+/* retrieve profiling information of a device */
+#define BIODASDPRRD    _IOR(DASD_IOCTL_LETTER,2,dasd_profile_info_t)
+/* #define BIODASDFORMAT  _IOW(IOCTL_LETTER,0,format_data_t) , deprecated */
+#define BIODASDFMT     _IOW(DASD_IOCTL_LETTER,1,format_data_t) 
+#endif /* DASD_API_VERSION */
 #endif				/* DASD_H */
 
 /*
diff -urN linux/include/asm-s390/debug.h linux-2.4.7/include/asm-s390/debug.h
--- linux/include/asm-s390/debug.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/debug.h	Mon Dec 17 13:41:49 2001
@@ -44,6 +44,7 @@
 
 #define DEBUG_MAX_LEVEL            6  /* debug levels range from 0 to 6 */
 #define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
+#define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
 #define DEBUG_MAX_VIEWS            10 /* max number of views in proc fs */
 #define DEBUG_MAX_PROCF_LEN        16 /* max length for a proc file name */
 #define DEBUG_DEFAULT_LEVEL        3  /* initial debug level */
@@ -53,7 +54,7 @@
 #define DEBUG_DATA(entry) (char*)(entry + 1) /* data is stored behind */
                                              /* the entry information */
 
-#define STCK(x)	asm volatile ("STCK %0":"=m" (x))
+#define STCK(x)	asm volatile ("STCK %0" : "=m" (x) : : "cc" )
 
 typedef struct __debug_entry debug_entry_t;
 
diff -urN linux/include/asm-s390/div64.h linux-2.4.7/include/asm-s390/div64.h
--- linux/include/asm-s390/div64.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/div64.h	Mon Dec 17 13:41:20 2001
@@ -36,7 +36,7 @@
 	     "1: st   1,4+%1\n"					\
              "   lr   %0,0"					\
 	     : "=d" (__r), "+m" (__n)				\
-	     : "d" (base) : "0", "1", "2" );			\
+	     : "d" (base) : "0", "1", "2", "cc" );		\
 	(n) = (__n);						\
         __r;                                                    \
 })
diff -urN linux/include/asm-s390/gdb-stub.h linux-2.4.7/include/asm-s390/gdb-stub.h
--- linux/include/asm-s390/gdb-stub.h	Fri May 12 14:41:44 2000
+++ linux-2.4.7/include/asm-s390/gdb-stub.h	Mon Dec 17 13:42:42 2001
@@ -10,9 +10,13 @@
 #define __S390_GDB_STUB__
 #include <linux/config.h>
 #if CONFIG_REMOTE_DEBUG
-#include <asm/s390-gdbregs.h>
 #include <asm/ptrace.h>
 extern int    gdb_stub_initialised;
-extern void gdb_stub_handle_exception(gdb_pt_regs *regs,int sigval);
+extern void gdb_stub_handle_exception(struct gdb_pt_regs *regs,int sigval);
+struct net_device;
+extern struct net_device *gdb_dev;
+void gdb_do_timers(void);
+extern int putDebugChar(char c);    /* write a single character      */
+extern char getDebugChar(void);     /* read and return a single char */
 #endif
 #endif
diff -urN linux/include/asm-s390/hardirq.h linux-2.4.7/include/asm-s390/hardirq.h
--- linux/include/asm-s390/hardirq.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/hardirq.h	Mon Dec 17 13:41:20 2001
@@ -17,44 +17,28 @@
 #include <asm/lowcore.h>
 #include <linux/sched.h>
 
-/* No irq_cpustat_t for s390, the data is held directly in S390_lowcore */
+/* entry.S is sensitive to the offsets of these fields */
+typedef struct {
+	unsigned int __softirq_pending;
+	unsigned int __local_irq_count;
+	unsigned int __local_bh_count;
+	unsigned int __syscall_count;
+	struct task_struct * __ksoftirqd_task; /* waitqueue is too large */
+} ____cacheline_aligned irq_cpustat_t;
 
-/*
- * Simple wrappers reducing source bloat.  S390 specific because each
- * cpu stores its data in S390_lowcore (PSA) instead of using a cache
- * aligned array element like most architectures.
- */
-
-#ifdef CONFIG_SMP
-
-#define softirq_active(cpu)	(safe_get_cpu_lowcore(cpu).__softirq_active)
-#define softirq_mask(cpu)	(safe_get_cpu_lowcore(cpu).__softirq_mask)
-#define local_irq_count(cpu)	(safe_get_cpu_lowcore(cpu).__local_irq_count)
-#define local_bh_count(cpu)	(safe_get_cpu_lowcore(cpu).__local_bh_count)
-#define syscall_count(cpu)	(safe_get_cpu_lowcore(cpu).__syscall_count)
-
-#else	/* CONFIG_SMP */
-
-/* Optimize away the cpu calculation, it is always current PSA */
-#define softirq_active(cpu)	((void)(cpu), S390_lowcore.__softirq_active)
-#define softirq_mask(cpu)	((void)(cpu), S390_lowcore.__softirq_mask)
-#define local_irq_count(cpu)	((void)(cpu), S390_lowcore.__local_irq_count)
-#define local_bh_count(cpu)	((void)(cpu), S390_lowcore.__local_bh_count)
-#define syscall_count(cpu)	((void)(cpu), S390_lowcore.__syscall_count)
-
-#endif	/* CONFIG_SMP */
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
 
 /*
  * Are we in an interrupt context? Either doing bottom half
  * or hardware interrupt processing?
- * Special definitions for s390, always access current PSA.
  */
-#define in_interrupt() ((S390_lowcore.__local_irq_count + S390_lowcore.__local_bh_count) != 0)
-  
-#define in_irq() (S390_lowcore.__local_irq_count != 0)
+#define in_interrupt() ({ int __cpu = smp_processor_id(); \
+	(local_irq_count(__cpu) + local_bh_count(__cpu) != 0); })
+
+#define in_irq() (local_irq_count(smp_processor_id()) != 0)
   
 #ifndef CONFIG_SMP
-  
+
 #define hardirq_trylock(cpu)	(local_irq_count(cpu) == 0)
 #define hardirq_endlock(cpu)	do { } while (0)
   
@@ -63,7 +47,7 @@
 
 #define synchronize_irq()	do { } while (0)
 
-#else
+#else	/* CONFIG_SMP */
 
 #include <asm/atomic.h>
 #include <asm/smp.h>
@@ -77,7 +61,7 @@
 	/* if we didn't own the irq lock, just ignore.. */
 	if (atomic_read(&global_irq_holder) ==  cpu) {
 		atomic_set(&global_irq_holder,NO_PROC_ID);
-		clear_bit(0,&global_irq_lock);
+		atomic_set(&global_irq_lock,0);
 	}
 }
 
@@ -95,13 +79,14 @@
 
 static inline int hardirq_trylock(int cpu)
 {
-	return !atomic_read(&global_irq_count) && !test_bit(0,&global_irq_lock);
+	return !atomic_read(&global_irq_count) &&
+	       !atomic_read(&global_irq_lock);
 }
 
 #define hardirq_endlock(cpu)	do { } while (0)
 
 extern void synchronize_irq(void);
 
-#endif /* CONFIG_SMP */
+#endif	/* CONFIG_SMP */
 
 #endif /* __ASM_HARDIRQ_H */
diff -urN linux/include/asm-s390/idals.h linux-2.4.7/include/asm-s390/idals.h
--- linux/include/asm-s390/idals.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/idals.h	Mon Dec 17 13:41:20 2001
@@ -10,36 +10,51 @@
 #include <linux/config.h>
 #include <asm/irq.h>
 
-typedef unsigned long idaw_t;
+#define IDA_SIZE_LOG 12 /* 11 for 2k , 12 for 4k */
+#define IDA_BLOCK_SIZE (1L<<IDA_SIZE_LOG)
 
-static inline idaw_t *
+static inline addr_t *
 idal_alloc ( int nridaws )
 {
 	if ( nridaws > 33 )
 		BUG();
-	return kmalloc(nridaws * sizeof(idaw_t), GFP_ATOMIC | GFP_DMA );
+	return kmalloc(nridaws * sizeof(addr_t), GFP_ATOMIC | GFP_DMA );
 }
 
 static inline void 
-idal_free ( idaw_t *idal )
+idal_free ( addr_t *idal )
 {
 	kfree (idal);
 }
 
+#if defined(CONFIG_ARCH_S390X)
+extern unsigned long __create_idal(unsigned long address, int count);
+#endif
+
 /*
  * Function: set_normalized_cda
  * sets the address of the data in CCW
  * if necessary it allocates an IDAL and sets sthe appropriate flags
  */
-#if defined (CONFIG_ARCH_S390X)
-extern void set_normalized_cda(ccw1_t * ccw, unsigned long address);
-#else
-static inline void
+static inline int
 set_normalized_cda(ccw1_t * ccw, unsigned long address)
 {
-	ccw->cda = address;
-}
+	int ret = 0;
+
+#if defined (CONFIG_ARCH_S390X)
+	if (((address + ccw->count) >> 31) != 0) {
+		if (ccw->flags & CCW_FLAG_IDA)
+			BUG();
+		address = __create_idal(address, ccw->count);
+		if (address)
+			ccw->flags |= CCW_FLAG_IDA;
+		else
+			ret = -ENOMEM;
+	}
 #endif
+	ccw->cda = (__u32) address;
+	return ret;
+}
 
 /*
  * Function: clear_normalized_cda
@@ -48,10 +63,12 @@
 static inline void
 clear_normalized_cda ( ccw1_t * ccw ) 
 {
+#if defined(CONFIG_ARCH_S390X)
 	if ( ccw -> flags & CCW_FLAG_IDA ) {
-		idal_free ( (idaw_t *) (ccw -> cda ));
+		idal_free ( (addr_t *)(unsigned long) (ccw -> cda ));
 		ccw -> flags &= ~CCW_FLAG_IDA;
 	}
+#endif
 	ccw -> cda = 0;
 }
 
diff -urN linux/include/asm-s390/init.h linux-2.4.7/include/asm-s390/init.h
--- linux/include/asm-s390/init.h	Fri May 12 14:41:44 2000
+++ linux-2.4.7/include/asm-s390/init.h	Mon Dec 17 13:41:20 2001
@@ -23,7 +23,7 @@
 #define __INITDATA      .section        ".data.init",#alloc,#write
 */
 
-#define __cacheline_aligned __attribute__ ((__aligned__(16)))
+#define __cacheline_aligned __attribute__ ((__aligned__(256)))
 
 #endif
 
diff -urN linux/include/asm-s390/io.h linux-2.4.7/include/asm-s390/io.h
--- linux/include/asm-s390/io.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/io.h	Mon Dec 17 13:41:20 2001
@@ -31,7 +31,7 @@
                  "   jz     0f\n"
                  "   sr     %0,%0\n"
                  "0:"
-                 : "=a" (real_address) : "a" (address) );
+                 : "=a" (real_address) : "a" (address) : "cc" );
         return real_address;
 }
 
diff -urN linux/include/asm-s390/irq.h linux-2.4.7/include/asm-s390/irq.h
--- linux/include/asm-s390/irq.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/irq.h	Mon Dec 17 13:43:29 2001
@@ -313,7 +313,7 @@
       scsw_t scsw;             /* subchannel status word */
       esw_t  esw;              /* extended status word */
       __u8   ecw[32];          /* extended control word */
-   } irb_t __attribute__ ((packed,aligned(4)));
+   } __attribute__ ((packed,aligned(4))) irb_t;
 #ifdef __KERNEL__
 
 /*
@@ -572,6 +572,10 @@
 extern int set_cons_dev(int irq);
 extern int reset_cons_dev(int irq);
 extern int wait_cons_dev(int irq);
+extern schib_t *s390_get_schib( int irq );
+
+extern int s390_register_adapter_interrupt(adapter_int_handler_t handler);
+extern int s390_unregister_adapter_interrupt(adapter_int_handler_t handler);
 
 /*
  * Some S390 specific IO instructions as inline
@@ -626,11 +630,6 @@
                 "   .align 8\n"
                 "   .quad 0b,2b\n"
                 ".previous"
-                "    lr   1,%1\n"
-                "    msch 0(%2)\n"
-                "0:  ipm  %0\n"
-                "    srl  %0,28\n"
-                "1:\n"
 #else
                 ".section .fixup,\"ax\"\n"
                 "2:  l    %0,%3\n"
diff -urN linux/include/asm-s390/lowcore.h linux-2.4.7/include/asm-s390/lowcore.h
--- linux/include/asm-s390/lowcore.h	Fri Mar  2 14:12:06 2001
+++ linux-2.4.7/include/asm-s390/lowcore.h	Mon Dec 17 13:42:42 2001
@@ -41,13 +41,14 @@
 
 #define __LC_SAVE_AREA                  0xC00
 #define __LC_KERNEL_STACK               0xC40
-#define __LC_KERNEL_LEVEL               0xC44
-#define __LC_IRQ_STAT                   0xC48
+#define __LC_ASYNC_STACK                0xC44
 #define __LC_CPUID                      0xC60
 #define __LC_CPUADDR                    0xC68
 #define __LC_IPLDEV                     0xC7C
 #define __LC_PANIC_MAGIC                0xE00
 
+#define __LC_PFAULT_INTPARM             0x080
+
 /* interrupt handler start with all io, external and mcck interrupt disabled */
 
 #define _RESTART_PSW_MASK    0x00080000
@@ -85,6 +86,12 @@
 #include <asm/atomic.h>
 #include <asm/sigp.h>
 
+void restart_int_handler(void);
+void ext_int_handler(void);
+void system_call(void);
+void pgm_check_handler(void);
+void mcck_int_handler(void);
+void io_int_handler(void);
 
 struct _lowcore
 {
@@ -106,7 +113,7 @@
 	__u16        cpu_addr;                 /* 0x084 */
 	__u16        ext_int_code;             /* 0x086 */
         __u16        svc_ilc;                  /* 0x088 */
-        __u16        scv_code;                 /* 0x08a */
+        __u16        svc_code;                 /* 0x08a */
         __u16        pgm_ilc;                  /* 0x08c */
         __u16        pgm_code;                 /* 0x08e */
 	__u32        trans_exc_code;           /* 0x090 */
@@ -146,15 +153,9 @@
         /* System info area */
 	__u32        save_area[16];            /* 0xc00 */
 	__u32        kernel_stack;             /* 0xc40 */
-	__u32        kernel_level;             /* 0xc44 */
+	__u32        async_stack;              /* 0xc44 */
 	/* entry.S sensitive area start */
-	/* Next 6 words are the s390 equivalent of irq_stat */
-	__u32        __softirq_active;         /* 0xc48 */
-	__u32        __softirq_mask;           /* 0xc4c */
-	__u32        __local_irq_count;        /* 0xc50 */
-	__u32        __local_bh_count;         /* 0xc54 */
-	__u32        __syscall_count;          /* 0xc58 */
-	__u8         pad10[0xc60-0xc5c];       /* 0xc5c */
+	__u8         pad10[0xc60-0xc48];       /* 0xc5c */
 	struct       cpuinfo_S390 cpu_data;    /* 0xc60 */
 	__u32        ipl_device;               /* 0xc7c */
 	/* entry.S sensitive area end */
@@ -162,9 +163,7 @@
         /* SMP info area: defined by DJB */
         __u64        jiffy_timer_cc;           /* 0xc80 */
 	atomic_t     ext_call_fast;            /* 0xc88 */
-	atomic_t     ext_call_queue;           /* 0xc8c */
-        atomic_t     ext_call_count;           /* 0xc90 */
-        __u8         pad11[0xe00-0xc94];       /* 0xc94 */
+        __u8         pad11[0xe00-0xc8c];       /* 0xc8c */
 
         /* 0xe00 is used as indicator for dump tools */
         /* whether the kernel died with panic() or not */
diff -urN linux/include/asm-s390/page.h linux-2.4.7/include/asm-s390/page.h
--- linux/include/asm-s390/page.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/page.h	Mon Dec 17 13:41:20 2001
@@ -28,7 +28,7 @@
 	rp.subreg.odd = (unsigned long) 4096;
         asm volatile ("   slr  1,1\n"
 		      "   mvcl %0,0"
-		      : "+&a" (rp) : : "memory", "1" );
+		      : "+&a" (rp) : : "memory", "cc", "1" );
 }
 
 static inline void copy_page(void *to, void *from)
@@ -37,7 +37,7 @@
 		asm volatile ("   sr   0,0\n"
 			      "   mvpg %0,%1"
 			      : : "a" ((void *)(to)), "a" ((void *)(from))
-			      : "memory", "0" );
+			      : "memory", "cc", "0" );
 	else
 		asm volatile ("   mvc  0(256,%0),0(%1)\n"
 			      "   mvc  256(256,%0),256(%1)\n"
diff -urN linux/include/asm-s390/pgalloc.h linux-2.4.7/include/asm-s390/pgalloc.h
--- linux/include/asm-s390/pgalloc.h	Mon Apr 23 18:28:07 2001
+++ linux-2.4.7/include/asm-s390/pgalloc.h	Mon Dec 17 13:42:42 2001
@@ -84,6 +84,8 @@
 #define pmd_alloc_one_fast(mm, address) ({ BUG(); ((pmd_t *)1); })
 #define pmd_alloc_one(mm,address)       ({ BUG(); ((pmd_t *)2); })
 #define pmd_free(x)                     do { } while (0)
+#define pmd_free_slow(x)		do { } while (0)
+#define pmd_free_fast(x)                do { } while (0)
 #define pgd_populate(mm, pmd, pte)      BUG()
 
 extern inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
diff -urN linux/include/asm-s390/pgtable.h linux-2.4.7/include/asm-s390/pgtable.h
--- linux/include/asm-s390/pgtable.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/pgtable.h	Mon Dec 17 13:41:20 2001
@@ -58,13 +58,6 @@
 #endif /* !__ASSEMBLY__ */
 
 /*
- * Certain architectures need to do special things when PTEs
- * within a page table are directly modified.  Thus, the following
- * hook is made available.
- */
-#define set_pte(pteptr, pteval) ((*(pteptr)) = (pteval))
-
-/*
  * PMD_SHIFT determines the size of the area a second-level page
  * table can map
  */
@@ -162,6 +155,7 @@
 
 /* Bits in the page table entry */
 #define _PAGE_PRESENT   0x001          /* Software                         */
+#define _PAGE_MKCLEAR   0x002          /* Software                         */
 #define _PAGE_RO        0x200          /* HW read-only                     */
 #define _PAGE_INVALID   0x400          /* HW invalid                       */
 
@@ -226,6 +220,25 @@
 #define __S111  PAGE_SHARED
 
 /*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ */
+extern inline void set_pte(pte_t *pteptr, pte_t pteval)
+{
+	if ((pte_val(pteval) & (_PAGE_MKCLEAR|_PAGE_INVALID))
+	    == _PAGE_MKCLEAR) 
+	{
+		pte_val(pteval) &= ~_PAGE_MKCLEAR;
+               
+		asm volatile ("sske %0,%1" 
+				: : "d" (0), "a" (pte_val(pteval)));
+	}
+
+	*pteptr = pteval;
+}
+
+/*
  * Permanent address of a page.
  */
 #define page_address(page) ((page)->virtual)
@@ -323,29 +336,28 @@
 
 extern inline pte_t pte_mkclean(pte_t pte)
 {
-	/* We can't clear the changed bit atomically. The iske/and/sske
-         * sequence has a race condition with the page referenced bit.
-         * At the moment pte_mkclean is always followed by a pte_mkold.
-         * So its safe to ignore the problem for now. Hope this will
-         * never change ... */
-	asm volatile ("sske %0,%1" 
-	              : : "d" (0), "a" (pte_val(pte)));
+	/* The only user of pte_mkclean is the fork() code.
+	   We must *not* clear the *physical* page dirty bit
+	   just because fork() wants to clear the dirty bit in
+	   *one* of the page's mappings.  So we just do nothing. */
 	return pte;
 }
 
 extern inline pte_t pte_mkdirty(pte_t pte)
 {
-	/* We can't set the changed bit atomically either. For now we
+	/* We can't set the changed bit atomically. For now we
          * set (!) the page referenced bit. */
 	asm volatile ("sske %0,%1" 
 	              : : "d" (_PAGE_CHANGED|_PAGE_REFERENCED),
 		          "a" (pte_val(pte)));
+
+	pte_val(pte) &= ~_PAGE_MKCLEAR;
 	return pte;
 }
 
 extern inline pte_t pte_mkold(pte_t pte)
 {
-	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)));
+	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)) : "cc" );
 	return pte;
 }
 
@@ -364,7 +376,8 @@
 
 	asm volatile ("rrbe 0,%1\n\t"
 		      "ipm  %0\n\t"
-		      "srl  %0,28\n\t" : "=d" (ccode) : "a" (pte_val(*ptep)));
+		      "srl  %0,28\n\t" 
+                      : "=d" (ccode) : "a" (pte_val(*ptep)) : "cc" );
 	return ccode & 2;
 }
 
@@ -410,7 +423,23 @@
 	pte_val(__pte) = physpage + pgprot_val(pgprot);
 	return __pte;
 }
-#define mk_pte(page,pgprot) mk_pte_phys(__pa(((page)-mem_map)<<PAGE_SHIFT),pgprot)
+
+#define mk_pte(pg, pgprot)                                                \
+({                                                                        \
+	struct page *__page = (pg);                                       \
+	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
+	pte_t __pte = mk_pte_phys(__physpage, (pgprot));                  \
+	                                                                  \
+	if (__page != ZERO_PAGE(__physpage)) {                            \
+		int __users = page_count(__page);                         \
+		__users -= !!__page->buffers + !!__page->mapping;         \
+	                                                                  \
+		if (__users == 1)                                         \
+			pte_val(__pte) |= _PAGE_MKCLEAR;                  \
+        }                                                                 \
+	                                                                  \
+	__pte;                                                            \
+})
 
 #define pte_page(x) (mem_map+(unsigned long)((pte_val(x) >> PAGE_SHIFT)))
 
diff -urN linux/include/asm-s390/processor.h linux-2.4.7/include/asm-s390/processor.h
--- linux/include/asm-s390/processor.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/processor.h	Mon Dec 17 13:41:20 2001
@@ -87,8 +87,10 @@
         /* perform syscall argument validation (get/set_fs) */
         mm_segment_t fs;
         per_struct per_info;/* Must be aligned on an 4 byte boundary*/
-	addr_t  ieee_instruction_pointer; 
 	/* Used to give failing instruction back to user for ieee exceptions */
+	addr_t  ieee_instruction_pointer; 
+        /* pfault_wait is used to block the process on a pfault event */
+	addr_t  pfault_wait;
 };
 
 typedef struct thread_struct thread_struct;
@@ -105,7 +107,8 @@
               (__pa((__u32) &swapper_pg_dir[0]) + _SEGMENT_TABLE),\
                      0,0,0,                                       \
                      (mm_segment_t) { 0,1},                       \
-                     (per_struct) {{{{0,}}},0,0,0,0,{{0,}}}       \
+                     (per_struct) {{{{0,}}},0,0,0,0,{{0,}}},      \
+                     0, 0                                         \
 }
 
 /* need to define ... */
@@ -196,7 +199,7 @@
                       "    stctl 0,15,0x1c0\n" /* store control registers */
                       "    oi    0(%1),0x10\n" /* fake protection bit */
                       "    lpsw 0(%0)"
-                      : : "a" (dw_psw), "a" (&ctl_buf));
+                      : : "a" (dw_psw), "a" (&ctl_buf) : "cc" );
 }
 
 #endif                                 /* __ASM_S390_PROCESSOR_H           */
diff -urN linux/include/asm-s390/ptrace.h linux-2.4.7/include/asm-s390/ptrace.h
--- linux/include/asm-s390/ptrace.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/ptrace.h	Mon Dec 17 13:41:20 2001
@@ -191,6 +191,7 @@
 	__u32 trap;
 	__u32 crs[16];
 	s390_fp_regs fp_regs;
+	__u32 old_ilc;
 };
 #endif
 
diff -urN linux/include/asm-s390/queue.h linux-2.4.7/include/asm-s390/queue.h
--- linux/include/asm-s390/queue.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/queue.h	Mon Dec 17 13:41:20 2001
@@ -7,7 +7,8 @@
  *
  *  A little set of queue utilies.
  */
-
+#ifndef __ASM_QUEUE_H
+#define __ASM_QUEUE_H
 #include <linux/stddef.h>
 
 typedef struct queue
@@ -29,12 +30,11 @@
 }
 
 static __inline__ void enqueue_tail(qheader *qhead,queue *member)
-{
-	queue *tail=qhead->tail;
-	member->next=NULL;
-	
+{	
 	if(member)
 	{
+		queue *tail=qhead->tail;
+
 		if(tail)
 			tail->next=member;
 		else
@@ -166,5 +166,5 @@
 	return(0);
 }
 
-
+#endif /* __ASM_QUEUE_H */
 
diff -urN linux/include/asm-s390/s390dyn.h linux-2.4.7/include/asm-s390/s390dyn.h
--- linux/include/asm-s390/s390dyn.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/s390dyn.h	Mon Dec 17 13:41:20 2001
@@ -37,11 +37,14 @@
 	oper_handler_func_t  oper_func;
 } devreg_t;
 
-#define DEVREG_EXACT_MATCH      0x00000001
-#define DEVREG_MATCH_DEV_TYPE   0x00000002
-#define DEVREG_MATCH_CU_TYPE    0x00000004
-#define DEVREG_NO_CU_INFO       0x00000008
-#define DEVREG_NO_DEV_INFO      0x00000010
+#define DEVREG_MATCH_CU_TYPE    0x00000001
+#define DEVREG_MATCH_CU_MODEL   0x00000002
+#define DEVREG_MATCH_DEV_TYPE   0x00000004
+#define DEVREG_MATCH_DEV_MODEL  0x00000008
+
+#define DEVREG_EXACT_MATCH      (DEVREG_MATCH_CU_TYPE|DEVREG_MATCH_CU_MODEL|DEVREG_MATCH_DEV_TYPE|DEVREG_MATCH_DEV_MODEL)
+#define DEVREG_NO_CU_INFO       (DEVREG_MATCH_DEV_TYPE|DEVREG_MATCH_DEV_MODEL)
+#define DEVREG_NO_DEV_INFO      (DEVREG_MATCH_CU_TYPE|DEVREG_MATCH_CU_MODEL)
 
 #define DEVREG_TYPE_DEVNO       0x80000000
 #define DEVREG_TYPE_DEVCHARS    0x40000000
diff -urN linux/include/asm-s390/setup.h linux-2.4.7/include/asm-s390/setup.h
--- linux/include/asm-s390/setup.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/setup.h	Mon Dec 17 13:41:20 2001
@@ -31,6 +31,22 @@
 #define MACHINE_HAS_CSP  (machine_flags & 8)
 #define MACHINE_HAS_MVPG (machine_flags & 16)
 
+#define MACHINE_HAS_HWC  (!MACHINE_IS_P390)
+
+/*
+ * Console mode. Override with conmode=
+ */
+extern unsigned int console_mode;
+extern unsigned int console_device;
+
+#define CONSOLE_IS_UNDEFINED	(console_mode == 0)
+#define CONSOLE_IS_HWC		(console_mode == 1)
+#define CONSOLE_IS_3215		(console_mode == 2)
+#define CONSOLE_IS_3270		(console_mode == 3)
+#define SET_CONSOLE_HWC		do { console_mode = 1; } while (0)
+#define SET_CONSOLE_3215	do { console_mode = 2; } while (0)
+#define SET_CONSOLE_3270	do { console_mode = 3; } while (0)
+
 #else 
 
 #define IPL_DEVICE        0x10404
diff -urN linux/include/asm-s390/sigcontext.h linux-2.4.7/include/asm-s390/sigcontext.h
--- linux/include/asm-s390/sigcontext.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/sigcontext.h	Mon Dec 17 13:42:42 2001
@@ -26,14 +26,14 @@
 {
         unsigned long mask;
         unsigned long addr;
-} _psw_t __attribute__ ((aligned(8)));
+} __attribute__ ((aligned(8))) _psw_t;
 
 typedef struct
 {
 	_psw_t psw;
 	unsigned long gprs[__NUM_GPRS];
 	unsigned int  acrs[__NUM_ACRS];
-} _s390_regs_common __attribute__ ((packed));
+} _s390_regs_common;
 
 typedef struct
 {
diff -urN linux/include/asm-s390/siginfo.h linux-2.4.7/include/asm-s390/siginfo.h
--- linux/include/asm-s390/siginfo.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/siginfo.h	Mon Dec 17 13:43:29 2001
@@ -111,7 +111,7 @@
 #define SI_USER		0	/* sent by kill, sigsend, raise */
 #define SI_KERNEL	0x80	/* sent by the kernel from somewhere */
 #define SI_QUEUE	-1	/* sent by sigqueue */
-#define SI_TIMER	-2	/* sent by timer expiration */
+#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
 #define SI_MESGQ	-3	/* sent by real time mesq state change */
 #define SI_ASYNCIO	-4	/* sent by AIO completion */
 #define SI_SIGIO	-5	/* sent by queued SIGIO */
@@ -122,71 +122,71 @@
 /*
  * SIGILL si_codes
  */
-#define ILL_ILLOPC	1	/* illegal opcode */
-#define ILL_ILLOPN	2	/* illegal operand */
-#define ILL_ILLADR	3	/* illegal addressing mode */
-#define ILL_ILLTRP	4	/* illegal trap */
-#define ILL_PRVOPC	5	/* privileged opcode */
-#define ILL_PRVREG	6	/* privileged register */
-#define ILL_COPROC	7	/* coprocessor error */
-#define ILL_BADSTK	8	/* internal stack error */
+#define ILL_ILLOPC	(__SI_FAULT|1)	/* illegal opcode */
+#define ILL_ILLOPN	(__SI_FAULT|2)	/* illegal operand */
+#define ILL_ILLADR	(__SI_FAULT|3)	/* illegal addressing mode */
+#define ILL_ILLTRP	(__SI_FAULT|4)	/* illegal trap */
+#define ILL_PRVOPC	(__SI_FAULT|5)	/* privileged opcode */
+#define ILL_PRVREG	(__SI_FAULT|6)	/* privileged register */
+#define ILL_COPROC	(__SI_FAULT|7)	/* coprocessor error */
+#define ILL_BADSTK	(__SI_FAULT|8)	/* internal stack error */
 #define NSIGILL		8
 
 /*
  * SIGFPE si_codes
  */
-#define FPE_INTDIV	1	/* integer divide by zero */
-#define FPE_INTOVF	2	/* integer overflow */
-#define FPE_FLTDIV	3	/* floating point divide by zero */
-#define FPE_FLTOVF	4	/* floating point overflow */
-#define FPE_FLTUND	5	/* floating point underflow */
-#define FPE_FLTRES	6	/* floating point inexact result */
-#define FPE_FLTINV	7	/* floating point invalid operation */
-#define FPE_FLTSUB	8	/* subscript out of range */
+#define FPE_INTDIV	(__SI_FAULT|1)	/* integer divide by zero */
+#define FPE_INTOVF	(__SI_FAULT|2)	/* integer overflow */
+#define FPE_FLTDIV	(__SI_FAULT|3)	/* floating point divide by zero */
+#define FPE_FLTOVF	(__SI_FAULT|4)	/* floating point overflow */
+#define FPE_FLTUND	(__SI_FAULT|5)	/* floating point underflow */
+#define FPE_FLTRES	(__SI_FAULT|6)	/* floating point inexact result */
+#define FPE_FLTINV	(__SI_FAULT|7)	/* floating point invalid operation */
+#define FPE_FLTSUB	(__SI_FAULT|8)	/* subscript out of range */
 #define NSIGFPE		8
 
 /*
  * SIGSEGV si_codes
  */
-#define SEGV_MAPERR	1	/* address not mapped to object */
-#define SEGV_ACCERR	2	/* invalid permissions for mapped object */
+#define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */
+#define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */
 #define NSIGSEGV	2
 
 /*
  * SIGBUS si_codes
  */
-#define BUS_ADRALN	1	/* invalid address alignment */
-#define BUS_ADRERR	2	/* non-existant physical address */
-#define BUS_OBJERR	3	/* object specific hardware error */
+#define BUS_ADRALN	(__SI_FAULT|1)	/* invalid address alignment */
+#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
+#define BUS_OBJERR	(__SI_FAULT|3)	/* object specific hardware error */
 #define NSIGBUS		3
 
 /*
  * SIGTRAP si_codes
  */
-#define TRAP_BRKPT	1	/* process breakpoint */
-#define TRAP_TRACE	2	/* process trace trap */
+#define TRAP_BRKPT	(__SI_FAULT|1)	/* process breakpoint */
+#define TRAP_TRACE	(__SI_FAULT|2)	/* process trace trap */
 #define NSIGTRAP	2
 
 /*
  * SIGCHLD si_codes
  */
-#define CLD_EXITED	1	/* child has exited */
-#define CLD_KILLED	2	/* child was killed */
-#define CLD_DUMPED	3	/* child terminated abnormally */
-#define CLD_TRAPPED	4	/* traced child has trapped */
-#define CLD_STOPPED	5	/* child has stopped */
-#define CLD_CONTINUED	6	/* stopped child has continued */
+#define CLD_EXITED	(__SI_CHLD|1)	/* child has exited */
+#define CLD_KILLED	(__SI_CHLD|2)	/* child was killed */
+#define CLD_DUMPED	(__SI_CHLD|3)	/* child terminated abnormally */
+#define CLD_TRAPPED	(__SI_CHLD|4)	/* traced child has trapped */
+#define CLD_STOPPED	(__SI_CHLD|5)	/* child has stopped */
+#define CLD_CONTINUED	(__SI_CHLD|6)	/* stopped child has continued */
 #define NSIGCHLD
 
 /*
  * SIGPOLL si_codes
  */
-#define POLL_IN		1	/* data input available */
-#define POLL_OUT	2	/* output buffers available */
-#define POLL_MSG	3	/* input message available */
-#define POLL_ERR	4	/* i/o error */
-#define POLL_PRI	5	/* high priority input available */
-#define POLL_HUP	6	/* device disconnected */
+#define POLL_IN		(__SI_POLL|1)	/* data input available */
+#define POLL_OUT	(__SI_POLL|2)	/* output buffers available */
+#define POLL_MSG	(__SI_POLL|3)	/* input message available */
+#define POLL_ERR	(__SI_POLL|4)	/* i/o error */
+#define POLL_PRI	(__SI_POLL|5)	/* high priority input available */
+#define POLL_HUP	(__SI_POLL|6)	/* device disconnected */
 #define NSIGPOLL	6
 
 /*
@@ -224,7 +224,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -urN linux/include/asm-s390/sigp.h linux-2.4.7/include/asm-s390/sigp.h
--- linux/include/asm-s390/sigp.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/sigp.h	Mon Dec 17 13:41:49 2001
@@ -62,34 +62,9 @@
         ec_restart,
         ec_halt,
         ec_power_off,
-        ec_ptlb,
+	ec_call_function,
 	ec_bit_last
 } ec_bit_sig;
-
-/* Signals which come with a parameter area, synchronous */
-typedef enum
-{
-        ec_callback_async,
-        ec_callback_sync
-} ec_cmd_sig;
-
-/* state information for synchronous signals */
-typedef enum
-{
-	ec_pending,
-	ec_executing,
-	ec_done
-} ec_state;
-
-/* header for the queuing of signals with a parameter area */
-typedef struct ec_ext_call
-{
-	ec_cmd_sig cmd;
-	atomic_t status;
-	struct ec_ext_call *next;
-        void (*func)(void *info);
-        void *info;
-} ec_ext_call;
 
 /*
  * Signal processor
diff -urN linux/include/asm-s390/smp.h linux-2.4.7/include/asm-s390/smp.h
--- linux/include/asm-s390/smp.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/smp.h	Mon Dec 17 13:41:49 2001
@@ -64,12 +64,5 @@
 
 void smp_local_timer_interrupt(struct pt_regs * regs);
 
-sigp_ccode smp_ext_call(int cpu, void (*cb)(void *info), void *info, int wait);
-void smp_ext_call_others(void (*cb)(void *info), void *info, int wait);
-sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig);
-void smp_ext_bitcall_others(ec_bit_sig sig);
-
-int smp_signal_others(sigp_order_code order_code,__u32 parameter,
-                      int spin,sigp_info *info);
 #endif
 #endif
diff -urN linux/include/asm-s390/softirq.h linux-2.4.7/include/asm-s390/softirq.h
--- linux/include/asm-s390/softirq.h	Fri Aug  4 19:15:37 2000
+++ linux-2.4.7/include/asm-s390/softirq.h	Mon Dec 17 13:41:49 2001
@@ -17,13 +17,29 @@
 #include <asm/hardirq.h>
 #include <asm/lowcore.h>
 
-#define cpu_bh_disable(cpu)	do { local_bh_count(cpu)++; barrier(); } while (0)
-#define cpu_bh_enable(cpu)	do { barrier(); local_bh_count(cpu)--; } while (0)
+#define __cpu_bh_enable(cpu) \
+                do { barrier(); local_bh_count(cpu)--; } while (0)
+#define cpu_bh_disable(cpu) \
+                do { local_bh_count(cpu)++; barrier(); } while (0)
 
-#define local_bh_disable()	cpu_bh_disable(smp_processor_id())
-#define local_bh_enable()	cpu_bh_enable(smp_processor_id())
+#define local_bh_disable()      cpu_bh_disable(smp_processor_id())
+#define __local_bh_enable()     __cpu_bh_enable(smp_processor_id())
 
 #define in_softirq() (local_bh_count(smp_processor_id()) != 0)
+
+extern void do_call_softirq(void);
+
+#define local_bh_enable()			          	        \
+do {							                \
+        unsigned int *ptr = &local_bh_count(smp_processor_id());        \
+        barrier();                                                      \
+        if (!--*ptr)							\
+		if (softirq_pending(smp_processor_id()))		\
+			/* Use the async. stack for softirq */		\
+			do_call_softirq();				\
+} while (0)
+
+#define __cpu_raise_softirq(cpu, nr) (softirq_pending(cpu) |= (1<<nr))
 
 #endif	/* __ASM_SOFTIRQ_H */
 
diff -urN linux/include/asm-s390/spinlock.h linux-2.4.7/include/asm-s390/spinlock.h
--- linux/include/asm-s390/spinlock.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/spinlock.h	Mon Dec 17 13:42:42 2001
@@ -32,20 +32,19 @@
         __asm__ __volatile("    bras  1,1f\n"
                            "0:  diag  0,0,68\n"
                            "1:  slr   0,0\n"
-                           "    cs    0,1,%1\n"
+                           "    cs    0,1,0(%0)\n"
                            "    jl    0b\n"
-                           : "=m" (lp->lock)
-                           : "0" (lp->lock) : "0", "1", "cc" );
+                           : : "a" (&lp->lock) : "0", "1", "cc", "memory" );
 }
 
 extern inline int spin_trylock(spinlock_t *lp)
 {
 	unsigned long result;
-	__asm__ __volatile("    slr   %1,%1\n"
+	__asm__ __volatile("    slr   %0,%0\n"
 			   "    basr  1,0\n"
-			   "0:  cs    %1,1,%0"
-			   : "=m" (lp->lock), "=&d" (result)
-			   : "0" (lp->lock) : "1", "cc" );
+			   "0:  cs    %0,1,0(%1)"
+			   : "=&d" (result)
+			   : "a" (&lp->lock) : "1", "cc", "memory" );
 	return !result;
 }
 
@@ -53,7 +52,7 @@
 {
 	__asm__ __volatile("    xc 0(4,%0),0(%0)\n"
                            "    bcr 15,0"
-			   : /* no output */ : "a" (lp) : "memory", "cc" );
+			   : : "a" (&lp->lock) : "memory", "cc" );
 }
 		
 /*
@@ -76,24 +75,24 @@
 #define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
 #define read_lock(rw)   \
-        asm volatile("   l     2,%0\n"   \
+        asm volatile("   l     2,0(%0)\n"   \
                      "   j     1f\n"     \
                      "0: diag  0,0,68\n" \
-                     "1: la    2,0(2)\n"  /* clear high (=write) bit */ \
-                     "   la    3,1(2)\n"  /* one more reader */ \
-                     "   cs    2,3,%0\n"  /* try to write new value */ \
+                     "1: la    2,0(2)\n"     /* clear high (=write) bit */ \
+                     "   la    3,1(2)\n"     /* one more reader */ \
+                     "   cs    2,3,0(%0)\n"  /* try to write new value */ \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define read_unlock(rw) \
-        asm volatile("   l     2,%0\n"   \
+        asm volatile("   l     2,0(%0)\n"   \
                      "   j     1f\n"     \
                      "0: diag  0,0,68\n" \
                      "1: lr    3,2\n"    \
                      "   ahi   3,-1\n"    /* one less reader */ \
-                     "   cs    2,3,%0\n" \
+                     "   cs    2,3,0(%0)\n" \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define write_lock(rw) \
         asm volatile("   lhi   3,1\n"    \
@@ -101,9 +100,9 @@
                      "   j     1f\n"     \
                      "0: diag  0,0,68\n" \
                      "1: slr   2,2\n"     /* old lock value must be 0 */ \
-                     "   cs    2,3,%0\n" \
+                     "   cs    2,3,0(%0)\n" \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define write_unlock(rw) \
         asm volatile("   slr   3,3\n"     /* new lock value = 0 */ \
@@ -111,8 +110,8 @@
                      "0: diag  0,0,68\n" \
                      "1: lhi   2,1\n"    \
                      "   sll   2,31\n"    /* old lock value must be 0x80000000 */ \
-                     "   cs    2,3,%0\n" \
+                     "   cs    2,3,0(%0)\n" \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #endif /* __ASM_SPINLOCK_H */
diff -urN linux/include/asm-s390/system.h linux-2.4.7/include/asm-s390/system.h
--- linux/include/asm-s390/system.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/system.h	Mon Dec 17 13:41:20 2001
@@ -61,7 +61,7 @@
                                 "   jl    1b\n"
                                 "   ex    0,4(2)"     /* store *ptr to x */
                                 : "+a&" (ptr) : "a" (&x)
-                                : "memory", "0", "1", "2");
+                                : "memory", "cc", "0", "1", "2");
 			break;
                 case 2:
                         if(((__u32)ptr)&1)
@@ -84,7 +84,7 @@
                                 "   jl    1b\n"
                                 "   ex    0,4(2)"     /* store *ptr to x */
                                 : "+a&" (ptr) : "a" (&x)
-                                : "memory", "0", "1", "2");
+                                : "memory", "cc", "0", "1", "2");
                         break;
                 case 4:
                         if(((__u32)ptr)&3)
@@ -95,7 +95,7 @@
                                 "    jl  0b\n"
                                 "    lr  %0,0\n"
                                 : "+d&" (x) : "a" (ptr)
-                                : "memory", "0" );
+                                : "memory", "cc", "0" );
                         break;
                default:
                         abort();
@@ -149,7 +149,7 @@
         __asm__ __volatile__("ssm   %0" : : "m" (x) : "memory")
 
 #define __load_psw(psw) \
-	__asm__ __volatile__("lpsw %0" : : "m" (psw));
+	__asm__ __volatile__("lpsw %0" : : "m" (psw) : "cc" );
 
 #define __ctl_load(array, low, high) ({ \
 	__asm__ __volatile__ ( \
@@ -185,7 +185,7 @@
                 "    st    0,0(1)\n" \
                 "1:  ex    %1,4(2)"      /* execute lctl */ \
                 : "=m" (dummy) : "a" (cr*17), "a" (1<<(bit)) \
-                : "0", "1", "2"); \
+                : "cc", "0", "1", "2"); \
         })
 
 #define __ctl_clear_bit(cr, bit) ({ \
@@ -204,7 +204,7 @@
                 "    st    0,0(1)\n" \
                 "1:  ex    %1,4(2)"      /* execute lctl */ \
                 : "=m" (dummy) : "a" (cr*17), "a" (~(1<<(bit))) \
-                : "0", "1", "2"); \
+                : "cc", "0", "1", "2"); \
         })
 
 /* For spinlocks etc */
diff -urN linux/include/asm-s390/timex.h linux-2.4.7/include/asm-s390/timex.h
--- linux/include/asm-s390/timex.h	Fri May 12 14:41:44 2000
+++ linux-2.4.7/include/asm-s390/timex.h	Mon Dec 17 13:43:29 2001
@@ -17,7 +17,7 @@
 	(1000000/CLOCK_TICK_FACTOR) / (CLOCK_TICK_RATE/CLOCK_TICK_FACTOR)) \
 		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
 
-typedef unsigned long cycles_t;
+typedef unsigned long long cycles_t;
 
 extern cycles_t cacheflush_time;
 
diff -urN linux/include/asm-s390/uaccess.h linux-2.4.7/include/asm-s390/uaccess.h
--- linux/include/asm-s390/uaccess.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/uaccess.h	Mon Dec 17 13:41:49 2001
@@ -102,7 +102,7 @@
 				".previous"
                                 : "=m" (*((__u32*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 
@@ -130,7 +130,7 @@
 				".previous"
                                 : "=m" (*((__u16*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 
@@ -158,7 +158,7 @@
 				".previous"
                                 : "=m" (*((__u8*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 
@@ -223,7 +223,7 @@
                                 ".previous"                                \
                                 : "=d" (x) , "=&d" (err)                   \
                                 : "m" (*(const __u32*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                   \
+                                : "cc", "4" );                             \
 })
 
 #define __get_user_asm_2(x, ptr, err)                                      \
@@ -248,7 +248,7 @@
                                 ".previous"                                \
                                 : "=d" (x) , "=&d" (err)                   \
                                 : "m" (*(const __u16*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                   \
+                                : "cc", "4" );                             \
 })
 
 #define __get_user_asm_1(x, ptr, err)                                     \
@@ -274,7 +274,7 @@
                                 ".previous"                               \
                                 : "=d" (x) , "=&d" (err)                  \
                                 : "m" (*(const __u8*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                  \
+                                : "cc", "4" );                            \
 })
 
 #define __get_user(x, ptr)                                      \
@@ -340,7 +340,7 @@
 				"   .long  0b,__copy_to_user_fixup\n"
 				".previous"
                                 : "+&d" (n) : "d" (to), "d" (from)
-                                : "2", "3", "4", "5" );
+                                : "cc", "2", "3", "4", "5" );
         return n;
 }
 
@@ -372,13 +372,13 @@
                                 "0: mvcle 2,4,0\n"
                                 "   jo    0b\n"
                                 "   sacf  0\n"
-                                "   lr    %0,3\n"
+                                "   lr    %0,5\n"
 				".section __ex_table,\"a\"\n"
 				"   .align 4\n"
 				"   .long  0b,__copy_from_user_fixup\n"
 				".previous"
                                 : "+&d" (n) : "d" (to), "d" (from)
-                                : "2", "3", "4", "5" );
+                                : "cc", "2", "3", "4", "5" );
         return n;
 }
 
@@ -436,7 +436,7 @@
                                 : "=&a" (len)
                                 : "a" (dst), "d" (src), "d" (count),
                                   "K" (-EFAULT)
-                                : "2", "3", "4", "memory" );
+                                : "2", "3", "4", "memory", "cc" );
         return len;
 }
 
diff -urN linux/include/asm-s390/ucontext.h linux-2.4.7/include/asm-s390/ucontext.h
--- linux/include/asm-s390/ucontext.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/ucontext.h	Mon Dec 17 13:41:20 2001
@@ -13,10 +13,8 @@
 	unsigned long	  uc_flags;
 	struct ucontext  *uc_link;
 	stack_t		  uc_stack;
+	_sigregs          uc_mcontext;
 	sigset_t	  uc_sigmask;	/* mask last for extensibility */
-	struct sigcontext *sc; /* Added for pthread support */
 };
-
-
 
 #endif /* !_ASM_S390_UCONTEXT_H */
diff -urN linux/include/asm-s390/unistd.h linux-2.4.7/include/asm-s390/unistd.h
--- linux/include/asm-s390/unistd.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390/unistd.h	Mon Dec 17 13:41:49 2001
@@ -178,6 +178,8 @@
 #define __NR_capset             185
 #define __NR_sigaltstack        186
 #define __NR_sendfile           187
+#define __NR_getpmsg		188
+#define __NR_putpmsg		189
 #define __NR_vfork		190
 #define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
 #define __NR_mmap2		192
diff -urN linux/include/asm-s390/vtoc.h linux-2.4.7/include/asm-s390/vtoc.h
--- linux/include/asm-s390/vtoc.h	Wed Apr 11 22:02:28 2001
+++ linux-2.4.7/include/asm-s390/vtoc.h	Mon Dec 17 13:42:42 2001
@@ -15,41 +15,59 @@
 #include <linux/types.h>
 #include <linux/hdreg.h>
 #include <linux/version.h>
-#endif
 #include <asm/dasd.h>
+#endif
+
+#define DASD_API_VERSION 0
 
 #define LINE_LENGTH 80
 #define VTOC_START_CC 0x0
 #define VTOC_START_HH 0x1
+#define FIRST_USABLE_CYL 1
+#define FIRST_USABLE_TRK 2
+
+#define DASD_3380_TYPE 13148
+#define DASD_3390_TYPE 13200
+#define DASD_9345_TYPE 37701
+
+#define DASD_3380_VALUE 0xbb60
+#define DASD_3390_VALUE 0xe5a2
+#define DASD_9345_VALUE 0xbc98
 
-enum failure {unable_to_open,
-	      unable_to_seek,
-	      unable_to_write,
-	      unable_to_read};
+#define VOLSER_LENGTH 6
+#define BIG_DISK_SIZE 0x10000
 
-typedef struct ttr {
+#define VTOC_ERROR "VTOC error:"
+
+
+typedef struct ttr 
+{
         __u16 tt;
         __u8  r;
 } __attribute__ ((packed)) ttr_t;
 
-typedef struct cchhb {
+typedef struct cchhb 
+{
         __u16 cc;
         __u16 hh;
         __u8 b;
 } __attribute__ ((packed)) cchhb_t;
 
-typedef struct cchh {
+typedef struct cchh 
+{
         __u16 cc;
         __u16 hh;
 } __attribute__ ((packed)) cchh_t;
 
-typedef struct labeldate {
+typedef struct labeldate 
+{
         __u8  year;
         __u16 day;
 } __attribute__ ((packed)) labeldate_t;
 
 
-typedef struct volume_label {
+typedef struct volume_label 
+{
         char volkey[4];         /* volume key = volume label                 */
 	char vollbl[4];	        /* volume label                              */
 	char volid[6];	        /* volume identifier                         */
@@ -66,7 +84,8 @@
 } __attribute__ ((packed)) volume_label_t;
 
 
-typedef struct extent {
+typedef struct extent 
+{
         __u8  typeind;          /* extent type indicator                     */
         __u8  seqno;            /* extent sequence number                    */
         cchh_t llimit;          /* starting point of this extent             */
@@ -74,7 +93,8 @@
 } __attribute__ ((packed)) extent_t;
 
 
-typedef struct dev_const {
+typedef struct dev_const 
+{
         __u16 DS4DSCYL;           /* number of logical cyls                  */
         __u16 DS4DSTRK;           /* number of tracks in a logical cylinder  */
         __u16 DS4DEVTK;           /* device track length                     */
@@ -88,7 +108,8 @@
 } __attribute__ ((packed)) dev_const_t;
 
 
-typedef struct format1_label {
+typedef struct format1_label 
+{
 	char  DS1DSNAM[44];       /* data set name                           */
 	__u8  DS1FMTID;           /* format identifier                       */
 	char  DS1DSSN[6];         /* data set serial number                  */
@@ -124,7 +145,8 @@
 } __attribute__ ((packed)) format1_label_t;
 
 
-typedef struct format4_label {
+typedef struct format4_label 
+{
 	char  DS4KEYCD[44];       /* key code for VTOC labels: 44 times 0x04 */
         __u8  DS4IDFMT;           /* format identifier                       */
 	cchhb_t DS4HPCHR;         /* highest address of a format 1 DSCB      */
@@ -153,6 +175,43 @@
 } __attribute__ ((packed)) format4_label_t;
 
 
+typedef struct ds5ext 
+{
+	__u16 t;                  /* RTA of the first track of free extent   */
+	__u16 fc;                 /* number of whole cylinders in free ext.  */
+	__u8  ft;                 /* number of remaining free tracks         */
+} __attribute__ ((packed)) ds5ext_t;
+
+
+typedef struct format5_label 
+{
+	char DS5KEYID[4];         /* key identifier                          */
+	ds5ext_t DS5AVEXT;        /* first available (free-space) extent.    */
+	ds5ext_t DS5EXTAV[7];     /* seven available extents                 */
+	__u8 DS5FMTID;            /* format identifier                       */
+	ds5ext_t DS5MAVET[18];    /* eighteen available extents              */
+	cchhb_t DS5PTRDS;         /* pointer to next format5 DSCB            */
+} __attribute__ ((packed)) format5_label_t;
+
+
+typedef struct ds7ext 
+{
+	__u32 a;                  /* starting RTA value                      */
+	__u32 b;                  /* ending RTA value + 1                    */
+} __attribute__ ((packed)) ds7ext_t;
+
+
+typedef struct format7_label 
+{
+	char DS7KEYID[4];         /* key identifier                          */
+	ds7ext_t DS7EXTNT[5];     /* space for 5 extent descriptions         */
+	__u8 DS7FMTID;            /* format identifier                       */
+	ds7ext_t DS7ADEXT[11];    /* space for 11 extent descriptions        */
+	char res1[2];             /* reserved                                */
+	cchhb_t DS7PTRDS;         /* pointer to next FMT7 DSCB               */
+} __attribute__ ((packed)) format7_label_t;
+
+
 char * vtoc_ebcdic_enc (
         unsigned char source[LINE_LENGTH],
         unsigned char target[LINE_LENGTH],
@@ -181,45 +240,126 @@
         __u8 year,
         __u16 day);
 
+void vtoc_volume_label_init (
+	volume_label_t *vlabel);
 
 int vtoc_read_volume_label (
         char * device,
         unsigned long vlabel_start,
         volume_label_t * vlabel);
+
 int vtoc_write_volume_label (
-        char * device,
+        char *device,
         unsigned long vlabel_start,
-        volume_label_t * vlabel);
+        volume_label_t *vlabel);
+
+void vtoc_volume_label_set_volser (
+	volume_label_t *vlabel,
+	char *volser);
+
+char *vtoc_volume_label_get_volser (
+	volume_label_t *vlabel,
+	char *volser);
+
+void vtoc_volume_label_set_key (
+        volume_label_t *vlabel,
+        char *key);     
+
+void vtoc_volume_label_set_label (
+	volume_label_t *vlabel,
+	char *lbl);
+
+char *vtoc_volume_label_get_label (
+	volume_label_t *vlabel,
+	char *lbl);
+
 void vtoc_read_label (
         char *device,
         unsigned long position,
+        format1_label_t *f1,
         format4_label_t *f4,
-        format1_label_t *f1);
+        format5_label_t *f5,
+        format7_label_t *f7);
+
 void vtoc_write_label (
         char *device,
         unsigned long position,
+        format1_label_t *f1,
 	format4_label_t *f4,
-	format1_label_t *f1);
-void vtoc_init_format4_label (
-        struct hd_geometry *geo,
-        format4_label_t *f4lbl,
-	unsigned int usable_partitions,
-	unsigned int cylinders,
-	unsigned int tracks,
-	unsigned int blocks);
+	format5_label_t *f5,
+	format7_label_t *f7);
+
+
 void vtoc_init_format1_label (
         char *volid,
         unsigned int blksize,
         extent_t *part_extent,
         format1_label_t *f1);
+
+
+void vtoc_init_format4_label (
+        format4_label_t *f4lbl,
+	unsigned int usable_partitions,
+	unsigned int cylinders,
+	unsigned int tracks,
+	unsigned int blocks,
+	unsigned int blksize,
+	__u16 dev_type);
+
 void vtoc_update_format4_label (
 	format4_label_t *f4,
 	cchhb_t *highest_f1,
-	__u8 unused_update,
-	__u16 freespace_update);
+	__u16 unused_update);
+
 
+void vtoc_init_format5_label (
+	format5_label_t *f5);
 
+void vtoc_update_format5_label_add (
+	format5_label_t *f5,
+	int verbose,
+	int cyl,
+	int trk,
+	__u16 a, 
+	__u16 b, 
+	__u8 c);
+ 
+void vtoc_update_format5_label_del (
+	format5_label_t *f5,
+	int verbose,
+	int cyl,
+	int trk,
+	__u16 a, 
+	__u16 b, 
+	__u8 c);
+
+
+void vtoc_init_format7_label (
+	format7_label_t *f7);
+
+void vtoc_update_format7_label_add (
+	format7_label_t *f7,
+	int verbose,
+	__u32 a, 
+	__u32 b);
+
+void vtoc_update_format7_label_del (
+	format7_label_t *f7, 
+	int verbose,
+	__u32 a, 
+	__u32 b);
 
+
+void vtoc_set_freespace(
+	format4_label_t *f4,
+	format5_label_t *f5,
+	format7_label_t *f7,
+	char ch,
+	int verbose,
+	__u32 start,
+	__u32 stop,
+	int cyl,
+	int trk);
 
 
 
diff -urN linux/include/asm-s390x/atomic.h linux-2.4.7/include/asm-s390x/atomic.h
--- linux/include/asm-s390x/atomic.h	Tue Jul 10 00:27:45 2001
+++ linux-2.4.7/include/asm-s390x/atomic.h	Mon Dec 17 13:42:42 2001
@@ -20,18 +20,18 @@
  * S390 uses 'Compare And Swap' for atomicity in SMP enviroment
  */
 
-typedef struct { volatile int counter; } atomic_t __attribute__ ((aligned (4)));
+typedef struct { volatile int counter; } __attribute__ ((aligned (4))) atomic_t;
 #define ATOMIC_INIT(i)  { (i) }
 
 #define atomic_eieio()          __asm__ __volatile__ ("BCR 15,0")
 
-#define __CS_LOOP(old, new, ptr, op_val, op_string)			\
+#define __CS_LOOP(old_val, new_val, ptr, op_val, op_string)		\
         __asm__ __volatile__("   l     %0,0(%2)\n"			\
                              "0: lr    %1,%0\n"				\
                              op_string "  %1,%3\n"			\
                              "   cs    %0,%1,0(%2)\n"			\
                              "   jl    0b"				\
-                             : "=&d" (old), "=&d" (new)			\
+                             : "=&d" (old_val), "=&d" (new_val)		\
 			     : "a" (ptr), "d" (op_val) : "cc" );
 
 static __inline__ int atomic_read(atomic_t *v)
@@ -52,80 +52,80 @@
 
 static __inline__ void atomic_add(int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "ar");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "ar");
 }
 
 static __inline__ int atomic_add_return (int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "ar");
-	return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "ar");
+	return new_val;
 }
 
 static __inline__ int atomic_add_negative(int i, atomic_t *v)
 {
-	int old, new;
-        __CS_LOOP(old, new, v, i, "ar");
-        return new < 0;
+	int old_val, new_val;
+        __CS_LOOP(old_val, new_val, v, i, "ar");
+        return new_val < 0;
 }
 
 static __inline__ void atomic_sub(int i, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, i, "sr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, i, "sr");
 }
 
 static __inline__ void atomic_inc(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
 }
 
 static __inline__ int atomic_inc_return(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
-        return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
+        return new_val;
 }
 
 static __inline__ int atomic_inc_and_test(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "ar");
-	return new != 0;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "ar");
+	return new_val != 0;
 }
 
 static __inline__ void atomic_dec(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
 }
 
 static __inline__ int atomic_dec_return(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
-	return new;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
+	return new_val;
 }
 
 static __inline__ int atomic_dec_and_test(volatile atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, 1, "sr");
-        return new == 0;
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, 1, "sr");
+        return new_val == 0;
 }
 
 static __inline__ void atomic_clear_mask(unsigned long mask, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, ~mask, "nr");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, ~mask, "nr");
 }
 
 static __inline__ void atomic_set_mask(unsigned long mask, atomic_t *v)
 {
-	int old, new;
-	__CS_LOOP(old, new, v, mask, "or");
+	int old_val, new_val;
+	__CS_LOOP(old_val, new_val, v, mask, "or");
 }
 
 /*
diff -urN linux/include/asm-s390x/cache.h linux-2.4.7/include/asm-s390x/cache.h
--- linux/include/asm-s390x/cache.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/cache.h	Mon Dec 17 13:41:20 2001
@@ -11,6 +11,7 @@
 #ifndef __ARCH_S390_CACHE_H
 #define __ARCH_S390_CACHE_H
 
-#define L1_CACHE_BYTES     16
+#define L1_CACHE_BYTES     256
+#define L1_CACHE_SHIFT     8
 
 #endif
diff -urN linux/include/asm-s390x/chandev.h linux-2.4.7/include/asm-s390x/chandev.h
--- linux/include/asm-s390x/chandev.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/chandev.h	Mon Dec 17 13:41:20 2001
@@ -6,49 +6,86 @@
  * 
  *  Generic channel device initialisation support. 
  */
+#ifndef __S390_CHANDEV_H
+#define __S390_CHANDEV_H
 #include <linux/version.h>
 #include <asm/types.h>
 #include <linux/netdevice.h>
 
+
+/* Setting this flag to true causes a device name to be built based on the read_devno of the device */
+/* this is exported so external code can look at this flags setting */
+extern int chandev_use_devno_names;
+
+
 /* chandev_type is a bitmask for registering & describing device types. */
 typedef enum
 {
-	none=0x0,
-	ctc=0x1,
-	escon=0x2,
-	lcs=0x4,
-	osad=0x8,
-	qeth=0x10,
-	claw=0x20,
+	chandev_type_none=0x0,
+	chandev_type_ctc=0x1,
+	chandev_type_escon=0x2,
+	chandev_type_lcs=0x4,
+	chandev_type_osad=0x8,
+	chandev_type_qeth=0x10,
+	chandev_type_claw=0x20,
 } chandev_type;
 
 typedef enum
 {
-	no_category,
-	network_device,
-	serial_device,
+	chandev_category_none,
+	chandev_category_network_device,
+	chandev_category_serial_device,
 } chandev_category;
 
+
+
+typedef struct
+{
+	int     irq;
+	u16     devno;
+	u16     cu_type;      /* control unit type */
+	u8      cu_model;     /* control unit model */
+	u16     dev_type;     /* device type */
+	u8      dev_model;    /* device model */
+	u8      pim;          /* path installed mask */
+	u8      chpid[8];     /* CHPID 0-7 (if available) */
+} chandev_subchannel_info;
+
+#define CLAW_NAMELEN 9
+/* CLAW specific parameters other drivers should ignore these fields */
+typedef struct
+{
+	
+	char	 host_name[CLAW_NAMELEN];    /* local host name */
+	char	 adapter_name[CLAW_NAMELEN]; /* workstation adapter name */
+	char	 api_type[CLAW_NAMELEN];     /* API type either TCPIP or API */
+} chandev_claw_info;
+
 /*
  * The chandev_probeinfo structure is passed to the device driver with configuration
  * info for which irq's & ports to use when attempting to probe the device.
  */
 typedef struct
 {
-        int     read_irq;
-	int     write_irq;
-	u16     read_devno;
-	u16     write_devno;
-        s16     port_protocol_no; /* -1 don't care */
+	chandev_subchannel_info read;
+	chandev_subchannel_info write;
+	chandev_subchannel_info data;
+	/* memory_usage_in_k is the suggested memory the driver should attempt to use for io */
+	/* buffers -1 means use the driver default the driver should set this field to the */
+	/* amount of memory it actually uses when returning this probeinfo to the channel */
+	/* device layer with chandev_initdevice */
+	s32     memory_usage_in_k;
+	chandev_claw_info       claw;
+	u8      data_exists; /* whether this device has a data channel */
+	u8      cu_dev_info_inconsistent; /* either ctc or we possibly had a bad sense_id */
+	u8      chpid_info_inconsistent;  /* either ctc or schib info bad */
+        s16     port_protocol_no; /* 0 by default, set specifically when forcing */
 	u8      hint_port_no;   /* lcs specific */
-	u8      max_port_no;    /* lcs specific */
+	u8      max_port_no;    /* lcs/qeth specific */
 	chandev_type chan_type;
 	u8      checksum_received_ip_pkts;
 	u8      use_hw_stats; /* where available e.g. lcs */
-	u16     cu_type;      /* control unit type */
-	u8      cu_model;     /* control unit model */
-	u16     dev_type;     /* device type */
-	u8      dev_model;    /* device model */
+	u8      device_forced; /* indicates the device hasn't been autodetected */
 	char    *parmstr;       /* driver specific parameters added by add_parms keyword */
 	/* newdevice used internally by chandev.c */
 	struct  chandev_activelist *newdevice; 
@@ -75,19 +112,21 @@
 
 typedef enum
 {
-	good=0,
-	not_oper,
-	first_msck=not_oper,
-	no_path,
-	revalidate,
-	gone,
-	last_msck,
+	chandev_status_good,
+	chandev_status_not_oper,
+	chandev_status_first_msck=chandev_status_not_oper,
+	chandev_status_no_path,
+	chandev_status_revalidate,
+	chandev_status_gone,
+	chandev_status_last_msck,
+	chandev_status_all_chans_good /* pseudo machine check to indicate all channels are healthy */
 } chandev_msck_status;
 
 typedef int (*chandev_probefunc)(chandev_probeinfo *probeinfo);
-typedef void (*chandev_shutdownfunc)(void *device);
+typedef int (*chandev_shutdownfunc)(void *device);
 typedef void (*chandev_unregfunc)(void *device);
-typedef void (*chandev_reoperfunc)(void *device,int msck_for_read_chan,chandev_msck_status prevstatus);
+typedef void (*chandev_msck_notification_func)(void *device,int msck_irq,
+chandev_msck_status prevstatus,chandev_msck_status newstatus);
 
 
 
@@ -100,10 +139,14 @@
  * not operational the previous status is sent in the prevstatus variable.
  * This can be used in cases when the default handling isn't quite adequete
  * e.g. if a ssch is needed to reinitialize long running channel programs.
+ *
+ * This returns the number of devices found or -ENOMEM if the code didn't
+ * have enough memory to allocate the chandev control block
+ * or -EPERM if a duplicate entry is found.
  */
 int chandev_register_and_probe(chandev_probefunc probefunc,
 			       chandev_shutdownfunc shutdownfunc,
-			       chandev_reoperfunc reoperfunc,
+			       chandev_msck_notification_func msck_notfunc,
 			       chandev_type chan_type);
 
 /* The chandev_unregister function is typically called when a module is being removed 
@@ -117,6 +160,33 @@
 int chandev_initdevice(chandev_probeinfo *probeinfo,void *dev_ptr,u8 port_no,char *devname,
 chandev_category category,chandev_unregfunc unreg_dev);
 
+/* This function builds a device name & copies it into destnamebuff suitable for calling 
+   init_trdev or whatever & it honours the use_devno_names flag, it is used by chandev_initnetdevice 
+   setting the buildfullname flag to TRUE will cause it to always build a full unique name based 
+   on basename either honouring the chandev_use_devno_names flag if set or starting at index 
+   0 & checking the namespace of the channel device layer itself for a free index, this
+   may be useful when one doesn't have control of the name an upper layer may choose.
+   It returns NULL on error.
+*/
+char *chandev_build_device_name(chandev_probeinfo *probeinfo,char *destnamebuff,char *basename,int buildfullname);
+
+
+
+
+/* chandev_init_netdev registers with the normal network device layer */
+/* it doesn't update any of the chandev internal structures. */
+/* i.e. it is optional */
+/* it was part of chandev_initnetdevice but I separated it as */
+/* chandev_initnetdevice may make too many assumptions for some users */
+/* chandev_initnetdevice = chandev_initdevice followed by chandev_init_netdev */
+#if LINUX_VERSION_CODE>=KERNEL_VERSION(2,3,0)
+struct net_device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct net_device *dev, int sizeof_priv,struct net_device *(*init_netdevfunc)(struct net_device *dev, int sizeof_priv));
+#else
+struct device *chandev_init_netdev(chandev_probeinfo *probeinfo,char *basename,
+struct device *dev, int sizeof_priv,struct device *(*init_netdevfunc)(struct device *dev, int sizeof_priv));
+#endif
+
 /* chandev_initnetdevice registers a network device with the channel layer. 
  * It returns the device structure if successful,if dev=NULL it kmallocs it, 
  * On device initialisation failure it will kfree it under ALL curcumstances
@@ -148,8 +218,18 @@
 				     void (*unreg_netdevfunc)(struct device *dev));
 #endif
 
-
-
+/* chandev_add & delete model shouldn't normally be needed by drivers except if */
+/* someone is developing a driver which the channel device layer doesn't know about */
+void chandev_add_model(chandev_type chan_type,s32 cu_type,s16 cu_model,
+		       s32 dev_type,s16 dev_model,u8 max_port_no,int auto_msck_recovery,
+		        u8 default_checksum_received_ip_pkts,u8 default_use_hw_stats);
+void chandev_del_model(s32 cu_type,s16 cu_model,s32 dev_type,s16 dev_model);
+
+/* modules should use chandev_persist to see if they should stay loaded */
+/* this is useful for debugging purposes where you may wish to examine */
+/* /proc/s390dbf/ entries */
+int chandev_persist(chandev_type chan_type);
+#endif /* __S390_CHANDEV_H */
 
 
 
diff -urN linux/include/asm-s390x/checksum.h linux-2.4.7/include/asm-s390x/checksum.h
--- linux/include/asm-s390x/checksum.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/checksum.h	Mon Dec 17 13:41:20 2001
@@ -67,18 +67,24 @@
  *
  * here even more important to align src and dst on a 32-bit (or even
  * better 64-bit) boundary
+ *
+ * Copy from userspace and compute checksum.  If we catch an exception
+ * then zero the rest of the buffer.
  */
-
 extern inline unsigned int 
-csum_partial_copy_from_user(const char *src, char *dst,
-                            int len, unsigned int sum, int *errp)
+csum_partial_copy_from_user (const char *src, char *dst,
+                                          int len, unsigned int sum,
+                                          int *err_ptr)
 {
-	if (copy_from_user(dst, src, len)) {
-		*errp = -EFAULT;
-		memset(dst, 0, len);
-		return sum;
-        }
-        return csum_partial_inline(dst, len, sum);
+	int missing;
+
+	missing = copy_from_user(dst, src, len);
+	if (missing) {
+		memset(dst + len - missing, 0, missing);
+		*err_ptr = -EFAULT;
+	}
+		
+	return csum_partial(dst, len, sum);
 }
 
 extern inline unsigned int
diff -urN linux/include/asm-s390x/current.h linux-2.4.7/include/asm-s390x/current.h
--- linux/include/asm-s390x/current.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/current.h	Mon Dec 17 13:41:49 2001
@@ -19,8 +19,8 @@
 {
         struct task_struct *current;
         __asm__("lghi  %0,-16384\n\t"
-                "ngr   %0,15"
-                : "=&r" (current) );
+                "alg   %0,0xd40"
+                : "=&r" (current) : : "cc" );
         return current;
  }
 
diff -urN linux/include/asm-s390x/dasd.h linux-2.4.7/include/asm-s390x/dasd.h
--- linux/include/asm-s390x/dasd.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/dasd.h	Mon Dec 17 13:41:49 2001
@@ -4,43 +4,40 @@
  * Bugreports.to..: <Linux390@de.ibm.com>
  * (C) IBM Corporation, IBM Deutschland Entwicklung GmbH, 1999,2000
  *
+ * This file is the interface of the DASD device driver, which is exported to user space
+ * any future changes wrt the API will result in a change of the APIVERSION reported
+ * to userspace by the DASDAPIVER-ioctl
+ *
  * History of changes (starts July 2000)
- * 02/01/01 added dynamic registration of ioctls
+ * 05/04/01 created by moving the kernel interface to drivers/s390/block/dasd_int.h
  */
 
 #ifndef DASD_H
 #define DASD_H
-
-#undef ERP_DEBUG               /* enable debug messages */
-#undef ERP_FULL_ERP            /* enable full ERP - experimental code !!!! */
-#define CONFIG_DASD_DYNAMIC
-
 #include <linux/ioctl.h>
-#include <asm/irq.h>
 
-#define IOCTL_LETTER 'D'
-/* Disable the volume (for Linux) */
-#define BIODASDDISABLE _IO(IOCTL_LETTER,0) 
-/* Enable the volume (for Linux) */
-#define BIODASDENABLE  _IO(IOCTL_LETTER,1) 
-/* Issue a reserve/release command, rsp. */
-#define BIODASDRSRV    _IO(IOCTL_LETTER,2) /* reserve */
-#define BIODASDRLSE    _IO(IOCTL_LETTER,3) /* release */
-#define BIODASDSLCK    _IO(IOCTL_LETTER,4) /* steal lock */
-/* Read sense ID infpormation */
-#define BIODASDRSID    _IOR(IOCTL_LETTER,0,senseid_t)
-/* Format the volume or an extent */
-#define BIODASDFORMAT  _IOW(IOCTL_LETTER,0,format_data_t) 
-/* translate blocknumber of partition to absolute */
-#define BIODASDRWTB    _IOWR(IOCTL_LETTER,0,int)
+#define DASD_IOCTL_LETTER 'D'
 
-typedef int(*dasd_ioctl_fn_t) (struct inode *inp, int no, long args);
-int dasd_ioctl_no_register(int no, dasd_ioctl_fn_t handler);
-int dasd_ioctl_no_unregister(int no, dasd_ioctl_fn_t handler);
+#if (DASD_API_VERSION == 0)
 
-#define DASD_NAME "dasd"
 #define DASD_PARTN_BITS 2
-#define DASD_PER_MAJOR ( 1U<<(MINORBITS-DASD_PARTN_BITS))
+
+/* 
+ * struct profile_info_t
+ * holds the profinling information 
+ */
+typedef struct dasd_profile_info_t {
+        unsigned int dasd_io_reqs;	 /* number of requests processed at all */
+        unsigned int dasd_io_sects;	 /* number of sectors processed at all */
+        unsigned int dasd_io_secs[32];	 /* histogram of request's sizes */
+        unsigned int dasd_io_times[32];	 /* histogram of requests's times */
+        unsigned int dasd_io_timps[32];	 /* histogram of requests's times per sector */
+        unsigned int dasd_io_time1[32];	 /* histogram of time from build to start */
+        unsigned int dasd_io_time2[32];	 /* histogram of time from start to irq */
+        unsigned int dasd_io_time2ps[32]; /* histogram of time from start to irq */
+        unsigned int dasd_io_time3[32];	 /* histogram of time from irq to end */
+        unsigned int dasd_io_nr_req[32]; /* histogram of # of requests in chanq */
+} dasd_profile_info_t;
 
 /* 
  * struct format_data_t
@@ -50,334 +47,65 @@
 	int start_unit; /* from track */
 	int stop_unit;  /* to track */
 	int blksize;    /* sectorsize */
-        int intensity;  /* 0: normal, 1:record zero, 3:home address, 4 invalidate tracks */
-} __attribute__ ((packed)) format_data_t;
-
-#define DASD_FORMAT_DEFAULT_START_UNIT 0
-#define DASD_FORMAT_DEFAULT_STOP_UNIT -1
-#define DASD_FORMAT_DEFAULT_BLOCKSIZE -1
-#define DASD_FORMAT_DEFAULT_INTENSITY -1
-
-#define DASD_FORMAT_INTENS_WRITE_RECZERO 0x01
-#define DASD_FORMAT_INTENS_WRITE_HOMEADR 0x02
-#define DASD_FORMAT_INTENS_INVALIDATE    0x04
-#define DASD_FORMAT_INTENS_CDL 0x08
-#ifdef __KERNEL__
-#include <linux/version.h>
-#include <linux/major.h>
-#include <linux/wait.h>
-#include <asm/ccwcache.h>
-#include <linux/blk.h> 
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-#include <linux/blkdev.h> 
-#include <linux/devfs_fs_kernel.h>
-#endif
-#include <linux/genhd.h>
-#include <linux/hdreg.h>
-#include <linux/compatmac.h>
+        int intensity;  
+} format_data_t;
 
-#include <asm/s390dyn.h>
-#include <asm/todclk.h>
-#include <asm/debug.h>
-
-/* Kernel Version Compatibility section */
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,98))
-typedef struct request *request_queue_t;
-#define block_device_operations file_operations
-#define __setup(x,y) struct dasd_device_t
-#define devfs_register_blkdev(major,name,ops) register_blkdev(major,name,ops)
-#define register_disk(dd,dev,partn,ops,size) \
-do { \
-	dd->sizes[MINOR(dev)] = size >> 1; \
-	resetup_one_dev(dd,MINOR(dev)>>DASD_PARTN_BITS); \
-} while(0)
-#define init_waitqueue_head(x) do { *x = NULL; } while(0)
-#define blk_cleanup_queue(x) do {} while(0)
-#define blk_init_queue(x...) do {} while(0)
-#define blk_queue_headactive(x...) do {} while(0)
-#define blk_queue_make_request(x) do {} while(0)
-#define list_empty(x) (0)
-#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
-do { \
-        blk_dev[d_major].request_fn = d_request_fn; \
-        blk_dev[d_major].queue = d_queue_fn; \
-        blk_dev[d_major].current_request = d_current; \
-} while(0)
-#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
-	major:D_MAJOR, \
-	major_name:D_NAME, \
-	minor_shift:D_PARTN_BITS, \
-	max_p:1 << D_PARTN_BITS, \
-	max_nr:D_PER_MAJOR, \
-	nr_real:D_PER_MAJOR,
-static inline struct request * 
-dasd_next_request( request_queue_t *queue ) 
-{
-    return *queue;
-}
-static inline void 
-dasd_dequeue_request( request_queue_t * q, struct request *req )
-{
-        *q = req->next;
-        req->next = NULL;
-}
-#else
-#define INIT_BLK_DEV(d_major,d_request_fn,d_queue_fn,d_current) \
-do { \
-        blk_dev[d_major].queue = d_queue_fn; \
-} while(0)
-#define INIT_GENDISK(D_MAJOR,D_NAME,D_PARTN_BITS,D_PER_MAJOR) \
-	major:D_MAJOR, \
-	major_name:D_NAME, \
-	minor_shift:D_PARTN_BITS, \
-	max_p:1 << D_PARTN_BITS, \
-	nr_real:D_PER_MAJOR,
-static inline struct request * 
-dasd_next_request( request_queue_t *queue ) 
-{
-        return blkdev_entry_next_request(&queue->queue_head);
-}
-static inline void 
-dasd_dequeue_request( request_queue_t * q, struct request *req )
-{
-        blkdev_dequeue_request (req);
-}
-#endif
-
-/* dasd_range_t are used for dynamic device att-/detachment */
-typedef struct dasd_devreg_t {
-        devreg_t devreg; /* the devreg itself */
-        /* build a linked list of devregs, needed for cleanup */
-        struct list_head list;
-} dasd_devreg_t;
-
-typedef struct {
-	struct list_head list;
-	int no;
-	dasd_ioctl_fn_t handler;
-} dasd_ioctl_list_t;
-
-typedef enum {
-	dasd_era_fatal = -1,	/* no chance to recover              */
-	dasd_era_none = 0,	/* don't recover, everything alright */
-	dasd_era_msg = 1,	/* don't recover, just report...     */
-	dasd_era_recover = 2	/* recovery action recommended       */
-} dasd_era_t;
-
-/* BIT DEFINITIONS FOR SENSE DATA */
-#define DASD_SENSE_BIT_0 0x80
-#define DASD_SENSE_BIT_1 0x40
-#define DASD_SENSE_BIT_2 0x20
-#define DASD_SENSE_BIT_3 0x10
-
-#define check_then_set(where,from,to) \
-do { \
-        if ((*(where)) != (from) ) { \
-                printk (KERN_ERR PRINTK_HEADER "was %d\n", *(where)); \
-                BUG(); \
-        } \
-        (*(where)) = (to); \
-} while (0)
-
-#define DASD_MESSAGE(d_loglevel,d_device,d_string,d_args...)\
-do { \
-        int d_devno = d_device->devinfo.devno; \
-        int d_irq = d_device->devinfo.irq; \
-        char *d_name = d_device->name; \
-        int d_major = MAJOR(d_device->kdev); \
-        int d_minor = MINOR(d_device->kdev); \
-        printk(d_loglevel PRINTK_HEADER \
-               "/dev/%s(%d:%d),%04X IRQ0x%x:" \
-               d_string "\n",d_name,d_major,d_minor,d_devno,d_irq,d_args ); \
-} while(0)
-
-/* 
- * struct dasd_sizes_t
- * represents all data needed to access dasd with properly set up sectors
- */
-typedef
-struct dasd_sizes_t {
-	unsigned long blocks; /* size of volume in blocks */
-	unsigned int bp_block; /* bytes per block */
-	unsigned int s2b_shift; /* log2 (bp_block/512) */
-        unsigned int pt_block; /* from which block to read the partn table */
-} dasd_sizes_t;
-
-/* 
- * struct dasd_chanq_t 
- * represents a queue of channel programs related to a single device
- */
-typedef
-struct dasd_chanq_t {
-	ccw_req_t *head;
-	ccw_req_t *tail;
-} dasd_chanq_t;
-
-#define DASD_DEVICE_FORMAT_STRING "Device: %p"
-#define DASD_DEVICE_DEBUG_EVENT(d_level, d_device, d_str, d_data...)\
-do {\
-        if ( d_device->debug_area != NULL )\
-        debug_sprintf_event(d_device->debug_area,d_level,\
-                    DASD_DEVICE_FORMAT_STRING d_str "\n",\
-                    d_device, d_data);\
-} while(0);
-#define DASD_DEVICE_DEBUG_EXCEPTION(d_level, d_device, d_str, d_data...)\
-do {\
-        if ( d_device->debug_area != NULL )\
-        debug_sprintf_exception(d_device->debug_area,d_level,\
-                        DASD_DEVICE_FORMAT_STRING d_str "\n",\
-                        d_device, d_data);\
-} while(0);
-
-#define DASD_DRIVER_FORMAT_STRING "Driver: <[%p]>"
-#define DASD_DRIVER_DEBUG_EVENT(d_level, d_fn, d_str, d_data...)\
-do {\
-        if ( dasd_debug_area != NULL )\
-        debug_sprintf_event(dasd_debug_area, d_level,\
-                    DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
-                    d_fn, d_data);\
-} while(0);
-#define DASD_DRIVER_DEBUG_EXCEPTION(d_level, d_fn, d_str, d_data...)\
-do {\
-        if ( dasd_debug_area != NULL )\
-        debug_sprintf_exception(dasd_debug_area, d_level,\
-                        DASD_DRIVER_FORMAT_STRING #d_fn ":" d_str "\n",\
-                        d_fn, d_data);\
-} while(0);
-
-struct dasd_device_t;
-struct request;
+/*
+ * values to be used for format_data_t.intensity
+ * 0/8: normal format
+ * 1/9: also write record zero
+ * 3/11: also write home address
+ * 4/12: invalidate track
+ */
+#define DASD_FMT_INT_FMT_R0 1 /* write record zero */
+#define DASD_FMT_INT_FMT_HA 2 /* write home address, also set FMT_R0 ! */
+#define DASD_FMT_INT_INVAL  4 /* invalidate tracks */
+#define DASD_FMT_INT_COMPAT 8 /* use OS/390 compatible disk layout */
 
 /* 
- * signatures for the functions of dasd_discipline_t 
- * make typecasts much easier
- */
-typedef ccw_req_t *(*dasd_erp_action_fn_t) (ccw_req_t * cqr);
-typedef ccw_req_t *(*dasd_erp_postaction_fn_t) (ccw_req_t * cqr);
-
-typedef int (*dasd_ck_id_fn_t) (s390_dev_info_t *);
-typedef int (*dasd_ck_characteristics_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_fill_geometry_fn_t) (struct dasd_device_t *, struct hd_geometry *);
-typedef ccw_req_t *(*dasd_format_fn_t) (struct dasd_device_t *, struct format_data_t *);
-typedef ccw_req_t *(*dasd_init_analysis_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_do_analysis_fn_t) (struct dasd_device_t *);
-typedef int (*dasd_io_starter_fn_t) (ccw_req_t *);
-typedef void (*dasd_int_handler_fn_t)(int irq, void *, struct pt_regs *);
-typedef dasd_era_t (*dasd_error_examine_fn_t) (ccw_req_t *, devstat_t * stat);
-typedef dasd_erp_action_fn_t (*dasd_error_analyse_fn_t) (ccw_req_t *);
-typedef dasd_erp_postaction_fn_t (*dasd_erp_analyse_fn_t) (ccw_req_t *);
-typedef ccw_req_t *(*dasd_cp_builder_fn_t)(struct dasd_device_t *,struct request *);
-typedef char *(*dasd_dump_sense_fn_t)(struct dasd_device_t *,ccw_req_t *);
-typedef ccw_req_t *(*dasd_reserve_fn_t)(struct dasd_device_t *);
-typedef ccw_req_t *(*dasd_release_fn_t)(struct dasd_device_t *);
-typedef ccw_req_t *(*dasd_merge_cp_fn_t)(struct dasd_device_t *);
-
-
-/*
- * the dasd_discipline_t is
- * sth like a table of virtual functions, if you think of dasd_eckd
- * inheriting dasd...
- * no, currently we are not planning to reimplement the driver in C++
+ * struct dasd_information_t
+ * represents any data about the data, which is visible to userspace
  */
-typedef struct dasd_discipline_t {
-	char ebcname[8]; /* a name used for tagging and printks */
-        char name[8];		/* a name used for tagging and printks */
-	int max_blocks;	/* maximum number of blocks to be chained */
-	dasd_ck_id_fn_t id_check;	/* to check sense data */
-	dasd_ck_characteristics_fn_t check_characteristics;	/* to check the characteristics */
-	dasd_init_analysis_fn_t init_analysis;	/* to start the analysis of the volume */
-	dasd_do_analysis_fn_t do_analysis;	/* to complete the analysis of the volume */
-	dasd_fill_geometry_fn_t fill_geometry;	/* to set up hd_geometry */
-	dasd_io_starter_fn_t start_IO;
-        dasd_format_fn_t format_device;		/* to format the device */
-	dasd_error_examine_fn_t examine_error;
-	dasd_error_analyse_fn_t erp_action;
-	dasd_erp_analyse_fn_t erp_postaction;
-        dasd_cp_builder_fn_t build_cp_from_req;
-        dasd_dump_sense_fn_t dump_sense;
-        dasd_int_handler_fn_t int_handler;
-        dasd_reserve_fn_t reserve;
-        dasd_release_fn_t release;
-        dasd_merge_cp_fn_t merge_cp;
-	
-	struct dasd_discipline_t *next;	/* used for list of disciplines */
-} dasd_discipline_t;
-
-#define DASD_MAJOR_INFO_REGISTERED 1
-#define DASD_MAJOR_INFO_IS_STATIC 2
-
-typedef struct major_info_t {
-	struct list_head list;
-	struct dasd_device_t **dasd_device;
-	int flags;
-	struct gendisk gendisk; /* actually contains the major number */
-} __attribute__ ((packed)) major_info_t;
-
-typedef struct dasd_profile_info_t {
-        unsigned long dasd_io_reqs;	/* number of requests processed at all */
-        unsigned long dasd_io_secs[32];	/* histogram of request's sizes */
-        unsigned long dasd_io_times[32];	/* histogram of requests's times */
-        unsigned long dasd_io_timps[32];	/* histogram of requests's times per sector */
-        unsigned long dasd_io_time1[32];	/* histogram of time from build to start */
-       unsigned  long dasd_io_time2[32];	/* histogram of time from start to irq */
-        unsigned long dasd_io_time2ps[32];	/* histogram of time from start to irq */
-        unsigned long dasd_io_time3[32];	/* histogram of time from irq to end */
-} dasd_profile_info_t;
-
-typedef struct dasd_device_t {
-	s390_dev_info_t devinfo;
-	dasd_discipline_t *discipline;
-	int level;
-        int open_count;
-        kdev_t kdev;
-        major_info_t *major_info;
-	struct dasd_chanq_t queue;
-        wait_queue_head_t wait_q;
-        request_queue_t request_queue;
-        struct timer_list timer;      
-	devstat_t dev_status; /* needed ONLY!! for request_irq */
-        dasd_sizes_t sizes;
-        char name[16]; /* The name of the device in /dev */
-	char *private;	/* to be used by the discipline internally */
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,3,98))
-        devfs_handle_t devfs_entry;
-#endif /* LINUX_IS_24 */
-	struct tq_struct bh_tq;
-        atomic_t bh_scheduled;
-        debug_info_t *debug_area;
-        dasd_profile_info_t profile;
-        struct proc_dir_entry *proc_dir; /* directory node */
-        struct proc_dir_entry *proc_info; /* information from dasd_device_t */
-        struct proc_dir_entry *proc_stats; /* statictics information */
-}  dasd_device_t;
-
-/* dasd_device_t.level can be: */
-#define DASD_DEVICE_LEVEL_UNKNOWN 0x00
-#define DASD_DEVICE_LEVEL_RECOGNIZED 0x01
-#define DASD_DEVICE_LEVEL_ANALYSIS_PENDING 0x02
-#define DASD_DEVICE_LEVEL_ANALYSIS_PREPARED 0x04
-#define DASD_DEVICE_LEVEL_ANALYSED 0x08
-#define DASD_DEVICE_LEVEL_ONLINE 0x10
-
-int dasd_init (void);
-void dasd_discipline_enq (dasd_discipline_t *);
-int dasd_discipline_deq(dasd_discipline_t *);
-int dasd_start_IO (ccw_req_t *);
-void dasd_int_handler (int , void *, struct pt_regs *);
-ccw_req_t *default_erp_action (ccw_req_t *);
-ccw_req_t *default_erp_postaction (ccw_req_t *);
-int dasd_chanq_deq (dasd_chanq_t *, ccw_req_t *);
-ccw_req_t *dasd_alloc_request (char *, int, int);
-void dasd_free_request (ccw_req_t *);
-extern int (*genhd_dasd_name) (char *, int, int, struct gendisk *);
-extern int (*genhd_dasd_fillgeo) (int, struct hd_geometry *);
-int dasd_oper_handler (int irq, devreg_t * devreg);
-void dasd_schedule_bh (dasd_device_t *);
-
-debug_info_t *dasd_debug_area;
-
-#endif /* __KERNEL__ */
+typedef struct dasd_information_t {
+        unsigned int devno; /* S/390 devno */
+        unsigned int real_devno; /* for aliases */
+        unsigned int schid; /* S/390 subchannel identifier */
+        unsigned int cu_type  : 16; /* from SenseID */
+        unsigned int cu_model :  8; /* from SenseID */
+        unsigned int dev_type : 16; /* from SenseID */
+        unsigned int dev_model : 8; /* from SenseID */
+        unsigned int open_count; 
+        unsigned int req_queue_len; 
+        unsigned int chanq_len;
+        char type[4]; /* from discipline.name, 'none' for unknown */
+        unsigned int status; /* current device level */
+        unsigned int label_block; /* where to find the VOLSER */
+        unsigned int FBA_layout; /* fixed block size (like AIXVOL) */
+        unsigned int characteristics_size;
+        unsigned int confdata_size;
+        char characteristics[64]; /* from read_device_characteristics */
+        char configuration_data[256]; /* from read_configuration_data */
+} dasd_information_t;
 
+/* Disable the volume (for Linux) */
+#define BIODASDDISABLE _IO(DASD_IOCTL_LETTER,0) 
+/* Enable the volume (for Linux) */
+#define BIODASDENABLE  _IO(DASD_IOCTL_LETTER,1)  
+/* Issue a reserve/release command, rsp. */
+#define BIODASDRSRV    _IO(DASD_IOCTL_LETTER,2) /* reserve */
+#define BIODASDRLSE    _IO(DASD_IOCTL_LETTER,3) /* release */
+#define BIODASDSLCK    _IO(DASD_IOCTL_LETTER,4) /* steal lock */
+/* reset profiling information of a device */
+#define BIODASDPRRST   _IO(DASD_IOCTL_LETTER,5)
+/* retrieve API version number */
+#define DASDAPIVER     _IOR(DASD_IOCTL_LETTER,0,int)
+/* Get information on a dasd device */
+#define BIODASDINFO    _IOR(DASD_IOCTL_LETTER,1,dasd_information_t)
+/* retrieve profiling information of a device */
+#define BIODASDPRRD    _IOR(DASD_IOCTL_LETTER,2,dasd_profile_info_t)
+/* #define BIODASDFORMAT  _IOW(IOCTL_LETTER,0,format_data_t) , deprecated */
+#define BIODASDFMT     _IOW(DASD_IOCTL_LETTER,1,format_data_t) 
+#endif /* DASD_API_VERSION */
 #endif				/* DASD_H */
 
 /*
diff -urN linux/include/asm-s390x/debug.h linux-2.4.7/include/asm-s390x/debug.h
--- linux/include/asm-s390x/debug.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/debug.h	Mon Dec 17 13:41:49 2001
@@ -44,6 +44,7 @@
 
 #define DEBUG_MAX_LEVEL            6  /* debug levels range from 0 to 6 */
 #define DEBUG_OFF_LEVEL            -1 /* level where debug is switched off */
+#define DEBUG_FLUSH_ALL            -1 /* parameter to flush all areas */
 #define DEBUG_MAX_VIEWS            10 /* max number of views in proc fs */
 #define DEBUG_MAX_PROCF_LEN        16 /* max length for a proc file name */
 #define DEBUG_DEFAULT_LEVEL        3  /* initial debug level */
@@ -53,7 +54,7 @@
 #define DEBUG_DATA(entry) (char*)(entry + 1) /* data is stored behind */
                                              /* the entry information */
 
-#define STCK(x)	asm volatile ("STCK %0":"=m" (x))
+#define STCK(x)	asm volatile ("STCK %0" : "=m" (x) : : "cc" )
 
 typedef struct __debug_entry debug_entry_t;
 
diff -urN linux/include/asm-s390x/hardirq.h linux-2.4.7/include/asm-s390x/hardirq.h
--- linux/include/asm-s390x/hardirq.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/hardirq.h	Mon Dec 17 13:41:20 2001
@@ -17,42 +17,26 @@
 #include <asm/lowcore.h>
 #include <linux/sched.h>
 
-/* No irq_cpustat_t for s390, the data is held directly in S390_lowcore */
+/* entry.S is sensitive to the offsets of these fields */
+typedef struct {
+	unsigned int __softirq_pending;
+	unsigned int __local_irq_count;
+	unsigned int __local_bh_count;
+	unsigned int __syscall_count;
+	struct task_struct * __ksoftirqd_task; /* waitqueue is too large */
+} ____cacheline_aligned irq_cpustat_t;
 
-/*
- * Simple wrappers reducing source bloat.  S390 specific because each
- * cpu stores its data in S390_lowcore (PSA) instead of using a cache
- * aligned array element like most architectures.
- */
-
-#ifdef CONFIG_SMP
-
-#define softirq_active(cpu)	(safe_get_cpu_lowcore(cpu).__softirq_active)
-#define softirq_mask(cpu)	(safe_get_cpu_lowcore(cpu).__softirq_mask)
-#define local_irq_count(cpu)	(safe_get_cpu_lowcore(cpu).__local_irq_count)
-#define local_bh_count(cpu)	(safe_get_cpu_lowcore(cpu).__local_bh_count)
-#define syscall_count(cpu)	(safe_get_cpu_lowcore(cpu).__syscall_count)
-
-#else	/* CONFIG_SMP */
-
-/* Optimize away the cpu calculation, it is always current PSA */
-#define softirq_active(cpu)	((void)(cpu), S390_lowcore.__softirq_active)
-#define softirq_mask(cpu)	((void)(cpu), S390_lowcore.__softirq_mask)
-#define local_irq_count(cpu)	((void)(cpu), S390_lowcore.__local_irq_count)
-#define local_bh_count(cpu)	((void)(cpu), S390_lowcore.__local_bh_count)
-#define syscall_count(cpu)	((void)(cpu), S390_lowcore.__syscall_count)
-
-#endif	/* CONFIG_SMP */
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
 
 /*
  * Are we in an interrupt context? Either doing bottom half
  * or hardware interrupt processing?
- * Special definitions for s390, always access current PSA.
  */
-#define in_interrupt() ((S390_lowcore.__local_irq_count + S390_lowcore.__local_bh_count) != 0)
-  
-#define in_irq() (S390_lowcore.__local_irq_count != 0)
-  
+#define in_interrupt() ({ int __cpu = smp_processor_id(); \
+	(local_irq_count(__cpu) + local_bh_count(__cpu) != 0); })
+
+#define in_irq() (local_irq_count(smp_processor_id()) != 0)
+
 #ifndef CONFIG_SMP
   
 #define hardirq_trylock(cpu)	(local_irq_count(cpu) == 0)
diff -urN linux/include/asm-s390x/idals.h linux-2.4.7/include/asm-s390x/idals.h
--- linux/include/asm-s390x/idals.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/idals.h	Mon Dec 17 13:41:20 2001
@@ -10,36 +10,51 @@
 #include <linux/config.h>
 #include <asm/irq.h>
 
-typedef unsigned long idaw_t;
+#define IDA_SIZE_LOG 12 /* 11 for 2k , 12 for 4k */
+#define IDA_BLOCK_SIZE (1L<<IDA_SIZE_LOG)
 
-static inline idaw_t *
+static inline addr_t *
 idal_alloc ( int nridaws )
 {
 	if ( nridaws > 33 )
 		BUG();
-	return kmalloc(nridaws * sizeof(idaw_t), GFP_ATOMIC | GFP_DMA );
+	return kmalloc(nridaws * sizeof(addr_t), GFP_ATOMIC | GFP_DMA );
 }
 
 static inline void 
-idal_free ( idaw_t *idal )
+idal_free ( addr_t *idal )
 {
 	kfree (idal);
 }
 
+#if defined(CONFIG_ARCH_S390X)
+extern unsigned long __create_idal(unsigned long address, int count);
+#endif
+
 /*
  * Function: set_normalized_cda
  * sets the address of the data in CCW
  * if necessary it allocates an IDAL and sets sthe appropriate flags
  */
-#if defined (CONFIG_ARCH_S390X)
-extern void set_normalized_cda(ccw1_t * ccw, unsigned long address);
-#else
-static inline void
+static inline int
 set_normalized_cda(ccw1_t * ccw, unsigned long address)
 {
-	ccw->cda = address;
-}
+	int ret = 0;
+
+#if defined (CONFIG_ARCH_S390X)
+	if (((address + ccw->count) >> 31) != 0) {
+		if (ccw->flags & CCW_FLAG_IDA)
+			BUG();
+		address = __create_idal(address, ccw->count);
+		if (address)
+			ccw->flags |= CCW_FLAG_IDA;
+		else
+			ret = -ENOMEM;
+	}
 #endif
+	ccw->cda = (__u32) address;
+	return ret;
+}
 
 /*
  * Function: clear_normalized_cda
@@ -48,10 +63,12 @@
 static inline void
 clear_normalized_cda ( ccw1_t * ccw ) 
 {
+#if defined(CONFIG_ARCH_S390X)
 	if ( ccw -> flags & CCW_FLAG_IDA ) {
-		idal_free ( (idaw_t *)(unsigned long) (ccw -> cda ));
+		idal_free ( (addr_t *)(unsigned long) (ccw -> cda ));
 		ccw -> flags &= ~CCW_FLAG_IDA;
 	}
+#endif
 	ccw -> cda = 0;
 }
 
diff -urN linux/include/asm-s390x/init.h linux-2.4.7/include/asm-s390x/init.h
--- linux/include/asm-s390x/init.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/init.h	Mon Dec 17 13:41:20 2001
@@ -23,7 +23,7 @@
 #define __INITDATA      .section        ".data.init",#alloc,#write
 */
 
-#define __cacheline_aligned __attribute__ ((__aligned__(16)))
+#define __cacheline_aligned __attribute__ ((__aligned__(256)))
 
 #endif
 
diff -urN linux/include/asm-s390x/io.h linux-2.4.7/include/asm-s390x/io.h
--- linux/include/asm-s390x/io.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/io.h	Mon Dec 17 13:41:20 2001
@@ -31,7 +31,7 @@
                  "   jz     0f\n"
                  "   slgr   %0,%0\n"
                  "0:"
-                 : "=a" (real_address) : "a" (address) );
+                 : "=a" (real_address) : "a" (address) : "cc" );
         return real_address;
 }
 
diff -urN linux/include/asm-s390x/irq.h linux-2.4.7/include/asm-s390x/irq.h
--- linux/include/asm-s390x/irq.h	Wed Jul  4 14:50:39 2001
+++ linux-2.4.7/include/asm-s390x/irq.h	Mon Dec 17 13:43:29 2001
@@ -313,7 +313,7 @@
       scsw_t scsw;             /* subchannel status word */
       esw_t  esw;              /* extended status word */
       __u8   ecw[32];          /* extended control word */
-   } irb_t __attribute__ ((packed,aligned(4)));
+   } __attribute__ ((packed,aligned(4))) irb_t;
 #ifdef __KERNEL__
 
 /*
@@ -572,6 +572,10 @@
 extern int set_cons_dev(int irq);
 extern int reset_cons_dev(int irq);
 extern int wait_cons_dev(int irq);
+extern schib_t *s390_get_schib( int irq );
+
+extern int s390_register_adapter_interrupt(adapter_int_handler_t handler);
+extern int s390_unregister_adapter_interrupt(adapter_int_handler_t handler);
 
 /*
  * Some S390 specific IO instructions as inline
@@ -626,11 +630,6 @@
                 "   .align 8\n"
                 "   .quad 0b,2b\n"
                 ".previous"
-                "    lr   1,%1\n"
-                "    msch 0(%2)\n"
-                "0:  ipm  %0\n"
-                "    srl  %0,28\n"
-                "1:\n"
 #else
                 ".section .fixup,\"ax\"\n"
                 "2:  l    %0,%3\n"
diff -urN linux/include/asm-s390x/lowcore.h linux-2.4.7/include/asm-s390x/lowcore.h
--- linux/include/asm-s390x/lowcore.h	Fri Mar  2 14:12:06 2001
+++ linux-2.4.7/include/asm-s390x/lowcore.h	Mon Dec 17 13:42:42 2001
@@ -1,3 +1,4 @@
+
 /*
  *  include/asm-s390/lowcore.h
  *
@@ -38,17 +39,18 @@
 #define __LC_MCCK_CODE                  0x0E8
 
 #define __LC_SAVE_AREA                  0xC00
-#define __LC_CREGS_SAVE_AREA            0xC80
-#define __LC_AREGS_SAVE_AREA            0xD00
 #define __LC_KERNEL_STACK               0xD40
-#define __LC_KERNEL_LEVEL               0xD48
-#define __LC_IRQ_STAT                   0xD50
+#define __LC_ASYNC_STACK                0xD48
 #define __LC_CPUID                      0xD90
 #define __LC_CPUADDR                    0xD98
 #define __LC_IPLDEV                     0xDB8
 
 #define __LC_PANIC_MAGIC                0xE00
 
+#define __LC_AREGS_SAVE_AREA            0x1340
+#define __LC_CREGS_SAVE_AREA            0x1380
+
+#define __LC_PFAULT_INTPARM             0x11B8
 
 /* interrupt handler start with all io, external and mcck interrupt disabled */
 
@@ -84,6 +86,12 @@
 #include <asm/atomic.h>
 #include <asm/sigp.h>
 
+void restart_int_handler(void);
+void ext_int_handler(void);
+void system_call(void);
+void pgm_check_handler(void);
+void mcck_int_handler(void);
+void io_int_handler(void);
 
 struct _lowcore
 {
@@ -95,7 +103,7 @@
 	__u16        cpu_addr;                 /* 0x084 */
 	__u16        ext_int_code;             /* 0x086 */
         __u16        svc_ilc;                  /* 0x088 */
-        __u16        scv_code;                 /* 0x08a */
+        __u16        svc_code;                 /* 0x08a */
         __u16        pgm_ilc;                  /* 0x08c */
         __u16        pgm_code;                 /* 0x08e */
 	__u32        data_exc_code;            /* 0x090 */
@@ -139,37 +147,46 @@
         __u8         pad8[0xc00-0x214];        /* 0x214 */
         /* System info area */
 	__u64        save_area[16];            /* 0xc00 */
-	__u64        cregs_save_area[16];      /* 0xc80 */
-	__u32        access_regs_save_area[16];/* 0xd00 */
+        __u8         pad9[0xd40-0xc80];        /* 0xc80 */
  	__u64        kernel_stack;             /* 0xd40 */
-	__u64        kernel_level;             /* 0xd48 */
+	__u64        async_stack;              /* 0xd48 */
 	/* entry.S sensitive area start */
-	/* Next 6 words are the s390 equivalent of irq_stat */
-	__u32        __softirq_active;         /* 0xd50 */
-	__u32        __softirq_mask;           /* 0xd54 */
-	__u32        __local_irq_count;        /* 0xd58 */
-	__u32        __local_bh_count;         /* 0xd5c */
-	__u32        __syscall_count;          /* 0xd60 */
-	__u8         pad10[0xd80-0xd64];       /* 0xd64 */
+	__u8         pad10[0xd80-0xd50];       /* 0xd64 */
 	struct       cpuinfo_S390 cpu_data;    /* 0xd80 */
 	__u32        ipl_device;               /* 0xdb8 */
-	__u32        pad13;                    /* 0xdbc was lsw word of ipl_device until a bug was found DJB */
+	__u32        pad11;                    /* 0xdbc was lsw word of ipl_device until a bug was found DJB */
 	/* entry.S sensitive area end */
 
         /* SMP info area: defined by DJB */
         __u64        jiffy_timer_cc;           /* 0xdc0 */
 	__u64        ext_call_fast;            /* 0xdc8 */
-	__u64        ext_call_queue;           /* 0xdd0 */
-        __u64        ext_call_count;           /* 0xdd8 */
-
-        __u8         pad11[0xe00-0xde0];       /* 0xde0 */
+        __u8         pad12[0xe00-0xdd0];       /* 0xdd0 */
 
         /* 0xe00 is used as indicator for dump tools */
         /* whether the kernel died with panic() or not */
         __u32        panic_magic;              /* 0xe00 */
 
-        /* Align to the top 1k of prefix area */
-	__u8         pad12[0x1000-0xe04];      /* 0xe04 */
+	__u8         pad13[0x1200-0xe04];      /* 0xe04 */
+
+        /* System info area */ 
+
+	__u64        floating_pt_save_area[16]; /* 0x1200 */
+	__u64        gpregs_save_area[16];      /* 0x1280 */
+	__u32        st_status_fixed_logout[4]; /* 0x1300 */
+	__u8         pad14[0x1318-0x1310];      /* 0x1310 */
+	__u32        prefixreg_save_area;       /* 0x1318 */
+	__u32        fpt_creg_save_area;        /* 0x131c */
+	__u8         pad15[0x1324-0x1320];      /* 0x1320 */
+	__u32        tod_progreg_save_area;     /* 0x1324 */
+	__u32        cpu_timer_save_area[2];    /* 0x1328 */
+	__u32        clock_comp_save_area[2];   /* 0x1330 */
+	__u8         pad16[0x1340-0x1338];      /* 0x1338 */ 
+	__u32        access_regs_save_area[16]; /* 0x1340 */ 
+	__u64        cregs_save_area[16];       /* 0x1380 */
+
+	/* align to the top of the prefix area */
+
+	__u8         pad17[0x2000-0x1400];      /* 0x1400 */
 } __attribute__((packed)); /* End structure*/
 
 extern __inline__ void set_prefix(__u32 address)
diff -urN linux/include/asm-s390x/mathemu.h linux-2.4.7/include/asm-s390x/mathemu.h
--- linux/include/asm-s390x/mathemu.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/mathemu.h	Wed Dec 31 19:00:00 1969
@@ -1,48 +0,0 @@
-/*
- *  arch/s390/kernel/mathemu.h
- *    IEEE floating point emulation.
- *
- *  S390 version
- *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Martin Schwidefsky (schwidefsky@de.ibm.com)
- */
-
-#ifndef __MATHEMU__
-#define __MATHEMU__
-
-extern int math_emu_b3(__u8 *, struct pt_regs *);
-extern int math_emu_ed(__u8 *, struct pt_regs *);
-extern void math_emu_ldr(__u8 *);
-extern void math_emu_ler(__u8 *);
-extern void math_emu_std(__u8 *, struct pt_regs *);
-extern void math_emu_ld(__u8 *, struct pt_regs *);
-extern void math_emu_ste(__u8 *, struct pt_regs *);
-extern void math_emu_le(__u8 *, struct pt_regs *);
-extern int math_emu_lfpc(__u8 *, struct pt_regs *);
-extern int math_emu_stfpc(__u8 *, struct pt_regs *);
-extern int math_emu_srnm(__u8 *, struct pt_regs *);
-
-
-extern __u64 __adddf3(__u64,__u64);
-extern __u64 __subdf3(__u64,__u64);
-extern __u64 __muldf3(__u64,__u64);
-extern __u64 __divdf3(__u64,__u64);
-extern long  __cmpdf2(__u64,__u64);
-extern __u64 __negdf2(__u64);
-extern __u64 __absdf2(__u64);
-extern __u32 __addsf3(__u32,__u32);
-extern __u32 __subsf3(__u32,__u32);
-extern __u32 __mulsf3(__u32,__u32);
-extern __u32 __divsf3(__u32,__u32);
-extern __u32 __negsf2(__u32);
-extern __u32 __abssf2(__u32);
-extern long  __cmpsf2(__u32,__u32);
-extern __u32 __truncdfsf2(__u64);
-extern __u32 __fixsfsi(__u32);
-extern __u32 __fixdfsi(__u64);
-extern __u64  __floatsidf(__u32);
-extern __u32  __floatsisf(__u32);
-extern __u64  __extendsfdf2(__u32);
-
-#endif                                 /* __MATHEMU__                      */
-
diff -urN linux/include/asm-s390x/page.h linux-2.4.7/include/asm-s390x/page.h
--- linux/include/asm-s390x/page.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/page.h	Mon Dec 17 13:41:20 2001
@@ -26,7 +26,7 @@
                       "   slgr 1,1\n"
                       "   mvcl 2,0"
                       : : "a" ((void *) (page))
-		      : "memory", "1", "2", "3" );
+		      : "memory", "cc", "1", "2", "3" );
 }
 
 static inline void copy_page(void *to, void *from)
@@ -35,7 +35,7 @@
 		asm volatile ("   sgr  0,0\n"
 			      "   mvpg %0,%1"
 			      : : "a" ((void *)(to)), "a" ((void *)(from))
-			      : "memory", "0" );
+			      : "memory", "cc", "0" );
 	else
 		asm volatile ("   mvc  0(256,%0),0(%1)\n"
 			      "   mvc  256(256,%0),256(%1)\n"
diff -urN linux/include/asm-s390x/pci.h linux-2.4.7/include/asm-s390x/pci.h
--- linux/include/asm-s390x/pci.h	Wed Dec 31 19:00:00 1969
+++ linux-2.4.7/include/asm-s390x/pci.h	Mon Dec 17 13:41:20 2001
@@ -0,0 +1,9 @@
+#ifndef __ASM_S390_PCI_H
+#define __ASM_S390_PCI_H
+
+/* S/390 systems don't have a PCI bus. This file is just here because some stupid .c code
+ * includes it even if CONFIG_PCI is not set.
+ */
+
+#endif /* __ASM_S390_PCI_H */
+
diff -urN linux/include/asm-s390x/pgalloc.h linux-2.4.7/include/asm-s390x/pgalloc.h
--- linux/include/asm-s390x/pgalloc.h	Mon Apr 23 18:28:07 2001
+++ linux-2.4.7/include/asm-s390x/pgalloc.h	Mon Dec 17 13:41:20 2001
@@ -253,7 +253,7 @@
                 "    slr  2,2\n"
                 "    slr  3,3\n"
                 "    csp  2,4"
-                : : "a" (&dummy) : "2", "3", "4" );
+                : : "a" (&dummy) : "cc", "2", "3", "4" );
 }
 
 /*
diff -urN linux/include/asm-s390x/pgtable.h linux-2.4.7/include/asm-s390x/pgtable.h
--- linux/include/asm-s390x/pgtable.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/pgtable.h	Mon Dec 17 13:41:20 2001
@@ -54,13 +54,6 @@
 #endif /* !__ASSEMBLY__ */
 
 /*
- * Certain architectures need to do special things when PTEs
- * within a page table are directly modified.  Thus, the following
- * hook is made available.
- */
-#define set_pte(pteptr, pteval) ((*(pteptr)) = (pteval))
-
-/*
  * PMD_SHIFT determines the size of the area a second-level page
  * table can map
  */
@@ -164,6 +157,7 @@
 
 /* Bits in the page table entry */
 #define _PAGE_PRESENT   0x001          /* Software                         */
+#define _PAGE_MKCLEAR   0x002          /* Software                         */
 #define _PAGE_RO        0x200          /* HW read-only                     */
 #define _PAGE_INVALID   0x400          /* HW invalid                       */
 
@@ -180,7 +174,8 @@
  */
 #define _REGION_THIRD       0x4
 #define _REGION_THIRD_LEN   0x3 
-#define _REGION_TABLE       (_REGION_THIRD|_REGION_THIRD_LEN)
+#define _REGION_TABLE       (_REGION_THIRD|_REGION_THIRD_LEN|0x40|0x100)
+#define _KERN_REGION_TABLE  (_REGION_THIRD|_REGION_THIRD_LEN)
 
 /* Bits in the storage key */
 #define _PAGE_CHANGED    0x02          /* HW changed bit                   */
@@ -220,6 +215,25 @@
 #define __S111  PAGE_SHARED
 
 /*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ */
+extern inline void set_pte(pte_t *pteptr, pte_t pteval)
+{
+	if ((pte_val(pteval) & (_PAGE_MKCLEAR|_PAGE_INVALID))
+	    == _PAGE_MKCLEAR) 
+	{
+		pte_val(pteval) &= ~_PAGE_MKCLEAR;
+               
+		asm volatile ("sske %0,%1" 
+				: : "d" (0), "a" (pte_val(pteval)));
+	}
+
+	*pteptr = pteval;
+}
+
+/*
  * Permanent address of a page.
  */
 #define page_address(page) ((page)->virtual)
@@ -341,13 +355,10 @@
 
 extern inline pte_t pte_mkclean(pte_t pte)
 {
-	/* We can't clear the changed bit atomically. The iske/and/sske
-         * sequence has a race condition with the page referenced bit.
-         * At the moment pte_mkclean is always followed by a pte_mkold.
-         * So its safe to ignore the problem for now. Hope this will
-         * never change ... */
-	asm volatile ("sske %0,%1" 
-	              : : "d" (0), "a" (pte_val(pte)));
+	/* The only user of pte_mkclean is the fork() code.
+	   We must *not* clear the *physical* page dirty bit
+	   just because fork() wants to clear the dirty bit in
+	   *one* of the page's mappings.  So we just do nothing. */
 	return pte;
 }
 
@@ -358,12 +369,14 @@
 	asm volatile ("sske %0,%1" 
 	              : : "d" (_PAGE_CHANGED|_PAGE_REFERENCED),
 		          "a" (pte_val(pte)));
+
+	pte_val(pte) &= ~_PAGE_MKCLEAR;
 	return pte;
 }
 
 extern inline pte_t pte_mkold(pte_t pte)
 {
-	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)));
+	asm volatile ("rrbe 0,%0" : : "a" (pte_val(pte)) : "cc" );
 	return pte;
 }
 
@@ -382,7 +395,8 @@
 
 	asm volatile ("rrbe 0,%1\n\t"
 		      "ipm  %0\n\t"
-		      "srl  %0,28\n\t" : "=d" (ccode) : "a" (pte_val(*ptep)));
+		      "srl  %0,28\n\t"
+		      : "=d" (ccode) : "a" (pte_val(*ptep)) : "cc" );
 	return ccode & 2;
 }
 
@@ -428,7 +442,23 @@
 	pte_val(__pte) = physpage + pgprot_val(pgprot);
 	return __pte;
 }
-#define mk_pte(page,pgprot) mk_pte_phys(__pa(((page)-mem_map)<<PAGE_SHIFT),pgprot)
+
+#define mk_pte(pg, pgprot)                                                \
+({                                                                        \
+	struct page *__page = (pg);                                       \
+	unsigned long __physpage = __pa((__page-mem_map) << PAGE_SHIFT);  \
+	pte_t __pte = mk_pte_phys(__physpage, (pgprot));                  \
+	                                                                  \
+	if (__page != ZERO_PAGE(__physpage)) {                            \
+		int __users = page_count(__page);                         \
+		__users -= !!__page->buffers + !!__page->mapping;         \
+	                                                                  \
+		if (__users == 1)                                         \
+			pte_val(__pte) |= _PAGE_MKCLEAR;                  \
+        }                                                                 \
+	                                                                  \
+	__pte;                                                            \
+})
 
 #define pte_page(x) (mem_map+(unsigned long)((pte_val(x) >> PAGE_SHIFT)))
 
diff -urN linux/include/asm-s390x/processor.h linux-2.4.7/include/asm-s390x/processor.h
--- linux/include/asm-s390x/processor.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/processor.h	Mon Dec 17 13:41:20 2001
@@ -90,9 +90,11 @@
         __u32   error_code;            /* error-code of last prog-excep.   */
         __u32   trap_no;
         per_struct per_info;/* Must be aligned on an 4 byte boundary*/
-	addr_t  ieee_instruction_pointer; 
 	/* Used to give failing instruction back to user for ieee exceptions */
+	addr_t  ieee_instruction_pointer; 
 	unsigned long flags;            /* various flags */
+        /* pfault_wait is used to block the process on a pfault event */
+	addr_t  pfault_wait;
 };
 
 typedef struct thread_struct thread_struct;
@@ -109,7 +111,7 @@
               (__pa((addr_t) &swapper_pg_dir[0]) + _REGION_TABLE),\
                      0,0,0,                                       \
                      (per_struct) {{{{0,}}},0,0,0,0,{{0,}}},      \
-		     0					          \
+		     0, 0, 0				          \
 } 
 
 /* need to define ... */
@@ -220,7 +222,7 @@
                       "    stctg 0,15,0x380(1)\n" /* store control registers */
                       "    oi    0x384(1),0x10\n" /* fake protection bit */
                       "    lpswe 0(%0)"
-                      : : "a" (dw_psw), "a" (&ctl_buf) : "0", "1");
+                      : : "a" (dw_psw), "a" (&ctl_buf) : "cc", "0", "1");
 }
 
 #endif                                 /* __ASM_S390_PROCESSOR_H           */
diff -urN linux/include/asm-s390x/queue.h linux-2.4.7/include/asm-s390x/queue.h
--- linux/include/asm-s390x/queue.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/queue.h	Mon Dec 17 13:41:20 2001
@@ -7,7 +7,8 @@
  *
  *  A little set of queue utilies.
  */
-
+#ifndef __ASM_QUEUE_H
+#define __ASM_QUEUE_H
 #include <linux/stddef.h>
 
 typedef struct queue
@@ -29,12 +30,11 @@
 }
 
 static __inline__ void enqueue_tail(qheader *qhead,queue *member)
-{
-	queue *tail=qhead->tail;
-	member->next=NULL;
-	
+{	
 	if(member)
 	{
+		queue *tail=qhead->tail;
+
 		if(tail)
 			tail->next=member;
 		else
@@ -166,5 +166,5 @@
 	return(0);
 }
 
-
+#endif /* __ASM_QUEUE_H */
 
diff -urN linux/include/asm-s390x/s390-regs-common.h linux-2.4.7/include/asm-s390x/s390-regs-common.h
--- linux/include/asm-s390x/s390-regs-common.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/s390-regs-common.h	Wed Dec 31 19:00:00 1969
@@ -1,115 +0,0 @@
-/*
- *  include/asm-s390/s390-regs-common.h
- *
- *  S390 version
- *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
- *    Author(s): Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)
- *
- *  this file is designed to keep as much compatibility between
- *  gdb's representation of registers & the kernels representation of registers
- *  as possible so as to minimise translation between gdb registers &
- *  kernel registers please keep this matched with gdb & strace 
- */
-
-#ifndef _S390_REGS_COMMON_H
-#define _S390_REGS_COMMON_H
-#ifndef __ASSEMBLY__
-#include <asm/types.h>
-#endif
-#if defined(WANT_S390_TGT_DEFS) || defined(__KERNEL__)
-#define REGISTER_SIZE 8
-#endif
-#define NUM_GPRS      16
-#define GPR_SIZE      8
-#define PSW_MASK_SIZE 8
-#define PSW_ADDR_SIZE 8
-#define NUM_FPRS      16
-#define FPR_SIZE      8
-#define FPC_SIZE      4
-#define FPC_PAD_SIZE  4 /* gcc insists on aligning the fpregs */
-#define NUM_CRS       16
-#define CR_SIZE       8
-#define NUM_ACRS      16
-#define ACR_SIZE      4
-
-#define STACK_FRAME_OVERHEAD    160      /* size of minimum stack frame */
-
-#ifndef __ASSEMBLY__
-/* this typedef defines how a Program Status Word looks like */
-typedef struct 
-{
-        __u64   mask;
-        __u64   addr;
-} psw_t __attribute__ ((aligned(8)));
-
-typedef __u64 gpr_t;
-
-/* 2 __u32's are used for floats instead to compile  with a __STRICT_ANSI__ defined */ 
-typedef union
-{
-#ifdef __KERNEL__ 
-	__u64   d; /* mathemu.h gets upset otherwise */
-#else
-	double  d; /* ansi c dosen't like long longs & make sure that */
-	/* alignments are identical for both compiles */ 
-#endif
-       struct
-       {
-	       __u32 hi;
-	       __u32 lo;
-       } fp;
-       __u32    f; 
-} freg_t;
-
-typedef struct
-{
-/*
-  The compiler appears to like aligning freg_t on an 8 byte boundary
-  so I always access fpregs, this was causing fun when I was doing
-  coersions.
- */
-	__u32   fpc;
-	freg_t  fprs[NUM_FPRS];              
-} s390_fp_regs;
-
-#define FPC_EXCEPTION_MASK      0xF8000000
-#define FPC_FLAGS_MASK          0x00F80000
-#define FPC_DXC_MASK            0x0000FF00
-#define FPC_RM_MASK             0x00000003
-#define FPC_VALID_MASK         ((FPC_EXCEPTION_MASK|FPC_FLAGS_MASK| \
-                                 FPC_DXC_MASK|FPC_RM_MASK))
-
-
-/*
-  gdb structures & the kernel have this much always in common
- */
-#define S390_REGS_COMMON       \
-psw_t psw;                     \
-__u64 gprs[NUM_GPRS];          \
-__u32  acrs[NUM_ACRS];         \
-
-typedef struct
-{
-	S390_REGS_COMMON
-} s390_regs_common __attribute__ ((packed));
-
-
-/* Sequence of bytes for breakpoint illegal instruction.  */
-#define S390_BREAKPOINT {0x0,0x1}
-#define S390_BREAKPOINT_U16 ((__u16)0x0001)
-#define S390_SYSCALL_OPCODE ((__u16)0x0a00)
-#define S390_SYSCALL_SIZE   2
-#if defined(WANT_S390_TGT_DEFS) || defined(__KERNEL__)
-#define ADDR_BITS_REMOVE(addr) ((addr))
-#endif
-#endif
-#endif
-
-
-
-
-
-
-
-
-
diff -urN linux/include/asm-s390x/s390dyn.h linux-2.4.7/include/asm-s390x/s390dyn.h
--- linux/include/asm-s390x/s390dyn.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/s390dyn.h	Mon Dec 17 13:41:20 2001
@@ -37,11 +37,14 @@
 	oper_handler_func_t  oper_func;
 } devreg_t;
 
-#define DEVREG_EXACT_MATCH      0x00000001
-#define DEVREG_MATCH_DEV_TYPE   0x00000002
-#define DEVREG_MATCH_CU_TYPE    0x00000004
-#define DEVREG_NO_CU_INFO       0x00000008
-#define DEVREG_NO_DEV_INFO      0x00000010
+#define DEVREG_MATCH_CU_TYPE    0x00000001
+#define DEVREG_MATCH_CU_MODEL   0x00000002
+#define DEVREG_MATCH_DEV_TYPE   0x00000004
+#define DEVREG_MATCH_DEV_MODEL  0x00000008
+
+#define DEVREG_EXACT_MATCH      (DEVREG_MATCH_CU_TYPE|DEVREG_MATCH_CU_MODEL|DEVREG_MATCH_DEV_TYPE|DEVREG_MATCH_DEV_MODEL)
+#define DEVREG_NO_CU_INFO       (DEVREG_MATCH_DEV_TYPE|DEVREG_MATCH_DEV_MODEL)
+#define DEVREG_NO_DEV_INFO      (DEVREG_MATCH_CU_TYPE|DEVREG_MATCH_CU_MODEL)
 
 #define DEVREG_TYPE_DEVNO       0x80000000
 #define DEVREG_TYPE_DEVCHARS    0x40000000
diff -urN linux/include/asm-s390x/setup.h linux-2.4.7/include/asm-s390x/setup.h
--- linux/include/asm-s390x/setup.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/setup.h	Mon Dec 17 13:41:20 2001
@@ -29,6 +29,22 @@
 #define MACHINE_IS_P390  (machine_flags & 4)
 #define MACHINE_HAS_MVPG (machine_flags & 16)
 
+#define MACHINE_HAS_HWC  (!MACHINE_IS_P390)
+
+/*
+ * Console mode. Override with conmode=
+ */
+extern unsigned int console_mode;
+extern unsigned int console_device;
+
+#define CONSOLE_IS_UNDEFINED	(console_mode == 0)
+#define CONSOLE_IS_HWC		(console_mode == 1)
+#define CONSOLE_IS_3215		(console_mode == 2)
+#define CONSOLE_IS_3270		(console_mode == 3)
+#define SET_CONSOLE_HWC		do { console_mode = 1; } while (0)
+#define SET_CONSOLE_3215	do { console_mode = 2; } while (0)
+#define SET_CONSOLE_3270	do { console_mode = 3; } while (0)
+
 #else 
 
 #define IPL_DEVICE        0x10400
diff -urN linux/include/asm-s390x/sigcontext.h linux-2.4.7/include/asm-s390x/sigcontext.h
--- linux/include/asm-s390x/sigcontext.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/sigcontext.h	Mon Dec 17 13:42:42 2001
@@ -24,14 +24,14 @@
 {
         unsigned long mask;
         unsigned long addr;
-} _psw_t __attribute__ ((aligned(8)));
+} __attribute__ ((aligned(8))) _psw_t;
 
 typedef struct
 {
 	_psw_t psw;
 	unsigned long gprs[__NUM_GPRS];
 	unsigned int  acrs[__NUM_ACRS];
-} _s390_regs_common __attribute__ ((packed));
+} _s390_regs_common;
 
 typedef struct
 {
diff -urN linux/include/asm-s390x/siginfo.h linux-2.4.7/include/asm-s390x/siginfo.h
--- linux/include/asm-s390x/siginfo.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/siginfo.h	Mon Dec 17 13:43:29 2001
@@ -111,7 +111,7 @@
 #define SI_USER		0	/* sent by kill, sigsend, raise */
 #define SI_KERNEL	0x80	/* sent by the kernel from somewhere */
 #define SI_QUEUE	-1	/* sent by sigqueue */
-#define SI_TIMER	-2	/* sent by timer expiration */
+#define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
 #define SI_MESGQ	-3	/* sent by real time mesq state change */
 #define SI_ASYNCIO	-4	/* sent by AIO completion */
 #define SI_SIGIO	-5	/* sent by queued SIGIO */
@@ -122,71 +122,71 @@
 /*
  * SIGILL si_codes
  */
-#define ILL_ILLOPC	1	/* illegal opcode */
-#define ILL_ILLOPN	2	/* illegal operand */
-#define ILL_ILLADR	3	/* illegal addressing mode */
-#define ILL_ILLTRP	4	/* illegal trap */
-#define ILL_PRVOPC	5	/* privileged opcode */
-#define ILL_PRVREG	6	/* privileged register */
-#define ILL_COPROC	7	/* coprocessor error */
-#define ILL_BADSTK	8	/* internal stack error */
+#define ILL_ILLOPC	(__SI_FAULT|1)	/* illegal opcode */
+#define ILL_ILLOPN	(__SI_FAULT|2)	/* illegal operand */
+#define ILL_ILLADR	(__SI_FAULT|3)	/* illegal addressing mode */
+#define ILL_ILLTRP	(__SI_FAULT|4)	/* illegal trap */
+#define ILL_PRVOPC	(__SI_FAULT|5)	/* privileged opcode */
+#define ILL_PRVREG	(__SI_FAULT|6)	/* privileged register */
+#define ILL_COPROC	(__SI_FAULT|7)	/* coprocessor error */
+#define ILL_BADSTK	(__SI_FAULT|8)	/* internal stack error */
 #define NSIGILL		8
 
 /*
  * SIGFPE si_codes
  */
-#define FPE_INTDIV	1	/* integer divide by zero */
-#define FPE_INTOVF	2	/* integer overflow */
-#define FPE_FLTDIV	3	/* floating point divide by zero */
-#define FPE_FLTOVF	4	/* floating point overflow */
-#define FPE_FLTUND	5	/* floating point underflow */
-#define FPE_FLTRES	6	/* floating point inexact result */
-#define FPE_FLTINV	7	/* floating point invalid operation */
-#define FPE_FLTSUB	8	/* subscript out of range */
+#define FPE_INTDIV	(__SI_FAULT|1)	/* integer divide by zero */
+#define FPE_INTOVF	(__SI_FAULT|2)	/* integer overflow */
+#define FPE_FLTDIV	(__SI_FAULT|3)	/* floating point divide by zero */
+#define FPE_FLTOVF	(__SI_FAULT|4)	/* floating point overflow */
+#define FPE_FLTUND	(__SI_FAULT|5)	/* floating point underflow */
+#define FPE_FLTRES	(__SI_FAULT|6)	/* floating point inexact result */
+#define FPE_FLTINV	(__SI_FAULT|7)	/* floating point invalid operation */
+#define FPE_FLTSUB	(__SI_FAULT|8)	/* subscript out of range */
 #define NSIGFPE		8
 
 /*
  * SIGSEGV si_codes
  */
-#define SEGV_MAPERR	1	/* address not mapped to object */
-#define SEGV_ACCERR	2	/* invalid permissions for mapped object */
+#define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */
+#define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */
 #define NSIGSEGV	2
 
 /*
  * SIGBUS si_codes
  */
-#define BUS_ADRALN	1	/* invalid address alignment */
-#define BUS_ADRERR	2	/* non-existant physical address */
-#define BUS_OBJERR	3	/* object specific hardware error */
+#define BUS_ADRALN	(__SI_FAULT|1)	/* invalid address alignment */
+#define BUS_ADRERR	(__SI_FAULT|2)	/* non-existant physical address */
+#define BUS_OBJERR	(__SI_FAULT|3)	/* object specific hardware error */
 #define NSIGBUS		3
 
 /*
  * SIGTRAP si_codes
  */
-#define TRAP_BRKPT	1	/* process breakpoint */
-#define TRAP_TRACE	2	/* process trace trap */
+#define TRAP_BRKPT	(__SI_FAULT|1)	/* process breakpoint */
+#define TRAP_TRACE	(__SI_FAULT|2)	/* process trace trap */
 #define NSIGTRAP	2
 
 /*
  * SIGCHLD si_codes
  */
-#define CLD_EXITED	1	/* child has exited */
-#define CLD_KILLED	2	/* child was killed */
-#define CLD_DUMPED	3	/* child terminated abnormally */
-#define CLD_TRAPPED	4	/* traced child has trapped */
-#define CLD_STOPPED	5	/* child has stopped */
-#define CLD_CONTINUED	6	/* stopped child has continued */
+#define CLD_EXITED	(__SI_CHLD|1)	/* child has exited */
+#define CLD_KILLED	(__SI_CHLD|2)	/* child was killed */
+#define CLD_DUMPED	(__SI_CHLD|3)	/* child terminated abnormally */
+#define CLD_TRAPPED	(__SI_CHLD|4)	/* traced child has trapped */
+#define CLD_STOPPED	(__SI_CHLD|5)	/* child has stopped */
+#define CLD_CONTINUED	(__SI_CHLD|6)	/* stopped child has continued */
 #define NSIGCHLD
 
 /*
  * SIGPOLL si_codes
  */
-#define POLL_IN		1	/* data input available */
-#define POLL_OUT	2	/* output buffers available */
-#define POLL_MSG	3	/* input message available */
-#define POLL_ERR	4	/* i/o error */
-#define POLL_PRI	5	/* high priority input available */
-#define POLL_HUP	6	/* device disconnected */
+#define POLL_IN		(__SI_POLL|1)	/* data input available */
+#define POLL_OUT	(__SI_POLL|2)	/* output buffers available */
+#define POLL_MSG	(__SI_POLL|3)	/* input message available */
+#define POLL_ERR	(__SI_POLL|4)	/* i/o error */
+#define POLL_PRI	(__SI_POLL|5)	/* high priority input available */
+#define POLL_HUP	(__SI_POLL|6)	/* device disconnected */
 #define NSIGPOLL	6
 
 /*
@@ -224,7 +224,7 @@
 #ifdef __KERNEL__
 #include <linux/string.h>
 
-extern inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
+static inline void copy_siginfo(siginfo_t *to, siginfo_t *from)
 {
 	if (from->si_code < 0)
 		memcpy(to, from, sizeof(siginfo_t));
diff -urN linux/include/asm-s390x/signal.h linux-2.4.7/include/asm-s390x/signal.h
--- linux/include/asm-s390x/signal.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/signal.h	Mon Dec 17 13:41:20 2001
@@ -166,9 +166,9 @@
           __sighandler_t _sa_handler;
           void (*_sa_sigaction)(int, struct siginfo *, void *);
         } _u;
-        sigset_t sa_mask;
         unsigned long sa_flags;
         void (*sa_restorer)(void);
+	sigset_t sa_mask;
 };
 
 #define sa_handler      _u._sa_handler
diff -urN linux/include/asm-s390x/sigp.h linux-2.4.7/include/asm-s390x/sigp.h
--- linux/include/asm-s390x/sigp.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/sigp.h	Mon Dec 17 13:41:49 2001
@@ -62,33 +62,10 @@
         ec_restart,
         ec_halt,
         ec_power_off,
+	ec_call_function,
 	ec_bit_last
 } ec_bit_sig;
 
-/* Signals which come with a parameter area */
-typedef enum
-{
-        ec_callback_sync,
-        ec_callback_async
-} ec_cmd_sig;
-
-/* state information for signals */
-typedef enum
-{
-	ec_pending,
-	ec_executing,
-	ec_done
-} ec_state;
-
-/* header for the queuing of callbacks */
-typedef struct ec_ext_call
-{
-	ec_cmd_sig cmd;
-	atomic_t status;
-	struct ec_ext_call *next;
-	void (*func)(void *info);
-	void *info;
-} ec_ext_call;
 
 /*
  * Signal processor
diff -urN linux/include/asm-s390x/smp.h linux-2.4.7/include/asm-s390x/smp.h
--- linux/include/asm-s390x/smp.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/smp.h	Mon Dec 17 13:41:49 2001
@@ -64,12 +64,5 @@
 
 void smp_local_timer_interrupt(struct pt_regs * regs);
 
-sigp_ccode smp_ext_call(int cpu, void (*cb)(void *info), void *info, int wait);
-void smp_ext_call_others(void (*cb)(void *info), void *info, int wait);
-sigp_ccode smp_ext_bitcall(int cpu, ec_bit_sig sig);
-void smp_ext_bitcall_others(ec_bit_sig sig);
-
-int smp_signal_others(sigp_order_code order_code,__u32 parameter,
-                      int spin,sigp_info *info);
 #endif
 #endif
diff -urN linux/include/asm-s390x/softirq.h linux-2.4.7/include/asm-s390x/softirq.h
--- linux/include/asm-s390x/softirq.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/softirq.h	Mon Dec 17 13:41:49 2001
@@ -17,13 +17,29 @@
 #include <asm/hardirq.h>
 #include <asm/lowcore.h>
 
-#define cpu_bh_disable(cpu)	do { local_bh_count(cpu)++; barrier(); } while (0)
-#define cpu_bh_enable(cpu)	do { barrier(); local_bh_count(cpu)--; } while (0)
+#define __cpu_bh_enable(cpu) \
+                do { barrier(); local_bh_count(cpu)--; } while (0)
+#define cpu_bh_disable(cpu) \
+                do { local_bh_count(cpu)++; barrier(); } while (0)
 
-#define local_bh_disable()	cpu_bh_disable(smp_processor_id())
-#define local_bh_enable()	cpu_bh_enable(smp_processor_id())
+#define local_bh_disable()      cpu_bh_disable(smp_processor_id())
+#define __local_bh_enable()     __cpu_bh_enable(smp_processor_id())
 
 #define in_softirq() (local_bh_count(smp_processor_id()) != 0)
+
+extern void do_call_softirq(void);
+
+#define local_bh_enable()			          	        \
+do {							                \
+        unsigned int *ptr = &local_bh_count(smp_processor_id());        \
+        barrier();                                                      \
+        if (!--*ptr)							\
+		if (softirq_pending(smp_processor_id()))		\
+			/* Use the async. stack for softirq */		\
+			do_call_softirq();				\
+} while (0)
+
+#define __cpu_raise_softirq(cpu, nr) (softirq_pending(cpu) |= (1<<nr))
 
 #endif	/* __ASM_SOFTIRQ_H */
 
diff -urN linux/include/asm-s390x/spinlock.h linux-2.4.7/include/asm-s390x/spinlock.h
--- linux/include/asm-s390x/spinlock.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/spinlock.h	Mon Dec 17 13:42:42 2001
@@ -20,7 +20,7 @@
 
 typedef struct {
 	volatile unsigned int lock;
-} spinlock_t __attribute__ ((aligned (8)));
+} __attribute__ ((aligned (4))) spinlock_t;
 
 #define SPIN_LOCK_UNLOCKED (spinlock_t) { 0 }
 #define spin_lock_init(lp) do { (lp)->lock = 0; } while(0)
@@ -32,20 +32,19 @@
         __asm__ __volatile("    bras  1,1f\n"
                            "0:  # diag  0,0,68\n"
                            "1:  slr   0,0\n"
-                           "    cs    0,1,%1\n"
+                           "    cs    0,1,0(%0)\n"
                            "    jl    0b\n"
-                           : "=m" (lp->lock)
-                           : "0" (lp->lock) : "0", "1", "cc" );
+                           : : "a" (&lp->lock) : "0", "1", "cc", "memory" );
 }
 
 extern inline int spin_trylock(spinlock_t *lp)
 {
 	unsigned int result;
-	__asm__ __volatile("    slr   %1,%1\n"
+	__asm__ __volatile("    slr   %0,%0\n"
 			   "    basr  1,0\n"
-			   "0:  cs    %1,1,%0"
-			   : "=m" (lp->lock), "=&d" (result)
-			   : "0" (lp->lock) : "1", "cc" );
+			   "0:  cs    %0,1,0(%1)"
+			   : "=&d" (result)
+			   : "a" (&lp->lock) : "1", "cc", "memory" );
 	return !result;
 }
 
@@ -53,7 +52,7 @@
 {
 	__asm__ __volatile("    xc 0(4,%0),0(%0)\n"
                            "    bcr 15,0"
-			   : /* no output */ : "a" (lp) : "memory", "cc" );
+			   : : "a" (&lp->lock) : "memory", "cc" );
 }
 		
 /*
@@ -76,46 +75,42 @@
 #define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
 
 #define read_lock(rw)   \
-        asm volatile("   la    1,%0\n"   \
-                     "   lg    2,0(1)\n"   \
+        asm volatile("   lg    2,0(%0)\n"   \
                      "   j     1f\n"     \
                      "0: # diag  0,0,68\n" \
                      "1: nihh  2,0x7fff\n" /* clear high (=write) bit */ \
                      "   la    3,1(2)\n"   /* one more reader */  \
-                     "   csg   2,3,0(1)\n" /* try to write new value */ \
+                     "   csg   2,3,0(%0)\n" /* try to write new value */ \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "1", "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define read_unlock(rw) \
-        asm volatile("   la    1,%0\n"   \
-                     "   lg    2,0(1)\n"   \
+        asm volatile("   lg    2,0(%0)\n"   \
                      "   j     1f\n"     \
                      "0: # diag  0,0,68\n" \
                      "1: lgr   3,2\n"    \
                      "   bctgr 3,0\n"    /* one less reader */ \
-                     "   csg   2,3,0(1)\n" \
+                     "   csg   2,3,0(%0)\n" \
                      "   jl    0b"       \
-                     : "+m" ((rw)->lock) : : "1", "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define write_lock(rw) \
-        asm volatile("   la    1,%0\n"     \
-                     "   llihh 3,0x8000\n" /* new lock value = 0x80...0 */ \
+        asm volatile("   llihh 3,0x8000\n" /* new lock value = 0x80...0 */ \
                      "   j     1f\n"       \
                      "0: # diag  0,0,68\n"   \
                      "1: slgr  2,2\n"      /* old lock value must be 0 */ \
-                     "   csg   2,3,0(1)\n" \
+                     "   csg   2,3,0(%0)\n" \
                      "   jl    0b"         \
-                     : "+m" ((rw)->lock) : : "1", "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #define write_unlock(rw) \
-        asm volatile("   la    1,%0\n"     \
-                     "   slgr  3,3\n"      /* new lock value = 0 */ \
+        asm volatile("   slgr  3,3\n"      /* new lock value = 0 */ \
                      "   j     1f\n"       \
                      "0: # diag  0,0,68\n"   \
                      "1: llihh 2,0x8000\n" /* old lock value must be 0x8..0 */\
-                     "   csg   2,3,0(1)\n"   \
+                     "   csg   2,3,0(%0)\n"   \
                      "   jl    0b"         \
-                     : "+m" ((rw)->lock) : : "1", "2", "3", "cc" );
+                     : : "a" (&(rw)->lock) : "2", "3", "cc", "memory" );
 
 #endif /* __ASM_SPINLOCK_H */
 
diff -urN linux/include/asm-s390x/system.h linux-2.4.7/include/asm-s390x/system.h
--- linux/include/asm-s390x/system.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/system.h	Mon Dec 17 13:41:20 2001
@@ -63,7 +63,7 @@
                                 "   jl    1b\n"
                                 "   ex    0,4(2)"     /* store *ptr to x */
                                 : "+&a" (ptr) : "a" (&x)
-                                : "memory", "0", "1", "2");
+                                : "memory", "cc", "0", "1", "2");
 			break;
                 case 2:
                         if(((addr_t)ptr)&1)
@@ -86,7 +86,7 @@
                                 "   jl    1b\n"
                                 "   ex    0,4(2)"     /* store *ptr to x */
                                 : "+&a" (ptr) : "a" (&x)
-                                : "memory", "0", "1", "2");
+                                : "memory", "cc", "0", "1", "2");
                         break;
                 case 4:
                         if(((addr_t)ptr)&3)
@@ -97,7 +97,7 @@
                                 "    jl   0b\n"
                                 "    lgfr %0,0\n"
                                 : "+d" (x) : "a" (ptr)
-                                : "memory", "0" );
+                                : "memory", "cc", "0" );
                         break;
                 case 8:
                         if(((addr_t)ptr)&7)
@@ -108,7 +108,7 @@
                                 "    jl  0b\n"
                                 "    lgr %0,0\n"
                                 : "+d" (x) : "a" (ptr)
-                                : "memory", "0" );
+                                : "memory", "cc", "0" );
                         break;
                default:
                         abort();
@@ -161,7 +161,7 @@
         __asm__ __volatile__("ssm   %0" : : "m" (x) : "memory")
 
 #define __load_psw(psw) \
-        __asm__ __volatile__("lpswe %0" : : "m" (psw));
+        __asm__ __volatile__("lpswe %0" : : "m" (psw) : "cc" );
 
 #define __ctl_load(array, low, high) ({ \
 	__asm__ __volatile__ ( \
@@ -196,7 +196,7 @@
                 "    stg   0,0(1)\n" \
                 "1:  ex    %1,6(2)"      /* execute lctl */ \
                 : "=m" (dummy) : "a" (cr*17), "a" (1L<<(bit)) \
-                : "0", "1", "2"); \
+                : "cc", "0", "1", "2"); \
         })
 
 #define __ctl_clear_bit(cr, bit) ({ \
@@ -214,7 +214,7 @@
                 "    stg   0,0(1)\n" \
                 "1:  ex    %1,6(2)"      /* execute lctl */ \
                 : "=m" (dummy) : "a" (cr*17), "a" (~(1L<<(bit))) \
-                : "0", "1", "2"); \
+                : "cc", "0", "1", "2"); \
         })
 
 /* For spinlocks etc */
diff -urN linux/include/asm-s390x/termios.h linux-2.4.7/include/asm-s390x/termios.h
--- linux/include/asm-s390x/termios.h	Mon Jun 11 22:15:27 2001
+++ linux-2.4.7/include/asm-s390x/termios.h	Mon Dec 17 13:41:20 2001
@@ -63,7 +63,7 @@
 #define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
 #define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
 #define N_HDLC         13	/* synchronous HDLC */
-#define N_BT		15	/* bluetooth */
+#define N_HCI		15	/* Bluetooth HCI UART */
 
 #ifdef __KERNEL__
 
diff -urN linux/include/asm-s390x/timex.h linux-2.4.7/include/asm-s390x/timex.h
--- linux/include/asm-s390x/timex.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/timex.h	Mon Dec 17 13:43:29 2001
@@ -17,7 +17,7 @@
 	(1000000/CLOCK_TICK_FACTOR) / (CLOCK_TICK_RATE/CLOCK_TICK_FACTOR)) \
 		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
 
-typedef unsigned long cycles_t;
+typedef unsigned long long cycles_t;
 
 extern cycles_t cacheflush_time;
 
diff -urN linux/include/asm-s390x/uaccess.h linux-2.4.7/include/asm-s390x/uaccess.h
--- linux/include/asm-s390x/uaccess.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/uaccess.h	Mon Dec 17 13:41:20 2001
@@ -97,7 +97,7 @@
 				".previous"
                                 : "=m" (*((__u64*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 extern inline int __put_user_asm_4(__u32 x, void *ptr)
@@ -119,7 +119,7 @@
 				".previous"
                                 : "=m" (*((__u32*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 
@@ -142,7 +142,7 @@
 				".previous"
                                 : "=m" (*((__u16*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "4" );
+                                : "cc", "4" );
         return err;
 }
 
@@ -165,7 +165,7 @@
 				".previous"
                                 : "=m" (*((__u8*) ptr)) , "=&d" (err)
                                 : "d" (x), "K" (-EFAULT)
-                                : "1", "4" );
+                                : "cc", "1", "4" );
         return err;
 }
 
@@ -228,7 +228,7 @@
                                 ".previous"                                \
                                 : "=d" (x) , "=&d" (err)                   \
                                 : "m" (*(const __u64*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                   \
+                                : "cc", "4" );                             \
 })
 #define __get_user_asm_4(x, ptr, err)                                      \
 ({                                                                         \
@@ -247,7 +247,7 @@
                                 ".previous"                                \
                                 : "=d" (x) , "=&d" (err)                   \
                                 : "m" (*(const __u32*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                   \
+                                : "cc", "4" );                             \
 })
 
 #define __get_user_asm_2(x, ptr, err)                                      \
@@ -267,7 +267,7 @@
                                 ".previous"                                \
                                 : "=d" (x) , "=&d" (err)                   \
                                 : "m" (*(const __u16*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                   \
+                                : "cc", "4" );                             \
 })
 
 #define __get_user_asm_1(x, ptr, err)                                     \
@@ -288,7 +288,7 @@
                                 ".previous"                               \
                                 : "=d" (x) , "=&d" (err)                  \
                                 : "m" (*(const __u8*)(ptr)),"K" (-EFAULT) \
-                                : "4" );                                  \
+                                : "cc", "4" );                            \
 })
 
 #define __get_user(x, ptr)                                      \
@@ -357,7 +357,7 @@
 				"   .quad  0b,__copy_to_user_fixup\n"
 				".previous"
                                 : "+&d" (n) : "d" (to), "d" (from)
-                                : "1", "2", "3", "4", "5" );
+                                : "cc", "1", "2", "3", "4", "5" );
         return n;
 }
 
@@ -395,7 +395,7 @@
 				"   .quad  0b,__copy_from_user_fixup\n"
 				".previous"
                                 : "+&d" (n) : "d" (to), "d" (from)
-                                : "1", "2", "3", "4", "5" );
+                                : "cc", "1", "2", "3", "4", "5" );
         return n;
 }
 
@@ -450,7 +450,7 @@
                                 : "=&a" (len)
                                 : "a"  (dst), "d" (src), "d" (count),
                                   "K" (-EFAULT)
-                                : "2" ,"3", "4" );
+                                : "cc", "2" ,"3", "4" );
         return len;
 }
 
diff -urN linux/include/asm-s390x/ucontext.h linux-2.4.7/include/asm-s390x/ucontext.h
--- linux/include/asm-s390x/ucontext.h	Tue Feb 13 17:13:44 2001
+++ linux-2.4.7/include/asm-s390x/ucontext.h	Mon Dec 17 13:41:20 2001
@@ -13,10 +13,8 @@
 	unsigned long	  uc_flags;
 	struct ucontext  *uc_link;
 	stack_t		  uc_stack;
+	_sigregs          uc_mcontext;
 	sigset_t	  uc_sigmask;	/* mask last for extensibility */
-	struct sigcontext *sc; /* Added for pthread support */
 };
-
-
 
 #endif /* !_ASM_S390_UCONTEXT_H */
diff -urN linux/include/asm-s390x/unistd.h linux-2.4.7/include/asm-s390x/unistd.h
--- linux/include/asm-s390x/unistd.h	Fri Mar  2 14:12:06 2001
+++ linux-2.4.7/include/asm-s390x/unistd.h	Mon Dec 17 13:41:49 2001
@@ -154,6 +154,8 @@
 #define __NR_capset             185
 #define __NR_sigaltstack        186
 #define __NR_sendfile           187
+#define __NR_getpmsg		188
+#define __NR_putpmsg		189
 #define __NR_vfork		190
 #define __NR_getrlimit		191	/* SuS compliant getrlimit */
 #define __NR_lchown  		198
@@ -179,7 +181,6 @@
 #define __NR_mincore            218
 #define __NR_madvise            219
 #define __NR_getdents64         220
-#define __NR_fcntl64            221
 
 
 /* user-visible error numbers are in the range -1 - -122: see <asm-s390/errno.h> */
@@ -200,7 +201,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name)                          \
                 : _svc_clobber );                            \
@@ -213,7 +214,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name),                         \
                   "d" (__arg1)                               \
@@ -228,7 +229,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name),                         \
                   "d" (__arg1),                              \
@@ -245,7 +246,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name),                         \
                   "d" (__arg1),                              \
@@ -265,7 +266,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name),                         \
                   "d" (__arg1),                              \
@@ -288,7 +289,7 @@
         long __res;                                          \
         __asm__ __volatile__ (                               \
                 "    svc %b1\n"                              \
-                "    lr  %0,2"                               \
+                "    lgr  %0,2"                              \
                 : "=d" (__res)                               \
                 : "i" (__NR_##name),                         \
                   "d" (__arg1),                              \
diff -urN linux/include/asm-s390x/vtoc.h linux-2.4.7/include/asm-s390x/vtoc.h
--- linux/include/asm-s390x/vtoc.h	Wed Apr 11 22:02:29 2001
+++ linux-2.4.7/include/asm-s390x/vtoc.h	Mon Dec 17 13:42:42 2001
@@ -15,41 +15,59 @@
 #include <linux/types.h>
 #include <linux/hdreg.h>
 #include <linux/version.h>
-#endif
 #include <asm/dasd.h>
+#endif
+
+#define DASD_API_VERSION 0
 
 #define LINE_LENGTH 80
 #define VTOC_START_CC 0x0
 #define VTOC_START_HH 0x1
+#define FIRST_USABLE_CYL 1
+#define FIRST_USABLE_TRK 2
+
+#define DASD_3380_TYPE 13148
+#define DASD_3390_TYPE 13200
+#define DASD_9345_TYPE 37701
+
+#define DASD_3380_VALUE 0xbb60
+#define DASD_3390_VALUE 0xe5a2
+#define DASD_9345_VALUE 0xbc98
 
-enum failure {unable_to_open,
-	      unable_to_seek,
-	      unable_to_write,
-	      unable_to_read};
+#define VOLSER_LENGTH 6
+#define BIG_DISK_SIZE 0x10000
 
-typedef struct ttr {
+#define VTOC_ERROR "VTOC error:"
+
+
+typedef struct ttr 
+{
         __u16 tt;
         __u8  r;
 } __attribute__ ((packed)) ttr_t;
 
-typedef struct cchhb {
+typedef struct cchhb 
+{
         __u16 cc;
         __u16 hh;
         __u8 b;
 } __attribute__ ((packed)) cchhb_t;
 
-typedef struct cchh {
+typedef struct cchh 
+{
         __u16 cc;
         __u16 hh;
 } __attribute__ ((packed)) cchh_t;
 
-typedef struct labeldate {
+typedef struct labeldate 
+{
         __u8  year;
         __u16 day;
 } __attribute__ ((packed)) labeldate_t;
 
 
-typedef struct volume_label {
+typedef struct volume_label 
+{
         char volkey[4];         /* volume key = volume label                 */
 	char vollbl[4];	        /* volume label                              */
 	char volid[6];	        /* volume identifier                         */
@@ -66,7 +84,8 @@
 } __attribute__ ((packed)) volume_label_t;
 
 
-typedef struct extent {
+typedef struct extent 
+{
         __u8  typeind;          /* extent type indicator                     */
         __u8  seqno;            /* extent sequence number                    */
         cchh_t llimit;          /* starting point of this extent             */
@@ -74,7 +93,8 @@
 } __attribute__ ((packed)) extent_t;
 
 
-typedef struct dev_const {
+typedef struct dev_const 
+{
         __u16 DS4DSCYL;           /* number of logical cyls                  */
         __u16 DS4DSTRK;           /* number of tracks in a logical cylinder  */
         __u16 DS4DEVTK;           /* device track length                     */
@@ -88,7 +108,8 @@
 } __attribute__ ((packed)) dev_const_t;
 
 
-typedef struct format1_label {
+typedef struct format1_label 
+{
 	char  DS1DSNAM[44];       /* data set name                           */
 	__u8  DS1FMTID;           /* format identifier                       */
 	char  DS1DSSN[6];         /* data set serial number                  */
@@ -124,7 +145,8 @@
 } __attribute__ ((packed)) format1_label_t;
 
 
-typedef struct format4_label {
+typedef struct format4_label 
+{
 	char  DS4KEYCD[44];       /* key code for VTOC labels: 44 times 0x04 */
         __u8  DS4IDFMT;           /* format identifier                       */
 	cchhb_t DS4HPCHR;         /* highest address of a format 1 DSCB      */
@@ -153,6 +175,43 @@
 } __attribute__ ((packed)) format4_label_t;
 
 
+typedef struct ds5ext 
+{
+	__u16 t;                  /* RTA of the first track of free extent   */
+	__u16 fc;                 /* number of whole cylinders in free ext.  */
+	__u8  ft;                 /* number of remaining free tracks         */
+} __attribute__ ((packed)) ds5ext_t;
+
+
+typedef struct format5_label 
+{
+	char DS5KEYID[4];         /* key identifier                          */
+	ds5ext_t DS5AVEXT;        /* first available (free-space) extent.    */
+	ds5ext_t DS5EXTAV[7];     /* seven available extents                 */
+	__u8 DS5FMTID;            /* format identifier                       */
+	ds5ext_t DS5MAVET[18];    /* eighteen available extents              */
+	cchhb_t DS5PTRDS;         /* pointer to next format5 DSCB            */
+} __attribute__ ((packed)) format5_label_t;
+
+
+typedef struct ds7ext 
+{
+	__u32 a;                  /* starting RTA value                      */
+	__u32 b;                  /* ending RTA value + 1                    */
+} __attribute__ ((packed)) ds7ext_t;
+
+
+typedef struct format7_label 
+{
+	char DS7KEYID[4];         /* key identifier                          */
+	ds7ext_t DS7EXTNT[5];     /* space for 5 extent descriptions         */
+	__u8 DS7FMTID;            /* format identifier                       */
+	ds7ext_t DS7ADEXT[11];    /* space for 11 extent descriptions        */
+	char res1[2];             /* reserved                                */
+	cchhb_t DS7PTRDS;         /* pointer to next FMT7 DSCB               */
+} __attribute__ ((packed)) format7_label_t;
+
+
 char * vtoc_ebcdic_enc (
         unsigned char source[LINE_LENGTH],
         unsigned char target[LINE_LENGTH],
@@ -181,45 +240,126 @@
         __u8 year,
         __u16 day);
 
+void vtoc_volume_label_init (
+	volume_label_t *vlabel);
 
 int vtoc_read_volume_label (
         char * device,
         unsigned long vlabel_start,
         volume_label_t * vlabel);
+
 int vtoc_write_volume_label (
-        char * device,
+        char *device,
         unsigned long vlabel_start,
-        volume_label_t * vlabel);
+        volume_label_t *vlabel);
+
+void vtoc_volume_label_set_volser (
+	volume_label_t *vlabel,
+	char *volser);
+
+char *vtoc_volume_label_get_volser (
+	volume_label_t *vlabel,
+	char *volser);
+
+void vtoc_volume_label_set_key (
+        volume_label_t *vlabel,
+        char *key);     
+
+void vtoc_volume_label_set_label (
+	volume_label_t *vlabel,
+	char *lbl);
+
+char *vtoc_volume_label_get_label (
+	volume_label_t *vlabel,
+	char *lbl);
+
 void vtoc_read_label (
         char *device,
         unsigned long position,
+        format1_label_t *f1,
         format4_label_t *f4,
-        format1_label_t *f1);
+        format5_label_t *f5,
+        format7_label_t *f7);
+
 void vtoc_write_label (
         char *device,
         unsigned long position,
+        format1_label_t *f1,
 	format4_label_t *f4,
-	format1_label_t *f1);
-void vtoc_init_format4_label (
-        struct hd_geometry *geo,
-        format4_label_t *f4lbl,
-	unsigned int usable_partitions,
-	unsigned int cylinders,
-	unsigned int tracks,
-	unsigned int blocks);
+	format5_label_t *f5,
+	format7_label_t *f7);
+
+
 void vtoc_init_format1_label (
         char *volid,
         unsigned int blksize,
         extent_t *part_extent,
         format1_label_t *f1);
+
+
+void vtoc_init_format4_label (
+        format4_label_t *f4lbl,
+	unsigned int usable_partitions,
+	unsigned int cylinders,
+	unsigned int tracks,
+	unsigned int blocks,
+	unsigned int blksize,
+	__u16 dev_type);
+
 void vtoc_update_format4_label (
 	format4_label_t *f4,
 	cchhb_t *highest_f1,
-	__u8 unused_update,
-	__u16 freespace_update);
+	__u16 unused_update);
+
 
+void vtoc_init_format5_label (
+	format5_label_t *f5);
 
+void vtoc_update_format5_label_add (
+	format5_label_t *f5,
+	int verbose,
+	int cyl,
+	int trk,
+	__u16 a, 
+	__u16 b, 
+	__u8 c);
+ 
+void vtoc_update_format5_label_del (
+	format5_label_t *f5,
+	int verbose,
+	int cyl,
+	int trk,
+	__u16 a, 
+	__u16 b, 
+	__u8 c);
+
+
+void vtoc_init_format7_label (
+	format7_label_t *f7);
+
+void vtoc_update_format7_label_add (
+	format7_label_t *f7,
+	int verbose,
+	__u32 a, 
+	__u32 b);
+
+void vtoc_update_format7_label_del (
+	format7_label_t *f7, 
+	int verbose,
+	__u32 a, 
+	__u32 b);
 
+
+void vtoc_set_freespace(
+	format4_label_t *f4,
+	format5_label_t *f5,
+	format7_label_t *f7,
+	char ch,
+	int verbose,
+	__u32 start,
+	__u32 stop,
+	int cyl,
+	int trk);
 
 
 
diff -urN linux/include/asm-sh/pgalloc.h linux-2.4.7/include/asm-sh/pgalloc.h
--- linux/include/asm-sh/pgalloc.h	Wed Jun 27 16:55:29 2001
+++ linux-2.4.7/include/asm-sh/pgalloc.h	Mon Dec 17 13:41:21 2001
@@ -131,4 +131,6 @@
 { /* Nothing to do */
 }
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* __ASM_SH_PGALLOC_H */
diff -urN linux/include/asm-sparc/pgalloc.h linux-2.4.7/include/asm-sparc/pgalloc.h
--- linux/include/asm-sparc/pgalloc.h	Thu Jul 19 21:11:13 2001
+++ linux-2.4.7/include/asm-sparc/pgalloc.h	Mon Dec 17 13:41:21 2001
@@ -142,4 +142,6 @@
 
 #define pte_free(pte)		free_pte_fast(pte)
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _SPARC_PGALLOC_H */
diff -urN linux/include/asm-sparc64/pgalloc.h linux-2.4.7/include/asm-sparc64/pgalloc.h
--- linux/include/asm-sparc64/pgalloc.h	Fri Apr 27 01:17:26 2001
+++ linux-2.4.7/include/asm-sparc64/pgalloc.h	Mon Dec 17 13:41:21 2001
@@ -304,4 +304,6 @@
 
 extern int do_check_pgt_cache(int, int);
 
+#include <asm-generic/pgalloc.h>
+
 #endif /* _SPARC64_PGALLOC_H */
diff -urN linux/include/linux/blk.h linux-2.4.7/include/linux/blk.h
--- linux/include/linux/blk.h	Fri Jul 20 15:53:47 2001
+++ linux-2.4.7/include/linux/blk.h	Mon Dec 17 13:41:21 2001
@@ -48,9 +48,9 @@
 extern int jsfd_init(void);
 
 #if defined(CONFIG_ARCH_S390)
-extern int mdisk_init(void);
 extern int dasd_init(void);
 extern int xpram_init(void);
+extern int tapeblock_init(void);
 #endif /* CONFIG_ARCH_S390 */
 
 extern void set_device_ro(kdev_t dev,int flag);
diff -urN linux/include/linux/list.h linux-2.4.7/include/linux/list.h
--- linux/include/linux/list.h	Fri Feb 16 19:06:17 2001
+++ linux-2.4.7/include/linux/list.h	Mon Dec 17 13:41:21 2001
@@ -149,6 +149,15 @@
 #define list_for_each(pos, head) \
 	for (pos = (head)->next; pos != (head); pos = pos->next)
 
+/**
+ * list_for_each_safe	-	iterate over a list safe agains removal of list entry
+ * @pos:	the &struct list_head to use as a loop counter.
+ * @n:	another &struct list_head to use as temporary storage
+ * @head:	the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); pos = n, n = pos->next)
+
 #endif /* __KERNEL__ || _LVM_H_INCLUDE */
 
 #endif
diff -urN linux/include/linux/tty.h linux-2.4.7/include/linux/tty.h
--- linux/include/linux/tty.h	Fri Jul 20 15:52:18 2001
+++ linux-2.4.7/include/linux/tty.h	Mon Dec 17 13:41:21 2001
@@ -381,6 +381,13 @@
 extern void tty_register_devfs (struct tty_driver *driver, unsigned int flags,
 				unsigned minor);
 extern void tty_unregister_devfs (struct tty_driver *driver, unsigned minor);
+struct devfs_entry;
+extern void tty_register_devfs_name (struct tty_driver *driver,
+				     unsigned int flags, unsigned minor,
+				     struct devfs_entry *dir, const char *name);
+extern void tty_unregister_devfs_name (struct tty_driver *driver,
+				       unsigned minor, struct devfs_entry *dir,
+				       const char *name);
 extern int tty_read_raw_data(struct tty_struct *tty, unsigned char *bufp,
 			     int buflen);
 extern void tty_write_message(struct tty_struct *tty, char *msg);
diff -urN linux/include/net/addrconf.h linux-2.4.7/include/net/addrconf.h
--- linux/include/net/addrconf.h	Wed May 16 13:31:27 2001
+++ linux-2.4.7/include/net/addrconf.h	Mon Dec 17 13:41:21 2001
@@ -88,6 +88,11 @@
 extern void			addrconf_prefix_rcv(struct net_device *dev,
 						    u8 *opt, int len);
 
+/* Device notifier */
+extern int register_inet6addr_notifier(struct notifier_block *nb);
+extern int unregister_inet6addr_notifier(struct notifier_block *nb);
+
+
 static inline struct inet6_dev *
 __in6_dev_get(struct net_device *dev)
 {
diff -urN linux/init/main.c linux-2.4.7/init/main.c
--- linux/init/main.c	Thu Jul  5 14:31:58 2001
+++ linux-2.4.7/init/main.c	Mon Dec 17 13:41:21 2001
@@ -222,6 +222,58 @@
 	{ "dasdf", (DASD_MAJOR << MINORBITS) + (5 << 2) },
 	{ "dasdg", (DASD_MAJOR << MINORBITS) + (6 << 2) },
 	{ "dasdh", (DASD_MAJOR << MINORBITS) + (7 << 2) },
+        { "dasdi", (DASD_MAJOR << MINORBITS) + (8 << 2) },
+        { "dasdj", (DASD_MAJOR << MINORBITS) + (9 << 2) },
+        { "dasdk", (DASD_MAJOR << MINORBITS) + (10 << 2) },
+        { "dasdl", (DASD_MAJOR << MINORBITS) + (11 << 2) },
+        { "dasdm", (DASD_MAJOR << MINORBITS) + (12 << 2) },
+        { "dasdn", (DASD_MAJOR << MINORBITS) + (13 << 2) },
+        { "dasdo", (DASD_MAJOR << MINORBITS) + (14 << 2) },
+        { "dasdp", (DASD_MAJOR << MINORBITS) + (15 << 2) },
+        { "dasdq", (DASD_MAJOR << MINORBITS) + (16 << 2) },
+        { "dasdr", (DASD_MAJOR << MINORBITS) + (17 << 2) },
+        { "dasds", (DASD_MAJOR << MINORBITS) + (18 << 2) },
+        { "dasdt", (DASD_MAJOR << MINORBITS) + (19 << 2) },
+        { "dasdu", (DASD_MAJOR << MINORBITS) + (20 << 2) },
+        { "dasdv", (DASD_MAJOR << MINORBITS) + (21 << 2) },
+        { "dasdw", (DASD_MAJOR << MINORBITS) + (22 << 2) },
+        { "dasdx", (DASD_MAJOR << MINORBITS) + (23 << 2) },
+        { "dasdy", (DASD_MAJOR << MINORBITS) + (24 << 2) },
+        { "dasdz", (DASD_MAJOR << MINORBITS) + (25 << 2) },
+#endif
+#ifdef CONFIG_BLK_DEV_XPRAM
+       { "xpram0", (XPRAM_MAJOR << MINORBITS) },
+       { "xpram1", (XPRAM_MAJOR << MINORBITS) + 1 },
+       { "xpram2", (XPRAM_MAJOR << MINORBITS) + 2 },
+       { "xpram3", (XPRAM_MAJOR << MINORBITS) + 3 },
+       { "xpram4", (XPRAM_MAJOR << MINORBITS) + 4 },
+       { "xpram5", (XPRAM_MAJOR << MINORBITS) + 5 },
+       { "xpram6", (XPRAM_MAJOR << MINORBITS) + 6 },
+       { "xpram7", (XPRAM_MAJOR << MINORBITS) + 7 },
+       { "xpram8", (XPRAM_MAJOR << MINORBITS) + 8 },
+       { "xpram9", (XPRAM_MAJOR << MINORBITS) + 9 },
+       { "xpram10", (XPRAM_MAJOR << MINORBITS) + 10 },
+       { "xpram11", (XPRAM_MAJOR << MINORBITS) + 11 },
+       { "xpram12", (XPRAM_MAJOR << MINORBITS) + 12 },
+       { "xpram13", (XPRAM_MAJOR << MINORBITS) + 13 },
+       { "xpram14", (XPRAM_MAJOR << MINORBITS) + 14 },
+       { "xpram15", (XPRAM_MAJOR << MINORBITS) + 15 },
+       { "xpram16", (XPRAM_MAJOR << MINORBITS) + 16 },
+       { "xpram17", (XPRAM_MAJOR << MINORBITS) + 17 },
+       { "xpram18", (XPRAM_MAJOR << MINORBITS) + 18 },
+       { "xpram19", (XPRAM_MAJOR << MINORBITS) + 19 },
+       { "xpram20", (XPRAM_MAJOR << MINORBITS) + 20 },
+       { "xpram21", (XPRAM_MAJOR << MINORBITS) + 21 },
+       { "xpram22", (XPRAM_MAJOR << MINORBITS) + 22 },
+       { "xpram23", (XPRAM_MAJOR << MINORBITS) + 23 },
+       { "xpram24", (XPRAM_MAJOR << MINORBITS) + 24 },
+       { "xpram25", (XPRAM_MAJOR << MINORBITS) + 25 },
+       { "xpram26", (XPRAM_MAJOR << MINORBITS) + 26 },
+       { "xpram27", (XPRAM_MAJOR << MINORBITS) + 27 },
+       { "xpram28", (XPRAM_MAJOR << MINORBITS) + 28 },
+       { "xpram29", (XPRAM_MAJOR << MINORBITS) + 29 },
+       { "xpram30", (XPRAM_MAJOR << MINORBITS) + 30 },
+       { "xpram31", (XPRAM_MAJOR << MINORBITS) + 31 },
 #endif
 #if defined(CONFIG_BLK_CPQ_DA) || defined(CONFIG_BLK_CPQ_DA_MODULE)
 	{ "ida/c0d0p",0x4800 },
diff -urN linux/kernel/ksyms.c linux-2.4.7/kernel/ksyms.c
--- linux/kernel/ksyms.c	Fri Jul 20 15:41:02 2001
+++ linux-2.4.7/kernel/ksyms.c	Mon Dec 17 13:41:21 2001
@@ -354,9 +354,7 @@
 EXPORT_SYMBOL(del_timer);
 EXPORT_SYMBOL(request_irq);
 EXPORT_SYMBOL(free_irq);
-#if !defined(CONFIG_ARCH_S390)
-EXPORT_SYMBOL(irq_stat);	/* No separate irq_stat for s390, it is part of PSA */
-#endif
+EXPORT_SYMBOL(irq_stat);
 
 /* waitqueue handling */
 EXPORT_SYMBOL(add_wait_queue);
@@ -457,6 +455,7 @@
 EXPORT_SYMBOL(bdevname);
 EXPORT_SYMBOL(cdevname);
 EXPORT_SYMBOL(simple_strtoul);
+EXPORT_SYMBOL(simple_strtoull);
 EXPORT_SYMBOL(system_utsname);	/* UTS data */
 EXPORT_SYMBOL(uts_sem);		/* UTS semaphore */
 #ifndef __mips__
diff -urN linux/kernel/printk.c linux-2.4.7/kernel/printk.c
--- linux/kernel/printk.c	Fri Jun 29 22:30:36 2001
+++ linux-2.4.7/kernel/printk.c	Mon Dec 17 13:41:21 2001
@@ -23,7 +23,12 @@
 
 #include <asm/uaccess.h>
 
-#define LOG_BUF_LEN	(16384)
+#ifndef CONFIG_ARCH_S390
+#define LOG_BUF_LEN     (16384)
+#else
+#define LOG_BUF_LEN     (131072)
+#endif
+
 #define LOG_BUF_MASK	(LOG_BUF_LEN-1)
 
 static char buf[1024];
diff -urN linux/kernel/sched.c linux-2.4.7/kernel/sched.c
--- linux/kernel/sched.c	Tue Jul 17 21:30:50 2001
+++ linux-2.4.7/kernel/sched.c	Mon Dec 17 13:43:30 2001
@@ -263,7 +263,7 @@
 				target_tsk = tsk;
 			}
 		} else {
-			if (oldest_idle == -1ULL) {
+			if (oldest_idle == (cycles_t) -1) {
 				int prio = preemption_goodness(tsk, p, cpu);
 
 				if (prio > max_prio) {
@@ -275,7 +275,7 @@
 	}
 	tsk = target_tsk;
 	if (tsk) {
-		if (oldest_idle != -1ULL) {
+		if (oldest_idle != (cycles_t) -1) {
 			best_cpu = tsk->processor;
 			goto send_now_idle;
 		}
diff -urN linux/kernel/softirq.c linux-2.4.7/kernel/softirq.c
--- linux/kernel/softirq.c	Mon Jul  9 19:32:45 2001
+++ linux-2.4.7/kernel/softirq.c	Mon Dec 17 13:41:21 2001
@@ -40,10 +40,7 @@
    - Bottom halves: globally serialized, grr...
  */
 
-/* No separate irq_stat for s390, it is part of PSA */
-#if !defined(CONFIG_ARCH_S390)
 irq_cpustat_t irq_stat[NR_CPUS];
-#endif	/* CONFIG_ARCH_S390 */
 
 static struct softirq_action softirq_vec[32] __cacheline_aligned;
 
diff -urN linux/mm/filemap.c linux-2.4.7/mm/filemap.c
--- linux/mm/filemap.c	Wed Jul 11 17:52:58 2001
+++ linux-2.4.7/mm/filemap.c	Mon Dec 17 13:41:21 2001
@@ -1651,8 +1651,8 @@
 
 	if (pte_present(pte)) {
 		struct page *page = pte_page(pte);
-		if (VALID_PAGE(page) && !PageReserved(page) && ptep_test_and_clear_dirty(ptep)) {
-			flush_tlb_page(vma, address);
+		if (VALID_PAGE(page) && !PageReserved(page) 
+                    && ptep_test_and_clear_and_flush_dirty(vma, address, ptep)) {
 			if (page->mapping)
 				set_page_dirty(page);
 		}
diff -urN linux/mm/memory.c linux-2.4.7/mm/memory.c
--- linux/mm/memory.c	Thu Jul 12 12:05:22 2001
+++ linux-2.4.7/mm/memory.c	Mon Dec 17 13:41:21 2001
@@ -844,20 +844,6 @@
 	return error;
 }
 
-/*
- * Establish a new mapping:
- *  - flush the old one
- *  - update the page tables
- *  - inform the TLB about the new one
- *
- * We hold the mm semaphore for reading and vma->vm_mm->page_table_lock
- */
-static inline void establish_pte(struct vm_area_struct * vma, unsigned long address, pte_t *page_table, pte_t entry)
-{
-	set_pte(page_table, entry);
-	flush_tlb_page(vma, address);
-	update_mmu_cache(vma, address, entry);
-}
 
 /*
  * We hold the mm semaphore for reading and vma->vm_mm->page_table_lock
@@ -868,7 +854,7 @@
 	copy_cow_page(old_page,new_page,address);
 	flush_page_to_ram(new_page);
 	flush_cache_page(vma, address);
-	establish_pte(vma, address, page_table, pte_mkwrite(pte_mkdirty(mk_pte(new_page, vma->vm_page_prot))));
+	ptep_establish(vma, address, page_table, pte_mkwrite(pte_mkdirty(mk_pte(new_page, vma->vm_page_prot))));
 }
 
 /*
@@ -929,7 +915,7 @@
 		if (PageReserved(old_page))
 			break;
 		flush_cache_page(vma, address);
-		establish_pte(vma, address, page_table, pte_mkyoung(pte_mkdirty(pte_mkwrite(pte))));
+		ptep_establish(vma, address, page_table, pte_mkyoung(pte_mkdirty(pte_mkwrite(pte))));
 		return 1;	/* Minor fault */
 	}
 
@@ -1294,7 +1280,7 @@
 		entry = pte_mkdirty(entry);
 	}
 	entry = pte_mkyoung(entry);
-	establish_pte(vma, address, pte, entry);
+	ptep_establish(vma, address, pte, entry);
 	return 1;
 }
 
diff -urN linux/mm/vmscan.c linux-2.4.7/mm/vmscan.c
--- linux/mm/vmscan.c	Mon Jul  9 13:18:50 2001
+++ linux-2.4.7/mm/vmscan.c	Mon Dec 17 13:41:21 2001
@@ -57,8 +57,7 @@
 	 * is needed on CPUs which update the accessed and dirty
 	 * bits in hardware.
 	 */
-	pte = ptep_get_and_clear(page_table);
-	flush_tlb_page(vma, address);
+	pte = ptep_invalidate(vma, address, page_table);
 
 	/*
 	 * Is the page already in the swap cache? If so, then
diff -urN linux/net/802/tr.c linux-2.4.7/net/802/tr.c
--- linux/net/802/tr.c	Mon Oct 16 15:42:53 2000
+++ linux-2.4.7/net/802/tr.c	Mon Dec 17 13:41:21 2001
@@ -6,7 +6,11 @@
  *		as published by the Free Software Foundation; either version
  *		2 of the License, or (at your option) any later version.
  *
- * Fixes:       3 Feb 97 Paul Norton <pnorton@cts.com> Minor routing fixes.
+ * Fixes:       1 Aug 01 D.J Barrow <djbarrow@de.ibm.com,barrow_dj@yahoo.com)
+ *              Changed rif_lock to spin_lock_irqsave in tr_add_rif_info as this 
+ *              causes crashes when called from interrupt also tr_source_route 
+ *              uses spin_lock_irqsave & these can't be mixed.  
+ *              3 Feb 97 Paul Norton <pnorton@cts.com> Minor routing fixes.
  *              Added rif table to /proc/net/tr_rif and rif timeout to
  *              /proc/sys/net/token-ring/rif_timeout.
  *              22 Jun 98 Paul Norton <p.norton@computer.org> Rearranged
@@ -325,9 +329,9 @@
 	int i;
 	unsigned int hash, rii_p = 0;
 	rif_cache entry;
+	unsigned long flags; 
 
-
-	spin_lock_bh(&rif_lock);
+	spin_lock_irqsave(&rif_lock,flags);
 	
 	/*
 	 *	Firstly see if the entry exists
@@ -366,7 +370,7 @@
 		if(!entry) 
 		{
 			printk(KERN_DEBUG "tr.c: Couldn't malloc rif cache entry !\n");
-			spin_unlock_bh(&rif_lock);
+			spin_unlock_irqrestore(&rif_lock,flags);
 			return;
 		}
 
@@ -408,7 +412,7 @@
 		    }                                         
            	entry->last_used=jiffies;               
 	}
-	spin_unlock_bh(&rif_lock);
+	spin_unlock_irqrestore(&rif_lock,flags);
 }
 
 /*
diff -urN linux/net/core/dev.c linux-2.4.7/net/core/dev.c
--- linux/net/core/dev.c	Sun Jul 15 19:29:40 2001
+++ linux-2.4.7/net/core/dev.c	Mon Dec 17 13:41:21 2001
@@ -20,7 +20,7 @@
  *              Pekka Riikonen <priikone@poesidon.pspt.fi>
  *
  *	Changes:
- *              D.J. Barrow     :       Fixed bug where dev->refcnt gets set to 2
+ *              D.J. Barrow     :       Fixed bug where dev->refcnt gets set to 2 
  *                                      if register_netdev gets called before
  *                                      net_dev_init & also removed a few lines
  *                                      of code in the process.
@@ -2391,7 +2391,6 @@
  */
 
 int net_dev_init(void);
-
 int register_netdevice(struct net_device *dev)
 {
 	struct net_device *d, **dp;
@@ -2408,7 +2407,6 @@
 
 	if (dev_boot_phase)
 		net_dev_init();
-
 #ifdef CONFIG_NET_DIVERT
 	ret = alloc_divert_blk(dev);
 	if (ret)
@@ -2792,6 +2790,9 @@
 {
 	char *argv[3], *envp[5], ifname[12 + IFNAMSIZ], action_str[32];
 	int i;
+
+	if (!dev_boot_phase)
+		return 0;
 
 	sprintf(ifname, "INTERFACE=%s", dev->name);
 	sprintf(action_str, "ACTION=%s", action);
diff -urN linux/net/core/skbuff.c linux-2.4.7/net/core/skbuff.c
--- linux/net/core/skbuff.c	Tue Jul 10 19:11:43 2001
+++ linux-2.4.7/net/core/skbuff.c	Mon Dec 17 13:42:42 2001
@@ -180,7 +180,7 @@
 	/* Get the HEAD */
 	skb = skb_head_from_pool();
 	if (skb == NULL) {
-		skb = kmem_cache_alloc(skbuff_head_cache, gfp_mask);
+		skb = kmem_cache_alloc(skbuff_head_cache, gfp_mask & ~__GFP_DMA);
 		if (skb == NULL)
 			goto nohead;
 	}
diff -urN linux/net/ipv4/tcp_ipv4.c linux-2.4.7/net/ipv4/tcp_ipv4.c
--- linux/net/ipv4/tcp_ipv4.c	Wed Apr 25 17:57:39 2001
+++ linux-2.4.7/net/ipv4/tcp_ipv4.c	Mon Dec 17 13:42:42 2001
@@ -1486,7 +1486,7 @@
 			bh_lock_sock(nsk);
 			return nsk;
 		}
-		tcp_tw_put((struct tcp_tw_bucket*)sk);
+		tcp_tw_put((struct tcp_tw_bucket*)nsk);
 		return NULL;
 	}
 
diff -urN linux/net/ipv4/tcp_minisocks.c linux-2.4.7/net/ipv4/tcp_minisocks.c
--- linux/net/ipv4/tcp_minisocks.c	Thu Apr 12 15:11:39 2001
+++ linux-2.4.7/net/ipv4/tcp_minisocks.c	Mon Dec 17 13:42:42 2001
@@ -371,7 +371,7 @@
 		tw->family	= sk->family;
 		tw->reuse	= sk->reuse;
 		tw->rcv_wscale	= tp->rcv_wscale;
-		atomic_set(&tw->refcnt, 0);
+		atomic_set(&tw->refcnt, 1);
 
 		tw->hashent	= sk->hashent;
 		tw->rcv_nxt	= tp->rcv_nxt;
@@ -407,6 +407,7 @@
 		}
 
 		tcp_tw_schedule(tw, timeo);
+		tcp_tw_put(tw);
 	} else {
 		/* Sorry, if we're out of memory, just CLOSE this
 		 * socket up.  We've got bigger problems than
diff -urN linux/net/ipv6/addrconf.c linux-2.4.7/net/ipv6/addrconf.c
--- linux/net/ipv6/addrconf.c	Thu Jun 21 00:00:55 2001
+++ linux-2.4.7/net/ipv6/addrconf.c	Mon Dec 17 13:41:21 2001
@@ -45,6 +45,7 @@
 #include <linux/sysctl.h>
 #endif
 #include <linux/delay.h>
+#include <linux/notifier.h>
 
 #include <linux/proc_fs.h>
 #include <net/sock.h>
@@ -99,6 +100,8 @@
 static void addrconf_rs_timer(unsigned long data);
 static void ipv6_ifa_notify(int event, struct inet6_ifaddr *ifa);
 
+static struct notifier_block *inet6addr_chain;
+
 struct ipv6_devconf ipv6_devconf =
 {
 	0,				/* forwarding		*/
@@ -392,6 +395,8 @@
 	write_unlock_bh(&idev->lock);
 	read_unlock(&addrconf_lock);
 
+	notifier_call_chain(&inet6addr_chain,NETDEV_UP,ifa);
+
 	return ifa;
 }
 
@@ -433,6 +438,7 @@
 
 	ipv6_ifa_notify(RTM_DELADDR, ifp);
 
+	notifier_call_chain(&inet6addr_chain,NETDEV_DOWN,ifp);
 
 	addrconf_del_timer(ifp);
 
@@ -1958,6 +1964,20 @@
 
 
 #endif
+
+/*
+ *      Device notifier
+ */
+
+int register_inet6addr_notifier(struct notifier_block *nb)
+{
+        return notifier_chain_register(&inet6addr_chain, nb);
+}
+
+int unregister_inet6addr_notifier(struct notifier_block *nb)
+{
+        return notifier_chain_unregister(&inet6addr_chain,nb);
+}
 
 /*
  *	Init / cleanup code
diff -urN linux/net/ipv6/tcp_ipv6.c linux-2.4.7/net/ipv6/tcp_ipv6.c
--- linux/net/ipv6/tcp_ipv6.c	Thu Jun 21 00:00:55 2001
+++ linux-2.4.7/net/ipv6/tcp_ipv6.c	Mon Dec 17 13:42:42 2001
@@ -1098,7 +1098,7 @@
 			bh_lock_sock(nsk);
 			return nsk;
 		}
-		tcp_tw_put((struct tcp_tw_bucket*)sk);
+		tcp_tw_put((struct tcp_tw_bucket*)nsk);
 		return NULL;
 	}
 
diff -urN linux/net/netsyms.c linux-2.4.7/net/netsyms.c
--- linux/net/netsyms.c	Wed Jul 11 18:44:45 2001
+++ linux-2.4.7/net/netsyms.c	Mon Dec 17 13:41:21 2001
@@ -61,6 +61,7 @@
 #include <net/ipv6.h>
 #include <net/ndisc.h>
 #include <net/transp_v6.h>
+#include <net/addrconf.h>
 
 extern int sysctl_local_port_range[2];
 extern int tcp_port_rover;
@@ -280,6 +281,9 @@
 #ifdef CONFIG_IPV6
 EXPORT_SYMBOL(ipv6_addr_type);
 EXPORT_SYMBOL(icmpv6_send);
+EXPORT_SYMBOL(ndisc_mc_map);
+EXPORT_SYMBOL(register_inet6addr_notifier);
+EXPORT_SYMBOL(unregister_inet6addr_notifier);
 #endif
 #if defined (CONFIG_IPV6_MODULE) || defined (CONFIG_KHTTPD) || defined (CONFIG_KHTTPD_MODULE)
 /* inet functions common to v4 and v6 */
