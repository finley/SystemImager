package SystemImager::KeaConfUtils;

use strict;
use warnings;
use JSON::PP;
use File::Spec;
use POSIX qw(strftime);
use SystemImager::IpUtils qw(valid_ip is_ip_in_network ip_to_int is_range_overlap first_usable_ip);

# Charger la configuration Kea depuis un fichier
sub load_kea_config {
    my ($file, $debug) = @_;
    my $config = { "Dhcp4" => {} };
    my $config_exists = 0;
    my @changelog = ();  # Stocker les entrées du changelog

    if (-r $file) {
        open my $fh, '<', $file or die "Impossible d'ouvrir $file: $!\n";
        local $/;
        my $content = <$fh>;
        close $fh;

        # Extraire le changelog
        if ($content =~ m{^// ---------- Changelog ----------\n(.*?)(?=(?:^\{|\Z))}ms) {
            my $changelog_content = $1;
            print "DEBUG: Contenu brut du changelog extrait :\n$changelog_content\n" if $debug;
            @changelog = split(/\n/, $changelog_content);
            # Filtrer les lignes valides (commençant par // et contenant une date au format YYYY-MM-DD HH:MM:SS)
            @changelog = grep { m{^//\s*\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\s+} } @changelog;
            print "DEBUG: Entrées du changelog après filtrage :\n", join("\n", @changelog), "\n" if $debug && @changelog;
            print "DEBUG: Aucune entrée de changelog valide trouvée\n" if $debug && !@changelog;
        } else {
            print "DEBUG: Aucune section changelog trouvée dans $file\n" if $debug;
        }

        # Supprimer les commentaires (// et /* */) pour le JSON
        $content =~ s#//.*$##gm;           # Supprime les commentaires //
        $content =~ s#/\*.*?\*/##gs;       # Supprime les commentaires /* ... */
        $content =~ s/^\s*[\r\n]+//gm;     # Supprime les lignes vides ou contenant uniquement des espaces
        $content =~ s/^\s*$//gm;           # Supprime les lignes blanches

        # Vérifier si le JSON restant est vide
        if ($content =~ /^\s*$/) {
            print "DEBUG: Le fichier $file est vide ou ne contient que des commentaires, création d'une nouvelle configuration\n" if $debug;
        } else {
            eval { $config = decode_json($content) };
            if ($@) {
                die "Erreur lors du décodage JSON de $file: $@\n";
            }
            $config_exists = 1;
            print "DEBUG: Configuration chargée depuis $file\n" if $debug;
        }
    } else {
        print "DEBUG: Aucun fichier de configuration existant, création d'une nouvelle configuration\n" if $debug;
    }

    return ($config, $config_exists, \@changelog);
}

# Écrire la configuration Kea dans un fichier
sub write_kea_config {
    my ($config, $file, $changelog) = @_;
    my $json = JSON::PP->new->pretty->canonical;
    my $config_data = $json->encode($config);

    # Générer l'en-tête avec la date et l'heure actuelles
    my $current_time = strftime("%Y-%m-%d %H:%M:%S %Z", localtime);
    my $header = <<EOF;
// This is a Kea DHCPv4 server configuration file generated by si_mkdhcpserver on $current_time
// You can tune it, but it is not guaranteed that your comments are kept upon next use of si_mkdhcpserver
//
EOF

    # Ajouter le changelog
    my $changelog_content = "";
    if (@$changelog) {
        $changelog_content = "// ---------- Changelog ----------\n" . join("\n", @$changelog) . "\n//\n";
    }

    # Écrire le fichier
    open my $fh, '>', $file or die "Impossible d'écrire dans $file: $!\n";
    print $fh $header;
    print $fh $changelog_content;
    print $fh $config_data;
    close $fh;
    print "Fichier de configuration généré: $file\n";
}

# Ajouter un pool à un sous-réseau
sub add_pool {
    my ($config, $net, $ip_start, $ip_end, $debug) = @_;
    die "Erreur: Paramètre réseau manquant pour add_pool\n" unless defined $net && $net ne '';
    my ($ip, $mask) = split('/', $net);
    die "Format réseau invalide: $net\n" unless defined $ip && defined $mask && valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32;
    die "IP de début invalide: $ip_start\n" unless defined $ip_start && valid_ip($ip_start);
    die "IP de fin invalide: $ip_end\n" unless defined $ip_end && valid_ip($ip_end);
    die "IP de début ($ip_start) n'est pas dans le sous-réseau $net\n" unless is_ip_in_network($ip_start, $mask, $ip, $mask);
    die "IP de fin ($ip_end) n'est pas dans le sous-réseau $net\n" unless is_ip_in_network($ip_end, $mask, $ip, $mask);
    die "IP de début ($ip_start) est supérieure à IP de fin ($ip_end)\n" if ip_to_int($ip_start) > ip_to_int($ip_end);

    # Trouver le sous-réseau
    my $subnet;
    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        $subnet = (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0];
    }
    die "Sous-réseau $net n'existe pas\n" unless $subnet;

    # Vérifier les conflits avec les réservations
    my @conflicting_reservations;
    $config->{"Dhcp4"}->{"reservations"} ||= [];
    foreach my $reservation (@{$config->{"Dhcp4"}->{"reservations"}}) {
        if ($reservation->{'ip-address'} && is_ip_in_range($reservation->{'ip-address'}, $ip_start, $ip_end)) {
            push @conflicting_reservations, $reservation;
        }
    }
    if (@conflicting_reservations) {
        print "Erreur: Le pool $ip_start - $ip_end dans le sous-réseau $net est en conflit avec les réservations suivantes :\n";
        foreach my $res (@conflicting_reservations) {
            print "  - ", ($res->{"hostname"} || $res->{'hw-address'} || $res->{'ip-address'}), "\n";
        }
        die "Abandon de l'opération pour le sous-réseau $net\n";
    }

    # Vérifier les chevauchements
    $subnet->{"pools"} ||= [];
    my @new_pools;
    foreach my $pool (@{$subnet->{"pools"}}) {
        next unless defined $pool->{"pool"} && $pool->{"pool"} =~ /\S/;
        my ($existing_start, $existing_end) = split(/\s*-\s*/, $pool->{"pool"});
        next unless defined $existing_start && defined $existing_end && valid_ip($existing_start) && valid_ip($existing_end);
        my ($is_included, $is_partial_overlap) = is_range_overlap($ip_start, $ip_end, $existing_start, $existing_end);
        if ($is_partial_overlap) {
            die "Erreur: Le pool $ip_start - $ip_end chevauche partiellement le pool existant $existing_start - $existing_end dans le sous-réseau $net\n";
        }
        push @new_pools, $pool unless $is_included;
    }
    push @new_pools, { "pool" => "$ip_start - $ip_end" };
    $subnet->{"pools"} = @new_pools ? \@new_pools : [];
    print "DEBUG: Pool ajouté: $ip_start - $ip_end dans le sous-réseau $net\n" if $debug;
    return 1;
}

# Supprimer un pool d'un sous-réseau
sub del_pool {
    my ($config, $net, $ip_start, $ip_end, $debug) = @_;
    die "Erreur: Paramètre réseau manquant pour del_pool\n" unless defined $net && $net ne '';
    my ($ip, $mask) = split('/', $net);
    die "Format réseau invalide: $net\n" unless defined $ip && defined $mask && valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32;
    die "IP de début invalide: $ip_start\n" unless defined $ip_start && valid_ip($ip_start);
    die "IP de fin invalide: $ip_end\n" unless defined $ip_end && valid_ip($ip_end);
    die "IP de début ($ip_start) n'est pas dans le sous-réseau $net\n" unless is_ip_in_network($ip_start, $mask, $ip, $mask);
    die "IP de fin ($ip_end) n'est pas dans le sous-réseau $net\n" unless is_ip_in_network($ip_end, $mask, $ip, $mask);
    die "IP de début ($ip_start) est supérieure à IP de fin ($ip_end)\n" if ip_to_int($ip_start) > ip_to_int($ip_end);

    # Trouver le sous-réseau
    my $subnet;
    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        $subnet = (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0];
    }
    die "Sous-réseau $net n'existe pas\n" unless $subnet;

    # Supprimer le pool spécifié
    $subnet->{"pools"} ||= [];
    my @new_pools;
    foreach my $pool (@{$subnet->{"pools"}}) {
        next unless defined $pool->{"pool"} && $pool->{"pool"} =~ /\S/;
        my ($existing_start, $existing_end) = split(/\s*-\s*/, $pool->{"pool"});
        next unless defined $existing_start && defined $existing_end && valid_ip($existing_start) && valid_ip($existing_end);
        if ($existing_start ne $ip_start || $existing_end ne $ip_end) {
            push @new_pools, $pool;
        }
    }
    $subnet->{"pools"} = @new_pools ? \@new_pools : [];
    print "DEBUG: Pool supprimé: $ip_start - $ip_end dans le sous-réseau $net\n" if $debug;
    return 1;
}

# Ajouter ou mettre à jour un sous-réseau
sub add_network {
    my ($config, $net, $ip_start, $ip_end, $debug) = @_;
    die "Erreur: Paramètre réseau manquant pour add_network\n" unless defined $net && $net ne '';
    my ($ip, $mask) = split('/', $net);
    die "Format réseau invalide: $net\n" unless defined $ip && defined $mask && valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32;

    # Vérifier si ip_start est fourni sans ip_end
    if (defined $ip_start && !defined $ip_end) {
        die "Erreur: IP de début fournie ($ip_start) mais IP de fin manquante pour le réseau $net\n";
    }

    # Créer la structure du sous-réseau
    my $subnet = {
        "subnet" => $net,
        "option-data" => [ { "name" => "routers", "data" => first_usable_ip($ip, $mask) } ]
    };

    # Gérer le pool si fourni
    if (defined $ip_start && defined $ip_end) {
        # Ajouter le pool via add_pool
        my $existing_subnet = (exists $config->{"Dhcp4"}->{"subnet4"} ? 
            (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0] : undef);
        if (!$existing_subnet) {
            # Créer le sous-réseau s'il n'existe pas
            $config->{"Dhcp4"}->{"subnet4"} ||= [];
            push @{$config->{"Dhcp4"}->{"subnet4"}}, $subnet;
        }
        add_pool($config, $net, $ip_start, $ip_end, $debug) or die "Échec de l'ajout du pool $ip_start - $ip_end dans $net\n";
    } else {
        # Aucun pool spécifié, préserver les pools valides existants
        my $existing_subnet = (exists $config->{"Dhcp4"}->{"subnet4"} ? 
            (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0] : undef);
        if ($existing_subnet && exists $existing_subnet->{"pools"}) {
            my @valid_pools;
            foreach my $pool (@{$existing_subnet->{"pools"}}) {
                if (defined $pool->{"pool"} && $pool->{"pool"} =~ /\S/) {
                    my ($start, $end) = split(/\s*-\s*/, $pool->{"pool"});
                    push @valid_pools, $pool if defined $start && defined $end && valid_ip($start) && valid_ip($end);
                }
            }
            $subnet->{"pools"} = @valid_pools ? \@valid_pools : [];
        } else {
            $subnet->{"pools"} = [];
        }
    }

    # Assigner un ID unique
    my $max_id = 0;
    my %used_ids;
    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $s (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            if (exists $s->{"id"} && $s->{"id"} =~ /^\d+$/) {
                $used_ids{$s->{"id"}} = 1;
                $max_id = $s->{"id"} if $s->{"id"} > $max_id;
            }
        }
    }
    my $existing_subnet = (exists $config->{"Dhcp4"}->{"subnet4"} ? 
        (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0] : undef);
    if ($existing_subnet && exists $existing_subnet->{"id"} && $existing_subnet->{"id"} =~ /^\d+$/) {
        $subnet->{"id"} = $existing_subnet->{"id"};
        $used_ids{$subnet->{"id"}} = 1;
    } else {
        $max_id++;
        while (exists $used_ids{$max_id}) {
            $max_id++;
        }
        $subnet->{"id"} = $max_id;
        $used_ids{$max_id} = 1;
    }

    # Préserver les attributs existants
    if ($existing_subnet) {
        foreach my $key (keys %$existing_subnet) {
            next if $key eq "id" || $key eq "subnet" || $key eq "pools" || $key eq "option-data";
            $subnet->{$key} = $existing_subnet->{$key};
        }
        my %existing_option_data;
        if (exists $existing_subnet->{"option-data"}) {
            foreach my $opt (@{$existing_subnet->{"option-data"}}) {
                next unless defined $opt->{"name"};
                $existing_option_data{$opt->{"name"}} = $opt unless grep { defined $_->{"name"} && $_->{"name"} eq $opt->{"name"} } @{$subnet->{"option-data"}};
            }
        }
        $subnet->{"option-data"} = [ @{$subnet->{"option-data"}}, values %existing_option_data ];
    }

    # Mettre à jour la liste des sous-réseaux
    $config->{"Dhcp4"}->{"subnet4"} ||= [];
    @{$config->{"Dhcp4"}->{"subnet4"}} = grep { $_->{"subnet"} ne $net } @{$config->{"Dhcp4"}->{"subnet4"}};
    push @{$config->{"Dhcp4"}->{"subnet4"}}, $subnet;
    print "DEBUG: Sous-réseau ajouté/mis à jour: $net\n" if $debug;
    return 1;
}

# Supprimer un sous-réseau
sub del_network {
    my ($config, $net, $force, $debug) = @_;
    die "Erreur: Paramètre réseau manquant pour del_network\n" unless defined $net && $net ne '';
    my ($ip, $mask) = split('/', $net);
    die "Format réseau invalide: $net\n" unless defined $ip && defined $mask && valid_ip($ip) && $mask =~ /^\d+$/ && $mask >= 0 && $mask <= 32;
    $force = defined $force && $force ? 1 : 0;

    # Vérifier si le sous-réseau existe
    my $existing_subnet = (exists $config->{"Dhcp4"}->{"subnet4"} ? 
        (grep { $_->{"subnet"} eq $net } @{$config->{"Dhcp4"}->{"subnet4"}})[0] : undef);
    unless ($existing_subnet) {
        print "Erreur: Le sous-réseau $net n'existe pas dans la configuration\n";
        return 0;
    }

    # Vérifier les réservations dans le sous-réseau
    my @conflicting_reservations;
    my @remaining_global_reservations;
    $config->{"Dhcp4"}->{"reservations"} ||= [];
    foreach my $reservation (@{$config->{"Dhcp4"}->{"reservations"}}) {
        if ($reservation->{'ip-address'} && is_ip_in_network($reservation->{'ip-address'}, $mask, $ip, $mask)) {
            push @conflicting_reservations, $reservation;
        } else {
            push @remaining_global_reservations, $reservation;
        }
    }

    if (@conflicting_reservations && !$force) {
        print "Erreur: Impossible de supprimer le sous-réseau $net car il contient des réservations :\n";
        foreach my $res (@conflicting_reservations) {
            print "  - ", ($res->{"hostname"} || $res->{'hw-address'} || $res->{'ip-address'}), "\n";
        }
        print "Utilisez --force pour supprimer le sous-réseau et ses réservations.\n";
        return 0;
    }

    # Supprimer le sous-réseau
    $config->{"Dhcp4"}->{"subnet4"} = [ grep { $_->{"subnet"} ne $net } @{$config->{"Dhcp4"}->{"subnet4"}} ];
    my @deleted_subnets = ($net);

    # Supprimer les réservations si --force
    my @deleted_reservations;
    if ($force && @conflicting_reservations) {
        push @deleted_reservations, map { $_->{"hostname"} || $_->{'hw-address'} || $_->{'ip-address'} } @conflicting_reservations;
        $config->{"Dhcp4"}->{"reservations"} = \@remaining_global_reservations;
    }

    if (@deleted_subnets) {
        print "Sous-réseau(s) supprimé(s) : ", join(", ", @deleted_subnets), "\n";
        if (@deleted_reservations) {
            print "Réservation(s) supprimée(s) : ", join(", ", @deleted_reservations), "\n";
        }
    }
    return 1;
}

# Supprimer des clients
sub del_clients {
    my ($config, $criteria, $debug) = @_;
    my $deleted_count = 0;
    my @deleted_clients;

    # Supprimer les réservations globales
    my @remaining_global_reservations;
    $config->{"Dhcp4"}->{"reservations"} ||= [];
    foreach my $reservation (@{$config->{"Dhcp4"}->{"reservations"}}) {
        my $keep = 1;
        foreach my $criterion (@$criteria) {
            my $regex = $criterion;
            $regex =~ s/\*/.*/g;
            if (($reservation->{"hostname"} && $reservation->{"hostname"} =~ /^$regex$/) ||
                ($reservation->{'hw-address'} && $reservation->{'hw-address'} =~ /^$regex$/i) ||
                ($reservation->{'ip-address'} && $reservation->{'ip-address'} =~ /^$regex$/)) {
                $keep = 0;
                $deleted_count++;
                push @deleted_clients, $reservation->{"hostname"} || $reservation->{'hw-address'} || $reservation->{'ip-address'};
            }
        }
        push @remaining_global_reservations, $reservation if $keep;
    }
    $config->{"Dhcp4"}->{"reservations"} = \@remaining_global_reservations;

    # Supprimer les réservations dans les sous-réseaux
    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            next unless exists $subnet->{"reservations"};
            my @remaining_subnet_reservations;
            foreach my $reservation (@{$subnet->{"reservations"}}) {
                my $keep = 1;
                foreach my $criterion (@$criteria) {
                    my $regex = $criterion;
                    $regex =~ s/\*/.*/g;
                    if (($reservation->{"hostname"} && $reservation->{"hostname"} =~ /^$regex$/) ||
                        ($reservation->{'hw-address'} && $reservation->{'hw-address'} =~ /^$regex$/i) ||
                        ($reservation->{'ip-address'} && $reservation->{'ip-address'} =~ /^$regex$/)) {
                        $keep = 0;
                        $deleted_count++;
                        push @deleted_clients, $reservation->{"hostname"} || $reservation->{'hw-address'} || $reservation->{'ip-address'};
                    }
                }
                push @remaining_subnet_reservations, $reservation if $keep;
            }
            $subnet->{"reservations"} = \@remaining_subnet_reservations;
        }
    }

    if ($deleted_count > 0) {
        print "Supprimé $deleted_count client(s) : ", join(", ", @deleted_clients), "\n";
        return $deleted_count;
    } else {
        print "Aucun client supprimé\n";
        return 0;
    }
}

# Ajouter un client (réservation)
sub add_client {
    my ($config, $name, $mac, $ip, $global, $debug) = @_;
    die "Nom d'hôte manquant\n" unless defined $name && $name ne '';
    die "Adresse MAC manquante\n" unless defined $mac && $mac =~ /^[0-9a-fA-F:]+$/;
    die "Adresse IP manquante ou invalide: $ip\n" unless defined $ip && valid_ip($ip);

    # Vérifier l'unicité
    my @existing_reservations;
    $config->{"Dhcp4"}->{"reservations"} ||= [];
    push @existing_reservations, @{$config->{"Dhcp4"}->{"reservations"}};
    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            push @existing_reservations, @{$subnet->{"reservations"}} if exists $subnet->{"reservations"};
        }
    }
    foreach my $res (@existing_reservations) {
        die "Erreur: Nom d'hôte $name déjà utilisé\n" if $res->{"hostname"} && $res->{"hostname"} eq $name;
        die "Erreur: Adresse MAC $mac déjà utilisée\n" if $res->{'hw-address'} && $res->{'hw-address'} eq $mac;
        die "Erreur: Adresse IP $ip déjà utilisée\n" if $res->{'ip-address'} && $res->{'ip-address'} eq $ip;
    }

    # Créer la réservation
    my $reservation = {
        "hostname" => $name,
        'hw-address' => $mac,
        'ip-address' => $ip
    };

    # Vérifier si l'IP appartient à un sous-réseau
    my $subnet;
    if (!$global && exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $s (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            my ($subnet_ip, $mask) = split('/', $s->{"subnet"});
            if (is_ip_in_network($ip, $mask, $subnet_ip, $mask)) {
                $subnet = $s;
                last;
            }
        }
    }
    die "Erreur: L'adresse IP $ip n'appartient à aucun sous-réseau\n" unless $global || $subnet;

    if ($global) {
        push @{$config->{"Dhcp4"}->{"reservations"}}, $reservation;
    } else {
        $subnet->{"reservations"} ||= [];
        push @{$subnet->{"reservations"}}, $reservation;
    }
    print "DEBUG: Réservation ajoutée: $name, $mac, $ip\n" if $debug;
    return 1;
}

# Lister les clients
sub list_clients {
    my ($config, $csv, $debug) = @_;
    my @reservations;
    my @interfaces = exists $config->{"Dhcp4"}->{"interfaces-config"} ? @{$config->{"Dhcp4"}->{"interfaces-config"}->{"interfaces"}} : ("N/A");

    $config->{"Dhcp4"}->{"reservations"} ||= [];
    foreach my $res (@{$config->{"Dhcp4"}->{"reservations"}}) {
        push @reservations, {
            subnet => "global",
            subnet_id => "N/A",
            interface => "N/A",
            hostname => $res->{"hostname"} || "N/A",
            mac => $res->{'hw-address'} || "N/A",
            ip => $res->{'ip-address'} || "N/A"
        };
    }

    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            my $subnet_id = $subnet->{"id"} || "N/A";
            my $subnet_str = $subnet->{"subnet"} || "N/A";
            my ($subnet_ip, $mask) = split('/', $subnet_str);
            my $interface = "N/A";
            foreach my $iface (@interfaces) {
                my ($ip, $m) = split('/', $iface);
                if ($ip && $m && is_ip_in_network($ip, $m, $subnet_ip, $mask)) {
                    $interface = $iface;
                    last;
                }
            }
            if (exists $subnet->{"reservations"}) {
                foreach my $res (@{$subnet->{"reservations"}}) {
                    push @reservations, {
                        subnet => $subnet_str,
                        subnet_id => $subnet_id,
                        interface => $interface,
                        hostname => $res->{"hostname"} || "N/A",
                        mac => $res->{'hw-address'} || "N/A",
                        ip => $res->{'ip-address'} || "N/A"
                    };
                }
            }
        }
    }

    if (@reservations) {
        if ($csv) {
            print "subnet,subnet-id,net-interface,fqdn,MAC,IP\n";
            foreach my $res (@reservations) {
                print join(",", map { defined $_ ? $_ : "N/A" } ($res->{subnet}, $res->{subnet_id}, $res->{interface}, $res->{hostname}, $res->{mac}, $res->{ip})), "\n";
            }
        } else {
            my $table = Text::Table->new("Subnet", "Subnet ID", "Interface", "FQDN", "MAC", "IP");
            foreach my $res (@reservations) {
                $table->add($res->{subnet}, $res->{subnet_id}, $res->{interface}, $res->{hostname}, $res->{mac}, $res->{ip});
            }
            print $table;
        }
    } else {
        print "Aucune réservation trouvée\n";
    }
}

# Lister les pools
sub list_pools {
    my ($config, $csv, $debug) = @_;
    my @pools;
    my @interfaces = exists $config->{"Dhcp4"}->{"interfaces-config"} ? @{$config->{"Dhcp4"}->{"interfaces-config"}->{"interfaces"}} : ("N/A");

    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            my $subnet_id = $subnet->{"id"} || "N/A";
            my $subnet_str = $subnet->{"subnet"} || "N/A";
            my ($subnet_ip, $mask) = split('/', $subnet_str);
            my $interface = "N/A";
            foreach my $iface (@interfaces) {
                my ($ip, $m) = split('/', $iface);
                if ($ip && $m && is_ip_in_network($ip, $m, $subnet_ip, $mask)) {
                    $interface = $iface;
                    last;
                }
            }
            if (exists $subnet->{"pools"}) {
                foreach my $pool (@{$subnet->{"pools"}}) {
                    next unless defined $pool->{"pool"} && $pool->{"pool"} =~ /\S/;
                    my ($start, $end) = split(/\s*-\s*/, $pool->{"pool"});
                    push @pools, {
                        subnet => $subnet_str,
                        subnet_id => $subnet_id,
                        interface => $interface,
                        pool_start => $start,
                        pool_end => $end
                    };
                }
            }
        }
    }

    if (@pools) {
        if ($csv) {
            print "subnet,subnet-id,net-interface,pool-start,pool-end\n";
            foreach my $pool (@pools) {
                print join(",", map { defined $_ ? $_ : "N/A" } ($pool->{subnet}, $pool->{subnet_id}, $pool->{interface}, $pool->{pool_start}, $pool->{pool_end})), "\n";
            }
        } else {
            my $table = Text::Table->new("Subnet", "Subnet ID", "Interface", "Pool Start", "Pool End");
            foreach my $pool (@pools) {
                $table->add($pool->{subnet}, $pool->{subnet_id}, $pool->{interface}, $pool->{pool_start}, $pool->{pool_end});
            }
            print $table;
        }
    } else {
        print "Aucun pool trouvé\n";
    }
}

# Lister les sous-réseaux
sub list_networks {
    my ($config, $csv, $debug) = @_;
    my @subnets;
    my @interfaces = exists $config->{"Dhcp4"}->{"interfaces-config"} ? @{$config->{"Dhcp4"}->{"interfaces-config"}->{"interfaces"}} : ("N/A");

    if (exists $config->{"Dhcp4"}->{"subnet4"}) {
        foreach my $subnet (@{$config->{"Dhcp4"}->{"subnet4"}}) {
            my $subnet_id = $subnet->{"id"} || "N/A";
            my $subnet_str = $subnet->{"subnet"} || "N/A";
            my ($subnet_ip, $mask) = split('/', $subnet_str);
            my $ip_min = first_usable_ip($subnet_ip, $mask);
            my $ip_max = "N/A"; # À implémenter si nécessaire
            push @subnets, {
                subnet => $subnet_str,
                subnet_id => $subnet_id,
                ip_min => $ip_min,
                ip_max => $ip_max
            };
        }
    }

    if (@subnets) {
        if ($csv) {
            print "subnet,subnet-id,ip-min,ip-max\n";
            foreach my $subnet (@subnets) {
                print join(",", map { defined $_ ? $_ : "N/A" } ($subnet->{subnet}, $subnet->{subnet_id}, $subnet->{ip_min}, $subnet->{ip_max})), "\n";
            }
        } else {
            my $table = Text::Table->new("Subnet", "Subnet ID", "IP Min", "IP Max");
            foreach my $subnet (@subnets) {
                $table->add($subnet->{subnet}, $subnet->{subnet_id}, $subnet->{ip_min}, $subnet->{ip_max});
            }
            print $table;
        }
    } else {
        print "Aucun sous-réseau trouvé\n";
    }
}

1;
